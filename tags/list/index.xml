<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>list on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/tags/list/</link>
    <description>Recent content in list on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Fri, 23 Sep 2022 10:14:17 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/tags/list/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 707. 设计链表</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-707.-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 23 Sep 2022 10:14:17 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-707.-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</guid>
      <description>链接： https://leetcode.cn/problems/design-linked-list/
难度： 中等
题目描述 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。
在链表类中实现这些功能：
get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果 index 小于 0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 示例： MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1,2); //链表变为1-&amp;gt; 2-&amp;gt; 3 linkedList.get(1); //返回2 linkedList.deleteAtIndex(1); //现在链表是1-&amp;gt; 3 linkedList.get(1); //返回3 提示： 所有 val 值都在 [1, 1000] 之内。 操作次数将在 [1, 1000] 之内。 请不要使用内置的 LinkedList 库。 解题思路 单向链表 type node struct { val int next *node } type MyLinkedList struct { head *node length int } func Constructor() MyLinkedList { return MyLinkedList{ head: new(node), length: 0, } } func (this *MyLinkedList) Get(index int) int { if index &amp;lt; -1 || index &amp;gt;= this.</description>
    </item>
    
    <item>
      <title>剑指 Offer 50. 第一个只出现一次的字符</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Tue, 21 Sep 2021 23:36:33 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</guid>
      <description>链接： https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/
难度： 简单
题目描述 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。
示例 1： 输入： s = &amp;ldquo;abaccdeff&amp;rdquo;
输出： &amp;lsquo;b&amp;rsquo;
示例 2： 输入： s = &amp;quot;&amp;quot;
输出： &amp;rsquo; &#39;
限制： 0 &amp;lt;= s 的长度 &amp;lt;= 50000 解题思路 哈希 + 两次遍历 第一次遍历，使用哈希表记录每个字符是否重复出现；第二次遍历，返回找到的第一个不重复的字符，找不到返回 &#39; &#39;。
func firstUniqChar(s string) byte { repeat := make(map[byte]bool) for i := range s { _, ok := repeat[s[i]] if !ok { repeat[s[i]] = false } else { repeat[s[i]] = true } } for i := range s { if !</description>
    </item>
    
  </channel>
</rss>
