<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>backtracking on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/tags/backtracking/</link>
    <description>Recent content in backtracking on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Thu, 30 Sep 2021 10:40:00 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/tags/backtracking/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 46. 全排列</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-46.-%E5%85%A8%E6%8E%92%E5%88%97/</link>
      <pubDate>Thu, 30 Sep 2021 10:40:00 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-46.-%E5%85%A8%E6%8E%92%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/permutations/
难度： 中等
题目描述 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
示例 1：  输入： nums = [1,2,3]
输出： [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 示例 2：  输入： nums = [0,1]
输出： [[0,1],[1,0]]
 示例 3：  输入： nums = [1]
输出： [[1]]
 提示：  1 &amp;lt;= nums.length &amp;lt;= 6 -10 &amp;lt;= nums[i] &amp;lt;= 10 nums 中的所有整数 互不相同  解题思路 回溯 每次从可选数字中选出一个数，加入到栈中，直到栈中元素数量与原数组相同，则其为其中一个的全排列，加入到结果中，回溯，重复上述步骤，直到搜索到所有情况。
func permute(nums []int) [][]int { cnt := 1 for i := 2; i &amp;lt;= len(nums); i++ { cnt *= i } ans := make([][]int, 0, cnt) choice := make(map[int]struct{}) var backtracking func(stack []int) backtracking = func(stack []int) { if len(stack) == len(nums) { t := make([]int, len(stack)) copy(t, stack) ans = append(ans, t) return } for _, num := range nums { if _, ok := choice[num]; ok { continue } choice[num] = struct{}{} stack = append(stack, num) backtracking(stack) stack = stack[:len(stack)-1] delete(choice, num) } } backtracking(make([]int, 0, len(nums))) return ans } 复杂度  时间复杂度：$ O(N*N!</description>
    </item>
    
    <item>
      <title>Leetcode 526. 优美的排列</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-526.-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/</link>
      <pubDate>Mon, 16 Aug 2021 22:54:27 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-526.-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/beautiful-arrangement/
难度： 中等
题目描述 假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 &amp;lt;= i &amp;lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：
 第 i 位的数字能被 i 整除 i 能被第 i 位上的数字整除  现在给定一个整数 N，请问可以构造多少个优美的排列？
示例：  输入: 2
输出: 2
解释:
第 1 个优美的排列是 [1, 2]:
第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除
第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除
第 2 个优美的排列是 [2, 1]:
第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除
第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除
 说明：  N 是一个正整数，并且不会超过 15。  解题思路 回溯 使用一个数组 arr 记录该排列，另使用一个数组 choice 记录每个数字是否已经被填写到 arr 中。</description>
    </item>
    
    <item>
      <title>剑指 Offer 38. 字符串的排列</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-38.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</link>
      <pubDate>Tue, 22 Jun 2021 21:43:40 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-38.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/
难度： 中等
题目描述 输入一个字符串，打印出该字符串中字符的所有排列。
你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。
示例1：  输入： s = &amp;ldquo;abc&amp;rdquo;
输出： [&amp;ldquo;abc&amp;rdquo;,&amp;ldquo;acb&amp;rdquo;,&amp;ldquo;bac&amp;rdquo;,&amp;ldquo;bca&amp;rdquo;,&amp;ldquo;cab&amp;rdquo;,&amp;ldquo;cba&amp;rdquo;]
 提示：  1 &amp;lt;= s 的长度 &amp;lt;= 8  解题思路 回溯 遍历未入栈字符列表，每次选取一个字符入栈，并标记此字符已经入栈，递归的寻找下一个字符，直到所有字符全部入栈，将结果加入集合中。
func permutation(s string) []string { only := make(map[string]bool) choice := make([]bool, len(s)) prefix := make([]byte, 0, len(s)) var backtrack func() backtrack = func() { if len(prefix) == len(s) { only[string(prefix)] = true return } for i := range choice { if choice[i] { continue } prefix = append(prefix, s[i]) choice[i] = true backtrack() choice[i] = false prefix = prefix[:len(prefix)-1] } } backtrack() res := make([]string, 0, 1&amp;lt;&amp;lt;(len(s)-1)) for k := range only { res = append(res, k) } return res } 复杂度  时间复杂度：O(N*N!</description>
    </item>
    
  </channel>
</rss>
