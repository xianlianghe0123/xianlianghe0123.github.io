<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>heap on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/tags/heap/</link>
    <description>Recent content in heap on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Fri, 14 Jan 2022 10:58:34 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/tags/heap/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 373. 查找和最小的K对数字</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-373.-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 14 Jan 2022 10:58:34 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-373.-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/
难度： 中等
题目描述 给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。
定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。
请找到和最小的 k 个数对 (u1,v1), (u2,v2) &amp;hellip; (uk,vk) 。
示例 1：  输入： nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出： [1,2],[1,4],[1,6]
解释： 返回序列中的前 3 对数：
[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
 示例 2：  输入： nums1 = [1,1,2], nums2 = [1,2,3], k = 2
输出： [1,1],[1,1]
解释： 返回序列中的前 2 对数：
[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]
 示例 3：  输入： nums1 = [1,2], nums2 = [3], k = 3</description>
    </item>
    
    <item>
      <title>Leetcode 747. 至少是其他数字两倍的最大数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-747.-%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0/</link>
      <pubDate>Thu, 13 Jan 2022 10:11:31 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-747.-%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/
难度： 简单
题目描述 给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。
请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。
示例 1：  输入： nums = [3,6,1,0]
输出： 1
解释： 6 是最大的整数，对于数组中的其他整数，6 大于数组中其他元素的两倍。6 的下标是 1 ，所以返回 1 。
 示例 2：  输入： nums = [1,2,3,4]
输出： -1
解释： 4 没有超过 3 的两倍大，所以返回 -1 。
 示例 3：  输入： nums = [1]
输出： 0
解释： 因为不存在其他数字，所以认为现有数字 1 至少是其他数字的两倍。
 提示：  1 &amp;lt;= nums.</description>
    </item>
    
    <item>
      <title>Leetcode 1705. 吃苹果的最大数目</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1705.-%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/</link>
      <pubDate>Fri, 24 Dec 2021 10:36:12 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1705.-%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/</guid>
      <description>链接： https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/
难度： 中等
题目描述 有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。
你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。
给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。
示例 1：  输入： apples = [1,2,3,5,2], days = [3,2,1,4,2]
输出： 7
解释： 你可以吃掉 7 个苹果：
 第一天，你吃掉第一天长出来的苹果。 第二天，你吃掉一个第二天长出来的苹果。 第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。 第四天到第七天，你吃的都是第四天长出来的苹果。   示例 2：  输入： apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]</description>
    </item>
    
    <item>
      <title>Leetcode 786. 第 K 个最小的素数分数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-786.-%E7%AC%AC-k-%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E7%B4%A0%E6%95%B0%E5%88%86%E6%95%B0/</link>
      <pubDate>Mon, 29 Nov 2021 10:26:07 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-786.-%E7%AC%AC-k-%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E7%B4%A0%E6%95%B0%E5%88%86%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/
难度： 困难
题目描述 给你一个按递增顺序排序的数组 arr 和一个整数 k 。数组 arr 由 1 和若干 素数 组成，且其中所有整数互不相同。
对于每对满足 0 &amp;lt; i &amp;lt; j &amp;lt; arr.length 的 i 和 j ，可以得到分数 arr[i] / arr[j] 。
那么第 k 个最小的分数是多少呢? 以长度为 2 的整数数组返回你的答案, 这里 answer[0] == arr[i] 且 answer[1] == arr[j] 。
示例 1：  输入： arr = [1,2,3,5], k = 3
输出： [2,5]
解释： 已构造好的分数,排序后如下所示:
1/5, 1/3, 2/5, 1/2, 3/5, 2/3
很明显第三个最小的分数是 2/5</description>
    </item>
    
    <item>
      <title>剑指 Offer 59 - I. 滑动窗口的最大值</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-59-i.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</link>
      <pubDate>Tue, 05 Oct 2021 18:12:15 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-59-i.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</guid>
      <description>链接： https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/
难度： 困难
题目描述 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
示例：  输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7]
解释:
滑动窗口的位置 最大值
[1 3 -1] -3 5 3 6 7 3
1 [3 -1 -3] 5 3 6 7 3
1 3 [-1 -3 5] 3 6 7 5
1 3 -1 [-3 5 3] 6 7 5
1 3 -1 -3 [5 3 6] 7 6
1 3 -1 -3 5 [3 6 7] 7</description>
    </item>
    
    <item>
      <title>剑指 Offer 49. 丑数</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-49.-%E4%B8%91%E6%95%B0/</link>
      <pubDate>Tue, 21 Sep 2021 17:50:14 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-49.-%E4%B8%91%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/chou-shu-lcof/
难度： 中等
题目描述 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。
示例：  输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
 说明：  1 是丑数。 n 不超过 1690。  解题思路 堆 + 哈希 维护一个小顶堆和哈希表，初始堆中元素为 1，每次弹出堆顶最小元素，然后将其分别乘以 2、3、5加入堆中，此处需要使用哈希表去重。
弹出的第 n 个数即为第 n 个丑数。
type MinHeap struct { sort.IntSlice } func (this *MinHeap) Push(x interface{}) { this.IntSlice = append(this.</description>
    </item>
    
    <item>
      <title>剑指 Offer 40. 最小的k个数</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Mon, 20 Sep 2021 16:17:39 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/
难度： 简单
题目描述 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。
示例 1：  输入： arr = [3,2,1], k = 2
输出： [1,2] 或者 [2,1]
 示例 2：  输入： arr = [0,1,2,1], k = 1
输出： [0]
 限制：  0 &amp;lt;= k &amp;lt;= arr.length &amp;lt;= 10000 0 &amp;lt;= arr[i] &amp;lt;= 10000  解题思路 排序 对数组进行排序，返回前 k 个数。
func getLeastNumbers(arr []int, k int) []int { sort.Ints(arr) return arr[:k] } 复杂度  时间复杂度：$ O(N\log{N}), N = len(arr) $ 空间复杂度：$ O(\log{N}) $  堆 使用大顶堆维护最小的 k 个数。遍历数组，当堆不满 k 时，入堆；否则，当前元素小于堆顶元素时，弹出最大元素，当前元素入堆。</description>
    </item>
    
    <item>
      <title>面试题 17.14. 最小K个数</title>
      <link>https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.14.-%E6%9C%80%E5%B0%8Fk%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Fri, 03 Sep 2021 11:30:22 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.14.-%E6%9C%80%E5%B0%8Fk%E4%B8%AA%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/smallest-k-lcci/
难度： 中等
题目描述 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。
示例：  输入： arr = [1,3,5,7,2,4,6,8], k = 4
输出： [1,2,3,4]
 提示：  0 &amp;lt;= len(arr) &amp;lt;= 100000 0 &amp;lt;= k &amp;lt;= min(100000, len(arr))  解题思路 排序 对原数组排序，返回前 k 个元素。
func smallestK(arr []int, k int) []int { sort.Ints(arr) return arr[:k] } 复杂度  时间复杂度：$ O(N\log N), N = len(arr) $ 空间复杂度：$ O(\log N) $  堆 构建一个大顶堆，保存前 k 个最小的数。遍历 arr 数组
 当堆中元素数量不足 k 时，入堆； 当堆中元素书数量为 k 时，与堆顶元素比较  当堆顶元素为较大时，弹出队顶元素，当前元素入堆 否则，忽略当前元素    遍历结束，返回堆中所有元素。</description>
    </item>
    
    <item>
      <title>Leetcode 313. 超级丑数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-313.-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/</link>
      <pubDate>Mon, 09 Aug 2021 11:00:42 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-313.-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/super-ugly-number/
难度： 中等
题目描述 超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。
给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。
题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。
示例 1：  输入： n = 12, primes = [2,7,13,19]
输出： 32
解释： 给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。
 示例 2：  输入： n = 1, primes = [2,3,5]
输出： 1
解释： 1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。
 注意：  1 &amp;lt;= n &amp;lt;= 106 1 &amp;lt;= primes.</description>
    </item>
    
    <item>
      <title>Leetcode 743. 网络延迟时间</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-743.-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/</link>
      <pubDate>Tue, 03 Aug 2021 20:16:01 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-743.-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/</guid>
      <description>链接： https://leetcode-cn.com/problems/network-delay-time/
难度： 中等
题目描述 有 n 个网络节点，标记为 1 到 n 。
给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。
现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。
示例 1：  输入： times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
输出： 2
 示例 2：  输入： times = [[1,2,1]], n = 2, k = 1
输出： 1
 示例 3：  输入： times = [[1,2,1]], n = 2, k = 2</description>
    </item>
    
  </channel>
</rss>
