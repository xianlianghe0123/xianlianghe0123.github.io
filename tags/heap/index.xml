<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>heap on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/tags/heap/</link>
    <description>Recent content in heap on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Tue, 21 Sep 2021 17:50:14 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/tags/heap/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>剑指 Offer 49. 丑数</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-49.-%E4%B8%91%E6%95%B0/</link>
      <pubDate>Tue, 21 Sep 2021 17:50:14 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-49.-%E4%B8%91%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/chou-shu-lcof/
难度： 中等
题目描述 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。
示例：  输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
 说明：  1 是丑数。 n 不超过 1690。  解题思路 堆 + 哈希 维护一个小顶堆和哈希表，初始堆中元素为 1，每次弹出堆顶最小元素，然后将其分别乘以 2、3、5加入堆中，此处需要使用哈希表去重。
弹出的第 n 个数即为第 n 个丑数。
type MinHeap struct { sort.IntSlice } func (this *MinHeap) Push(x interface{}) { this.IntSlice = append(this.</description>
    </item>
    
    <item>
      <title>剑指 Offer 40. 最小的k个数</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Mon, 20 Sep 2021 16:17:39 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/
难度： 简单
题目描述 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。
示例 1：  输入： arr = [3,2,1], k = 2
输出： [1,2] 或者 [2,1]
 示例 2：  输入： arr = [0,1,2,1], k = 1
输出： [0]
 限制：  0 &amp;lt;= k &amp;lt;= arr.length &amp;lt;= 10000 0 &amp;lt;= arr[i] &amp;lt;= 10000  解题思路 排序 对数组进行排序，返回前 k 个数。
func getLeastNumbers(arr []int, k int) []int { sort.Ints(arr) return arr[:k] } 复杂度  时间复杂度：$ O(N\log{N}), N = len(arr) $ 空间复杂度：$ O(\log{N}) $  堆 使用大顶堆维护最小的 k 个数。遍历数组，当堆不满 k 时，入堆；否则，当前元素小于堆顶元素时，弹出最大元素，当前元素入堆。</description>
    </item>
    
    <item>
      <title>面试题 17.14. 最小K个数</title>
      <link>https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.14.-%E6%9C%80%E5%B0%8Fk%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Fri, 03 Sep 2021 11:30:22 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.14.-%E6%9C%80%E5%B0%8Fk%E4%B8%AA%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/smallest-k-lcci/
难度： 中等
题目描述 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。
示例：  输入： arr = [1,3,5,7,2,4,6,8], k = 4
输出： [1,2,3,4]
 提示：  0 &amp;lt;= len(arr) &amp;lt;= 100000 0 &amp;lt;= k &amp;lt;= min(100000, len(arr))  解题思路 排序 对原数组排序，返回前 k 个元素。
func smallestK(arr []int, k int) []int { sort.Ints(arr) return arr[:k] } 复杂度  时间复杂度：$ O(N\log N), N = len(arr) $ 空间复杂度：$ O(\log N) $  堆 构建一个大顶堆，保存前 k 个最小的数。遍历 arr 数组
 当堆中元素数量不足 k 时，入堆； 当堆中元素书数量为 k 时，与堆顶元素比较  当堆顶元素为较大时，弹出队顶元素，当前元素入堆 否则，忽略当前元素    遍历结束，返回堆中所有元素。</description>
    </item>
    
    <item>
      <title>Leetcode 313. 超级丑数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-313.-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/</link>
      <pubDate>Mon, 09 Aug 2021 11:00:42 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-313.-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/super-ugly-number/
难度： 中等
题目描述 超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。
给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。
题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。
示例 1：  输入： n = 12, primes = [2,7,13,19]
输出： 32
解释： 给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。
 示例 2：  输入： n = 1, primes = [2,3,5]
输出： 1
解释： 1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。
 注意：  1 &amp;lt;= n &amp;lt;= 106 1 &amp;lt;= primes.</description>
    </item>
    
    <item>
      <title>Leetcode 743. 网络延迟时间</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-743.-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/</link>
      <pubDate>Tue, 03 Aug 2021 20:16:01 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-743.-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/</guid>
      <description>链接： https://leetcode-cn.com/problems/network-delay-time/
难度： 中等
题目描述 有 n 个网络节点，标记为 1 到 n 。
给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。
现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。
示例 1：  输入： times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
输出： 2
 示例 2：  输入： times = [[1,2,1]], n = 2, k = 1
输出： 1
 示例 3：  输入： times = [[1,2,1]], n = 2, k = 2</description>
    </item>
    
  </channel>
</rss>
