<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>greedy on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/tags/greedy/</link>
    <description>Recent content in greedy on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Sat, 06 Aug 2022 18:19:05 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/tags/greedy/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 1408. 数组中的字符串匹配</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1408.-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Sat, 06 Aug 2022 18:19:05 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1408.-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</guid>
      <description>链接： https://leetcode.cn/problems/string-matching-in-an-array/
难度： 中等
题目描述 给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。
如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 word[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。
示例 1： 输入： words = [&amp;ldquo;mass&amp;rdquo;,&amp;ldquo;as&amp;rdquo;,&amp;ldquo;hero&amp;rdquo;,&amp;ldquo;superhero&amp;rdquo;]
输出： [&amp;ldquo;as&amp;rdquo;,&amp;ldquo;hero&amp;rdquo;]
解释： &amp;ldquo;as&amp;rdquo; 是 &amp;ldquo;mass&amp;rdquo; 的子字符串，&amp;ldquo;hero&amp;rdquo; 是 &amp;ldquo;superhero&amp;rdquo; 的子字符串。
[&amp;ldquo;hero&amp;rdquo;,&amp;ldquo;as&amp;rdquo;] 也是有效的答案。
示例 2： 输入： words = [&amp;ldquo;leetcode&amp;rdquo;,&amp;ldquo;et&amp;rdquo;,&amp;ldquo;code&amp;rdquo;]
输出： [&amp;ldquo;et&amp;rdquo;,&amp;ldquo;code&amp;rdquo;]
解释： &amp;ldquo;et&amp;rdquo; 和 &amp;ldquo;code&amp;rdquo; 都是 &amp;ldquo;leetcode&amp;rdquo; 的子字符串。
示例 3： 输入： words = [&amp;ldquo;blue&amp;rdquo;,&amp;ldquo;green&amp;rdquo;,&amp;ldquo;bu&amp;rdquo;]
输出： []
提示： 1 &amp;lt;= words.length &amp;lt;= 100 1 &amp;lt;= words[i].</description>
    </item>
    
    <item>
      <title>Leetcode 1403. 非递增顺序的最小子序列</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1403.-%E9%9D%9E%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Thu, 04 Aug 2022 10:04:16 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1403.-%E9%9D%9E%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>链接： https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/
难度： 简单
题目描述 给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。
如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。
与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。
注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。
示例 1： 输入： nums = [4,3,10,9,8]
输出： [10,9]
解释： 子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 示例 2： 输入： nums = [4,4,7,6,7]
输出： [7,7,6]
解释： 子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。
示例 3： 输入： nums = [6]
输出： [6]
提示： 1 &amp;lt;= nums.length &amp;lt;= 500 1 &amp;lt;= nums[i] &amp;lt;= 100 解题思路 贪心（排序） 为使得子序列的长度最小，优先挑选值比较大的元素。</description>
    </item>
    
    <item>
      <title>Leetcode 942. 增减字符串匹配</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-942.-%E5%A2%9E%E5%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</link>
      <pubDate>Mon, 09 May 2022 09:59:48 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-942.-%E5%A2%9E%E5%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</guid>
      <description>链接： https://leetcode-cn.com/problems/range-sum-of-bst/
难度： 简单
题目描述 由范围 [0,n] 内所有整数组成的 n + 1 个整数的排列序列可以表示为长度为 n 的字符串 s ，其中:
如果 perm[i] &amp;lt; perm[i + 1] ，那么 s[i] == &#39;I&#39; 如果 perm[i] &amp;gt; perm[i + 1] ，那么 s[i] == &#39;D&#39; 给定一个字符串 s ，重构排列 perm 并返回它。如果有多个有效排列 perm，则返回其中 任何一个 。
示例 1： 输入： s = &amp;ldquo;IDID&amp;rdquo;
输出： [0,4,1,3,2]
示例 2： 输入： s = &amp;ldquo;III&amp;rdquo;
输出： [0,1,2,3]
示例 3： 输入： s = &amp;ldquo;DDI&amp;rdquo;
输出： [3,2,0,1]
提示： 1 &amp;lt;= s.</description>
    </item>
    
    <item>
      <title>Leetcode 1405. 最长快乐字符串</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1405.-%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 07 Feb 2022 09:38:43 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1405.-%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/longest-happy-string/
难度： 中等
题目描述 如果字符串中不含有任何 &#39;aaa&#39;，&#39;bbb&#39; 或 &#39;ccc&#39; 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。
给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s：
s 是一个尽可能长的快乐字符串。 s 中 最多 有 a 个字母 &#39;a&#39;、b 个字母 &#39;b&#39;、c 个字母 &#39;c&#39; 。 s 中只含有 &#39;a&#39;、&#39;b&#39; 、&#39;c&#39; 三种字母。 如果不存在这样的字符串 s ，请返回一个空字符串&amp;quot;&amp;quot;。
示例 1： 输入： a = 1, b = 1, c = 7
输出： &amp;ldquo;ccaccbcc&amp;rdquo;
解释： &amp;ldquo;ccbccacc&amp;rdquo; 也是一种正确答案。
示例 2： 输入： a = 2, b = 2, c = 1
输出： &amp;ldquo;aabbc&amp;rdquo;
示例 3： 输入： a = 7, b = 1, c = 0</description>
    </item>
    
    <item>
      <title>Leetcode 1414. 和为 K 的最少斐波那契数字数目</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1414.-%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/</link>
      <pubDate>Thu, 03 Feb 2022 11:11:52 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1414.-%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/</guid>
      <description>链接： https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/
难度： 中等
题目描述 给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。
斐波那契数字定义为：
F1 = 1 F2 = 1 Fn = Fn-1 + Fn-2 ， 其中 n &amp;gt; 2 。 数据保证对于给定的 k ，一定能找到可行解。
示例 1： 输入： k = 7
输出： 2
解释： 斐波那契数字为：1，1，2，3，5，8，13，……
对于 k = 7 ，我们可以得到 2 + 5 = 7 。
示例 2： 输入： k = 10
输出： 2
解释： 对于 k = 10 ，我们可以得到 2 + 8 = 10 。</description>
    </item>
    
    <item>
      <title>Leetcode 1705. 吃苹果的最大数目</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1705.-%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/</link>
      <pubDate>Fri, 24 Dec 2021 10:36:12 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1705.-%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/</guid>
      <description>链接： https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/
难度： 中等
题目描述 有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。
你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。
给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。
示例 1： 输入： apples = [1,2,3,5,2], days = [3,2,1,4,2]
输出： 7
解释： 你可以吃掉 7 个苹果：
第一天，你吃掉第一天长出来的苹果。 第二天，你吃掉一个第二天长出来的苹果。 第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。 第四天到第七天，你吃的都是第四天长出来的苹果。 示例 2： 输入： apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]
输出： 5
解释： 你可以吃掉 5 个苹果：</description>
    </item>
    
    <item>
      <title>Leetcode 807. 保持城市天际线</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-807.-%E4%BF%9D%E6%8C%81%E5%9F%8E%E5%B8%82%E5%A4%A9%E9%99%85%E7%BA%BF/</link>
      <pubDate>Mon, 13 Dec 2021 11:03:06 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-807.-%E4%BF%9D%E6%8C%81%E5%9F%8E%E5%B8%82%E5%A4%A9%E9%99%85%E7%BA%BF/</guid>
      <description>链接： https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline/
难度： 中等
题目描述 在二维数组 grid 中，grid[i][j] 代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。
最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的“天际线”必须与原始数组的天际线相同。 城市的天际线是从远处观看时，由所有建筑物形成的矩形的外部轮廓。 请看下面的例子。
建筑物高度可以增加的最大总和是多少？
例子：
输入： grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
输出： 35
解释：
The grid is: [ [3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0] ] 从数组竖直方向（即顶部，底部）看“天际线”是：[9, 4, 8, 7]
从水平水平方向（即左侧，右侧）看“天际线”是：[8, 7, 9, 3]
在不影响天际线的情况下对建筑物进行增高后，新数组如下：
gridNew = [ [8, 4, 8, 7], [7, 4, 7, 7], [9, 4, 8, 7], [3, 3, 3, 3] ] 说明： 1 &amp;lt; grid.</description>
    </item>
    
    <item>
      <title>剑指 Offer 14- II. 剪绳子 II</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii/</link>
      <pubDate>Mon, 27 Sep 2021 17:54:22 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/
难度： 中等
题目描述 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1： 输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
示例 2： 输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
提示： 2 &amp;lt;= n &amp;lt;= 1000 解题思路 数学 + 贪心 + 快速幂 根据几何均值不等式: $$ a_1a_2&amp;hellip;a_m \leq (\frac{a_1+a_2+&amp;hellip;+a_m}{m})，当且仅当 a_1=a_2=&amp;hellip;=a_m 时，等式成立 $$ 可以得知，当将绳子等分时，可以获得最大值。</description>
    </item>
    
  </channel>
</rss>
