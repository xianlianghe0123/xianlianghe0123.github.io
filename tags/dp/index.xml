<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dp on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/tags/dp/</link>
    <description>Recent content in dp on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Sat, 09 Jul 2022 09:42:30 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/tags/dp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 873. 最长的斐波那契子序列的长度</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-873.-%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Sat, 09 Jul 2022 09:42:30 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-873.-%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/</guid>
      <description>链接： https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/
难度： 中等
题目描述 如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的：
n &amp;gt;= 3 对于所有 i + 2 &amp;lt;= n，都有 X_i + X_{i+1} = X_{i+2} 给定一个 严格递增 的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。
（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）
示例 1： 输入： arr = [1,2,3,4,5,6,7,8]
输出： 5
解释： 最长的斐波那契式子序列为 [1,2,3,5,8] 。
示例 2： 输入： arr = [1,3,7,11,12,14,18]</description>
    </item>
    
    <item>
      <title>Leetcode 241. 为运算表达式设计优先级</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-241.-%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</link>
      <pubDate>Fri, 01 Jul 2022 10:16:30 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-241.-%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/</guid>
      <description>链接： https://leetcode.cn/problems/different-ways-to-add-parentheses/
难度： 中等
题目描述 给你一个由数字和运算符组成的字符串 expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。
生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 104 。
示例 1： 输入： expression = &amp;ldquo;2-1-1&amp;rdquo;
输出： [0,2]
解释：
((2-1)-1) = 0
(2-(1-1)) = 2
示例 2： 输入： expression = &amp;ldquo;2*3-4*5&amp;rdquo;
输出： [-34,-14,-10,-10,10]
解释：
(2*(3-(45))) = -34
((23)-(45)) = -14
((2(3-4))5) = -10
(2((3-4)5)) = -10
(((23)-4)*5) = 10
提示： 1 &amp;lt;= expression.length &amp;lt;= 20 expression 由数字和算符 &#39;+&#39;、&#39;-&#39; 和 &#39;*&#39; 组成。 输入表达式中的所有整数值在范围 [0, 99] 解题思路 分治 两个表达式进行运算，若其计算结果分别有 x 和 y 种，则最终的计算结果将 x 和 y 中所有结果的两两组合进行运算即可。</description>
    </item>
    
    <item>
      <title>剑指 Offer II 091. 粉刷房子</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-ii-091.-%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/</link>
      <pubDate>Sat, 25 Jun 2022 09:08:16 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-ii-091.-%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/</guid>
      <description>链接： https://leetcode.cn/problems/JEj789/
难度： 中等
题目描述 假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。
当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。
例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。
请计算出粉刷完所有房子最少的花费成本。
示例 1： 输入： costs = [[17,2,17],[16,16,5],[14,3,19]]
输出： 10
解释： 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。
最少花费: 2 + 5 + 3 = 10。
示例 2： 输入： costs = [[7,6,2]]
输出： 2
提示 costs.length == n costs[i].length == 3 1 &amp;lt;= n &amp;lt;= 100 1 &amp;lt;= costs[i][j] &amp;lt;= 20 解题思路 动态规划 如果按照顺序从头至尾粉刷所有的房子，则每一个房子可以被粉刷的颜色受到上一个房子粉刷的颜色约束。</description>
    </item>
    
    <item>
      <title>Leetcode 926. 将字符串翻转到单调递增</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-926.-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BF%BB%E8%BD%AC%E5%88%B0%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E/</link>
      <pubDate>Sat, 11 Jun 2022 09:38:44 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-926.-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BF%BB%E8%BD%AC%E5%88%B0%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E/</guid>
      <description>链接： https://leetcode.cn/problems/flip-string-to-monotone-increasing/
难度： 中等
题目描述 如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。
给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。
返回使 s 单调递增的最小翻转次数。
示例 1： 输入： s = &amp;ldquo;00110&amp;rdquo;
输出： 1
解释： 翻转最后一位得到 00111.
示例 2： 输入： s = &amp;ldquo;010110&amp;rdquo;
输出： 2
解释： 翻转得到 011111，或者是 000111。
示例 3： 输入： s = &amp;ldquo;00011000&amp;rdquo;
输出： 2
解释： 翻转得到 00000000。
提示： 1 &amp;lt;= s.length &amp;lt;= 105 s[i] 为 &#39;0&#39; 或 &#39;1&#39; 解题思路 动态规划 每个字符有 0 和 1 两种情况，若已知反转后的一个 单调递增 字符串分别以 0 和 1 结尾的最小翻转次数，则容易求得在末尾新添一个子串的最小翻转次数。</description>
    </item>
    
    <item>
      <title>Leetcode 1037. 有效的回旋镖</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1037.-%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%97%8B%E9%95%96/</link>
      <pubDate>Thu, 09 Jun 2022 10:04:08 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1037.-%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%97%8B%E9%95%96/</guid>
      <description>链接： https://leetcode.cn/problems/valid-boomerang/
难度： 简单
题目描述 给定一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点，如果这些点构成一个 回旋镖 则返回 true 。
回旋镖 定义为一组三个点，这些点 各不相同 且 不在一条直线上 。
示例 1： 输入： points = [[1,1],[2,3],[3,2]]
输出： true
示例 2： 输入： points = [[1,1],[2,2],[3,3]]
输出： false
提示： points.length == 3 points[i].length == 2 0 &amp;lt;= xi, yi &amp;lt;= 100 解题思路 数学 不妨设三个点为 A、B、C，分别求出直线 AB 和 AC 的斜率，若两条直线斜率相同，又因为有公共点 A，此时三个点在同一条直线上。如下公式：
$$ \frac{y_1-y_0}{x_1-x_0} = \frac{y_2-y_0}{x_2-x_0} $$
注意： 需要处理斜率为 ∞ 的情况，可以将上式进行交叉变换：$ (y_1-y_0)(x_2-x_0) = (y_2-y_0)(x_1-x_0) $</description>
    </item>
    
    <item>
      <title>Leetcode 553. 最优除法</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-553.-%E6%9C%80%E4%BC%98%E9%99%A4%E6%B3%95/</link>
      <pubDate>Sun, 27 Feb 2022 09:54:09 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-553.-%E6%9C%80%E4%BC%98%E9%99%A4%E6%B3%95/</guid>
      <description>链接： https://leetcode-cn.com/problems/optimal-division/
难度： 中等
题目描述 给定一组 正整数，相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -&amp;gt; 2 / 3 / 4 。
但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到 最大的 结果，并且返回相应的字符串格式的表达式。你的表达式不应该含有冗余的括号。
示例： 输入： [1000,100,10,2]
输出： &amp;ldquo;1000/(100/10/2)&amp;rdquo;
解释：
1000/(100/10/2) = 1000/((100/10)/2) = 200
但是，以下加粗的括号 &amp;ldquo;1000/((100/10)/2)&amp;rdquo; 是冗余的，
因为他们并不影响操作的优先级，所以你需要返回 &amp;ldquo;1000/(100/10/2)&amp;quot;。
其他用例:
1000/(100/10)/2 = 50
1000/(100/(10/2)) = 50
1000/100/10/2 = 0.5
1000/100/(10/2) = 2
说明： 输入数组的长度在 [1, 10] 之间。 数组中每个元素的大小都在 [2, 1000] 之间。 每个测试用例只有一个最优除法解。 解题思路 动态规划 对于一个除式而言，为使得其值最大，则要被除数尽量大，而除数尽量小。
需要从原式中找出使得值最大的分割点，则前半部分结果最大，后半部分结果最小，两部分是原问题的子问题，用动态规划求解。
使用 dp[i][j].max 和 dp[i][j].min 记录下标区间 [i, j] 的最大值和最小值，则有状态转移方程：
初始时，dp[i][i].max = dp[i][j].</description>
    </item>
    
    <item>
      <title>Leetcode 688. 骑士在棋盘上的概率</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-688.-%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</link>
      <pubDate>Thu, 17 Feb 2022 09:25:59 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-688.-%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/</guid>
      <description>链接： https://leetcode-cn.com/problems/knight-probability-in-chessboard/
难度： 中等
题目描述 在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。
象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。
每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。
骑士继续移动，直到它走了 k 步或离开了棋盘。
返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。
示例 1： 输入： n = 3, k = 2, row = 0, column = 0
输出： 0.0625
解释： 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。
在每一个位置上，也有两种移动可以让骑士留在棋盘上。
骑士留在棋盘上的总概率是0.0625。
示例 2： 输入： n = 1, k = 0, row = 0, column = 0</description>
    </item>
    
    <item>
      <title>Leetcode 1220. 统计元音字母序列的数目</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1220.-%E7%BB%9F%E8%AE%A1%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE/</link>
      <pubDate>Mon, 17 Jan 2022 10:39:20 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1220.-%E7%BB%9F%E8%AE%A1%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE/</guid>
      <description>链接： https://leetcode-cn.com/problems/count-vowels-permutation/
难度： 困难
题目描述 给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串：
字符串中的每个字符都应当是小写元音字母（&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;）
每个元音 &#39;a&#39; 后面都只能跟着 &#39;e&#39; 每个元音 &#39;e&#39; 后面只能跟着 &#39;a&#39; 或者是 &#39;i&#39; 每个元音 &#39;i&#39; 后面 不能 再跟着另一个 &#39;i&#39; 每个元音 &#39;o&#39; 后面只能跟着 &#39;i&#39; 或者是 &#39;u&#39; 每个元音 &#39;u&#39; 后面只能跟着 &#39;a&#39; 由于答案可能会很大，所以请你返回 模 109 + 7 之后的结果。
示例1： 输入： n = 1
输出： 5
解释： 所有可能的字符串分别是：&amp;ldquo;a&amp;rdquo;, &amp;ldquo;e&amp;rdquo;, &amp;ldquo;i&amp;rdquo; , &amp;ldquo;o&amp;rdquo; 和 &amp;ldquo;u&amp;rdquo;。
示例 2： 输入： n = 2
输出： 10
解释： 所有可能的字符串分别是：&amp;ldquo;ae&amp;rdquo;, &amp;ldquo;ea&amp;rdquo;, &amp;ldquo;ei&amp;rdquo;, &amp;ldquo;ia&amp;rdquo;, &amp;ldquo;ie&amp;rdquo;, &amp;ldquo;io&amp;rdquo;, &amp;ldquo;iu&amp;rdquo;, &amp;ldquo;oi&amp;rdquo;, &amp;ldquo;ou&amp;rdquo; 和 &amp;ldquo;ua&amp;rdquo;。</description>
    </item>
    
    <item>
      <title>Leetcode 1078. Bigram 分词</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1078.-bigram-%E5%88%86%E8%AF%8D/</link>
      <pubDate>Sun, 26 Dec 2021 11:02:37 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1078.-bigram-%E5%88%86%E8%AF%8D/</guid>
      <description>链接： https://leetcode-cn.com/problems/occurrences-after-bigram/
难度： 简单
题目描述 给出第一个词 first 和第二个词 second，考虑在某些文本 text 中可能以 &amp;quot;first second third&amp;quot; 形式出现的情况，其中 second 紧随 first 出现，third 紧随 second 出现。
对于每种这样的情况，将第三个词 &amp;quot;third&amp;quot; 添加到答案中，并返回答案。
示例 1： 输入： text = &amp;ldquo;alice is a good girl she is a good student&amp;rdquo;, first = &amp;ldquo;a&amp;rdquo;, second = &amp;ldquo;good&amp;rdquo;
输出： [&amp;ldquo;girl&amp;rdquo;,&amp;ldquo;student&amp;rdquo;]
示例 2： 输入： text = &amp;ldquo;we will we will rock you&amp;rdquo;, first = &amp;ldquo;we&amp;rdquo;, second = &amp;ldquo;will&amp;rdquo;
输出： [&amp;ldquo;we&amp;rdquo;,&amp;ldquo;rock&amp;rdquo;]
提示： 1 &amp;lt;= text.</description>
    </item>
    
    <item>
      <title>Leetcode 375. 猜数字大小 II</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-375.-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F-ii/</link>
      <pubDate>Fri, 12 Nov 2021 11:30:47 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-375.-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/
难度： 中等
题目描述 我们正在玩一个猜数游戏，游戏规则如下：
我从 1 到 n 之间选择一个数字。 你来猜我选了哪个数字。 如果你猜到正确的数字，就会 赢得游戏 。 如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。 每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。 给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。
示例 1： 输入： n = 10
输出： 16
解释： 制胜策略如下：
数字范围是 [1,10] 。你先猜测数字为 7 。 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。 在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。</description>
    </item>
    
    <item>
      <title>Leetcode 629. K个逆序对数组</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-629.-k%E4%B8%AA%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 11 Nov 2021 10:32:02 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-629.-k%E4%B8%AA%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E7%BB%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/valid-triangle-number/
难度： 困难
题目描述 给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。
逆序对的定义如下：对于数组的第 i 个和第 j 个元素，如果满足 i &amp;lt; j 且 a[i] &amp;gt; a[j]，则其为一个逆序对；否则不是。
由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。
示例 1： 输入: n = 3, k = 0
输出: 1
解释: 只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。
示例 2： 输入: n = 3, k = 1
输出: 2
解释: 数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。</description>
    </item>
    
    <item>
      <title>Leetcode 1218. 最长定差子序列</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1218.-%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Fri, 05 Nov 2021 22:33:00 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1218.-%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/
难度： 中等
题目描述 给你一个整数数组 arr 和一个整数 difference，请你找出并返回 arr 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 difference 。
子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 arr 派生出来的序列。
示例1： 输入： arr = [1,2,3,4], difference = 1
输出： 4
解释： 最长的等差子序列是 [1,2,3,4]。
示例 2： 输入： arr = [1,3,5,7], difference = 1
输出： 1
解释： 最长的等差子序列是任意单个元素。
示例 3： 输入： arr = [1,5,7,8,5,3,4,2,1], difference = -2
输出： 4
解释： 最长的等差子序列是 [7,5,3,1]。
提示： 1 &amp;lt;= arr.length &amp;lt;= 105 -104 &amp;lt;= arr[i], difference &amp;lt;= 104 解题思路 动态规划 对于 arr 中的某个元素 num ，其能否和之前的元素构成等差数列，取决于在其前面是否出现了 num - difference 这个元素，并可以不断向前追溯从而求得队列长度。所以要记录当前出现过的元素，同时为优化追溯过程，需要记录数列长度，故可以使用动态规划求解。</description>
    </item>
    
    <item>
      <title>Leetcode 53. 最大子序和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-53.-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</link>
      <pubDate>Thu, 14 Oct 2021 13:28:41 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-53.-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/maximum-subarray/
难度： 简单
题目描述 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1： 输入： nums = [-2,1,-3,4,-1,2,1,-5,4]
输出： 6
解释： 连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2： 输入： nums = [1]
输出： 1
示例 3： 输入： nums = [0]
输出： 0
示例 4： 输入： nums = [-1]
输出： -1
示例 5： 输入： nums = [-100000]
输出： -100000
提示： 1 &amp;lt;= nums.length &amp;lt;= 105 -104 &amp;lt;= nums[i] &amp;lt;= 104 进阶： 如果你已经实现复杂度为 $O(n)$ 的解法，尝试使用更为精妙的 分治法 求解。</description>
    </item>
    
    <item>
      <title>剑指 Offer 14- I. 剪绳子</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90/</link>
      <pubDate>Mon, 27 Sep 2021 17:22:32 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90/</guid>
      <description>链接： https://leetcode-cn.com/problems/jian-sheng-zi-lcof/
难度： 中等
题目描述 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
示例 1： 输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
示例 2： 输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
提示： 2 &amp;lt;= n &amp;lt;= 58 解题思路 动态规划 使用 dp[i] 表示绳子长度为 i 时的最大乘积。则：
初始，dp[1] = 0 dp[i] = max(dp[j], j) * (dp[i-j], i-j), 1 ≤ j &amp;lt; i func cuttingRope(n int) int { dp := make([]int, n+1) dp[1] = 1 for i := 2; i &amp;lt;= n; i++ { for j := 1; j &amp;lt; i; j++ { factor1 := dp[j] if factor1 &amp;lt; j { factor1 = j } factor2 := dp[i-j] if factor2 &amp;lt; i-j { factor2 = i - j } if dp[i] &amp;lt; factor1*factor2 { dp[i] = factor1 * factor2 } } } return dp[n] } 复杂度 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(n) $ </description>
    </item>
    
    <item>
      <title>剑指 Offer 46. 把数字翻译成字符串</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 20 Sep 2021 20:51:55 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/
难度： 中等
题目描述 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
示例： 输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是&amp;quot;bccfi&amp;quot;, &amp;ldquo;bwfi&amp;rdquo;, &amp;ldquo;bczi&amp;rdquo;, &amp;ldquo;mcfi&amp;quot;和&amp;quot;mzi&amp;rdquo;
提示： 0 &amp;lt;= num &amp;lt; 231 解题思路 动态规划 使用 dp[i] 记录前缀数组可以表示方案的最大值。状态转移方程为：
初始，dp[0] = 1； 如果，nums[i]nums[i+1] 可以翻译，则 dp[i+1] = dp[i] + dp[i-1]； 否则，dp[i+1] = dp[i]。 func translateNum(num int) int { s := strconv.FormatInt(int64(num), 10) dp := make([]int, len(s)) dp[0] = 1 for i := 0; i &amp;lt; len(s)-1; i++ { dp[i+1] = dp[i] if s[i] !</description>
    </item>
    
    <item>
      <title>Leetcode 1480. 一维数组的动态和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1480.-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/</link>
      <pubDate>Sat, 28 Aug 2021 11:05:35 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1480.-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/running-sum-of-1d-array/
难度： 简单
题目描述 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。
请返回 nums 的动态和。
示例 1： 输入： nums = [1,2,3,4]
输出： [1,3,6,10]
解释： 动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。
示例 2： 输入： nums = [1,1,1,1,1]
输出： [1,2,3,4,5]
解释： 动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。
示例 3： 输入： nums = [3,1,2,10,1]
输出： [3,4,6,16,17]
提示： 1 &amp;lt;= nums.length &amp;lt;= 1000 -106 &amp;lt;= nums[i] &amp;lt;= 106 解题思路 模拟 按照题目描述，依次求解动态和的每一项
func runningSum(nums []int) []int { sum := make([]int, len(nums)) for i := 0; i &amp;lt; len(nums); i++ { for j := 0; j &amp;lt;= i; j++ { sum[i] += nums[j] } } return sum } 复杂度 时间复杂度：$ O(N^2), N = len(nums) $ 空间复杂度：$ O(1) $ 动态规划 使用 sum[i] 记录第 i 项动态和，则可以得出：sum[i] = sum[i-1] + nums[i]，依次向后求解。</description>
    </item>
    
    <item>
      <title>Leetcode 576. 出界的路径数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-576.-%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/</link>
      <pubDate>Sun, 15 Aug 2021 11:04:33 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-576.-%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/out-of-boundary-paths/
难度： 中等
题目描述 给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。
给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 + 7 取余 后的结果。
示例 1： &amp;lt;img src=&amp;quot;/img/576.out_of_boundary_paths_1.png&amp;quot;, width=&amp;ldquo;500px&amp;rdquo;&amp;gt;
输入： m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0
输出： 6
示例 2： &amp;lt;img src=&amp;quot;/img/576.out_of_boundary_paths_2.png&amp;quot;, width=&amp;ldquo;500px&amp;rdquo;&amp;gt;
输入： m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1</description>
    </item>
    
    <item>
      <title>Leetcode 516. 最长回文子序列</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-516.-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Thu, 12 Aug 2021 11:16:23 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-516.-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/longest-palindromic-subsequence/
难度： 中等
题目描述 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。
子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
示例 1： 输入： s = &amp;ldquo;bbbab&amp;rdquo;
输出： 4
解释： 一个可能的最长回文子序列为 &amp;ldquo;bbbb&amp;rdquo; 。
示例 2： 输入： s = &amp;ldquo;cbbd&amp;rdquo;
输出： 2
解释： 一个可能的最长回文子序列为 &amp;ldquo;bb&amp;rdquo; 。
注意： 1 &amp;lt;= s.length &amp;lt;= 1000 s 仅由小写英文字母组成 解题思路 动态规划 该题可以转化为寻找原字符串 s 和倒序字符串 s&#39; 的最长公共子序列问题。使用动态规划求解，dp[i][j] 表示以下标 i, j 结尾的前缀字串最长公共子序列的长度，状态转移方程如下：
当 s[i] == s&#39;[j]，dp[i][j] = dp[i-1][j-1] + 1 当 s[i] == s&#39;[j]，dp[i][j] = max(dp[i-1][j], dp[i][j-1] 每次状态转移时仅依赖当前行和上一行，故可以使用滚动数组降低空间复杂度。
func longestPalindromeSubseq(s string) int { dp := [][]int{ make([]int, len(s)+1), make([]int, len(s)+1), } last := 1 cur := 0 for i := 0; i &amp;lt; len(s); i++ { cur, last = last, cur for j := 0; j &amp;lt; len(s); j++ { if s[i] == s[len(s)-1-j] { dp[cur][j+1] = dp[last][j] + 1 } else if dp[cur][j] &amp;gt; dp[last][j+1] { dp[cur][j+1] = dp[cur][j] } else { dp[cur][j+1] = dp[last][j+1] } } } return dp[cur][len(s)] } 复杂度 时间复杂度：$ O(N^2), N = len(s) $ 空间复杂度：$ O(N) $ </description>
    </item>
    
    <item>
      <title>Leetcode 1137. 第 N 个泰波那契数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1137.-%E7%AC%AC-n-%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</link>
      <pubDate>Sun, 08 Aug 2021 09:18:26 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1137.-%E7%AC%AC-n-%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/n-th-tribonacci-number/
难度： 简单
题目描述 泰波那契序列 Tn 定义如下： T0 = 0, T1 = 1, T2 = 1, 且在 n &amp;gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2
给你整数 n，请返回第 n 个泰波那契数 Tn 的值。
示例 1： 输入： n = 4
输出： 4
解释：
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
示例 2： 输入： n = 25 输出： 1389537</description>
    </item>
    
    <item>
      <title>剑指 Offer 42. 连续子数组的最大和</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-42.-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</link>
      <pubDate>Sat, 17 Jul 2021 13:21:52 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-42.-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/
难度： 简单
题目描述 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
要求时间复杂度为$O(n)$。
示例： 输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
提示： 1 &amp;lt;= arr.length &amp;lt;= 105 -100 &amp;lt;= arr[i] &amp;lt;= 100 解题思路 动态规划 用 dp[i] 记录以 i 为结尾的连续子数组和的最大值，容易得到状态转移方程：
dp[0] = nums[0] dp[i] = max(dp[i-1]+nums[i], nums[i]) 由于每次转移仅涉及到前一个结果，使用变量代替数组降低空间复杂度
func maxSubArray(nums []int) int { if len(nums) == 0 { return 0 } dp := nums[0] max := dp for pre, i := 0, 1; i &amp;lt; len(nums); i++ { pre = dp if pre+nums[i] &amp;gt; nums[i] { dp = pre + nums[i] } else { dp = nums[i] } if max &amp;lt; dp { max = dp } } return max } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ </description>
    </item>
    
    <item>
      <title>LCP 07. 传递信息</title>
      <link>https://xianlianghe0123.github.io/p/lcp-07.-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Thu, 01 Jul 2021 11:14:31 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/lcp-07.-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/</guid>
      <description>链接： https://leetcode-cn.com/problems/chuan-di-xin-xi/
难度： 简单
题目描述 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：
有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人 给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。
示例1： 输入： n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3
输出： 3
解释： 信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&amp;gt;2-&amp;gt;0-&amp;gt;4， 0-&amp;gt;2-&amp;gt;1-&amp;gt;4， 0-&amp;gt;2-&amp;gt;3-&amp;gt;4。</description>
    </item>
    
    <item>
      <title>Leetcode 279. 完全平方数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-279.-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</link>
      <pubDate>Fri, 11 Jun 2021 19:33:36 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-279.-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/perfect-squares/
难度： 中等
题目描述 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
示例 1： 输入： n = 12
输出： 3
解释： 12 = 4 + 4 + 4
示例 2： 输入： n = 13
输出： 2
解释： 13 = 4 + 9
注意： 你可以假设：
1 &amp;lt;= n &amp;lt;= 104 解题思路 动态规划 dp[i] 表示组成数字 i 的最少完全平方数，易得到状态转移方程：</description>
    </item>
    
    <item>
      <title>Leetcode 518. 零钱兑换 II</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-518.-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii/</link>
      <pubDate>Thu, 10 Jun 2021 10:35:20 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-518.-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/coin-change-2/
难度： 中等
题目描述 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。
示例 1： 输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
示例 2： 输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。
示例 3： 输入: amount = 10, coins = [10]
输出: 1
注意： 你可以假设：
0 &amp;lt;= amount (总金额) &amp;lt;= 5000 1 &amp;lt;= coin (硬币面额) &amp;lt;= 5000 硬币种类不超过 500 种 结果符合 32 位符号整数 解题思路 动态规划 dp[i][j] 表示前 i 种面额的硬币，组成总金额 j 的方案数，则可以得到状态转移方程：</description>
    </item>
    
    <item>
      <title>Leetcode 1049. 最后一块石头的重量 II</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1049.-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-ii/</link>
      <pubDate>Tue, 08 Jun 2021 11:35:42 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1049.-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/last-stone-weight-ii/
难度： 中等
题目描述 有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。
每一回合，从中选出 任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &amp;lt;= y。那么粉碎的可能结果如下：
如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。
示例 1： 输入： stones = [2,7,4,1,8,1]
输出： 1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</description>
    </item>
    
    <item>
      <title>Leetcode 494. 目标和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-494.-%E7%9B%AE%E6%A0%87%E5%92%8C/</link>
      <pubDate>Mon, 07 Jun 2021 20:34:13 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-494.-%E7%9B%AE%E6%A0%87%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/target-sum/
难度： 中等
题目描述 给你一个整数数组 nums 和一个整数 target 。
向数组中的每个整数前添加 &#39;+&#39; 或 &#39;-&#39; ，然后串联起所有整数，可以构造一个 表达式 ：
例如，nums = [2, 1] ，可以在 2 之前添加 &#39;+&#39; ，在 1 之前添加 &#39;-&#39; ，然后串联起来得到表达式 &amp;quot;+2-1&amp;quot; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。
示例 1： 输入： nums = [1,1,1,1,1], target = 3
输出： 5
解释： 一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3</description>
    </item>
    
    <item>
      <title>Leetcode 474. 一和零</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-474.-%E4%B8%80%E5%92%8C%E9%9B%B6/</link>
      <pubDate>Sun, 06 Jun 2021 10:08:43 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-474.-%E4%B8%80%E5%92%8C%E9%9B%B6/</guid>
      <description>链接： https://leetcode-cn.com/problems/ones-and-zeroes/
难度： 中等
题目描述 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。
请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。
如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。
示例 1： 输入： strs = [&amp;ldquo;10&amp;rdquo;, &amp;ldquo;0001&amp;rdquo;, &amp;ldquo;111001&amp;rdquo;, &amp;ldquo;1&amp;rdquo;, &amp;ldquo;0&amp;rdquo;], m = 5, n = 3
输出： 4
解释： 最多有 5 个 0 和 3 个 1 的最大子集是 {&amp;ldquo;10&amp;rdquo;,&amp;ldquo;0001&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;} ，因此答案是 4 。
其他满足题意但较小的子集包括 {&amp;ldquo;0001&amp;rdquo;,&amp;ldquo;1&amp;rdquo;} 和 {&amp;ldquo;10&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;} 。{&amp;ldquo;111001&amp;rdquo;} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</description>
    </item>
    
    <item>
      <title>Leetcode 1035. 不相交的线</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1035.-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF/</link>
      <pubDate>Fri, 21 May 2021 23:42:03 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1035.-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF/</guid>
      <description>链接： https://leetcode-cn.com/problems/uncrossed-lines/
难度： 中等
题目描述 在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。
现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：
nums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。
以这种方法绘制线条，并返回可以绘制的最大连线数。
示例 1： 输入： nums1 = [1,4,2], nums2 = [1,2,4]
输出： 2
解释： 可以画出两条不交叉的线，如上图所示。
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。
示例 2： 输入： nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]
输出： 3
示例 3: 输入： nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
输出： 2
提示： 1 &amp;lt;= nums1.length &amp;lt;= 500 1 &amp;lt;= nums2.</description>
    </item>
    
    <item>
      <title>Leetcode 1269. 停在原地的方案数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1269.-%E5%81%9C%E5%9C%A8%E5%8E%9F%E5%9C%B0%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/</link>
      <pubDate>Thu, 13 May 2021 23:12:12 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1269.-%E5%81%9C%E5%9C%A8%E5%8E%9F%E5%9C%B0%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/
难度： 困难
题目描述 有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。
每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。
给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。
由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。
示例 1： 输入： steps = 3, arrLen = 2
输出： 4
解释： 3 步后，总共有 4 种不同的方法可以停在索引 0 处。
向右，向左，不动
不动，向右，向左
向右，不动，向左
不动，不动，不动
示例 2： 输入： steps = 2, arrLen = 4
输出： 2
解释： 2 步后，总共有 2 种不同的方法可以停在索引 0 处。
向右，向左
不动，不动</description>
    </item>
    
    <item>
      <title>Leetcode 740. 删除并获得点数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-740.-%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/</link>
      <pubDate>Wed, 05 May 2021 23:47:15 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-740.-%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/delete-and-earn/
难度： 中等
题目描述 给你一个整数数组 nums ，你可以对它进行一些操作。
每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。
开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。
示例1： 输入： nums = [3,4,2]
输出： 6
解释： 删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。
示例2： 输入： nums = [2,2,3,3,3,4]
输出： 9
解释： 删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。</description>
    </item>
    
    <item>
      <title>Leetcode 403. 青蛙过河</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-403.-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/</link>
      <pubDate>Thu, 29 Apr 2021 14:21:06 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-403.-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/</guid>
      <description>链接： https://leetcode-cn.com/problems/frog-jump/
难度： 困难
题目描述 一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。
给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。
开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。
如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。
示例1： 输入： stones = [0,1,3,5,6,8,12,17]
输出： true
解释： 青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</description>
    </item>
    
    <item>
      <title>Leetcode 377. 组合总和 Ⅳ</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-377.-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</link>
      <pubDate>Sat, 24 Apr 2021 21:50:28 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-377.-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/combination-sum-iv/
难度： 中等
题目描述 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。
题目数据保证答案符合 32 位整数范围。
示例 1： 输入： nums = [1,2,3], target = 4
输出： 7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
示例 2： 输入： nums = [9], target = 3
输出： 0
提示： 1 &amp;lt;= nums.length &amp;lt;= 200 1 &amp;lt;= nums[i] &amp;lt;= 1000 nums 中的所有元素 互不相同 1 &amp;lt;= target &amp;lt;= 1000 解题思路 动态规划 用 dp[i] 表示当 i 作为 target 时，排列方案的数量。当 dp[i] 不为 0 时，不妨假设排列的做后一位数字为 num，则 i-num 的排列数为 dp[i-num] ，容易得知状态转移方程：</description>
    </item>
    
    <item>
      <title>Leetcode 91. 解码方式</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-91.-%E8%A7%A3%E7%A0%81%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Wed, 21 Apr 2021 10:35:45 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-91.-%E8%A7%A3%E7%A0%81%E6%96%B9%E5%BC%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/decode-ways/
难度： 中等
题目描述 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
&amp;#39;A&amp;#39; -&amp;gt; 1 &amp;#39;B&amp;#39; -&amp;gt; 2 ... &amp;#39;Z&amp;#39; -&amp;gt; 26 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&amp;quot;11106&amp;quot; 可以映射为：
&amp;quot;AAJF&amp;quot; ，将消息分组为 (1 1 10 6) &amp;quot;KJF&amp;quot; ，将消息分组为 (11 10 6) 注意，消息不能分组为 (1 11 06) ，因为 &amp;quot;06&amp;quot; 不能映射为 &amp;quot;F&amp;quot; ，这是由于 &amp;quot;6&amp;quot; 和 &amp;quot;06&amp;quot; 在映射中并不等价。
给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
题目数据保证答案肯定是一个 32 位 的整数。
示例1： 输入： s = &amp;ldquo;12&amp;rdquo;
输出： 2
解释： 它可以解码为 &amp;ldquo;AB&amp;rdquo;（1 2）或者 &amp;ldquo;L&amp;rdquo;（12）。</description>
    </item>
    
  </channel>
</rss>
