<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hash on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/tags/hash/</link>
    <description>Recent content in hash on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Mon, 01 Nov 2021 23:18:01 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/tags/hash/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 575. 分糖果</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-575.-%E5%88%86%E7%B3%96%E6%9E%9C/</link>
      <pubDate>Mon, 01 Nov 2021 23:18:01 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-575.-%E5%88%86%E7%B3%96%E6%9E%9C/</guid>
      <description>链接： https://leetcode-cn.com/problems/distribute-candies/
难度： 简单
题目描述 Alice 有 n 枚糖，其中第 i 枚糖的类型为 candyType[i] 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。
医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 n / 2 即可（n 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。
给你一个长度为 n 的整数数组 candyType ，返回： Alice 在仅吃掉 n / 2 枚糖的情况下，可以吃到糖的最多种类数。
示例 1：  输入： candyType = [1,1,2,2,3,3]
输出： 3
解释： Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。
 示例 2：  输入： candyType = [1,1,2,3]
输出： 2
解释： Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。</description>
    </item>
    
    <item>
      <title>Leetcode 500. 键盘行</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-500.-%E9%94%AE%E7%9B%98%E8%A1%8C/</link>
      <pubDate>Sun, 31 Oct 2021 13:42:17 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-500.-%E9%94%AE%E7%9B%98%E8%A1%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/keyboard-row/
难度： 简单
题目描述 给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。键盘如下图所示。
美式键盘 中：
 第一行由字符 &amp;quot;qwertyuiop&amp;quot; 组成。 第二行由字符 &amp;quot;asdfghjkl&amp;quot; 组成。 第三行由字符 &amp;quot;zxcvbnm&amp;quot; 组成。  示例 1：  输入： words = [&amp;ldquo;Hello&amp;rdquo;,&amp;ldquo;Alaska&amp;rdquo;,&amp;ldquo;Dad&amp;rdquo;,&amp;ldquo;Peace&amp;rdquo;]
输出： [&amp;ldquo;Alaska&amp;rdquo;,&amp;ldquo;Dad&amp;rdquo;]
 示例 2：  输入： words = [&amp;ldquo;omk&amp;rdquo;]
输出： []
 示例 3：  输入： words = [&amp;ldquo;adsdf&amp;rdquo;,&amp;ldquo;sfd&amp;rdquo;]
输出： [&amp;ldquo;adsdf&amp;rdquo;,&amp;ldquo;sfd&amp;rdquo;]
 提示：  1 &amp;lt;= words.length &amp;lt;= 20 1 &amp;lt;= words[i].length &amp;lt;= 100 words[i] 由英文字母（小写和大写字母）组成  解题思路 哈希 使用哈希表记录每个字母对应的行号。之后遍历每个字符串，判断每个字母行号是否相同。</description>
    </item>
    
    <item>
      <title>Leetcode 260. 只出现一次的数字 III</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-260.-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-iii/</link>
      <pubDate>Sat, 30 Oct 2021 11:40:06 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-260.-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-iii/</guid>
      <description>链接： https://leetcode-cn.com/problems/single-number-iii/
难度： 中等
题目描述 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。
进阶： 你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？
示例 1：  输入： nums = [1,2,1,3,2,5]
输出： [3,5]
解释： [5, 3] 也是有效的答案。
 示例 2：  输入： nums = [-1,0]
输出： [-1,0]
 示例 3：  输入： nums = [0,1]
输出： [1,0]
 提示：  2 &amp;lt;= nums.length &amp;lt;= 3 * 104 -231 &amp;lt;= nums[i] &amp;lt;= 231 - 1 除两个只出现一次的整数外，nums 中的其他数字都出现两次  解题思路 哈希 使用哈希表统计数字的出现次数，将出现次数为 1 的加入到结果中。</description>
    </item>
    
    <item>
      <title>Leetcode 229. 求众数 II</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-229.-%E6%B1%82%E4%BC%97%E6%95%B0-ii/</link>
      <pubDate>Fri, 22 Oct 2021 10:50:56 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-229.-%E6%B1%82%E4%BC%97%E6%95%B0-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/majority-element-ii/
难度： 中等
题目描述 给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。
示例 1：  输入： [3,2,3]
输出： [3]
 示例 2：  输入： nums = [1]
输出： [1]
 示例 3：  输入： [1,1,1,3,3,2,2,2]
输出： [1,2]
 提示：  1 &amp;lt;= nums.length &amp;lt;= 5 * 104 -109 &amp;lt;= nums[i] &amp;lt;= 109  解题思路 哈希 使用哈希表统计每个数字出现的数量，当其首次超过 ⌊ n/3 ⌋ 次时候，加入到结果集合中。
func majorityElement(nums []int) []int { major := make([]int, 0, 2) minCnt := len(nums)/3 + 1 cnt := make(map[int]int) for _, num := range nums { cnt[num]++ if cnt[num] == minCnt { major = append(major, num) } } return major } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  </description>
    </item>
    
    <item>
      <title>Leetcode 187. 重复的DNA序列</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-187.-%E9%87%8D%E5%A4%8D%E7%9A%84dna%E5%BA%8F%E5%88%97/</link>
      <pubDate>Fri, 08 Oct 2021 10:51:30 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-187.-%E9%87%8D%E5%A4%8D%E7%9A%84dna%E5%BA%8F%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/repeated-dna-sequences/
难度： 中等
题目描述 所有 DNA 都由一系列缩写为 &#39;A&#39;，&#39;C&#39;，&#39;G&#39; 和 &#39;T&#39; 的核苷酸组成，例如：&amp;quot;ACGAATTCCG&amp;quot;。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。
编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。
示例 1：  输入： s = &amp;ldquo;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&amp;rdquo;
输出： [&amp;ldquo;AAAAACCCCC&amp;rdquo;,&amp;ldquo;CCCCCAAAAA&amp;rdquo;]
 示例 2：  输入： s = &amp;ldquo;AAAAAAAAAAAAA&amp;rdquo;
输出： [&amp;ldquo;AAAAAAAAAA&amp;rdquo;]
 提示：  0 &amp;lt;= s.length &amp;lt;= 105 s[i] 为 &amp;lsquo;A&amp;rsquo;、&amp;lsquo;C&amp;rsquo;、&amp;lsquo;G&amp;rsquo; 或 &amp;lsquo;T&amp;rsquo;  解题思路 哈希 使用哈希表记录每个长度为 10 的字串的出现次数，出现次数大于 1 时，添加到结果队列中。
func findRepeatedDnaSequences(s string) []string { ans := make([]string, 0) cnt := make(map[string]int) for i := 10; i &amp;lt;= len(s); i++ { cnt[s[i-10:i]]++ if cnt[s[i-10:i]] == 2 { ans = append(ans, s[i-10:i]) } } return ans } 复杂度  时间复杂度：$ O(N) , N = len(s) $ 空间复杂度：$ O(N) $  </description>
    </item>
    
    <item>
      <title>Leetcode 3. 无重复字符的最长子串</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-3.-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Wed, 06 Oct 2021 22:51:34 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-3.-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/
难度： 中等
题目描述 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1：  输入: &amp;ldquo;abcabcbb&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;ldquo;abc&amp;rdquo;，所以其长度为 3。
 示例 2：  输入: &amp;ldquo;bbbbb&amp;rdquo;
输出: 1
解释: 因为无重复字符的最长子串是 &amp;ldquo;b&amp;rdquo;，所以其长度为 1。
 示例 3：  输入: &amp;ldquo;pwwkew&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;ldquo;wke&amp;rdquo;，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，&amp;ldquo;pwke&amp;rdquo; 是一个子序列，不是子串。
 示例 4：  输入: s = &amp;quot;&amp;quot;
输出: 0
 提示：  0 &amp;lt;= s.length &amp;lt;= 5 * 104 s 由英文字母、数字、符号和空格组成  解题思路 哈希 + 双指针 使用哈希表记录每个字符出现的下标，并记录有效字串开始的下标 start：当出现重复字符时，将 start 修正为重复字符出现的下一个位置。</description>
    </item>
    
    <item>
      <title>剑指 Offer 59 - I. 滑动窗口的最大值</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-59-i.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</link>
      <pubDate>Tue, 05 Oct 2021 18:12:15 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-59-i.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</guid>
      <description>链接： https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/
难度： 困难
题目描述 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。
示例：  输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7]
解释:
滑动窗口的位置 最大值
[1 3 -1] -3 5 3 6 7 3
1 [3 -1 -3] 5 3 6 7 3
1 3 [-1 -3 5] 3 6 7 5
1 3 -1 [-3 5 3] 6 7 5
1 3 -1 -3 [5 3 6] 7 6
1 3 -1 -3 5 [3 6 7] 7</description>
    </item>
    
    <item>
      <title>剑指 Offer 56 - II. 数组中数字出现的次数 II</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-56-ii.-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-ii/</link>
      <pubDate>Wed, 29 Sep 2021 20:54:30 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-56-ii.-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/
难度： 中等
题目描述 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
示例 1：  输入： nums = [3,4,3,3]
输出： 4
 示例 2：  输入： nums = [9,1,7,9,7,9,7]
输出： 1
 限制：  1 &amp;lt;= nums.length &amp;lt;= 10000 1 &amp;lt;= nums[i] &amp;lt; 231  解题思路 哈希 使用哈希表记录每个数字出现的次数，找到出现次数为 1 的返回即可。
func singleNumber(nums []int) int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ } for num, v := range cnt { if v == 1 { return num } } return 0 } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  排序 将整个数组排序，没三个一组进行首尾比较，相同继续，不同返回。</description>
    </item>
    
    <item>
      <title>剑指 Offer 53 - II. 0～n-1中缺失的数字</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-53-ii.-0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Tue, 28 Sep 2021 11:25:44 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-53-ii.-0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/
难度： 简单
题目描述 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
示例 1：  输入: [0,1,3]
输出: 2
 示例 2：  输入: [0,1,2,3,4,5,6,7,9]
输出: 8
 提示：  1 &amp;lt;= 数组长度 &amp;lt;= 10000  解题思路 哈希 使用哈希表标识出现过数字，遍历数据，将位于数组中的数字添加到哈希表中，然后在哈希表中寻找没有出现过的数。
func missingNumber(nums []int) int { exist := make(map[int]struct{}) for _, num := range nums { exist[num] = struct{}{} } for i := 0; i &amp;lt; len(nums); i++ { if _, ok := exist[i]; !ok { return i } } return len(nums) } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  顺序查找 由于数组递增，只需要找到与下标不相同的数，返回其下标即可。</description>
    </item>
    
    <item>
      <title>剑指 Offer 57. 和为s的两个数字</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-57.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 22 Sep 2021 19:39:43 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-57.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/
难度： 简单
题目描述 输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
示例 1：  输入： nums = [2,7,11,15], target = 9
输出： [2,7] 或者 [7,2]
 示例 2：  输入： nums = [10,26,30,31,47,60], target = 40
输出： [10,30] 或者 [30,10]
 限制：  1 &amp;lt;= nums.length &amp;lt;= 105 1 &amp;lt;= nums[i] &amp;lt;= 106  解题思路 哈希 使用哈希表记录每个数字是否出现过，遍历数组，计算对应的另一个数，若已出现过则返回这两个数。
func twoSum(nums []int, target int) []int { hash := make(map[int]struct{}) for _, num := range nums { if _, ok := hash[target-num]; ok { return []int{num, target - num} } hash[num] = struct{}{} } return make([]int, 0) } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  双指针 使用两个指针 i, j 从头尾分别向中间遍历：</description>
    </item>
    
    <item>
      <title>剑指 Offer 50. 第一个只出现一次的字符</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Tue, 21 Sep 2021 23:36:33 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</guid>
      <description>链接： https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/
难度： 简单
题目描述 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。
示例 1：  输入： s = &amp;ldquo;abaccdeff&amp;rdquo;
输出： &amp;lsquo;b&amp;rsquo;
 示例 2：  输入： s = &amp;quot;&amp;quot;
输出： &#39; &#39;
 限制：  0 &amp;lt;= s 的长度 &amp;lt;= 50000  解题思路 哈希 + 两次遍历 第一次遍历，使用哈希表记录每个字符是否重复出现；第二次遍历，返回找到的第一个不重复的字符，找不到返回 &#39; &#39;。
func firstUniqChar(s string) byte { repeat := make(map[byte]bool) for i := range s { _, ok := repeat[s[i]] if !ok { repeat[s[i]] = false } else { repeat[s[i]] = true } } for i := range s { if !</description>
    </item>
    
    <item>
      <title>剑指 Offer 49. 丑数</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-49.-%E4%B8%91%E6%95%B0/</link>
      <pubDate>Tue, 21 Sep 2021 17:50:14 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-49.-%E4%B8%91%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/chou-shu-lcof/
难度： 中等
题目描述 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。
示例：  输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
 说明：  1 是丑数。 n 不超过 1690。  解题思路 堆 + 哈希 维护一个小顶堆和哈希表，初始堆中元素为 1，每次弹出堆顶最小元素，然后将其分别乘以 2、3、5加入堆中，此处需要使用哈希表去重。
弹出的第 n 个数即为第 n 个丑数。
type MinHeap struct { sort.IntSlice } func (this *MinHeap) Push(x interface{}) { this.IntSlice = append(this.</description>
    </item>
    
    <item>
      <title>剑指 Offer 48. 最长不含重复字符的子字符串</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 21 Sep 2021 16:18:26 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/
难度： 中等
题目描述 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
示例 1：  输入: &amp;ldquo;abcabcbb&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;ldquo;abc&amp;rdquo;，所以其长度为 3。
 示例 2：  输入: &amp;ldquo;bbbbb&amp;rdquo;
输出: 1
解释: 因为无重复字符的最长子串是 &amp;ldquo;b&amp;rdquo;，所以其长度为 1。
 示例 3：  输入: &amp;ldquo;pwwkew&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;ldquo;wke&amp;rdquo;，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，&amp;ldquo;pwke&amp;rdquo; 是一个子序列，不是子串。
 提示：  s.length &amp;lt;= 40000  解题思路 哈希 + 双指针 使用哈希表记录每个字符出现过下标，并记录有效数组开始的下标 start：当出现重复字符时，将 start 修正为重复字符出现的下一个下标。
func lengthOfLongestSubstring(s string) int { ans := 0 pos := make(map[byte]int) start := 0 for i := 0; i &amp;lt; len(s); i++ { p, ok := pos[s[i]] if ok &amp;amp;&amp;amp; start &amp;lt;= p { start = p + 1 } pos[s[i]] = i if ans &amp;lt; i-start+1 { ans = i - start + 1 } } return ans } 复杂度  时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 39. 数组中出现次数超过一半的数字</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-39.-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 20 Sep 2021 16:00:42 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-39.-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/
难度： 简单
题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
示例：  输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2
 提示：  1 &amp;lt;= 数组长度 &amp;lt;= 50000  解题思路 哈希 遍历数组，用哈希表记录每个元素的出现次数，当超过半数时返回。
func majorityElement(nums []int) int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ if cnt[num] &amp;gt; len(nums)/2 { return num } } return 0 } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  排序 对数组排序，位于中间位置对必为多数元素。</description>
    </item>
    
    <item>
      <title>剑指 Offer 35. 复杂链表的复制</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-35.-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 20 Sep 2021 15:16:13 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-35.-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</guid>
      <description>链接： https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/
难度： 中等
题目描述 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。
示例 1：  输入： head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出： [[7,null],[13,0],[11,4],[10,2],[1,0]]
 示例 2：  输入： head = [[1,1],[2,1]]
输出： [[1,1],[2,1]]
 示例 3：  输入： head = [[3,null],[3,0],[3,null]]
输出： [[3,null],[3,0],[3,null]]
 示例 4:  输入： head = []
输出： []
解释： 给定的链表为空（空指针），因此返回 null
 提示：  -10000 &amp;lt;= Node.val &amp;lt;= 10000 Node.random 为空（null）或指向链表中的节点。 节点数目不超过 1000 。  解题思路 哈希 使用哈希表维护一个旧结点到新结点的映射，依次从前向后遍历链表，并逐一的构造新链表。</description>
    </item>
    
    <item>
      <title>Leetcode 36. 有效的数独</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-36.-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</link>
      <pubDate>Fri, 17 Sep 2021 11:22:25 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-36.-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</guid>
      <description>链接： https://leetcode-cn.com/problems/valid-sudoku/
难度： 中等
题目描述 请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）  数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。
注意： 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。
示例 1：  输入： board =
[[&amp;quot;5&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;], ,[&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;], ,[&amp;quot;.&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;], ,[&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;], ,[&amp;quot;4&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;], ,[&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;], ,[&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;], ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;5&amp;quot;], ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;9&amp;quot;]] 输出： true
 示例 2：  输入： board =
[[&amp;quot;8&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;] ,[&amp;quot;4&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;] ,[&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;5&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;9&amp;quot;]] 输出： false
解释： 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</description>
    </item>
    
    <item>
      <title>剑指 Offer 03. 数组中重复的数字</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Thu, 16 Sep 2021 19:19:47 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/
难度： 简单
题目描述 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
示例：  输入：
[2, 3, 1, 0, 2, 5, 3]
输出： 2 或 3
 提示：  2 &amp;lt;= n &amp;lt;= 100000  解题思路 哈希 使用哈希表记录数组中的元素是否出现过。遍历数组，如果出现过则返回；否则，在哈希表中标记该元素已出现。
func findRepeatNumber(nums []int) int { appear := make(map[int]struct{}) for _, num := range nums { if _, ok := appear[num]; ok { return num } appear[num] = struct{}{} } return 0 } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  </description>
    </item>
    
    <item>
      <title>Leetcode 447. 回旋镖的数量</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-447.-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/</link>
      <pubDate>Mon, 13 Sep 2021 10:21:25 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-447.-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/number-of-boomerangs/
难度： 中等
题目描述 给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。
返回平面上所有回旋镖的数量。
示例 1：  输入： points = [[0,0],[1,0],[2,0]]
输出： 2
解释： 两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]
 示例 2：  输入： points = [[1,1],[2,2],[3,3]]
输出： 2
 示例 3：  输入： points = [[1,1]]
输出： 0
 提示：  n == points.</description>
    </item>
    
    <item>
      <title>Leetcode 313. 超级丑数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-313.-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/</link>
      <pubDate>Mon, 09 Aug 2021 11:00:42 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-313.-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/super-ugly-number/
难度： 中等
题目描述 超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。
给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。
题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。
示例 1：  输入： n = 12, primes = [2,7,13,19]
输出： 32
解释： 给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。
 示例 2：  输入： n = 1, primes = [2,3,5]
输出： 1
解释： 1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。
 注意：  1 &amp;lt;= n &amp;lt;= 106 1 &amp;lt;= primes.</description>
    </item>
    
    <item>
      <title>Leetcode 987. 二叉树的垂序遍历</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-987.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sat, 31 Jul 2021 12:57:30 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-987.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>链接： https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/
难度： 困难
题目描述 给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。
对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。
二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。
返回二叉树的 垂序遍历 序列。
示例 1：  输入： root = [3,9,20,null,null,15,7]
输出： [[9],[3,15],[20],[7]]
解释：
列 -1 ：只有结点 9 在此列中。
列 0 ：只有结点 3 和 15 在此列中，按从上到下顺序。
列 1 ：只有结点 20 在此列中。
列 2 ：只有结点 7 在此列中。
 示例 2：  输入： root = [1,2,3,4,5,6,7]</description>
    </item>
    
    <item>
      <title>Leetcode 1743. 从相邻元素对还原数组</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1743.-%E4%BB%8E%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E5%AF%B9%E8%BF%98%E5%8E%9F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 25 Jul 2021 21:48:26 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1743.-%E4%BB%8E%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E5%AF%B9%E8%BF%98%E5%8E%9F%E6%95%B0%E7%BB%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/
难度： 中等
题目描述 存在一个由 n 个不同元素组成的整数数组 nums ，但你已经记不清具体内容。好在你还记得 nums 中的每一对相邻元素。
给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个 adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。
题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。这些相邻元素对可以 按任意顺序 出现。
返回 原始数组 nums 。如果存在多种解答，返回 其中任意一个 即可。
示例 1：  输入： adjacentPairs = [[2,1],[3,4],[3,2]]
输出： [1,2,3,4]
解释： 数组的所有相邻元素对都在 adjacentPairs 中。
特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。
 示例 2：  输入： adjacentPairs = [[4,-2],[1,4],[-3,1]]</description>
    </item>
    
    <item>
      <title>Leetcode 1893. 检查是否区域内所有整数都被覆盖</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1893.-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%8C%BA%E5%9F%9F%E5%86%85%E6%89%80%E6%9C%89%E6%95%B4%E6%95%B0%E9%83%BD%E8%A2%AB%E8%A6%86%E7%9B%96/</link>
      <pubDate>Fri, 23 Jul 2021 10:32:17 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1893.-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%8C%BA%E5%9F%9F%E5%86%85%E6%89%80%E6%9C%89%E6%95%B4%E6%95%B0%E9%83%BD%E8%A2%AB%E8%A6%86%E7%9B%96/</guid>
      <description>链接： https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/
难度： 简单
题目描述 给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的 闭区间 。
如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个 区间覆盖，那么请你返回 true ，否则返回 false 。
已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti &amp;lt;= x &amp;lt;= endi ，那么我们称整数 x 被覆盖了。
示例 1：  输入： ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5
输出： true
解释： 2 到 5 的每个整数都被覆盖了：</description>
    </item>
    
    <item>
      <title>Leetcode 138. 复制带随机指针的链表</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-138.-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 22 Jul 2021 11:22:49 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-138.-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/copy-list-with-random-pointer/
难度： 中等
题目描述 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。
构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。
例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --&amp;gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --&amp;gt; y 。
返回复制链表的头节点。
用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：
 val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。  你的代码 只 接受原链表的头节点 head 作为传入参数。
示例 1：  输入： head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出： [[7,null],[13,0],[11,4],[10,2],[1,0]]</description>
    </item>
    
    <item>
      <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 21 Jul 2021 10:43:36 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/
难度： 简单
题目描述 输入两个链表，找出它们的第一个公共节点。
如下面的两个链表：
在节点 c1 开始相交。
示例 1：  输入： intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出： Reference of the node with value = 8
输入解释： 相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
 示例 2：  输入： intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</description>
    </item>
    
    <item>
      <title>面试题 10.02. 变位词组</title>
      <link>https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-10.02.-%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84/</link>
      <pubDate>Sun, 18 Jul 2021 11:32:11 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-10.02.-%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/group-anagrams-lcci/
难度： 中等
题目描述 编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。
**注意：**本题相对原题稍作修改
示例：  输入: [&amp;ldquo;eat&amp;rdquo;, &amp;ldquo;tea&amp;rdquo;, &amp;ldquo;tan&amp;rdquo;, &amp;ldquo;ate&amp;rdquo;, &amp;ldquo;nat&amp;rdquo;, &amp;ldquo;bat&amp;rdquo;],
输出:
[
[&amp;ldquo;ate&amp;rdquo;,&amp;ldquo;eat&amp;rdquo;,&amp;ldquo;tea&amp;rdquo;],
[&amp;ldquo;nat&amp;rdquo;,&amp;ldquo;tan&amp;rdquo;],
[&amp;ldquo;bat&amp;rdquo;]
]
 解题思路 哈希 &amp;amp; 计数 对于每个字符串，使用数组统计每个字母出现的数字，两个同位词得出的统计数组必然相同，故用该数组作为 key
func groupAnagrams(strs []string) [][]string { cnt := func(s string) (cnt [26]int) { for i := range s { cnt[s[i]-&amp;#39;a&amp;#39;]++ } return } hash := make(map[[26]int][]string) for _, str := range strs { key := cnt(str) hash[key] = append(hash[key], str) } res := make([][]string, 0, len(hash)) for _, v := range hash { res = append(res, v) } return res } 复杂度  时间复杂度：$ O(NL), N = len(strs), L = max(len(str)) $ 空间复杂度：$ O(NL) $  哈希 &amp;amp; 排序 不同变位词中字母相同，所以将字符串按照字母排序后，其值也一定相同。故可以将其排序后的值作为哈希表的 key，并将其添加进 value 数组中。</description>
    </item>
    
    <item>
      <title>Leetcode 981. 基于时间的键值存储</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-981.-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/</link>
      <pubDate>Sat, 10 Jul 2021 11:47:18 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-981.-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/time-based-key-value-store/
难度： 中等
题目描述 创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作：
 set(string key, string value, int timestamp)  存储键 key、值 value，以及给定的时间戳 timestamp。
get(string key, int timestamp)  返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev &amp;lt;= timestamp。 如果有多个这样的值，则返回对应最大的 timestamp_prev 的那个值。 如果没有值，则返回空字符串（&amp;quot;&amp;quot;）。    示例1：  输入： inputs = [&amp;ldquo;TimeMap&amp;rdquo;,&amp;ldquo;set&amp;rdquo;,&amp;ldquo;get&amp;rdquo;,&amp;ldquo;get&amp;rdquo;,&amp;ldquo;set&amp;rdquo;,&amp;ldquo;get&amp;rdquo;,&amp;ldquo;get&amp;rdquo;], inputs = [[],[&amp;ldquo;foo&amp;rdquo;,&amp;ldquo;bar&amp;rdquo;,1],[&amp;ldquo;foo&amp;rdquo;,1],[&amp;ldquo;foo&amp;rdquo;,3],[&amp;ldquo;foo&amp;rdquo;,&amp;ldquo;bar2&amp;rdquo;,4],[&amp;ldquo;foo&amp;rdquo;,4],[&amp;ldquo;foo&amp;rdquo;,5]]
输出： [null,null,&amp;ldquo;bar&amp;rdquo;,&amp;ldquo;bar&amp;rdquo;,null,&amp;ldquo;bar2&amp;rdquo;,&amp;ldquo;bar2&amp;rdquo;]
解释：
TimeMap kv;
kv.set(&amp;ldquo;foo&amp;rdquo;, &amp;ldquo;bar&amp;rdquo;, 1); // 存储键 &amp;ldquo;foo&amp;rdquo; 和值 &amp;ldquo;bar&amp;rdquo; 以及时间戳 timestamp = 1
kv.get(&amp;ldquo;foo&amp;rdquo;, 1); // 输出 &amp;ldquo;bar&amp;rdquo;</description>
    </item>
    
    <item>
      <title>面试题 17.10. 主要元素</title>
      <link>https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.10.-%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/</link>
      <pubDate>Fri, 09 Jul 2021 10:46:07 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.10.-%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/</guid>
      <description>链接： https://leetcode-cn.com/problems/find-majority-element-lcci/
难度： 简单
题目描述 数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 $O(N)$ 、空间复杂度为 $O(1)$ 的解决方案。
示例 1：  输入： [1,2,5,9,5,9,5,5,5]
输出： 5
 示例 2：  输入： [3,2]
输出： -1
 示例 3：  输入： [2,2,1,1,1,2,2]
输出： 2
 解题思路 哈希计数 遍历数组，记录每个数出现的次数，直到某个数 num 出现的次数大于数组长度的一半则返回 num，否则返回 -1
func majorityElement(nums []int) int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ if cnt[num] &amp;gt; len(nums)/2 { return num } } return -1 } 复杂度  时间复杂度：$ O(N) $ 空间复杂度：$ O(N) $  排序 将数组排序，依次统计连续相同数字的数量，直到满足条件为止。</description>
    </item>
    
    <item>
      <title>Leetcode 930. 和相同的二元子数组</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-930.-%E5%92%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E5%85%83%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 08 Jul 2021 15:11:00 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-930.-%E5%92%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E5%85%83%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-subarrays-with-sum/
难度： 中等
题目描述 给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。
子数组 是数组的一段连续部分。
示例 1：  输入： nums = [1,0,1,0,1], goal = 2
输出： 4
解释：
有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]
 示例 2：  输入： nums = [0,0,0,0,0], goal = 0
输出： 15
 提示：  1 &amp;lt;= nums.length &amp;lt;= 3 * 104 nums[i] 不是 0 就是 1 0 &amp;lt;= goal &amp;lt;= nums.length  解题思路 哈希 假设满足条件的子数组下标为 [i, j) ，则以 i 和 j 为结尾的两个前缀数组的前缀和记作 sum[i]、sum[j] ，有 goal = sum[j] - sum[i]。</description>
    </item>
    
  </channel>
</rss>
