<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>binary search on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/tags/binary-search/</link>
    <description>Recent content in binary search on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Mon, 30 Aug 2021 10:33:25 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/tags/binary-search/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 528. 按权重随机选择</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-528.-%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9/</link>
      <pubDate>Mon, 30 Aug 2021 10:33:25 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-528.-%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9/</guid>
      <description>链接： https://leetcode-cn.com/problems/random-pick-with-weight/
难度： 中等
题目描述 给定一个正整数数组 w ，其中 w[i] 代表下标 i 的权重（下标从 0 开始），请写一个函数 pickIndex ，它可以随机地获取下标 i，选取下标 i 的概率与 w[i] 成正比。
例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。
也就是说，选取下标 i 的概率为 w[i] / sum(w) 。
示例 1：  输入：
[&amp;ldquo;Solution&amp;rdquo;,&amp;ldquo;pickIndex&amp;rdquo;]
[[[1]],[]]
输出：
[null,0]
解释：
Solution solution = new Solution([1]);
solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。</description>
    </item>
    
    <item>
      <title>Leetcode 611. 有效三角形的个数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-611.-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Wed, 04 Aug 2021 10:42:47 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-611.-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/valid-triangle-number/
难度： 中等
题目描述 给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。
示例：  输入: [2,2,3,4]
输出: 3
解释:
有效的组合是:
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
 注意：  数组长度不超过1000。 数组里整数的范围为 [0, 1000]。  解题思路 排序 + 二分查找 构成三角形的前提条件是两边之和小于第三边，也就是说，两个小边之和大于最长的那条边。
故，首先对数组进行排序，然后依次枚举两条小边 x 和 y ，其下标为 i 和 j (不妨假设 i ≤ i，则  x ≤ y)，即得到最大边的取值范围 x+y-1， 通过二分查找，找到其最大值的位置，与 j 相减即得到可取值的数量，求和。
func triangleNumber(nums []int) int { sort.Ints(nums) res := 0 for i := 0; i &amp;lt; len(nums)-2; i++ { if nums[i] == 0 { continue } for j := i + 1; j &amp;lt; len(nums)-1; j++ { pos := sort.</description>
    </item>
    
    <item>
      <title>Leetcode 1337. 矩阵中战斗力最弱的 K 行</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1337.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%88%98%E6%96%97%E5%8A%9B%E6%9C%80%E5%BC%B1%E7%9A%84-k-%E8%A1%8C/</link>
      <pubDate>Sun, 01 Aug 2021 09:54:54 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1337.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%88%98%E6%96%97%E5%8A%9B%E6%9C%80%E5%BC%B1%E7%9A%84-k-%E8%A1%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/
难度： 简单
题目描述 给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。
请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。
如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。
军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。
示例 1：  **输入：**mat =
[[1,1,0,0,0],
[1,1,1,1,0],
[1,0,0,0,0],
[1,1,0,0,0],
[1,1,1,1,1]],
k = 3
输出：[2,0,3]
解释： 每行中的军人数目： 行 0 -&amp;gt; 2
行 1 -&amp;gt; 4
行 2 -&amp;gt; 1
行 3 -&amp;gt; 2
行 4 -&amp;gt; 5</description>
    </item>
    
    <item>
      <title>剑指 Offer 53 - I. 在排序数组中查找数字 I</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-53-i.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-i/</link>
      <pubDate>Fri, 16 Jul 2021 14:55:24 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-53-i.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-i/</guid>
      <description>链接： https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/
难度： 简单
题目描述 统计一个数字在排序数组中出现的次数。
示例 1：  输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
 示例 2：  输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
 提示：  0 &amp;lt;= 数组长度 &amp;lt;= 50000  解题思路 顺序查找 顺序遍历，统计数量 target。由于数组有序，当当前元素大于 target时，
func search(nums []int, target int) int { cnt := 0 for _, num := range nums { if num == target { cnt++ } else if num &amp;gt; target { break } } return cnt } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $  二分查找 二分查找，找到首个等于 target 的元素位置，依次向后遍历到元素不等于 target 为止，记录出现的次数。</description>
    </item>
    
    <item>
      <title>Leetcode 1818. 绝对差值和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1818.-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E5%80%BC%E5%92%8C/</link>
      <pubDate>Wed, 14 Jul 2021 10:34:23 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1818.-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E5%80%BC%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/minimum-absolute-sum-difference/
难度： 中等
题目描述 给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。
数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|（0 &amp;lt;= i &amp;lt; n）的 总和（下标从 0 开始）。
你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。
在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 109 + 7 取余 后返回。
|x| 定义为：
 如果 x &amp;gt;= 0 ，值为 x ，或者 如果 x &amp;lt;= 0 ，值为 -x  示例 1：  **输入：**nums1 = [1,7,5], nums2 = [2,3,5]</description>
    </item>
    
    <item>
      <title>Leetcode 275. H 指数 II</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-275.-h-%E6%8C%87%E6%95%B0-ii/</link>
      <pubDate>Mon, 12 Jul 2021 10:50:26 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-275.-h-%E6%8C%87%E6%95%B0-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/h-index-ii/
难度： 中等
题目描述 给定一位研究者论文被引用次数的数组（被引用次数是非负整数）,数组已经按照 升序排列。编写一个方法，计算出研究者的 h 指数。
h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共 有 h 篇论文分别被引用了至少 h 次。且其余的 $N - h$ 篇论文每篇被引用次数 不超过 h 次。
例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。
示例：  **输入：**citations = [0,1,3,5,6]
**输出：**3
**解释：**给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。
由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。
 **说明：**如果 h 有多种可能的值，h 指数是其中最大的那个。</description>
    </item>
    
    <item>
      <title>Leetcode 981. 基于时间的键值存储</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-981.-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/</link>
      <pubDate>Sat, 10 Jul 2021 11:47:18 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-981.-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/time-based-key-value-store/
难度： 中等
题目描述 创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作：
 set(string key, string value, int timestamp)  存储键 key、值 value，以及给定的时间戳 timestamp。
get(string key, int timestamp)  返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev &amp;lt;= timestamp。 如果有多个这样的值，则返回对应最大的 timestamp_prev 的那个值。 如果没有值，则返回空字符串（&amp;quot;&amp;quot;）。    示例1：  **输入：**inputs = [&amp;ldquo;TimeMap&amp;rdquo;,&amp;ldquo;set&amp;rdquo;,&amp;ldquo;get&amp;rdquo;,&amp;ldquo;get&amp;rdquo;,&amp;ldquo;set&amp;rdquo;,&amp;ldquo;get&amp;rdquo;,&amp;ldquo;get&amp;rdquo;], inputs = [[],[&amp;ldquo;foo&amp;rdquo;,&amp;ldquo;bar&amp;rdquo;,1],[&amp;ldquo;foo&amp;rdquo;,1],[&amp;ldquo;foo&amp;rdquo;,3],[&amp;ldquo;foo&amp;rdquo;,&amp;ldquo;bar2&amp;rdquo;,4],[&amp;ldquo;foo&amp;rdquo;,4],[&amp;ldquo;foo&amp;rdquo;,5]]
输出：[null,null,&amp;ldquo;bar&amp;rdquo;,&amp;ldquo;bar&amp;rdquo;,null,&amp;ldquo;bar2&amp;rdquo;,&amp;ldquo;bar2&amp;rdquo;]
解释：
TimeMap kv;
kv.set(&amp;ldquo;foo&amp;rdquo;, &amp;ldquo;bar&amp;rdquo;, 1); // 存储键 &amp;ldquo;foo&amp;rdquo; 和值 &amp;ldquo;bar&amp;rdquo; 以及时间戳 timestamp = 1
kv.get(&amp;ldquo;foo&amp;rdquo;, 1); // 输出 &amp;ldquo;bar&amp;rdquo;
kv.get(&amp;ldquo;foo&amp;rdquo;, 3); // 输出 &amp;ldquo;bar&amp;rdquo; 因为在时间戳 3 和时间戳 2 处没有对应 &amp;ldquo;foo&amp;rdquo; 的值，所以唯一的值位于时间戳 1 处（即 &amp;gt; &amp;ldquo;bar&amp;rdquo;）</description>
    </item>
    
  </channel>
</rss>
