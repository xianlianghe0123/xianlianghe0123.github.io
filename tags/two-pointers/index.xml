<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>two pointers on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/tags/two-pointers/</link>
    <description>Recent content in two pointers on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Wed, 22 Sep 2021 19:39:43 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/tags/two-pointers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>剑指 Offer 57. 和为s的两个数字</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-57.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 22 Sep 2021 19:39:43 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-57.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/
难度： 简单
题目描述 输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
示例 1：  输入： nums = [2,7,11,15], target = 9
输出： [2,7] 或者 [7,2]
 示例 2：  输入： nums = [10,26,30,31,47,60], target = 40
输出： [10,30] 或者 [30,10]
 限制：  1 &amp;lt;= nums.length &amp;lt;= 105 1 &amp;lt;= nums[i] &amp;lt;= 106  解题思路 哈希 使用哈希表记录每个数字是否出现过，遍历数组，计算对应的另一个数，若已出现过则返回这两个数。
func twoSum(nums []int, target int) []int { hash := make(map[int]struct{}) for _, num := range nums { if _, ok := hash[target-num]; ok { return []int{num, target - num} } hash[num] = struct{}{} } return make([]int, 0) } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  双指针 使用两个指针 i, j 从头尾分别向中间遍历：</description>
    </item>
    
    <item>
      <title>Leetcode 345. 反转字符串中的元音字母</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-345.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</link>
      <pubDate>Thu, 19 Aug 2021 10:40:59 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-345.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</guid>
      <description>链接： https://leetcode-cn.com/problems/reverse-vowels-of-a-string/
难度： 简单
题目描述 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。
示例 1：  输入： &amp;ldquo;hello&amp;rdquo;
输出： &amp;ldquo;holle&amp;rdquo;
 示例 2：  输入： &amp;ldquo;leetcode&amp;rdquo;
输出： &amp;ldquo;leotcede&amp;rdquo;
 提示：  元音字母不包含字母 &amp;ldquo;y&amp;rdquo; 。  解题思路 双指针 使用两个指针 i, j 分别从字符串首尾向中间遍历：
 遇到非元音字母向中间靠拢； i, j 两个指针都指向元音字母时，交换两个指针指向的字母并向中靠拢  最终两个指针相遇时停止，元音字母反转完毕。
func reverseVowels(s string) string { t := []byte(s) isVowel := map[byte]bool{ &amp;#39;a&amp;#39;: true, &amp;#39;A&amp;#39;: true, &amp;#39;e&amp;#39;: true, &amp;#39;E&amp;#39;: true, &amp;#39;i&amp;#39;: true, &amp;#39;I&amp;#39;: true, &amp;#39;o&amp;#39;: true, &amp;#39;O&amp;#39;: true, &amp;#39;u&amp;#39;: true, &amp;#39;U&amp;#39;: true, } for i, j := 0, len(s)-1; i &amp;lt; j; { if !</description>
    </item>
    
    <item>
      <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 21 Jul 2021 10:43:36 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/
难度： 简单
题目描述 输入两个链表，找出它们的第一个公共节点。
如下面的两个链表：
在节点 c1 开始相交。
示例 1：  输入： intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出： Reference of the node with value = 8
输入解释： 相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
 示例 2：  输入： intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</description>
    </item>
    
  </channel>
</rss>
