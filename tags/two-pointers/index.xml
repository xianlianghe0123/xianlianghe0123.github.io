<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>two pointers on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/tags/two-pointers/</link>
    <description>Recent content in two pointers on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Mon, 27 Dec 2021 10:14:24 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/tags/two-pointers/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 825. 适龄的朋友</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-825.-%E9%80%82%E9%BE%84%E7%9A%84%E6%9C%8B%E5%8F%8B/</link>
      <pubDate>Mon, 27 Dec 2021 10:14:24 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-825.-%E9%80%82%E9%BE%84%E7%9A%84%E6%9C%8B%E5%8F%8B/</guid>
      <description>链接： https://leetcode-cn.com/problems/friends-of-appropriate-ages/
难度： 中等
题目描述 在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。
如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：
 age[y] &amp;lt;= 0.5 * age[x] + 7 age[y] &amp;gt; age[x] age[y] &amp;gt; 100 &amp;amp;&amp;amp; age[x] &amp;lt; 100  否则，x 将会向 y 发送一条好友请求。
注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。
返回在该社交媒体网站上产生的好友请求总数。
示例 1：  输入： ages = [16,16]
输出： 2
解释： 2 人互发好友请求。
 示例 2：  输入： ages = [16,17,18]</description>
    </item>
    
    <item>
      <title>Leetcode 240. 搜索二维矩阵 II</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-240.-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-ii/</link>
      <pubDate>Mon, 25 Oct 2021 11:40:02 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-240.-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/search-a-2d-matrix-ii/
难度： 中等
题目描述 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：
 每行的元素从左到右升序排列。 每列的元素从上到下升序排列。  示例 1：  输入： matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出： true
 示例 2：  输入： matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
输出： false
 提示：  m == matrix.length n == matrix[i].length 1 &amp;lt;= n, m &amp;lt;= 300 -109 &amp;lt;= matrix[i][j] &amp;lt;= 109 每行的所有元素从左到右升序排列 每列的所有元素从上到下升序排列 -109 &amp;lt;= target &amp;lt;= 109  解题思路 暴力求解 遍历整个矩阵，寻找 target。</description>
    </item>
    
    <item>
      <title>Leetcode 3. 无重复字符的最长子串</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-3.-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Wed, 06 Oct 2021 22:51:34 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-3.-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/
难度： 中等
题目描述 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1：  输入: &amp;ldquo;abcabcbb&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;ldquo;abc&amp;rdquo;，所以其长度为 3。
 示例 2：  输入: &amp;ldquo;bbbbb&amp;rdquo;
输出: 1
解释: 因为无重复字符的最长子串是 &amp;ldquo;b&amp;rdquo;，所以其长度为 1。
 示例 3：  输入: &amp;ldquo;pwwkew&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;ldquo;wke&amp;rdquo;，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，&amp;ldquo;pwke&amp;rdquo; 是一个子序列，不是子串。
 示例 4：  输入: s = &amp;quot;&amp;quot;
输出: 0
 提示：  0 &amp;lt;= s.length &amp;lt;= 5 * 104 s 由英文字母、数字、符号和空格组成  解题思路 哈希 + 双指针 使用哈希表记录每个字符出现的下标，并记录有效字串开始的下标 start：当出现重复字符时，将 start 修正为重复字符出现的下一个位置。</description>
    </item>
    
    <item>
      <title>剑指 Offer 57 - II. 和为s的连续正数序列</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-57-ii.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</link>
      <pubDate>Thu, 30 Sep 2021 20:04:58 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-57-ii.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/
难度： 简单
题目描述 输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
示例 1：  输入： target = 9
输出： [[2,3,4],[4,5]]
 示例 2：  输入： target = 15
输出： [[1,2,3,4,5],[4,5,6],[7,8]]
 限制：  1 &amp;lt;= target &amp;lt;= 105  解题思路 双指针 使用两个指针 i 和 j 代表连续正整数区间的两个端点，另使用变量 sum 记录该段区间的和。
 当 sum 小于 target 时，j 移动； 当 sum 大于 target 时，i 移动； 当 sum 等于 target 时，将区间加入到结果队列中，i 移动。  遍历到 j 大于 target 时结束，返回
func findContinuousSequence(target int) [][]int { ans := make([][]int, 0, 1) sum := 1 for i, j := 1, 1; j &amp;lt; target; { if sum &amp;lt; target { j++ sum += j } else if sum &amp;gt; target { sum -= i i++ } else { t := make([]int, 0, j-i+1) for k := i; k &amp;lt;= j; k++ { t = append(t, k) } ans = append(ans, t) sum -= i i++ } } return ans } 复杂度  时间复杂度：$ O(target) $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>Leetcode 19. 删除链表的倒数第 N 个结点</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-19.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/</link>
      <pubDate>Thu, 30 Sep 2021 10:58:01 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-19.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/
难度： 中等
题目描述 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶： 你能尝试使用一趟扫描实现吗？
示例 1：  输入： head = [1,2,3,4,5], n = 2
输出： [1,2,3,5]
 示例 2：  输入： head = [1], n = 1
输出： []
 示例 3：  输入： head = [1,2], n = 1
输出： [1]
 提示：  链表中结点的数目为 sz 1 &amp;lt;= sz &amp;lt;= 30 0 &amp;lt;= Node.val &amp;lt;= 100 1 &amp;lt;= n &amp;lt;= sz  解题思路 计算链表长度 遍历一遍列表，得到链表长度，从而求得距离链表头的偏移量，再次遍历将其删除即可。</description>
    </item>
    
    <item>
      <title>剑指 Offer 57. 和为s的两个数字</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-57.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 22 Sep 2021 19:39:43 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-57.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/
难度： 简单
题目描述 输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
示例 1：  输入： nums = [2,7,11,15], target = 9
输出： [2,7] 或者 [7,2]
 示例 2：  输入： nums = [10,26,30,31,47,60], target = 40
输出： [10,30] 或者 [30,10]
 限制：  1 &amp;lt;= nums.length &amp;lt;= 105 1 &amp;lt;= nums[i] &amp;lt;= 106  解题思路 哈希 使用哈希表记录每个数字是否出现过，遍历数组，计算对应的另一个数，若已出现过则返回这两个数。
func twoSum(nums []int, target int) []int { hash := make(map[int]struct{}) for _, num := range nums { if _, ok := hash[target-num]; ok { return []int{num, target - num} } hash[num] = struct{}{} } return make([]int, 0) } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  双指针 使用两个指针 i, j 从头尾分别向中间遍历：</description>
    </item>
    
    <item>
      <title>Leetcode 345. 反转字符串中的元音字母</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-345.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</link>
      <pubDate>Thu, 19 Aug 2021 10:40:59 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-345.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</guid>
      <description>链接： https://leetcode-cn.com/problems/reverse-vowels-of-a-string/
难度： 简单
题目描述 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。
示例 1：  输入： &amp;ldquo;hello&amp;rdquo;
输出： &amp;ldquo;holle&amp;rdquo;
 示例 2：  输入： &amp;ldquo;leetcode&amp;rdquo;
输出： &amp;ldquo;leotcede&amp;rdquo;
 提示：  元音字母不包含字母 &amp;ldquo;y&amp;rdquo; 。  解题思路 双指针 使用两个指针 i, j 分别从字符串首尾向中间遍历：
 遇到非元音字母向中间靠拢； i, j 两个指针都指向元音字母时，交换两个指针指向的字母并向中靠拢  最终两个指针相遇时停止，元音字母反转完毕。
func reverseVowels(s string) string { t := []byte(s) isVowel := map[byte]bool{ &amp;#39;a&amp;#39;: true, &amp;#39;A&amp;#39;: true, &amp;#39;e&amp;#39;: true, &amp;#39;E&amp;#39;: true, &amp;#39;i&amp;#39;: true, &amp;#39;I&amp;#39;: true, &amp;#39;o&amp;#39;: true, &amp;#39;O&amp;#39;: true, &amp;#39;u&amp;#39;: true, &amp;#39;U&amp;#39;: true, } for i, j := 0, len(s)-1; i &amp;lt; j; { if !</description>
    </item>
    
    <item>
      <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 21 Jul 2021 10:43:36 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/
难度： 简单
题目描述 输入两个链表，找出它们的第一个公共节点。
如下面的两个链表：
在节点 c1 开始相交。
示例 1：  输入： intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出： Reference of the node with value = 8
输入解释： 相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
 示例 2：  输入： intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</description>
    </item>
    
  </channel>
</rss>
