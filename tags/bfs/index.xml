<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bfs on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/tags/bfs/</link>
    <description>Recent content in bfs on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Sun, 31 Jul 2022 09:39:44 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 1161. 最大层内元素和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1161.-%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C/</link>
      <pubDate>Sun, 31 Jul 2022 09:39:44 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1161.-%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C/</guid>
      <description>链接： https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/
难度： 中等
题目描述 给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。
请返回层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。
示例 1： 输入： root = [1,7,0,7,-8,null,null]
输出： 2
解释：
第 1 层各元素之和为 1，
第 2 层各元素之和为 7 + 0 = 7，
第 3 层各元素之和为 7 + -8 = -1，
所以我们返回第 2 层的层号，它的层内元素之和最大。
示例 2： 输入： root = [989,null,10250,98693,-89388,null,null,null,-32127]
输出： 2
提示： 树中的节点数在 [1, 104] 范围内 -105 &amp;lt;= Node.val &amp;lt;= 105 解题思路 层序遍历 层序遍历，求得每层节点元素和，找出最大的那一层。
func maxLevelSum(root *TreeNode) int { q := list.</description>
    </item>
    
    <item>
      <title>Leetcode 919. 完全二叉树插入器</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-919.-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/</link>
      <pubDate>Mon, 25 Jul 2022 20:31:06 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-919.-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/</guid>
      <description>链接： https://leetcode.cn/problems/complete-binary-tree-inserter/
难度： 简单
题目描述 完全二叉树 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。
设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。
实现 CBTInserter 类:
CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构； CBTInserter.insert(int v) 向树中插入一个值为 Node.val == val 的新节点 TreeNode。使树保持完全二叉树的状态，并返回插入节点 TreeNode 的父节点的值； CBTInserter.get_root() 将返回树的头节点。 示例： 输入：
[&amp;ldquo;CBTInserter&amp;rdquo;, &amp;ldquo;insert&amp;rdquo;, &amp;ldquo;insert&amp;rdquo;, &amp;ldquo;get_root&amp;rdquo;]
[[[1, 2]], [3], [4], []]
输出：
[null, 1, 2, [1, 2, 3, 4]]
解释：
CBTInserter cBTInserter = new CBTInserter([1, 2]);
cBTInserter.insert(3); // 返回 1
cBTInserter.insert(4); // 返回 2
cBTInserter.get_root(); // 返回 [1, 2, 3, 4]
提示： 树中节点数量范围为 [1, 1000] 0 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title>Leetcode 433. 最小基因变化</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-433.-%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96/</link>
      <pubDate>Sat, 07 May 2022 10:07:37 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-433.-%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96/</guid>
      <description>链接： hhttps://leetcode-cn.com/problems/minimum-genetic-mutation/
难度： 中等
题目描述 基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 &#39;A&#39;、&#39;C&#39;、&#39;G&#39; 和 &#39;T&#39; 之一。
假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。
例如，&amp;quot;AACCGGTT&amp;quot; --&amp;gt; &amp;quot;AACCGGTA&amp;quot; 就是一次基因变化。 另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。
给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。
注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。
示例 1： 输入： start = &amp;ldquo;AACCGGTT&amp;rdquo;, end = &amp;ldquo;AACCGGTA&amp;rdquo;, bank = [&amp;ldquo;AACCGGTA&amp;rdquo;]
输出： 1
示例 2： 输入： start = &amp;ldquo;AACCGGTT&amp;rdquo;, end = &amp;ldquo;AAACGGTA&amp;rdquo;, bank = [&amp;ldquo;AACCGGTA&amp;rdquo;,&amp;ldquo;AACCGCTA&amp;rdquo;,&amp;ldquo;AAACGGTA&amp;rdquo;]
输出： 2
示例 3： 输入： start = &amp;ldquo;AAAAACCC&amp;rdquo;, end = &amp;ldquo;AACCCCCC&amp;rdquo;, bank = [&amp;ldquo;AAAACCCC&amp;rdquo;,&amp;ldquo;AAACCCCC&amp;rdquo;,&amp;ldquo;AACCCCCC&amp;rdquo;]</description>
    </item>
    
    <item>
      <title>Leetcode 417. 太平洋大西洋水流问题</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-417.-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 27 Apr 2022 10:34:55 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-417.-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/</guid>
      <description>链接： https://leetcode-cn.com/problems/pacific-atlantic-water-flow/
难度： 中等
题目描述 有一个 m × n 的矩形岛屿，与 太平洋 和 大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。
这个岛被分割成一个由若干方形单元格组成的网格。给定一个 m x n 的整数矩阵 heights ， heights[r][c] 表示坐标 (r, c) 上单元格 高于海平面的高度 。
岛上雨水较多，如果相邻单元格的高度 小于或等于 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。
返回 网格坐标 result 的 2D列表 ，其中 result[i] = [ri, ci] 表示雨水可以从单元格 (ri, ci) 流向 太平洋和大西洋 。
示例 1： 输入： heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
输出： [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
示例 2： 输入： heights = [[2,1],[1,2]]
输出： [[0,0],[0,1],[1,0],[1,1]]
提示： m == heights.</description>
    </item>
    
    <item>
      <title>Leetcode 429. N 叉树的层序遍历</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-429.-n-%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Fri, 08 Apr 2022 09:27:41 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-429.-n-%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>链接： https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/
难度： 中等
题目描述 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。
树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。
示例 1： 输入： root = [1,null,3,2,4,null,5,6]
输出： [[1],[3,2,4],[5,6]]
示例 2： 输入： root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出： [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
提示： 树的高度不会超过 1000 树的节点总数在 [0, 104] 之间 解题思路 层序遍历 使用队列记录遍历到的结点，从左往右逐层扫描。
func levelOrder(root *Node) [][]int { if root == nil { return nil } ans := make([][]int, 0, 1) queue := list.New() queue.PushBack(root) layerCnt := 1 // 记录下一层的结点数，提前开辟空间 for queue.Len() &amp;gt; 0 { layerElems := make([]int, 0, layerCnt) // 当前层元素 layerCnt = 0 // 归零，计算下一层的结点数 // 遍历当前层 for i := queue.</description>
    </item>
    
    <item>
      <title>Leetcode 2039. 网络空闲的时刻</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-2039.-%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B2%E7%9A%84%E6%97%B6%E5%88%BB/</link>
      <pubDate>Sun, 20 Mar 2022 10:47:12 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-2039.-%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B2%E7%9A%84%E6%97%B6%E5%88%BB/</guid>
      <description>链接： https://leetcode-cn.com/problems/stock-price-fluctuation/
难度： 中等
题目描述 给你一个有 n 个服务器的计算机网络，服务器编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示服务器 ui 和 vi 之间有一条信息线路，在 一秒 内它们之间可以传输 任意 数目的信息。再给你一个长度为 n 且下标从 0 开始的整数数组 patience 。
题目保证所有服务器都是 相通 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。
编号为 0 的服务器是 主 服务器，其他服务器为 数据 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 最优 线路传输，也就是说每个信息都会以 最少时间 到达主服务器。主服务器会处理 所有 新到达的信息并 立即 按照每条信息来时的路线 反方向 发送回复信息。
在 0 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 1 秒开始，每 一秒最 开始 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：
如果还没收到任何回复信息，那么该服务器会周期性 重发 信息。数据服务器 i 每 patience[i] 秒都会重发一条信息，也就是说，数据服务器 i 在上一次发送信息给主服务器后的 patience[i] 秒 后 会重发一条信息给主服务器。 否则，该数据服务器 不会重发 信息。 当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 空闲 状态。</description>
    </item>
    
    <item>
      <title>Leetcode 838. 推多米诺</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-838.-%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/</link>
      <pubDate>Mon, 21 Feb 2022 09:45:54 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-838.-%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/</guid>
      <description>链接： https://leetcode-cn.com/problems/push-dominoes/
难度： 中等
题目描述 n 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。
每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。
如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。
就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。
给你一个字符串 dominoes 表示这一行多米诺骨牌的初始状态，其中：
dominoes[i] = &#39;L&#39;，表示第 i 张多米诺骨牌被推向左侧， dominoes[i] = &#39;R&#39;，表示第 i 张多米诺骨牌被推向右侧， dominoes[i] = &#39;.&#39;，表示没有推动第 i 张多米诺骨牌。 返回表示最终状态的字符串。
示例 1： 输入： dominoes = &amp;ldquo;RR.L&amp;rdquo;
输出： &amp;ldquo;RR.L&amp;rdquo;
解释： 第一张多米诺骨牌没有给第二张施加额外的力。
示例 2： 输入： dominoes = &amp;ldquo;.L.R&amp;hellip;LR..L..&amp;rdquo;
输出： &amp;ldquo;LL.RR.LLRRLL..&amp;rdquo;
提示： -n == dominoes.length -1 &amp;lt;= n &amp;lt;= 105
dominoes[i] 为 &#39;L&#39;、&#39;R&#39; 或 &#39;.&#39; 解题思路 广度优先搜索 所有一开始被推的骨牌为起始状态，进行广度优先搜索，判定倒向一侧的下一个多米诺骨牌的状态：
当已经倒下时，忽略，不进行传递； 当另一侧存在同一时间与当前倒下方向相反的骨牌时，仍保持直立； 否则，保持与当前倒下方向一致，并加入到队列。 func pushDominoes(dominoes string) string { dominoesBytes := []byte(dominoes) times := make([]int, len(dominoesBytes)) // 记录倒下时间 queue := list.</description>
    </item>
    
    <item>
      <title>Leetcode 1020. 飞地的数量</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1020.-%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/</link>
      <pubDate>Sat, 12 Feb 2022 09:18:39 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1020.-%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/number-of-enclaves/
难度： 中等
题目描述 给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。
一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。
返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。
示例 1： 输入： grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出： 3
解释： 有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
示例 2： 输入： grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
输出： 0
解释： 所有 1 都在边界上或可以到达边界。
提示： m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 500 grid[i][j] 的值为 0 或 1 解题思路 广度优先搜索 从每个边界处出发，使用广度优先搜索，将可达的所有陆地标记出来，则剩余陆地为不可达，也即无法到达边界。</description>
    </item>
    
    <item>
      <title>Leetcode 1765. 地图中的最高点</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1765.-%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/</link>
      <pubDate>Sat, 29 Jan 2022 09:42:05 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1765.-%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/map-of-highest-peak/
难度： 中等
题目描述 给你一个大小为 m x n 的整数矩阵 isWater ，它代表了一个由 陆地 和 水域 单元格组成的地图。
如果 isWater[i][j] == 0 ，格子 (i, j) 是一个 陆地 格子。 如果 isWater[i][j] == 1 ，格子 (i, j) 是一个 水域 格子。 你需要按照如下规则给每个单元格安排高度：
每个格子的高度都必须是非负的。 如果一个格子是是 水域 ，那么它的高度必须为 0 。 任意相邻的格子高度差 至多 为 1 。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边） 找到一种安排高度的方案，使得矩阵中的最高高度值 最大 。
请你返回一个大小为 m x n 的整数矩阵 height ，其中 height[i][j] 是格子 (i, j) 的高度。如果有多种解法，请返回 任意一个 。
示例 1： 输入： isWater = [[0,1],[0,0]]</description>
    </item>
    
    <item>
      <title>Leetcode 1345. 跳跃游戏 IV</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1345.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-iv/</link>
      <pubDate>Fri, 21 Jan 2022 10:32:55 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1345.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-iv/</guid>
      <description>链接： https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/
难度： 简单
题目描述 给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。
每一步，你可以从下标 i 跳到下标：
i + 1 满足：i + 1 &amp;lt; arr.length i - 1 满足：i - 1 &amp;gt;= 0 j 满足：arr[i] == arr[j] 且 i != j 请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。
注意： 任何时候你都不能跳到数组外面。
示例 1： 输入： arr = [100,-23,-23,404,100,23,23,23,3,404]
输出： 3
解释： 那你需要跳跃 3 次，下标依次为 0 &amp;ndash;&amp;gt; 4 &amp;ndash;&amp;gt; 3 &amp;ndash;&amp;gt; 9 。下标 9 为数组的最后一个元素的下标。
示例 2： 输入： arr = [7]
输出： 0</description>
    </item>
    
    <item>
      <title>Leetcode 1609. 奇偶树</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1609.-%E5%A5%87%E5%81%B6%E6%A0%91/</link>
      <pubDate>Sat, 25 Dec 2021 20:01:00 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1609.-%E5%A5%87%E5%81%B6%E6%A0%91/</guid>
      <description>链接： https://leetcode-cn.com/problems/even-odd-tree/
难度： 中等
题目描述 如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：
二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。
偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增 奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减 给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。 示例 1： 输入： root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
输出： true
解释： 每一层的节点值分别是：
0 层：[1]
1 层：[10,4]
2 层：[3,7,9]
3 层：[12,8,6,2]
由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。
示例 2： 输入： root = [5,4,2,3,3,7]
输出： false
解释： 每一层的节点值分别是：
0 层：[5]</description>
    </item>
    
    <item>
      <title>Leetcode 1034. 边界着色</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1034.-%E8%BE%B9%E7%95%8C%E7%9D%80%E8%89%B2/</link>
      <pubDate>Tue, 07 Dec 2021 10:14:52 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1034.-%E8%BE%B9%E7%95%8C%E7%9D%80%E8%89%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/coloring-a-border/
难度： 中等
题目描述 给你一个大小为 m x n 的整数矩阵 grid ，表示一个网格。另给你三个整数 row、col 和 color 。网格中的每个值表示该位置处的网格块的颜色。
当两个网格块的颜色相同，而且在四个方向中任意一个方向上相邻时，它们属于同一 连通分量 。
连通分量的边界 是指连通分量中的所有与不在分量中的网格块相邻（四个方向上）的所有网格块，或者在网格的边界上（第一行/列或最后一行/列）的所有网格块。
请你使用指定颜色 color 为所有包含网格块 grid[row][col] 的 连通分量的边界 进行着色，并返回最终的网格 grid 。
示例 1： 输入： grid = [[1,1],[1,2]], row = 0, col = 0, color = 3
输出： [[3,3],[3,2]]
示例 2： 输入： grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3
输出： [[1,3,3],[2,3,3]]
示例 3： 输入： grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2</description>
    </item>
    
    <item>
      <title>Leetcode 103. 二叉树的锯齿形层序遍历</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-103.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Tue, 12 Oct 2021 13:08:58 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-103.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/
难度： 中等
题目描述 给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
例如： 给定二叉树 [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 返回锯齿形层序遍历如下：
[ [3], [20,9], [15,7] ] 解题思路 层序遍历 使用一个双端队列记录遍历到的结点，初始时根结点入队。
奇偶分离，偶数层从头至尾遍历完当前整层的所有元素，子结点先左后右从队尾入队；奇数层从尾至头遍历整层所有元素，子结点先右后左从队头入队。
每次遍历到的结点值加入到结果队列中，直至队列为空为止。
func zigzagLevelOrder(root *TreeNode) [][]int { if root == nil { return make([][]int, 0) } ans := make([][]int, 0, 1) deque := list.New() deque.PushBack(root) for deque.Len() &amp;gt; 0 { t := make([]int, 0, deque.Len()) for i := deque.Len(); i &amp;gt; 0; i-- { node := deque.</description>
    </item>
    
    <item>
      <title>Leetcode 199. 二叉树的右视图</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-199.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Thu, 30 Sep 2021 11:24:18 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-199.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-tree-right-side-view/
难度： 中等
题目描述 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
示例 1： 输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
示例 2： 输入: [1,null,3]
输出: [1,3]
示例 3： 输入: []
输出: []
提示： 二叉树的节点个数的范围是 [0,100] -100 &amp;lt;= Node.val &amp;lt;= 100 解题思路 先序遍历 先序遍历二叉树，同时传递深度信息，对于每个遍历到的结点，修改对应深度的结点为当前结点。
func rightSideView(root *TreeNode) []int { ans := make([]int, 0, 10) var dfs func(node *TreeNode, depth int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if depth == len(ans) { ans = append(ans, node.</description>
    </item>
    
    <item>
      <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-iii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/</link>
      <pubDate>Mon, 27 Sep 2021 19:19:06 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-iii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/</guid>
      <description>链接： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/
难度： 简单
题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
例如:
给定二叉树: [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 返回其层次遍历结果：
[ [3], [20,9], [15,7] ] 提示： 节点总数 &amp;lt;= 1000 解题思路 层序遍历 使用一个双端队列记录遍历到的结点，初始时根结点入队。
奇偶分离，偶数层从头至尾遍历完当前整层的所有元素，子结点先左后右从队尾入队；奇数层从尾至头遍历整层所有元素，子结点先右后左从队头入队。
每次遍历到的结点值加入到结果队列中，直至队列为空为止。
func levelOrder(root *TreeNode) [][]int { ans := make([][]int, 0) if root == nil { return ans } q := list.New() q.PushBack(root) for q.Len() &amp;gt; 0 { // 先偶数层 tmp := make([]int, 0, 1) for i := q.Len(); i &amp;gt; 0 ; i-- { node := q.</description>
    </item>
    
    <item>
      <title>剑指 Offer 32 - II. 从上到下打印二叉树 II</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-ii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/</link>
      <pubDate>Mon, 27 Sep 2021 19:05:28 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-ii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/
难度： 简单
题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
例如:
给定二叉树: [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 返回其层次遍历结果：
[ [3], [9,20], [15,7] ] 提示： 节点总数 &amp;lt;= 1000 解题思路 层序遍历 使用一个队列记录遍历到的结点，初始时根结点入队，每次从头至尾遍历完当前整层的所有元素，并加入到结果队列，按顺序依次将左右非空子结点入队，直到队列为空。
func levelOrder(root *TreeNode) [][]int { ans := make([][]int, 0) if root == nil { return ans } q := list.New() q.PushBack(root) for q.Len() &amp;gt; 0 { ans = append(ans, make([]int, 0, 1)) for i := q.Len(); i &amp;gt; 0 ; i-- { node := q.</description>
    </item>
    
    <item>
      <title>剑指 Offer 32 - I. 从上到下打印二叉树</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-i.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 27 Sep 2021 18:48:47 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-i.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>链接： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/
难度： 中等
题目描述 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
例如:
给定二叉树: [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 返回：
[3,9,20,15,7]
提示： 节点总数 &amp;lt;= 1000 解题思路 层序遍历 使用一个队列记录遍历到的结点，初始时根结点入队，每次从队头取出一个结点，将其值加入到结果队列，并按顺序将左右非空子结点入队，直到队列为空。
func levelOrder(root *TreeNode) []int { ans := make([]int, 0) if root == nil { return ans } q := list.New() q.PushBack(root) for q.Len() &amp;gt; 0 { node := q.Front().Value.(*TreeNode) q.Remove(q.Front()) ans = append(ans, node.Val) if node.Left != nil { q.PushBack(node.Left) } if node.Right !</description>
    </item>
    
    <item>
      <title>Leetcode 815. 公交路线</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-815.-%E5%85%AC%E4%BA%A4%E8%B7%AF%E7%BA%BF/</link>
      <pubDate>Mon, 28 Jun 2021 10:54:56 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-815.-%E5%85%AC%E4%BA%A4%E8%B7%AF%E7%BA%BF/</guid>
      <description>链接： https://leetcode-cn.com/problems/bus-routes/
难度： 困难
题目描述 给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。
例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -&amp;gt; 5 -&amp;gt; 7 -&amp;gt; 1 -&amp;gt; 5 -&amp;gt; 7 -&amp;gt; 1 -&amp;gt; ... 这样的车站路线行驶。 现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。
求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。
示例 1： 输入： routes = [[1,2,7],[3,6,7]], source = 1, target = 6
输出： 2
解释： 最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。
示例 2： 输入： routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12</description>
    </item>
    
  </channel>
</rss>
