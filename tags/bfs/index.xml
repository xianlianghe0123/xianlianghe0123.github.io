<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bfs on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/tags/bfs/</link>
    <description>Recent content in bfs on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Fri, 21 Jan 2022 10:32:55 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 1345. 跳跃游戏 IV</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1345.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-iv/</link>
      <pubDate>Fri, 21 Jan 2022 10:32:55 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1345.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-iv/</guid>
      <description>链接： https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/
难度： 简单
题目描述 给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。
每一步，你可以从下标 i 跳到下标：
 i + 1 满足：i + 1 &amp;lt; arr.length i - 1 满足：i - 1 &amp;gt;= 0 j 满足：arr[i] == arr[j] 且 i != j  请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。
注意： 任何时候你都不能跳到数组外面。
示例 1：  输入： arr = [100,-23,-23,404,100,23,23,23,3,404]
输出： 3
解释： 那你需要跳跃 3 次，下标依次为 0 &amp;ndash;&amp;gt; 4 &amp;ndash;&amp;gt; 3 &amp;ndash;&amp;gt; 9 。下标 9 为数组的最后一个元素的下标。
 示例 2：  输入： arr = [7]</description>
    </item>
    
    <item>
      <title>Leetcode 1609. 奇偶树</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1609.-%E5%A5%87%E5%81%B6%E6%A0%91/</link>
      <pubDate>Sat, 25 Dec 2021 20:01:00 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1609.-%E5%A5%87%E5%81%B6%E6%A0%91/</guid>
      <description>链接： https://leetcode-cn.com/problems/even-odd-tree/
难度： 中等
题目描述 如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：
二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。
 偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增 奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减 给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。  示例 1：  输入： root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
输出： true
解释： 每一层的节点值分别是：
0 层：[1]
1 层：[10,4]
2 层：[3,7,9]
3 层：[12,8,6,2]
由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。
 示例 2：  输入： root = [5,4,2,3,3,7]</description>
    </item>
    
    <item>
      <title>Leetcode 1034. 边界着色</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1034.-%E8%BE%B9%E7%95%8C%E7%9D%80%E8%89%B2/</link>
      <pubDate>Tue, 07 Dec 2021 10:14:52 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1034.-%E8%BE%B9%E7%95%8C%E7%9D%80%E8%89%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/coloring-a-border/
难度： 中等
题目描述 给你一个大小为 m x n 的整数矩阵 grid ，表示一个网格。另给你三个整数 row、col 和 color 。网格中的每个值表示该位置处的网格块的颜色。
当两个网格块的颜色相同，而且在四个方向中任意一个方向上相邻时，它们属于同一 连通分量 。
连通分量的边界 是指连通分量中的所有与不在分量中的网格块相邻（四个方向上）的所有网格块，或者在网格的边界上（第一行/列或最后一行/列）的所有网格块。
请你使用指定颜色 color 为所有包含网格块 grid[row][col] 的 连通分量的边界 进行着色，并返回最终的网格 grid 。
示例 1：  输入： grid = [[1,1],[1,2]], row = 0, col = 0, color = 3
输出： [[3,3],[3,2]]
 示例 2：  输入： grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3
输出： [[1,3,3],[2,3,3]]
 示例 3：  输入： grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2</description>
    </item>
    
    <item>
      <title>Leetcode 103. 二叉树的锯齿形层序遍历</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-103.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Tue, 12 Oct 2021 13:08:58 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-103.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/
难度： 中等
题目描述 给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
例如： 给定二叉树 [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7 返回锯齿形层序遍历如下：
[ [3], [20,9], [15,7] ] 解题思路 层序遍历 使用一个双端队列记录遍历到的结点，初始时根结点入队。
奇偶分离，偶数层从头至尾遍历完当前整层的所有元素，子结点先左后右从队尾入队；奇数层从尾至头遍历整层所有元素，子结点先右后左从队头入队。
每次遍历到的结点值加入到结果队列中，直至队列为空为止。
func zigzagLevelOrder(root *TreeNode) [][]int { if root == nil { return make([][]int, 0) } ans := make([][]int, 0, 1) deque := list.New() deque.PushBack(root) for deque.Len() &amp;gt; 0 { t := make([]int, 0, deque.Len()) for i := deque.Len(); i &amp;gt; 0; i-- { node := deque.</description>
    </item>
    
    <item>
      <title>Leetcode 199. 二叉树的右视图</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-199.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Thu, 30 Sep 2021 11:24:18 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-199.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-tree-right-side-view/
难度： 中等
题目描述 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
示例 1：  输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
 示例 2：  输入: [1,null,3]
输出: [1,3]
 示例 3：  输入: []
输出: []
 提示：  二叉树的节点个数的范围是 [0,100] -100 &amp;lt;= Node.val &amp;lt;= 100   解题思路 先序遍历 先序遍历二叉树，同时传递深度信息，对于每个遍历到的结点，修改对应深度的结点为当前结点。
func rightSideView(root *TreeNode) []int { ans := make([]int, 0, 10) var dfs func(node *TreeNode, depth int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if depth == len(ans) { ans = append(ans, node.</description>
    </item>
    
    <item>
      <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-iii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/</link>
      <pubDate>Mon, 27 Sep 2021 19:19:06 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-iii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/</guid>
      <description>链接： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/
难度： 简单
题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
例如:
 给定二叉树: [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  返回其层次遍历结果：
 [ [3], [20,9], [15,7] ]  提示：  节点总数 &amp;lt;= 1000  解题思路 层序遍历 使用一个双端队列记录遍历到的结点，初始时根结点入队。
奇偶分离，偶数层从头至尾遍历完当前整层的所有元素，子结点先左后右从队尾入队；奇数层从尾至头遍历整层所有元素，子结点先右后左从队头入队。
每次遍历到的结点值加入到结果队列中，直至队列为空为止。
func levelOrder(root *TreeNode) [][]int { ans := make([][]int, 0) if root == nil { return ans } q := list.New() q.PushBack(root) for q.Len() &amp;gt; 0 { // 先偶数层 	tmp := make([]int, 0, 1) for i := q.</description>
    </item>
    
    <item>
      <title>剑指 Offer 32 - II. 从上到下打印二叉树 II</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-ii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/</link>
      <pubDate>Mon, 27 Sep 2021 19:05:28 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-ii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/
难度： 简单
题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
例如:
 给定二叉树: [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  返回其层次遍历结果：
 [ [3], [9,20], [15,7] ]  提示：  节点总数 &amp;lt;= 1000  解题思路 层序遍历 使用一个队列记录遍历到的结点，初始时根结点入队，每次从头至尾遍历完当前整层的所有元素，并加入到结果队列，按顺序依次将左右非空子结点入队，直到队列为空。
func levelOrder(root *TreeNode) [][]int { ans := make([][]int, 0) if root == nil { return ans } q := list.New() q.PushBack(root) for q.Len() &amp;gt; 0 { ans = append(ans, make([]int, 0, 1)) for i := q.</description>
    </item>
    
    <item>
      <title>剑指 Offer 32 - I. 从上到下打印二叉树</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-i.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 27 Sep 2021 18:48:47 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-i.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>链接： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/
难度： 中等
题目描述 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
例如:
给定二叉树: [3,9,20,null,null,15,7],
  3 / \ 9 20 / \ 15 7  返回：
 [3,9,20,15,7]
 提示：  节点总数 &amp;lt;= 1000  解题思路 层序遍历 使用一个队列记录遍历到的结点，初始时根结点入队，每次从队头取出一个结点，将其值加入到结果队列，并按顺序将左右非空子结点入队，直到队列为空。
func levelOrder(root *TreeNode) []int { ans := make([]int, 0) if root == nil { return ans } q := list.New() q.PushBack(root) for q.Len() &amp;gt; 0 { node := q.Front().Value.(*TreeNode) q.Remove(q.Front()) ans = append(ans, node.Val) if node.Left !</description>
    </item>
    
  </channel>
</rss>
