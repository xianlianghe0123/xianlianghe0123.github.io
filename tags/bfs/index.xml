<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bfs on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/tags/bfs/</link>
    <description>Recent content in bfs on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Mon, 21 Feb 2022 09:45:54 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/tags/bfs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 838. 推多米诺</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-838.-%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/</link>
      <pubDate>Mon, 21 Feb 2022 09:45:54 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-838.-%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/</guid>
      <description>链接： https://leetcode-cn.com/problems/push-dominoes/
难度： 中等
题目描述 n 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。
每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。
如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。
就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。
给你一个字符串 dominoes 表示这一行多米诺骨牌的初始状态，其中：
 dominoes[i] = &#39;L&#39;，表示第 i 张多米诺骨牌被推向左侧， dominoes[i] = &#39;R&#39;，表示第 i 张多米诺骨牌被推向右侧， dominoes[i] = &#39;.&#39;，表示没有推动第 i 张多米诺骨牌。  返回表示最终状态的字符串。
示例 1：  输入： dominoes = &amp;ldquo;RR.L&amp;rdquo;
输出： &amp;ldquo;RR.L&amp;rdquo;
解释： 第一张多米诺骨牌没有给第二张施加额外的力。
 示例 2：  输入： dominoes = &amp;ldquo;.L.R&amp;hellip;LR..L..&amp;rdquo;
输出： &amp;ldquo;LL.RR.LLRRLL..&amp;rdquo;
 提示： -n == dominoes.length -1 &amp;lt;= n &amp;lt;= 105
 dominoes[i] 为 &#39;L&#39;、&#39;R&#39; 或 &#39;.&#39;  解题思路 广度优先搜索 所有一开始被推的骨牌为起始状态，进行广度优先搜索，判定倒向一侧的下一个多米诺骨牌的状态：</description>
    </item>
    
    <item>
      <title>Leetcode 1020. 飞地的数量</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1020.-%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/</link>
      <pubDate>Sat, 12 Feb 2022 09:18:39 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1020.-%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/number-of-enclaves/
难度： 中等
题目描述 给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。
一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。
返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。
示例 1：  输入： grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出： 3
解释： 有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
 示例 2： 输入： grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
输出： 0
解释： 所有 1 都在边界上或可以到达边界。
提示：  m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 500 grid[i][j] 的值为 0 或 1  解题思路 广度优先搜索 从每个边界处出发，使用广度优先搜索，将可达的所有陆地标记出来，则剩余陆地为不可达，也即无法到达边界。</description>
    </item>
    
    <item>
      <title>Leetcode 1765. 地图中的最高点</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1765.-%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/</link>
      <pubDate>Sat, 29 Jan 2022 09:42:05 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1765.-%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/map-of-highest-peak/
难度： 中等
题目描述 给你一个大小为 m x n 的整数矩阵 isWater ，它代表了一个由 陆地 和 水域 单元格组成的地图。
 如果 isWater[i][j] == 0 ，格子 (i, j) 是一个 陆地 格子。 如果 isWater[i][j] == 1 ，格子 (i, j) 是一个 水域 格子。  你需要按照如下规则给每个单元格安排高度：
 每个格子的高度都必须是非负的。 如果一个格子是是 水域 ，那么它的高度必须为 0 。 任意相邻的格子高度差 至多 为 1 。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边）  找到一种安排高度的方案，使得矩阵中的最高高度值 最大 。
请你返回一个大小为 m x n 的整数矩阵 height ，其中 height[i][j] 是格子 (i, j) 的高度。如果有多种解法，请返回 任意一个 。
示例 1：  输入： isWater = [[0,1],[0,0]]</description>
    </item>
    
    <item>
      <title>Leetcode 1345. 跳跃游戏 IV</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1345.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-iv/</link>
      <pubDate>Fri, 21 Jan 2022 10:32:55 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1345.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-iv/</guid>
      <description>链接： https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/
难度： 简单
题目描述 给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。
每一步，你可以从下标 i 跳到下标：
 i + 1 满足：i + 1 &amp;lt; arr.length i - 1 满足：i - 1 &amp;gt;= 0 j 满足：arr[i] == arr[j] 且 i != j  请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。
注意： 任何时候你都不能跳到数组外面。
示例 1：  输入： arr = [100,-23,-23,404,100,23,23,23,3,404]
输出： 3
解释： 那你需要跳跃 3 次，下标依次为 0 &amp;ndash;&amp;gt; 4 &amp;ndash;&amp;gt; 3 &amp;ndash;&amp;gt; 9 。下标 9 为数组的最后一个元素的下标。
 示例 2：  输入： arr = [7]</description>
    </item>
    
    <item>
      <title>Leetcode 1609. 奇偶树</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1609.-%E5%A5%87%E5%81%B6%E6%A0%91/</link>
      <pubDate>Sat, 25 Dec 2021 20:01:00 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1609.-%E5%A5%87%E5%81%B6%E6%A0%91/</guid>
      <description>链接： https://leetcode-cn.com/problems/even-odd-tree/
难度： 中等
题目描述 如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：
二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。
 偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增 奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减 给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。  示例 1：  输入： root = [1,10,4,3,null,7,9,12,8,6,null,null,2]
输出： true
解释： 每一层的节点值分别是：
0 层：[1]
1 层：[10,4]
2 层：[3,7,9]
3 层：[12,8,6,2]
由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。
 示例 2：  输入： root = [5,4,2,3,3,7]</description>
    </item>
    
    <item>
      <title>Leetcode 1034. 边界着色</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1034.-%E8%BE%B9%E7%95%8C%E7%9D%80%E8%89%B2/</link>
      <pubDate>Tue, 07 Dec 2021 10:14:52 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1034.-%E8%BE%B9%E7%95%8C%E7%9D%80%E8%89%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/coloring-a-border/
难度： 中等
题目描述 给你一个大小为 m x n 的整数矩阵 grid ，表示一个网格。另给你三个整数 row、col 和 color 。网格中的每个值表示该位置处的网格块的颜色。
当两个网格块的颜色相同，而且在四个方向中任意一个方向上相邻时，它们属于同一 连通分量 。
连通分量的边界 是指连通分量中的所有与不在分量中的网格块相邻（四个方向上）的所有网格块，或者在网格的边界上（第一行/列或最后一行/列）的所有网格块。
请你使用指定颜色 color 为所有包含网格块 grid[row][col] 的 连通分量的边界 进行着色，并返回最终的网格 grid 。
示例 1：  输入： grid = [[1,1],[1,2]], row = 0, col = 0, color = 3
输出： [[3,3],[3,2]]
 示例 2：  输入： grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3
输出： [[1,3,3],[2,3,3]]
 示例 3：  输入： grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2</description>
    </item>
    
    <item>
      <title>Leetcode 103. 二叉树的锯齿形层序遍历</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-103.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Tue, 12 Oct 2021 13:08:58 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-103.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/
难度： 中等
题目描述 给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
例如： 给定二叉树 [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7 返回锯齿形层序遍历如下：
[ [3], [20,9], [15,7] ] 解题思路 层序遍历 使用一个双端队列记录遍历到的结点，初始时根结点入队。
奇偶分离，偶数层从头至尾遍历完当前整层的所有元素，子结点先左后右从队尾入队；奇数层从尾至头遍历整层所有元素，子结点先右后左从队头入队。
每次遍历到的结点值加入到结果队列中，直至队列为空为止。
func zigzagLevelOrder(root *TreeNode) [][]int { if root == nil { return make([][]int, 0) } ans := make([][]int, 0, 1) deque := list.New() deque.PushBack(root) for deque.Len() &amp;gt; 0 { t := make([]int, 0, deque.Len()) for i := deque.Len(); i &amp;gt; 0; i-- { node := deque.</description>
    </item>
    
    <item>
      <title>Leetcode 199. 二叉树的右视图</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-199.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Thu, 30 Sep 2021 11:24:18 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-199.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-tree-right-side-view/
难度： 中等
题目描述 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
示例 1：  输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
 示例 2：  输入: [1,null,3]
输出: [1,3]
 示例 3：  输入: []
输出: []
 提示：  二叉树的节点个数的范围是 [0,100] -100 &amp;lt;= Node.val &amp;lt;= 100   解题思路 先序遍历 先序遍历二叉树，同时传递深度信息，对于每个遍历到的结点，修改对应深度的结点为当前结点。
func rightSideView(root *TreeNode) []int { ans := make([]int, 0, 10) var dfs func(node *TreeNode, depth int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if depth == len(ans) { ans = append(ans, node.</description>
    </item>
    
    <item>
      <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-iii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/</link>
      <pubDate>Mon, 27 Sep 2021 19:19:06 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-iii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/</guid>
      <description>链接： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/
难度： 简单
题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
例如:
 给定二叉树: [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  返回其层次遍历结果：
 [ [3], [20,9], [15,7] ]  提示：  节点总数 &amp;lt;= 1000  解题思路 层序遍历 使用一个双端队列记录遍历到的结点，初始时根结点入队。
奇偶分离，偶数层从头至尾遍历完当前整层的所有元素，子结点先左后右从队尾入队；奇数层从尾至头遍历整层所有元素，子结点先右后左从队头入队。
每次遍历到的结点值加入到结果队列中，直至队列为空为止。
func levelOrder(root *TreeNode) [][]int { ans := make([][]int, 0) if root == nil { return ans } q := list.New() q.PushBack(root) for q.Len() &amp;gt; 0 { // 先偶数层 	tmp := make([]int, 0, 1) for i := q.</description>
    </item>
    
    <item>
      <title>剑指 Offer 32 - II. 从上到下打印二叉树 II</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-ii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/</link>
      <pubDate>Mon, 27 Sep 2021 19:05:28 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-ii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/
难度： 简单
题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
例如:
 给定二叉树: [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  返回其层次遍历结果：
 [ [3], [9,20], [15,7] ]  提示：  节点总数 &amp;lt;= 1000  解题思路 层序遍历 使用一个队列记录遍历到的结点，初始时根结点入队，每次从头至尾遍历完当前整层的所有元素，并加入到结果队列，按顺序依次将左右非空子结点入队，直到队列为空。
func levelOrder(root *TreeNode) [][]int { ans := make([][]int, 0) if root == nil { return ans } q := list.New() q.PushBack(root) for q.Len() &amp;gt; 0 { ans = append(ans, make([]int, 0, 1)) for i := q.</description>
    </item>
    
    <item>
      <title>剑指 Offer 32 - I. 从上到下打印二叉树</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-i.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 27 Sep 2021 18:48:47 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-i.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>链接： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/
难度： 中等
题目描述 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
例如:
给定二叉树: [3,9,20,null,null,15,7],
  3 / \ 9 20 / \ 15 7  返回：
 [3,9,20,15,7]
 提示：  节点总数 &amp;lt;= 1000  解题思路 层序遍历 使用一个队列记录遍历到的结点，初始时根结点入队，每次从队头取出一个结点，将其值加入到结果队列，并按顺序将左右非空子结点入队，直到队列为空。
func levelOrder(root *TreeNode) []int { ans := make([]int, 0) if root == nil { return ans } q := list.New() q.PushBack(root) for q.Len() &amp;gt; 0 { node := q.Front().Value.(*TreeNode) q.Remove(q.Front()) ans = append(ans, node.Val) if node.Left !</description>
    </item>
    
  </channel>
</rss>
