<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dfs on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/tags/dfs/</link>
    <description>Recent content in dfs on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Thu, 14 Oct 2021 14:53:52 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 94. 二叉树的中序遍历</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-94.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 14 Oct 2021 14:53:52 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-94.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-tree-inorder-traversal/
难度： 简单
题目描述 给定一个二叉树的根节点 root ，返回它的 中序 遍历。
示例 1：  输入： root = [1,null,2,3]
输出： [1,3,2]
 示例 2：  输入： root = []
输出： []
 示例 3：  输入： root = [1]
输出： [1]
 示例 4：  输入： root = [1,2]
输出： [2,1]
 示例 5：  输入： root = [1,null,2]
输出： [1,2]
 提示：  树中节点数目在范围 [0, 100] 内 100 &amp;lt;= Node.val &amp;lt;= 100  **进阶: ** 递归算法很简单，你可以通过迭代算法完成吗？</description>
    </item>
    
    <item>
      <title>Leetcode 114. 二叉树展开为链表</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-114.-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 12 Oct 2021 18:29:58 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-114.-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/
难度： 中等
题目描述 给你二叉树的根结点 root ，请你将它展开为一个单链表：
 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。  示例 1：  输入： root = [1,2,5,3,4,null,6]
输出： [1,null,2,null,3,null,4,null,5,null,6]
 示例 2：  输入： root = []
输出： []
 示例 3：  输入： root = [0]
输出： [0]
 提示：  树中结点数在范围 [0, 2000] 内 -100 &amp;lt;= Node.val &amp;lt;= 100  进阶： 你可以使用原地算法（$O(1)$ 额外空间）展开这棵树吗？
解题思路 先序遍历 使用一个记录目前展开链表的尾部，先序遍历二叉树，每遇到一个新结点，将其加入到尾部。
func flatten(root *TreeNode) { head := new(TreeNode) tail := head var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } left := node.</description>
    </item>
    
    <item>
      <title>剑指 Offer 68 - II. 二叉树的最近公共祖先</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-68-ii.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Sat, 02 Oct 2021 17:21:23 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-68-ii.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/
难度： 简单
题目描述 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉搜索树: root = [3,5,1,6,2,0,8,null,null,7,4]
示例 1：  输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
 示例 2：  输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
 说明：  所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。  解题思路 深度优先搜索 + 记录路径 利用深度优先搜索找出从根结点开始分别到 p 和 q 的路径，然后找出两条路径中最后一个相同的结点并返回。</description>
    </item>
    
    <item>
      <title>Leetcode 543. 二叉树的直径</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-543.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</link>
      <pubDate>Thu, 30 Sep 2021 12:00:42 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-543.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/diameter-of-binary-tree/
难度： 简单
题目描述 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例： 给定二叉树
 1 / \ 2 3 / \ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
注意：  两结点之间的路径长度是以它们之间边的数目表示。  解题思路 后序遍历 某个子树的最大直径或者为左右子树的最大直径，或者为跨越当前根结点的左右子树的高度和。
递归的遍历每棵子树，返回找到的最大直径。
func diameterOfBinaryTree(root *TreeNode) int { var dfs func(node *TreeNode) (int, int) dfs = func(node *TreeNode) (int, int) { if node == nil { return 0, 0 } lDepth, lMax := dfs(node.Left) rDepth, rMax := dfs(node.Right) depth := lDepth if depth &amp;lt; rDepth { depth = rDepth } max := lDepth + rDepth if max &amp;lt; lMax { max = lMax } if max &amp;lt; rMax { max = rMax } return depth+1, max } _, max := dfs(root) return max } 复杂度  时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\log{N}) $  </description>
    </item>
    
    <item>
      <title>Leetcode 199. 二叉树的右视图</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-199.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Thu, 30 Sep 2021 11:24:18 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-199.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-tree-right-side-view/
难度： 中等
题目描述 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
示例 1：  输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
 示例 2：  输入: [1,null,3]
输出: [1,3]
 示例 3：  输入: []
输出: []
 提示：  二叉树的节点个数的范围是 [0,100] -100 &amp;lt;= Node.val &amp;lt;= 100   解题思路 先序遍历 先序遍历二叉树，同时传递深度信息，对于每个遍历到的结点，修改对应深度的结点为当前结点。
func rightSideView(root *TreeNode) []int { ans := make([]int, 0, 10) var dfs func(node *TreeNode, depth int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if depth == len(ans) { ans = append(ans, node.</description>
    </item>
    
    <item>
      <title>Leetcode 437. 路径总和 III</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-437.-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-iii/</link>
      <pubDate>Tue, 28 Sep 2021 14:08:48 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-437.-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-iii/</guid>
      <description>链接： https://leetcode-cn.com/problems/path-sum-iii/
难度： 中等
题目描述 给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。
路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
示例 1：  输入： root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出： 3
解释： 和等于 8 的路径有 3 条，如图所示。
 示例 2：  输入： root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出： 3
 提示：  二叉树的节点个数的范围是 [0,1000] -109 &amp;lt;= Node.val &amp;lt;= 109 -1000 &amp;lt;= targetSum &amp;lt;= 1000  解题思路 深度优先搜索 + 前缀和 采用深度优先搜索，并将从根到当前结点的路径和保存到哈希表中，记录该和出现的数量。
每当到达一个新结点时，查找到该结点的前缀和减去 target 是否存在于路径中，存在将其次数累加进结果中，然后递归的处理子结点，也将查询结果累加进结果中。</description>
    </item>
    
    <item>
      <title>剑指 Offer 55 - II. 平衡二叉树</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-55-ii.-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 28 Sep 2021 13:21:08 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-55-ii.-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>链接： https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/
难度： 简单
题目描述 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
示例 1： 给定二叉树 [3,9,20,null,null,15,7]
 3 / \ 9 20 / \ 15 7 返回 true 。
示例 2： 给定二叉树 [1,2,2,3,3,null,null,4,4]
 1 / \ 2 2 / \ 3 3 / \ 4 4 返回 false 。
限制：  0 &amp;lt;= 树的结点个数 &amp;lt;= 10000  解题思路 深度优先搜索 递归的遍历每个结点的左右子树，当左右子树均为平衡树且左右子树的最大深度差值 ≤ 1 时，返回 true。
func isBalanced(root *TreeNode) bool { var dfs func(root *TreeNode) (int, bool) dfs = func(root *TreeNode) (int, bool) { if root == nil { return 0, true } leftDepth, leftBalance := dfs(root.</description>
    </item>
    
    <item>
      <title>剑指 Offer 55 - I. 二叉树的深度</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-55-i.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Tue, 28 Sep 2021 12:16:07 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-55-i.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/
难度： 简单
题目描述 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
例如：
给定二叉树 [3,9,20,null,null,15,7]，
 3 / \ 9 20 / \ 15 7 返回它的最大深度 3 。
提示：  节点总数 &amp;lt;= 10000  解题思路 深度优先搜索 递归的遍历每个结点的左右子树，获得子树最大深度，+1 后返回，当结点不存在时，树高为空
func maxDepth(root *TreeNode) int { if root == nil { return 0 } depth := maxDepth(root.Left) rDepth := maxDepth(root.Right) if depth &amp;lt; rDepth { depth = rDepth } return depth + 1 } 复杂度  时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\log{N}) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 36. 二叉搜索树与双向链表</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-36.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 20 Sep 2021 17:20:45 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-36.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/
难度： 中等
题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
为了让您更好地理解问题，以下面的二叉搜索树为例：
我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。
特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。
解题思路 深度优先搜索 二叉搜索树中序遍历后的结果即为有序的，采用中序遍历的方式搜索二叉树。
维护两个指针 head 和 tail ，分别指向当前遍历到的链表的头和尾。对于当前遍历到的结点，将其 left 指向 tail，同时 tail 的 right 指向当前结点，后 tail 变更为指向当前结点。
完成遍历后，修改头尾指针，使其构成环。
class Solution { public: Node *treeToDoublyList(Node *root) { if (root == nullptr) { return nullptr; } dfs(root); head-&amp;gt;left = tail; tail-&amp;gt;right = head; return head; } private: Node *head, *tail; void dfs(Node *node) { if(node == nullptr) { return; } dfs(node-&amp;gt;left); if (head == nullptr) { head = node; } if (tail == nullptr) { tail = node; } else { tail-&amp;gt;right = node; node-&amp;gt;left = tail; tail = node; } dfs(node-&amp;gt;right); } }; 复杂度  时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\log{N}) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 34. 二叉树中和为某一值的路径</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-34.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 20 Sep 2021 14:55:24 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-34.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/
难度： 中等
题目描述 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。
示例： 给定如下二叉树，以及目标和 target = 22，
 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 返回:
[ [5,4,11,2], [5,8,4,5] ] 提示：  节点总数 &amp;lt;= 10000  解题思路 深度优先搜索 从根节点开始进行深度优先搜索，当整条路径上的结点值之和为 target 时，将其拷贝到结果队列中。
func pathSum(root *TreeNode, target int) [][]int { ans := make([][]int, 0) var dfs func(node *TreeNode, path []int, sum int) dfs = func(node *TreeNode, path []int, sum int) { if node == nil { return } path = append(path, node.</description>
    </item>
    
    <item>
      <title>剑指 Offer 26. 树的子结构</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-26.-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 19 Sep 2021 19:37:13 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-26.-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/
难度： 中等
题目描述 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
B是A的子结构， 即 A中有出现和B相同的结构和节点值。
例如: 给定的树 A:
 3 / \ 4 5 / \ 1 2 给定的树 B：
 4 / 1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
示例 1：  输入： A = [1,2,3], B = [3,1]
输出： false
 示例 2：  输入： A = [3,4,5,1,2], B = [4,1]
输出： true
 限制：  0 &amp;lt;= 节点个数 &amp;lt;= 10000  解题思路 深度优先搜索 在树 A 上进行 深度优先搜索（先序遍历），当子树根结点与 B 相同时，仍采用 深度优先搜索 的方式比较结构是否相同。</description>
    </item>
    
    <item>
      <title>剑指 Offer 13. 机器人的运动范围</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</link>
      <pubDate>Sun, 19 Sep 2021 14:29:35 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</guid>
      <description>链接： https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/
难度： 中等
题目描述 地上有一个 m 行 n 列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0,0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
示例 1：  输入： m = 2, n = 3, k = 1
输出： 3
 示例 2：  输入： m = 3, n = 1, k = 0
输出： 1
 提示：  1 &amp;lt;= n,m &amp;lt;= 100 0 &amp;lt;= k &amp;lt;= 20  解题思路 深度优先搜索 从 [0,0] 开始进行深度优先搜索，当针对 k 进行剪枝时，整个矩阵是关于 (i,i) 对称的，所以可以限制搜索方向为右和下。</description>
    </item>
    
    <item>
      <title>剑指 Offer 12. 矩阵中的路径</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sat, 18 Sep 2021 17:25:16 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/
难度： 中等
题目描述 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
例如，在下面的 3×4 的矩阵中包含单词 &amp;ldquo;ABCCED&amp;rdquo;（单词中的字母已标出）。
示例 1：  输入： board = [[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;B&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;E&amp;rdquo;],[&amp;ldquo;S&amp;rdquo;,&amp;ldquo;F&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;S&amp;rdquo;],[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;D&amp;rdquo;,&amp;ldquo;E&amp;rdquo;,&amp;ldquo;E&amp;rdquo;]], word = &amp;ldquo;ABCCED&amp;rdquo;
输出： true
 示例 2：  输入： board = [[&amp;ldquo;a&amp;rdquo;,&amp;ldquo;b&amp;rdquo;],[&amp;ldquo;c&amp;rdquo;,&amp;ldquo;d&amp;rdquo;]], word = &amp;ldquo;abcd&amp;rdquo;
输出： false
 提示：  1 &amp;lt;= board.length &amp;lt;= 200 1 &amp;lt;= board[i].length &amp;lt;= 200 board 和 word 仅由大小写英文字母组成  解题思路 深度优先搜索 遍历整个矩阵，从每个字符开始进行深度优先搜索，当无法找到下一个字符时，及时剪枝。</description>
    </item>
    
    <item>
      <title>Leetcode 797. 所有可能的路径</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-797.-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Wed, 25 Aug 2021 22:05:55 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-797.-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/all-paths-from-source-to-target/
难度： 中等
题目描述 给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）
二维数组的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些节点，空就是没有下一个结点了。
译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。
示例 1：  输入： graph = [[1,2],[3],[3],[]]
输出： [[0,1,3],[0,2,3]]
解释： 有两条路径 0 -&amp;gt; 1 -&amp;gt; 3 和 0 -&amp;gt; 2 -&amp;gt; 3
 示例 2：  输入： graph = [[4,3,1],[3,2,4],[3],[4],[]]
输出： [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
 示例 3：  输入： graph = [[1],[]]
输出： [[0,1]]
 示例 4：  输入： graph = [[1,2,3],[2],[3],[]]</description>
    </item>
    
    <item>
      <title>Leetcode 802. 找到最终的安全状态</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-802.-%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/</link>
      <pubDate>Thu, 05 Aug 2021 14:10:25 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-802.-%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/</guid>
      <description>链接： https://leetcode-cn.com/problems/find-eventual-safe-states/
难度： 中等
题目描述 在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。
对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。
返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。
该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。
示例 1：  输入： graph = [[1,2],[2,3],[5],[0],[5],[],[]]
输出： [2,4,5,6]
解释： 示意图如上。
 示例 2：  输入： graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
输出： [4]
 提示：  n == graph.length 1 &amp;lt;= n &amp;lt;= 104 0 &amp;lt;= graph[i].length &amp;lt;= n graph[i] 按严格递增顺序排列。 图中可能包含自环。 图中边的数目在范围 [1, 4 * 104] 内。  解题思路 深度优先搜索 通过分析题目得知，当图无环时，所有结点均为 安全 结点；当图有环时，无法到达环的结点属于 安全 结点。</description>
    </item>
    
    <item>
      <title>Leetcode 987. 二叉树的垂序遍历</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-987.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sat, 31 Jul 2021 12:57:30 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-987.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>链接： https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/
难度： 困难
题目描述 给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。
对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。
二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。
返回二叉树的 垂序遍历 序列。
示例 1：  输入： root = [3,9,20,null,null,15,7]
输出： [[9],[3,15],[20],[7]]
解释：
列 -1 ：只有结点 9 在此列中。
列 0 ：只有结点 3 和 15 在此列中，按从上到下顺序。
列 1 ：只有结点 20 在此列中。
列 2 ：只有结点 7 在此列中。
 示例 2：  输入： root = [1,2,3,4,5,6,7]</description>
    </item>
    
    <item>
      <title>Leetcode 863. 二叉树中所有距离为 K 的结点</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-863.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BA-k-%E7%9A%84%E7%BB%93%E7%82%B9/</link>
      <pubDate>Wed, 28 Jul 2021 11:09:17 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-863.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BA-k-%E7%9A%84%E7%BB%93%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/
难度： 中等
题目描述 给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。
返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。
示例：  输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2
输出：[7,4,1]
解释：
所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1
注意，输入的 &amp;ldquo;root&amp;rdquo; 和 &amp;ldquo;target&amp;rdquo; 实际上是树上的结点。
上面的输入仅仅是对这些对象进行了序列化描述。
 提示：  给定的树是非空的。 树上的每个结点都具有唯一的值 0 &amp;lt;= node.val &amp;lt;= 500 。 目标结点 target 是树上的结点。 0 &amp;lt;= K &amp;lt;= 1000  解题思路 深度优先搜索 一次遍历，找到结点 target，同时记录每个结点的父结点，使之构成一张无向图。
然后从 target 结点开始遍历图，找到所有距离为 K 的结点。</description>
    </item>
    
    <item>
      <title>Leetcode 671. 二叉树中第二小的节点</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-671.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 27 Jul 2021 10:31:04 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-671.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/
难度： 简单
题目描述 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。
更正式地说，root.val = min(root.left.val, root.right.val) 总成立。
给出这样的一个二叉树，你需要输出所有节点中的 第二小的值。如果第二小的值不存在的话，输出 -1 。
示例 1：  输入： root = [2,2,5,null,null,5,7]
输出： 5
解释： 最小的值是 2 ，第二小的值是 5 。
 示例 2：  输入： root = [2,2,2]
输出： -1
解释： 最小的值是 2, 但是不存在第二小的值。
 提示：  树中节点数目在范围 [1, 25] 内 1 &amp;lt;= Node.val &amp;lt;= 231 - 1 对于树中每个节点 root.val == min(root.left.val, root.right.val)  解题思路 深度优先搜索 据题意，树的根结点是最小值，故可以遍历整棵树，使用 min 记录最 第二小的值。</description>
    </item>
    
    <item>
      <title>LCP 07. 传递信息</title>
      <link>https://xianlianghe0123.github.io/p/lcp-07.-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Thu, 01 Jul 2021 11:14:31 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/lcp-07.-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/</guid>
      <description>链接： https://leetcode-cn.com/problems/chuan-di-xin-xi/
难度： 简单
题目描述 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：
 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人  给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。
示例1：  输入： n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3
输出： 3
解释： 信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&amp;gt;2-&amp;gt;0-&amp;gt;4， 0-&amp;gt;2-&amp;gt;1-&amp;gt;4， 0-&amp;gt;2-&amp;gt;3-&amp;gt;4。</description>
    </item>
    
    <item>
      <title>Leetcode 938. 二叉搜索树的范围和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-938.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</link>
      <pubDate>Tue, 27 Apr 2021 10:31:11 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-938.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/range-sum-of-bst/
难度： 简单
题目描述 给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。
示例1：  输入： root = [10,5,15,3,7,null,18], low = 7, high = 15
输出： 32
 示例2：  输入： root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
输出： 23
 提示：  树中节点数目在范围 [1, 2 * 104] 内 1 &amp;lt;= Node.val &amp;lt;= 105 1 &amp;lt;= low &amp;lt;= high &amp;lt;= 105 所有 Node.val 互不相同  解题思路 深度优先搜索 不同于一般搜索树的搜索，该搜索需要遍历整颗树，以累计求和，必要部分需要剪枝加快遍历速度。
搜索时需要区分三种情况：
 当前结点值 val &amp;lt; low 时，左子树均不满足条件，继续搜索右子树； 当前结点值 val &amp;gt; high 时，右子树均不满足条件，继续搜索左子树； 其余情况，累加当前结点值，无法剪枝，左右子树都需要继续搜索。  func rangeSumBST(root *TreeNode, low int, high int) int { sum := 0 var search func(node *TreeNode) search = func(node *TreeNode) { if node == nil { return } if node.</description>
    </item>
    
  </channel>
</rss>
