<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>dfs on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/tags/dfs/</link>
    <description>Recent content in dfs on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Wed, 11 May 2022 10:35:14 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/tags/dfs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 449. 序列化和反序列化二叉搜索树</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-449.-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Wed, 11 May 2022 10:35:14 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-449.-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>链接： baileetcode.cn/problems/serialize-and-deserialize-bst/
难度： 中等
题目描述 序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。
设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。
编码的字符串应尽可能紧凑。
示例 1：  输入： root = [2,1,3]
输出： [2,1,3]
 示例 2：  输入： root = []
输出： []
 提示：  树中节点数范围是 [0, 104] 0 &amp;lt;= Node.val &amp;lt;= 104 题目数据 保证 输入的树是一棵二叉搜索树。  解题思路 先序遍历 根据二叉搜索树的特性，对于每个结点，可以得出左右子数的数据范围。
故序列化时，进行先序遍历存储顺序即可；反序列化时，根据确定的数据范围，递归构建即可。
type Codec struct { } func Constructor() Codec { return Codec{} } // Serializes a tree to a single string. func (this *Codec) serialize(root *TreeNode) string { sVals := make([]string, 0, 5) var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } sVals = append(sVals, strconv.</description>
    </item>
    
    <item>
      <title>Leetcode 1305. 两棵二叉搜索树中的所有元素</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1305.-%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sun, 01 May 2022 09:22:48 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1305.-%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0/</guid>
      <description>链接： https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/
难度： 中等
题目描述 给你 root1 和 root2 这两棵二叉搜索树。请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。
示例 1：  输入： root1 = [2,1,4], root2 = [1,0,3]
输出： [0,1,1,2,3,4]
 示例 2：  输入： root1 = [1,null,8], root2 = [8,1]
输出： [1,1,8,8]
 提示：  每棵树的节点数在 [0, 5000] 范围内 -105 &amp;lt;= Node.val &amp;lt;= 105  解题思路 中序遍历 + 归并排序 两颗树都是二叉搜索树，所以分别对齐进行中序遍历，将得到两个有序的数组。
最后将这两个有序数组合并为一个有序数组，采用归并排序。
func getAllElements(root1 *TreeNode, root2 *TreeNode) []int { // 中序遍历 	var dfs func(node *TreeNode, nums *[]int) dfs = func(node *TreeNode, nums *[]int) { if node == nil { return } dfs(node.</description>
    </item>
    
    <item>
      <title>Leetcode 417. 太平洋大西洋水流问题</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-417.-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 27 Apr 2022 10:34:55 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-417.-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/</guid>
      <description>链接： https://leetcode-cn.com/problems/pacific-atlantic-water-flow/
难度： 中等
题目描述 有一个 m × n 的矩形岛屿，与 太平洋 和 大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。
这个岛被分割成一个由若干方形单元格组成的网格。给定一个 m x n 的整数矩阵 heights ， heights[r][c] 表示坐标 (r, c) 上单元格 高于海平面的高度 。
岛上雨水较多，如果相邻单元格的高度 小于或等于 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。
返回 网格坐标 result 的 2D列表 ，其中 result[i] = [ri, ci] 表示雨水可以从单元格 (ri, ci) 流向 太平洋和大西洋 。
示例 1：  输入： heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
输出： [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
 示例 2：  输入： heights = [[2,1],[1,2]]
输出： [[0,0],[0,1],[1,0],[1,1]]</description>
    </item>
    
    <item>
      <title>Leetcode 385. 迷你语法分析器</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-385.-%E8%BF%B7%E4%BD%A0%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/</link>
      <pubDate>Fri, 15 Apr 2022 09:32:19 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-385.-%E8%BF%B7%E4%BD%A0%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/mini-parser/
难度： 中等
题目描述 给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 NestedInteger 。
列表中的每个元素只可能是整数或整数嵌套列表
示例 1：  输入： s = &amp;ldquo;324&amp;rdquo;,
输出： 324
解释： 你应该返回一个 NestedInteger 对象，其中只包含整数值 324。
 示例 2：  输入： s = &amp;ldquo;[123,[456,[789]]]&amp;rdquo;,
输出： [123,[456,[789]]]
解释： 返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：
 一个 integer 包含值 123 一个包含两个元素的嵌套列表：
i. 一个 integer 包含值 456
ii. 一个包含一个元素的嵌套列表
a. 一个 integer 包含值 789   提示：  1 &amp;lt;= s.length &amp;lt;= 5 * 104 s 由数字、方括号 &amp;quot;[]&amp;quot;、负号 &#39;-&#39; 、逗号 &#39;,&#39; 组成 用例保证 s 是可解析的 NestedInteger 输入中的所有值的范围是 [-106, 106]  解题思路 深度优先搜索 嵌套列表只有两种情况，要么是一个值，要么是嵌套列表，在字符串中的体现是以 &#39;[&#39; 开头进行区分。</description>
    </item>
    
    <item>
      <title>Leetcode 653. 两数之和 IV - 输入 BST</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-653.-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-iv-%E8%BE%93%E5%85%A5-bst/</link>
      <pubDate>Mon, 21 Mar 2022 10:22:46 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-653.-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-iv-%E8%BE%93%E5%85%A5-bst/</guid>
      <description>链接： https://leetcode-cn.com/problems/2-keys-keyboard/
难度： 中等
题目描述 给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。
示例 1：  输入： root = [5,3,6,2,4,null,7], k = 9
输出： true
 示例 2：  输入： root = [5,3,6,2,4,null,7], k = 28
输出： false
 提示：  二叉树的节点个数的范围是 [1, 104]. -104 &amp;lt;= Node.val &amp;lt;= 104 root 为二叉搜索树 -105 &amp;lt;= k &amp;lt;= 105  解题思路 先序遍历 + 哈希 采用先序遍历遍历整颗树，将之前遍历到的所有数记录到哈希表中。
对于每个新遍历到的数字，在哈希表中寻找令其和为 k 的数。
func findTarget(root *TreeNode, k int) bool { exist := make(map[int]struct{}) var dfs func(*TreeNode) bool dfs = func(node *TreeNode) bool { if node == nil { return false } if _, ok := exist[k-node.</description>
    </item>
    
    <item>
      <title>Leetcode 606. 根据二叉树创建字符串</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-606.-%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 19 Mar 2022 10:59:32 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-606.-%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/construct-string-from-binary-tree/
难度： 简单
题目描述 你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。
空节点则用一对空括号 &amp;ldquo;()&amp;rdquo; 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。
示例 1：  输入： 二叉树: [1,2,3,4]
1
/ \
2 3
/ 4
输出： &amp;ldquo;1(2(4))(3)&amp;rdquo;
解释： 原本将是“1(2(4)())(3())”，
在你省略所有不必要的空括号对之后，
它将是“1(2(4))(3)”。
 示例 2：  输入： 二叉树: [1,2,3,null,4]
1
/ \
2 3
\
4
输出： &amp;ldquo;1(2()(4))(3)&amp;rdquo;
解释： 和第一个示例相似，
除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。
 解题思路 先序遍历 采用先序遍历遍历整棵树。对于遍历到的结点而言，当遍历子树时，需要在两侧加上括号，有如下两种情况：
 当任意子树不为空时，左子树遍历结果必然需要加上括号； 仅当右子树不为空时，右子树需要加括号，否则会产生无效的空括号对。  func tree2str(root *TreeNode) string { ans := make([]byte, 0, 10) var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } ans = append(ans, strconv.</description>
    </item>
    
    <item>
      <title>Leetcode 2049. 统计最高分的节点数目</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-2049.-%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/</link>
      <pubDate>Fri, 11 Mar 2022 10:21:02 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-2049.-%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/</guid>
      <description>链接： https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/
难度： 中等
题目描述 给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] == -1 。
一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。
请你返回有 最高得分 节点的 数目 。
示例 1：  输入： parents = [-1,2,0,2,0]
输出： 3
解释：
 节点 0 的分数为：3 * 1 = 3 节点 1 的分数为：4 = 4 节点 2 的分数为：1 * 1 * 2 = 2 节点 3 的分数为：4 = 4 节点 4 的分数为：4 = 4</description>
    </item>
    
    <item>
      <title>Leetcode 969. 煎饼排序</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-969.-%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 19 Feb 2022 10:07:04 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-969.-%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/pancake-sorting/
难度： 中等
题目描述 给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。
一次煎饼翻转的执行过程如下：
选择一个整数 k ，1 &amp;lt;= k &amp;lt;= arr.length 反转子数组 arr[0...k-1]（下标从 0 开始） 例如，arr = [3,2,1,4] ，选择 k = 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr = [1,2,3,4] 。
以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。
示例 1：  输入： [3,2,4,1]
输出： [4,2,4,3]
解释：
我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。
初始状态 arr = [3, 2, 4, 1]
第一次翻转后（k = 4）：arr = [1, 4, 2, 3]</description>
    </item>
    
    <item>
      <title>Leetcode 1020. 飞地的数量</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1020.-%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/</link>
      <pubDate>Sat, 12 Feb 2022 09:18:39 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1020.-%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/number-of-enclaves/
难度： 中等
题目描述 给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。
一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。
返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。
示例 1：  输入： grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出： 3
解释： 有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
 示例 2： 输入： grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
输出： 0
解释： 所有 1 都在边界上或可以到达边界。
提示：  m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 500 grid[i][j] 的值为 0 或 1  解题思路 广度优先搜索 从每个边界处出发，使用广度优先搜索，将可达的所有陆地标记出来，则剩余陆地为不可达，也即无法到达边界。</description>
    </item>
    
    <item>
      <title>Leetcode 472. 连接词</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-472.-%E8%BF%9E%E6%8E%A5%E8%AF%8D/</link>
      <pubDate>Tue, 28 Dec 2021 11:53:28 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-472.-%E8%BF%9E%E6%8E%A5%E8%AF%8D/</guid>
      <description>链接： https://leetcode-cn.com/problems/concatenated-words/
难度： 困难
题目描述 给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 。
连接词 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。
示例 1：  输入： words = [&amp;ldquo;cat&amp;rdquo;,&amp;ldquo;cats&amp;rdquo;,&amp;ldquo;catsdogcats&amp;rdquo;,&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;dogcatsdog&amp;rdquo;,&amp;ldquo;hippopotamuses&amp;rdquo;,&amp;ldquo;rat&amp;rdquo;,&amp;ldquo;ratcatdogcat&amp;rdquo;]
输出： [&amp;ldquo;catsdogcats&amp;rdquo;,&amp;ldquo;dogcatsdog&amp;rdquo;,&amp;ldquo;ratcatdogcat&amp;rdquo;]
解释： &amp;ldquo;catsdogcats&amp;rdquo; 由 &amp;ldquo;cats&amp;rdquo;, &amp;ldquo;dog&amp;rdquo; 和 &amp;ldquo;cats&amp;rdquo; 组成;
&amp;ldquo;dogcatsdog&amp;rdquo; 由 &amp;ldquo;dog&amp;rdquo;, &amp;ldquo;cats&amp;rdquo; 和 &amp;ldquo;dog&amp;rdquo; 组成;
&amp;ldquo;ratcatdogcat&amp;rdquo; 由 &amp;ldquo;rat&amp;rdquo;, &amp;ldquo;cat&amp;rdquo;, &amp;ldquo;dog&amp;rdquo; 和 &amp;ldquo;cat&amp;rdquo; 组成。
 示例 2：  输入： words = [&amp;ldquo;cat&amp;rdquo;,&amp;ldquo;dog&amp;rdquo;,&amp;ldquo;catdog&amp;rdquo;]
输出： [&amp;ldquo;catdog&amp;rdquo;]
 提示：  1 &amp;lt;= words.length &amp;lt;= 104 0 &amp;lt;= words[i].length &amp;lt;= 1000 words[i] 仅由小写字母组成 0 &amp;lt;= sum(words[i].</description>
    </item>
    
    <item>
      <title>Leetcode 851. 喧闹和富有</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-851.-%E5%96%A7%E9%97%B9%E5%92%8C%E5%AF%8C%E6%9C%89/</link>
      <pubDate>Wed, 15 Dec 2021 10:17:33 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-851.-%E5%96%A7%E9%97%B9%E5%92%8C%E5%AF%8C%E6%9C%89/</guid>
      <description>链接： https://leetcode-cn.com/problems/loud-and-rich/
难度： 中等
题目描述 有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 &amp;ldquo;person x &amp;ldquo;。
给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自恰（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。
现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。
示例 1：  输入： richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]</description>
    </item>
    
    <item>
      <title>Leetcode 1034. 边界着色</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1034.-%E8%BE%B9%E7%95%8C%E7%9D%80%E8%89%B2/</link>
      <pubDate>Tue, 07 Dec 2021 10:14:52 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1034.-%E8%BE%B9%E7%95%8C%E7%9D%80%E8%89%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/coloring-a-border/
难度： 中等
题目描述 给你一个大小为 m x n 的整数矩阵 grid ，表示一个网格。另给你三个整数 row、col 和 color 。网格中的每个值表示该位置处的网格块的颜色。
当两个网格块的颜色相同，而且在四个方向中任意一个方向上相邻时，它们属于同一 连通分量 。
连通分量的边界 是指连通分量中的所有与不在分量中的网格块相邻（四个方向上）的所有网格块，或者在网格的边界上（第一行/列或最后一行/列）的所有网格块。
请你使用指定颜色 color 为所有包含网格块 grid[row][col] 的 连通分量的边界 进行着色，并返回最终的网格 grid 。
示例 1：  输入： grid = [[1,1],[1,2]], row = 0, col = 0, color = 3
输出： [[3,3],[3,2]]
 示例 2：  输入： grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3
输出： [[1,3,3],[2,3,3]]
 示例 3：  输入： grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2</description>
    </item>
    
    <item>
      <title>Leetcode 559. N 叉树的最大深度</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-559.-n-%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Sun, 21 Nov 2021 10:32:51 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-559.-n-%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>链接： https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/
难度： 简单
题目描述 给定一个 N 叉树，找到其最大深度。
最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。
N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。
示例 1：  输入： root = [1,null,3,2,4,null,5,6]
输出： 3
 示例 2：  输入： root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出： 5
 提示：  树的深度不会超过 1000 。 树的节点数目位于 [0, 104] 之间。  解题思路 后序遍历 一颗树的最大深度是其所有子树的最大深度加一。递归的求解某个结点各个子树的深度，即可比较求得以当前结点为根结点的子树的最大深度。
func maxDepth(root *Node) int { if root == nil { return 0 } _maxDepth := 0 for _, node := range root.Children { depth := maxDepth(node) if _maxDepth &amp;lt; depth { _maxDepth = depth } } return _maxDepth + 1 } 复杂度  时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\log{N}) $  </description>
    </item>
    
    <item>
      <title>Leetcode 397. 整数替换</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-397.-%E6%95%B4%E6%95%B0%E6%9B%BF%E6%8D%A2/</link>
      <pubDate>Fri, 19 Nov 2021 10:07:59 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-397.-%E6%95%B4%E6%95%B0%E6%9B%BF%E6%8D%A2/</guid>
      <description>链接： https://leetcode-cn.com/problems/integer-replacement/
难度： 中等
题目描述 给定一个正整数 n ，你可以做如下操作：
 如果 n 是偶数，则用 n / 2 替换 n 。 如果 n 是奇数，则可以用 n + 1 或 n - 1 替换 n 。  n 变为 1 所需的最小替换次数是多少？
示例 1：  输入： n = 8
输出： 3
解释： 8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1
 示例 2：  输入： n = 7
输出： 4
解释： 7 -&amp;gt; 8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1</description>
    </item>
    
    <item>
      <title>Leetcode 563. 二叉树的坡度</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-563.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6/</link>
      <pubDate>Thu, 18 Nov 2021 10:13:03 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-563.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-tree-tilt/
难度： 简单
题目描述 给定一个二叉树，计算 整个树 的坡度 。
一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。
整个树 的坡度就是其所有节点的坡度之和。
示例 1：  输入： root = [1,2,3]
输出： 1
解释：
节点 2 的坡度：|0-0| = 0（没有子节点）
节点 3 的坡度：|0-0| = 0（没有子节点）
节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）
坡度总和：0 + 0 + 1 = 1
 示例 2：  输入： root = [4,2,9,3,5,null,7]
输出： 15
解释：
节点 3 的坡度：|0-0| = 0（没有子节点）</description>
    </item>
    
    <item>
      <title>Leetcode 677. 键值映射</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-677.-%E9%94%AE%E5%80%BC%E6%98%A0%E5%B0%84/</link>
      <pubDate>Sun, 14 Nov 2021 10:55:35 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-677.-%E9%94%AE%E5%80%BC%E6%98%A0%E5%B0%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/map-sum-pairs/
难度： 中等
题目描述 实现一个 MapSum 类，支持两个方法，insert 和 sum：
 MapSum() 初始化 MapSum 对象 void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对将被替代成新的键值对。 int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。  示例：  输入：
[&amp;ldquo;MapSum&amp;rdquo;, &amp;ldquo;insert&amp;rdquo;, &amp;ldquo;sum&amp;rdquo;, &amp;ldquo;insert&amp;rdquo;, &amp;ldquo;sum&amp;rdquo;]
[[], [&amp;ldquo;apple&amp;rdquo;, 3], [&amp;ldquo;ap&amp;rdquo;], [&amp;ldquo;app&amp;rdquo;, 2], [&amp;ldquo;ap&amp;rdquo;]]
输出：
[null, null, 3, null, 5]
解释：
MapSum mapSum = new MapSum();
mapSum.insert(&amp;ldquo;apple&amp;rdquo;, 3);
mapSum.sum(&amp;ldquo;ap&amp;rdquo;); // return 3 (apple = 3)</description>
    </item>
    
    <item>
      <title>Leetcode 230. 二叉搜索树中第K小的元素</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-230.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sun, 17 Oct 2021 10:43:50 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-230.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</guid>
      <description>链接： https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/
难度： 中等
题目描述 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。
示例 1：  输入： root = [3,1,4,null,2], k = 1
输出： 1
 示例 2：  输入： root = [5,3,6,2,4,null,null,1], k = 3
输出： 3
 提示：  树中的节点数为 n 。 1 &amp;lt;= k &amp;lt;= n &amp;lt;= 104 0 &amp;lt;= Node.val &amp;lt;= 104  进阶： 如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？
解题思路 中序遍历 中序遍历，每遇到一个结点， k = k - 1，当 k 减为 0 时，返回当前结点的值。</description>
    </item>
    
    <item>
      <title>Leetcode 94. 二叉树的中序遍历</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-94.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 14 Oct 2021 14:53:52 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-94.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-tree-inorder-traversal/
难度： 简单
题目描述 给定一个二叉树的根节点 root ，返回它的 中序 遍历。
示例 1：  输入： root = [1,null,2,3]
输出： [1,3,2]
 示例 2：  输入： root = []
输出： []
 示例 3：  输入： root = [1]
输出： [1]
 示例 4：  输入： root = [1,2]
输出： [2,1]
 示例 5：  输入： root = [1,null,2]
输出： [1,2]
 提示：  树中节点数目在范围 [0, 100] 内 100 &amp;lt;= Node.val &amp;lt;= 100  **进阶: ** 递归算法很简单，你可以通过迭代算法完成吗？</description>
    </item>
    
    <item>
      <title>Leetcode 114. 二叉树展开为链表</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-114.-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 12 Oct 2021 18:29:58 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-114.-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/
难度： 中等
题目描述 给你二叉树的根结点 root ，请你将它展开为一个单链表：
 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。  示例 1：  输入： root = [1,2,5,3,4,null,6]
输出： [1,null,2,null,3,null,4,null,5,null,6]
 示例 2：  输入： root = []
输出： []
 示例 3：  输入： root = [0]
输出： [0]
 提示：  树中结点数在范围 [0, 2000] 内 -100 &amp;lt;= Node.val &amp;lt;= 100  进阶： 你可以使用原地算法（$O(1)$ 额外空间）展开这棵树吗？
解题思路 先序遍历 使用一个记录目前展开链表的尾部，先序遍历二叉树，每遇到一个新结点，将其加入到尾部。
func flatten(root *TreeNode) { head := new(TreeNode) tail := head var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } left := node.</description>
    </item>
    
    <item>
      <title>剑指 Offer 68 - II. 二叉树的最近公共祖先</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-68-ii.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Sat, 02 Oct 2021 17:21:23 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-68-ii.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/
难度： 简单
题目描述 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉搜索树: root = [3,5,1,6,2,0,8,null,null,7,4]
示例 1：  输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
 示例 2：  输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
 说明：  所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。  解题思路 深度优先搜索 + 记录路径 利用深度优先搜索找出从根结点开始分别到 p 和 q 的路径，然后找出两条路径中最后一个相同的结点并返回。</description>
    </item>
    
    <item>
      <title>Leetcode 543. 二叉树的直径</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-543.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</link>
      <pubDate>Thu, 30 Sep 2021 12:00:42 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-543.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/diameter-of-binary-tree/
难度： 简单
题目描述 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例： 给定二叉树
 1 / \ 2 3 / \ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
注意：  两结点之间的路径长度是以它们之间边的数目表示。  解题思路 后序遍历 某个子树的最大直径或者为左右子树的最大直径，或者为跨越当前根结点的左右子树的高度和。
递归的遍历每棵子树，返回找到的最大直径。
func diameterOfBinaryTree(root *TreeNode) int { var dfs func(node *TreeNode) (int, int) dfs = func(node *TreeNode) (int, int) { if node == nil { return 0, 0 } lDepth, lMax := dfs(node.Left) rDepth, rMax := dfs(node.Right) depth := lDepth if depth &amp;lt; rDepth { depth = rDepth } max := lDepth + rDepth if max &amp;lt; lMax { max = lMax } if max &amp;lt; rMax { max = rMax } return depth+1, max } _, max := dfs(root) return max } 复杂度  时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\log{N}) $  </description>
    </item>
    
    <item>
      <title>Leetcode 199. 二叉树的右视图</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-199.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Thu, 30 Sep 2021 11:24:18 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-199.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-tree-right-side-view/
难度： 中等
题目描述 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
示例 1：  输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
 示例 2：  输入: [1,null,3]
输出: [1,3]
 示例 3：  输入: []
输出: []
 提示：  二叉树的节点个数的范围是 [0,100] -100 &amp;lt;= Node.val &amp;lt;= 100   解题思路 先序遍历 先序遍历二叉树，同时传递深度信息，对于每个遍历到的结点，修改对应深度的结点为当前结点。
func rightSideView(root *TreeNode) []int { ans := make([]int, 0, 10) var dfs func(node *TreeNode, depth int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if depth == len(ans) { ans = append(ans, node.</description>
    </item>
    
    <item>
      <title>Leetcode 437. 路径总和 III</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-437.-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-iii/</link>
      <pubDate>Tue, 28 Sep 2021 14:08:48 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-437.-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-iii/</guid>
      <description>链接： https://leetcode-cn.com/problems/path-sum-iii/
难度： 中等
题目描述 给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。
路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
示例 1：  输入： root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出： 3
解释： 和等于 8 的路径有 3 条，如图所示。
 示例 2：  输入： root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出： 3
 提示：  二叉树的节点个数的范围是 [0,1000] -109 &amp;lt;= Node.val &amp;lt;= 109 -1000 &amp;lt;= targetSum &amp;lt;= 1000  解题思路 深度优先搜索 + 前缀和 采用深度优先搜索，并将从根到当前结点的路径和保存到哈希表中，记录该和出现的数量。
每当到达一个新结点时，查找到该结点的前缀和减去 target 是否存在于路径中，存在将其次数累加进结果中，然后递归的处理子结点，也将查询结果累加进结果中。</description>
    </item>
    
    <item>
      <title>剑指 Offer 55 - II. 平衡二叉树</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-55-ii.-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 28 Sep 2021 13:21:08 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-55-ii.-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>链接： https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/
难度： 简单
题目描述 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
示例 1： 给定二叉树 [3,9,20,null,null,15,7]
 3 / \ 9 20 / \ 15 7 返回 true 。
示例 2： 给定二叉树 [1,2,2,3,3,null,null,4,4]
 1 / \ 2 2 / \ 3 3 / \ 4 4 返回 false 。
限制：  0 &amp;lt;= 树的结点个数 &amp;lt;= 10000  解题思路 深度优先搜索 递归的遍历每个结点的左右子树，当左右子树均为平衡树且左右子树的最大深度差值 ≤ 1 时，返回 true。
func isBalanced(root *TreeNode) bool { var dfs func(root *TreeNode) (int, bool) dfs = func(root *TreeNode) (int, bool) { if root == nil { return 0, true } leftDepth, leftBalance := dfs(root.</description>
    </item>
    
    <item>
      <title>剑指 Offer 55 - I. 二叉树的深度</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-55-i.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Tue, 28 Sep 2021 12:16:07 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-55-i.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/
难度： 简单
题目描述 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
例如：
给定二叉树 [3,9,20,null,null,15,7]，
 3 / \ 9 20 / \ 15 7 返回它的最大深度 3 。
提示：  节点总数 &amp;lt;= 10000  解题思路 深度优先搜索 递归的遍历每个结点的左右子树，获得子树最大深度，+1 后返回，当结点不存在时，树高为空
func maxDepth(root *TreeNode) int { if root == nil { return 0 } depth := maxDepth(root.Left) rDepth := maxDepth(root.Right) if depth &amp;lt; rDepth { depth = rDepth } return depth + 1 } 复杂度  时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\log{N}) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 36. 二叉搜索树与双向链表</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-36.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 20 Sep 2021 17:20:45 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-36.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/
难度： 中等
题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
为了让您更好地理解问题，以下面的二叉搜索树为例：
我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。
特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。
解题思路 深度优先搜索 二叉搜索树中序遍历后的结果即为有序的，采用中序遍历的方式搜索二叉树。
维护两个指针 head 和 tail ，分别指向当前遍历到的链表的头和尾。对于当前遍历到的结点，将其 left 指向 tail，同时 tail 的 right 指向当前结点，后 tail 变更为指向当前结点。
完成遍历后，修改头尾指针，使其构成环。
class Solution { public: Node *treeToDoublyList(Node *root) { if (root == nullptr) { return nullptr; } dfs(root); head-&amp;gt;left = tail; tail-&amp;gt;right = head; return head; } private: Node *head, *tail; void dfs(Node *node) { if(node == nullptr) { return; } dfs(node-&amp;gt;left); if (head == nullptr) { head = node; } if (tail == nullptr) { tail = node; } else { tail-&amp;gt;right = node; node-&amp;gt;left = tail; tail = node; } dfs(node-&amp;gt;right); } }; 复杂度  时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\log{N}) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 34. 二叉树中和为某一值的路径</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-34.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 20 Sep 2021 14:55:24 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-34.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/
难度： 中等
题目描述 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。
示例： 给定如下二叉树，以及目标和 target = 22，
 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 返回:
[ [5,4,11,2], [5,8,4,5] ] 提示：  节点总数 &amp;lt;= 10000  解题思路 深度优先搜索 从根节点开始进行深度优先搜索，当整条路径上的结点值之和为 target 时，将其拷贝到结果队列中。
func pathSum(root *TreeNode, target int) [][]int { ans := make([][]int, 0) var dfs func(node *TreeNode, path []int, sum int) dfs = func(node *TreeNode, path []int, sum int) { if node == nil { return } path = append(path, node.</description>
    </item>
    
    <item>
      <title>剑指 Offer 26. 树的子结构</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-26.-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 19 Sep 2021 19:37:13 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-26.-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/
难度： 中等
题目描述 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
B是A的子结构， 即 A中有出现和B相同的结构和节点值。
例如: 给定的树 A:
 3 / \ 4 5 / \ 1 2 给定的树 B：
 4 / 1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
示例 1：  输入： A = [1,2,3], B = [3,1]
输出： false
 示例 2：  输入： A = [3,4,5,1,2], B = [4,1]
输出： true
 限制：  0 &amp;lt;= 节点个数 &amp;lt;= 10000  解题思路 深度优先搜索 在树 A 上进行 深度优先搜索（先序遍历），当子树根结点与 B 相同时，仍采用 深度优先搜索 的方式比较结构是否相同。</description>
    </item>
    
    <item>
      <title>剑指 Offer 13. 机器人的运动范围</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</link>
      <pubDate>Sun, 19 Sep 2021 14:29:35 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</guid>
      <description>链接： https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/
难度： 中等
题目描述 地上有一个 m 行 n 列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0,0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
示例 1：  输入： m = 2, n = 3, k = 1
输出： 3
 示例 2：  输入： m = 3, n = 1, k = 0
输出： 1
 提示：  1 &amp;lt;= n,m &amp;lt;= 100 0 &amp;lt;= k &amp;lt;= 20  解题思路 深度优先搜索 从 [0,0] 开始进行深度优先搜索，当针对 k 进行剪枝时，整个矩阵是关于 (i,i) 对称的，所以可以限制搜索方向为右和下。</description>
    </item>
    
    <item>
      <title>剑指 Offer 12. 矩阵中的路径</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sat, 18 Sep 2021 17:25:16 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/
难度： 中等
题目描述 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
例如，在下面的 3×4 的矩阵中包含单词 &amp;ldquo;ABCCED&amp;rdquo;（单词中的字母已标出）。
示例 1：  输入： board = [[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;B&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;E&amp;rdquo;],[&amp;ldquo;S&amp;rdquo;,&amp;ldquo;F&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;S&amp;rdquo;],[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;D&amp;rdquo;,&amp;ldquo;E&amp;rdquo;,&amp;ldquo;E&amp;rdquo;]], word = &amp;ldquo;ABCCED&amp;rdquo;
输出： true
 示例 2：  输入： board = [[&amp;ldquo;a&amp;rdquo;,&amp;ldquo;b&amp;rdquo;],[&amp;ldquo;c&amp;rdquo;,&amp;ldquo;d&amp;rdquo;]], word = &amp;ldquo;abcd&amp;rdquo;
输出： false
 提示：  1 &amp;lt;= board.length &amp;lt;= 200 1 &amp;lt;= board[i].length &amp;lt;= 200 board 和 word 仅由大小写英文字母组成  解题思路 深度优先搜索 遍历整个矩阵，从每个字符开始进行深度优先搜索，当无法找到下一个字符时，及时剪枝。</description>
    </item>
    
    <item>
      <title>Leetcode 797. 所有可能的路径</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-797.-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Wed, 25 Aug 2021 22:05:55 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-797.-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/all-paths-from-source-to-target/
难度： 中等
题目描述 给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）
二维数组的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些节点，空就是没有下一个结点了。
译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。
示例 1：  输入： graph = [[1,2],[3],[3],[]]
输出： [[0,1,3],[0,2,3]]
解释： 有两条路径 0 -&amp;gt; 1 -&amp;gt; 3 和 0 -&amp;gt; 2 -&amp;gt; 3
 示例 2：  输入： graph = [[4,3,1],[3,2,4],[3],[4],[]]
输出： [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
 示例 3：  输入： graph = [[1],[]]
输出： [[0,1]]
 示例 4：  输入： graph = [[1,2,3],[2],[3],[]]</description>
    </item>
    
    <item>
      <title>Leetcode 802. 找到最终的安全状态</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-802.-%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/</link>
      <pubDate>Thu, 05 Aug 2021 14:10:25 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-802.-%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/</guid>
      <description>链接： https://leetcode-cn.com/problems/find-eventual-safe-states/
难度： 中等
题目描述 在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。
对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。
返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。
该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。
示例 1：  输入： graph = [[1,2],[2,3],[5],[0],[5],[],[]]
输出： [2,4,5,6]
解释： 示意图如上。
 示例 2：  输入： graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
输出： [4]
 提示：  n == graph.length 1 &amp;lt;= n &amp;lt;= 104 0 &amp;lt;= graph[i].length &amp;lt;= n graph[i] 按严格递增顺序排列。 图中可能包含自环。 图中边的数目在范围 [1, 4 * 104] 内。  解题思路 深度优先搜索 通过分析题目得知，当图无环时，所有结点均为 安全 结点；当图有环时，无法到达环的结点属于 安全 结点。</description>
    </item>
    
    <item>
      <title>Leetcode 987. 二叉树的垂序遍历</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-987.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sat, 31 Jul 2021 12:57:30 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-987.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>链接： https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/
难度： 困难
题目描述 给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。
对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。
二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。
返回二叉树的 垂序遍历 序列。
示例 1：  输入： root = [3,9,20,null,null,15,7]
输出： [[9],[3,15],[20],[7]]
解释：
列 -1 ：只有结点 9 在此列中。
列 0 ：只有结点 3 和 15 在此列中，按从上到下顺序。
列 1 ：只有结点 20 在此列中。
列 2 ：只有结点 7 在此列中。
 示例 2：  输入： root = [1,2,3,4,5,6,7]</description>
    </item>
    
    <item>
      <title>Leetcode 863. 二叉树中所有距离为 K 的结点</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-863.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BA-k-%E7%9A%84%E7%BB%93%E7%82%B9/</link>
      <pubDate>Wed, 28 Jul 2021 11:09:17 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-863.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BA-k-%E7%9A%84%E7%BB%93%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/
难度： 中等
题目描述 给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。
返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。
示例：  输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2
输出：[7,4,1]
解释：
所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1
注意，输入的 &amp;ldquo;root&amp;rdquo; 和 &amp;ldquo;target&amp;rdquo; 实际上是树上的结点。
上面的输入仅仅是对这些对象进行了序列化描述。
 提示：  给定的树是非空的。 树上的每个结点都具有唯一的值 0 &amp;lt;= node.val &amp;lt;= 500 。 目标结点 target 是树上的结点。 0 &amp;lt;= K &amp;lt;= 1000  解题思路 深度优先搜索 一次遍历，找到结点 target，同时记录每个结点的父结点，使之构成一张无向图。
然后从 target 结点开始遍历图，找到所有距离为 K 的结点。</description>
    </item>
    
    <item>
      <title>Leetcode 671. 二叉树中第二小的节点</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-671.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 27 Jul 2021 10:31:04 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-671.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/
难度： 简单
题目描述 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。
更正式地说，root.val = min(root.left.val, root.right.val) 总成立。
给出这样的一个二叉树，你需要输出所有节点中的 第二小的值。如果第二小的值不存在的话，输出 -1 。
示例 1：  输入： root = [2,2,5,null,null,5,7]
输出： 5
解释： 最小的值是 2 ，第二小的值是 5 。
 示例 2：  输入： root = [2,2,2]
输出： -1
解释： 最小的值是 2, 但是不存在第二小的值。
 提示：  树中节点数目在范围 [1, 25] 内 1 &amp;lt;= Node.val &amp;lt;= 231 - 1 对于树中每个节点 root.val == min(root.left.val, root.right.val)  解题思路 深度优先搜索 据题意，树的根结点是最小值，故可以遍历整棵树，使用 min 记录最 第二小的值。</description>
    </item>
    
    <item>
      <title>LCP 07. 传递信息</title>
      <link>https://xianlianghe0123.github.io/p/lcp-07.-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Thu, 01 Jul 2021 11:14:31 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/lcp-07.-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/</guid>
      <description>链接： https://leetcode-cn.com/problems/chuan-di-xin-xi/
难度： 简单
题目描述 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：
 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人  给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。
示例1：  输入： n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3
输出： 3
解释： 信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&amp;gt;2-&amp;gt;0-&amp;gt;4， 0-&amp;gt;2-&amp;gt;1-&amp;gt;4， 0-&amp;gt;2-&amp;gt;3-&amp;gt;4。</description>
    </item>
    
    <item>
      <title>Leetcode 938. 二叉搜索树的范围和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-938.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</link>
      <pubDate>Tue, 27 Apr 2021 10:31:11 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-938.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/range-sum-of-bst/
难度： 简单
题目描述 给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。
示例 1：  输入： root = [10,5,15,3,7,null,18], low = 7, high = 15
输出： 32
 示例 2：  输入： root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
输出： 23
 提示：  树中节点数目在范围 [1, 2 * 104] 内 1 &amp;lt;= Node.val &amp;lt;= 105 1 &amp;lt;= low &amp;lt;= high &amp;lt;= 105 所有 Node.val 互不相同  解题思路 深度优先搜索 不同于一般搜索树的搜索，该搜索需要遍历整颗树，以累计求和，必要部分需要剪枝加快遍历速度。
搜索时需要区分三种情况：</description>
    </item>
    
  </channel>
</rss>
