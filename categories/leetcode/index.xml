<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on 贺贤良</title>
    <link>https://xianlianghe0123.github.io/categories/leetcode/</link>
    <description>Recent content in Leetcode on 贺贤良</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn-zh</language>
    <lastBuildDate>Tue, 05 Oct 2021 13:38:07 +0800</lastBuildDate><atom:link href="https://xianlianghe0123.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 284. 顶端迭代器</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-284.-%E9%A1%B6%E7%AB%AF%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Tue, 05 Oct 2021 13:38:07 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-284.-%E9%A1%B6%E7%AB%AF%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/peeking-iterator/
难度： 中等
题目描述 请你设计一个迭代器，除了支持 hasNext 和 next 操作外，还支持 peek 操作。
实现 PeekingIterator 类：
 PeekingIterator(int[] nums) 使用指定整数数组 nums 初始化迭代器。 int next() 返回数组中的下一个元素，并将指针移动到下个元素处。 bool hasNext() 如果数组中存在下一个元素，返回 true ；否则，返回 false 。 int peek() 返回数组中的下一个元素，但 不 移动指针。  示例：  输入：
[&amp;ldquo;PeekingIterator&amp;rdquo;, &amp;ldquo;next&amp;rdquo;, &amp;ldquo;peek&amp;rdquo;, &amp;ldquo;next&amp;rdquo;, &amp;ldquo;next&amp;rdquo;, &amp;ldquo;hasNext&amp;rdquo;]
[[[1, 2, 3]], [], [], [], [], []]
输出：
[null, 1, 2, 2, 3, false]
解释：
PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]</description>
    </item>
    
    <item>
      <title>Leetcode 482. 密钥格式化</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-482.-%E5%AF%86%E9%92%A5%E6%A0%BC%E5%BC%8F%E5%8C%96/</link>
      <pubDate>Mon, 04 Oct 2021 11:44:14 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-482.-%E5%AF%86%E9%92%A5%E6%A0%BC%E5%BC%8F%E5%8C%96/</guid>
      <description>链接： https://leetcode-cn.com/problems/license-key-formatting/
难度： 简单
题目描述 有一个密钥字符串 S ，只包含字母，数字以及 &amp;lsquo;-&#39;（破折号）。其中， N 个 &amp;lsquo;-&amp;rsquo; 将字符串分成了 N+1 组。
给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 &amp;lsquo;-&#39;（破折号）隔开，并且将所有的小写字母转换为大写字母。
给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。
示例 1：  输入： S = &amp;ldquo;5F3Z-2e-9-w&amp;rdquo;, K = 4
输出： &amp;ldquo;5F3Z-2E9W&amp;rdquo;
解释： 字符串 S 被分成了两个部分，每部分 4 个字符；
注意，两个额外的破折号需要删掉。
 示例 2：  输入： S = &amp;ldquo;2-5g-3-J&amp;rdquo;, K = 2
输出： &amp;ldquo;2-5G-3J&amp;rdquo;
解释： 字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。
 提示：  S 的长度可能很长，请按需分配大小。K 为正整数。 S 只包含字母数字（a-z，A-Z，0-9）以及破折号&amp;rsquo;-&amp;rsquo; S 非空  解题思路 计数 遍历一遍列表，统计所有字母的数量，若首个分组不足 k 个，需要额外处理，之后按 k 个一组进行分组。</description>
    </item>
    
    <item>
      <title>Leetcode 166. 分数到小数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-166.-%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/</link>
      <pubDate>Sun, 03 Oct 2021 20:06:52 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-166.-%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/fraction-to-recurring-decimal/
难度： 中等
题目描述 给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。
如果小数部分为循环小数，则将循环的部分括在括号内。
如果存在多个答案，只需返回 任意一个 。
对于所有给定的输入，保证 答案字符串的长度小于 104 。
示例 1：  输入： numerator = 1, denominator = 2
输出： &amp;ldquo;0.5&amp;rdquo;
 示例 2：  输入： numerator = 2, denominator = 1
输出： &amp;ldquo;2&amp;rdquo;
 示例 3：  输入： numerator = 2, denominator = 3
输出： &amp;ldquo;0.(6)&amp;rdquo;
 示例 4：  输入： numerator = 4, denominator = 333
输出： &amp;ldquo;0.(012)&amp;rdquo;</description>
    </item>
    
    <item>
      <title>剑指 Offer II 001. 整数除法</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-ii-001.-%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95/</link>
      <pubDate>Sat, 02 Oct 2021 18:12:00 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-ii-001.-%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95/</guid>
      <description>链接： https://leetcode-cn.com/problems/xoh6Oh/
难度： 简单
题目描述 给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 &#39;*&#39;、除号 &#39;/&#39; 以及求余符号 &#39;%&#39; 。
注意：  整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231−1]。本题中，如果除法结果溢出，则返回 231 − 1  示例 1：  输入： a = 15, b = 2
输出： 7
解释： 15/2 = truncate(7.5) = 7
 示例 2：  输入： a = 7, b = -3
输出： -2
解释： 7/-3 = truncate(-2.33333..) = -2</description>
    </item>
    
    <item>
      <title>剑指 Offer 68 - II. 二叉树的最近公共祖先</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-68-ii.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Sat, 02 Oct 2021 17:21:23 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-68-ii.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/
难度： 简单
题目描述 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉搜索树: root = [3,5,1,6,2,0,8,null,null,7,4]
示例 1：  输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
 示例 2：  输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
 说明：  所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。  解题思路 深度优先搜索 + 记录路径 利用深度优先搜索找出从根结点开始分别到 p 和 q 的路径，然后找出两条路径中最后一个相同的结点并返回。</description>
    </item>
    
    <item>
      <title>Leetcode 405. 数字转换为十六进制数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-405.-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/</link>
      <pubDate>Sat, 02 Oct 2021 16:16:35 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-405.-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/
难度： 简单
题目描述 给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。
注意:  十六进制中所有字母(a-f)都必须是小写。 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符&#39;0&amp;rsquo;来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。  给定的数确保在32位有符号整数范围内。 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。  示例 1：  输入: 26
输出: &amp;ldquo;1a&amp;rdquo;
 示例 2：  输入: -1
输出: &amp;ldquo;ffffffff&amp;rdquo;
 解题思路 数学 将负数补码转换为正数，使用数学方法，除16取余，逆序排列。对0进行特判。
func toHex(num int) string { if num == 0 { return &amp;#34;0&amp;#34; } digit := []byte(&amp;#34;0123456789abcdef&amp;#34;) ans := make([]byte, 0, 8) t := uint32(num) for ; t != 0; t /= 16 { ans = append(ans, digit[t%16]) } for i := len(ans)/2 - 1; i &amp;gt;= 0; i-- { ans[i], ans[len(ans)-1-i] = ans[len(ans)-1-i], ans[i] } return string(ans) } 复杂度  时间复杂度：O(\log{num}) 空间复杂度：O(\log{num})  位运算 四个2进制位构成16进制，每次将末尾四个2进制位转换为16进制，并向右移动4位，直到 num 为0 或 转换次数到达上限。对0进行特判。</description>
    </item>
    
    <item>
      <title>剑指 Offer 68 - I. 二叉搜索树的最近公共祖先</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-68-i.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Sat, 02 Oct 2021 15:05:53 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-68-i.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/
难度： 简单
题目描述 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]
示例 1：  输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6
解释: 节点 2 和节点 8 的最近公共祖先是 6。
 示例 2：  输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
 说明：  所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。  解题思路 搜索 利用二叉树搜索数的性质：</description>
    </item>
    
    <item>
      <title>剑指 Offer 67. 把字符串转换成整数</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-67.-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</link>
      <pubDate>Sat, 02 Oct 2021 13:19:01 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-67.-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/
难度： 中等
题目描述 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。
首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。
当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。
该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。
注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。
在任何情况下，若函数不能进行有效的转换时，请返回 0。
说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。
示例 1：  输入: &amp;ldquo;42&amp;rdquo;
输出: 42
 示例 2：  输入: &amp;quot; -42&amp;quot;
输出: -42
解释: 第一个非空白字符为 &amp;lsquo;-&amp;rsquo;, 它是一个负号。
我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
 示例 3：  输入: &amp;ldquo;4193 with words&amp;rdquo;
输出: 4193
解释: 转换截止于数字 &amp;lsquo;3&amp;rsquo; ，因为它的下一个字符不为数字。
 示例 4：  输入: &amp;ldquo;words and 987&amp;rdquo;</description>
    </item>
    
    <item>
      <title>剑指 Offer 66. 构建乘积数组</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-66.-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 01 Oct 2021 22:53:59 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-66.-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/
难度： 中等
题目描述 给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。
示例：  输入: [1,2,3,4,5]
输出: [120,60,40,30,24]
 限制：  所有元素乘积之和不会溢出 32 位整数 a.length &amp;lt;= 100000  解题思路 前后缀积 计算前缀积 prefixProduct 和后缀积 suffixProduct，然后求得 B[i] = prefixProduct[i-1] * suffixProduct[i+1]。
func constructArr(a []int) []int { if len(a) == 0 { return make([]int, 0) } ans := make([]int, len(a)) ans[0] = 1 for i, prefixProduct := 1, 1; i &amp;lt; len(a); i++ { prefixProduct *= a[i-1] ans[i] = prefixProduct } for i, suffixProduct := len(a)-2, 1; i &amp;gt;= 0; i-- { suffixProduct *= a[i+1] ans[i] *= suffixProduct } return ans } 复杂度  时间复杂度：$ O(N), N = len(a) $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 65. 不用加减乘除做加法</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-65.-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</link>
      <pubDate>Fri, 01 Oct 2021 22:35:56 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-65.-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</guid>
      <description>链接： https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/
难度： 简单
题目描述 写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。
示例：  输入: a = 1, b = 1
输出: 2
 限制：  a, b 均可能是负数或 0 结果不会溢出 32 位整数  解题思路 位运算 以二进制位为单位进行运算，从最低位开始，使用位操作符诸位运算。
由于负数在计算机中存储的是补码，直接诸位求和即可，用 c 表示进位，利用 数字电路设计 得到计算方法如下：
 当前位计算结果为：$a\oplus b\oplus c$ 进位的计算结果为：$(a\oplus b)c + ab$  func add(a int, b int) int { ans := 0 c := 0 for bit := 1; bit != 0; bit &amp;lt;&amp;lt;= 1 { ans |= (a ^ b ^ c) &amp;amp; bit c = (((a ^ b) &amp;amp; c) | (a &amp;amp; b)) &amp;amp; bit &amp;lt;&amp;lt; 1 } return ans } 复杂度  时间复杂度：$ O(\log{MaxInt32}) $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 64. 求1&#43;2&#43;…&#43;n</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-64.-%E6%B1%821-2-n/</link>
      <pubDate>Fri, 01 Oct 2021 20:44:05 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-64.-%E6%B1%821-2-n/</guid>
      <description>链接： https://leetcode-cn.com/problems/qiu-12n-lcof/
难度： 中等
题目描述 求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。
示例 1：  输入: n = 3
输出: 6
 示例 2：  输入: n = 9
输出: 45
 限制：  1 &amp;lt;= n &amp;lt;= 10000  解题思路 递归 利用布尔表达式的短路返回，实现递归到终止条件。
func sumNums(n int) int { ans := 0 var sum func(n int) bool sum = func(n int) bool { ans += n return n &amp;gt; 0 &amp;amp;&amp;amp; sum(n-1) } sum(n) return ans } 复杂度  时间复杂度：$ O(n) $ 空间复杂度：$ O(n) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 63. 股票的最大利润</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-63.-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</link>
      <pubDate>Fri, 01 Oct 2021 20:29:26 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-63.-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</guid>
      <description>链接： https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/
难度： 中等
题目描述 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？
示例 1：  输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
 示例 2：  输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
 限制：  0 &amp;lt;= 数组长度 &amp;lt;= 105  解题思路 暴力求解 枚举买卖点，记录最大值。
func maxProfit(prices []int) int { ans := 0 for i := range prices { for j := i + 1; j &amp;lt; len(prices); j++ { if ans &amp;lt; prices[j]-prices[i] { ans = prices[j] - prices[i] } } } return ans } 复杂度  时间复杂度：$ O(N^2), N = len(prices) $ 空间复杂度：$ O(1) $  遍历 使用 min 记录到目前为止股票的最小值，每次使用当前股票价格减去 min ，更新最大利润。</description>
    </item>
    
    <item>
      <title>剑指 Offer 62. 圆圈中最后剩下的数字</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-62.-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 01 Oct 2021 14:38:53 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-62.-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/
难度： 简单
题目描述 0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。
例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。
示例 1：  输入: n = 5, m = 3
输出: 3
 示例 2：  输入: n = 10, m = 17
输出: 2
 限制：  1 &amp;lt;= n &amp;lt;= 105 1 &amp;lt;= m &amp;lt;= 106  解题思路 递归 令 f(n, m) 表示从 n 个数字中不断删除第 m 个数字后剩余的数字， 则需要删除的数字为 (m-1) % n，然后变成了从 n-1 个数字中删除第 m 个数字。
f(n-1, m) 可以得到从第 n-1 个数字中不断删除第 m 个数字后剩余的数字，该表达式是按照从第一个数字开始计数；然而在删除一个数字后，需要从 m % n 开始计数，故需要找到两者间的映射关系，即 f(n, m) = F(f(n-1, m))。</description>
    </item>
    
    <item>
      <title>剑指 Offer 61. 扑克牌中的顺子</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-61.-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</link>
      <pubDate>Fri, 01 Oct 2021 14:17:17 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-61.-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</guid>
      <description>链接： https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/
难度： 简单
题目描述 从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。
示例 1：  输入: [1,2,3,4,5]
输出: True
 示例 2：  输入: [0,0,1,2,5]
输出: True
 限制：  数组长度为 5 数组的数取值为 [0, 13] .  解题思路 排序 排序，统计大小王的数量，判断其余相邻牌的差值：
 当差值为 0 时，不构成顺子，返回 false； 当差值不为 0 时，使用大小王去补。 最后，当大小王数量不为负时，返回 true，否则返回 false 。  func isStraight(nums []int) bool { sort.Ints(nums) cnt := 0 for i := 0; i &amp;lt; len(nums); i++ { if nums[i] == 0 { cnt++ continue } if i-1 &amp;gt;= 0 &amp;amp;&amp;amp; nums[i-1] !</description>
    </item>
    
    <item>
      <title>剑指 Offer 59 - II. 队列的最大值</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-59-ii.-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</link>
      <pubDate>Fri, 01 Oct 2021 13:26:38 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-59-ii.-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</guid>
      <description>链接： https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/
难度： 中等
题目描述 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是$O(1)$。
若队列为空，pop_front 和 max_value 需要返回 -1 。
示例 1：  输入:
[&amp;ldquo;MaxQueue&amp;rdquo;,&amp;ldquo;push_back&amp;rdquo;,&amp;ldquo;push_back&amp;rdquo;,&amp;ldquo;max_value&amp;rdquo;,&amp;ldquo;pop_front&amp;rdquo;,&amp;ldquo;max_value&amp;rdquo;]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
 示例 2：  输入:
[&amp;ldquo;MaxQueue&amp;rdquo;,&amp;ldquo;pop_front&amp;rdquo;,&amp;ldquo;max_value&amp;rdquo;]
[[],[],[]]
输出: [null,-1,-1]
 限制：  1 &amp;lt;= push_back,pop_front,max_value的总操作数 &amp;lt;= 10000 1 &amp;lt;= value &amp;lt;= 105  解题思路 双队列 除正常存储数据的队列外，需要额外使用一个队列维护最大值信息。
可以发现，当某一个值入队后，之前入队的所有小于该值的元素对于 max_value 均无影响；仅当该值出队后，由此值后面的次大元素接任。
所以这个额外队列的队列头记录当前队列的最大值，后续按值非严格递减的顺序记录其他值。
 当入队时，需要从尾部开始将小于当前值的元素全部删除，然后该值入队； 当出队时，若队首元素是最大值，则两个队列都要出队。  type MaxQueue struct { queue *list.List maxQueue *list.List } func Constructor() MaxQueue { return MaxQueue{ queue: list.</description>
    </item>
    
    <item>
      <title>Leetcode 1436. 旅行终点站</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1436.-%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/</link>
      <pubDate>Fri, 01 Oct 2021 13:11:21 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1436.-%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/</guid>
      <description>链接： https://leetcode-cn.com/problems/destination-city/
难度： 中等
题目描述 给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。
题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。
示例 1：  输入： paths = [[&amp;ldquo;London&amp;rdquo;,&amp;ldquo;New York&amp;rdquo;],[&amp;ldquo;New York&amp;rdquo;,&amp;ldquo;Lima&amp;rdquo;],[&amp;ldquo;Lima&amp;rdquo;,&amp;ldquo;Sao Paulo&amp;rdquo;]]
输出： &amp;ldquo;Sao Paulo&amp;rdquo;
解释： 从 &amp;ldquo;London&amp;rdquo; 出发，最后抵达终点站 &amp;ldquo;Sao Paulo&amp;rdquo; 。本次旅行的路线是 &amp;ldquo;London&amp;rdquo; -&amp;gt; &amp;ldquo;New York&amp;rdquo; -&amp;gt; &amp;ldquo;Lima&amp;rdquo; -&amp;gt; &amp;ldquo;Sao Paulo&amp;rdquo; 。
 示例 2:  输入： paths = [[&amp;ldquo;B&amp;rdquo;,&amp;ldquo;C&amp;rdquo;],[&amp;ldquo;D&amp;rdquo;,&amp;ldquo;B&amp;rdquo;],[&amp;ldquo;C&amp;rdquo;,&amp;ldquo;A&amp;rdquo;]]
输出： &amp;ldquo;A&amp;rdquo;
解释： 所有可能的线路是：
&amp;ldquo;D&amp;rdquo; -&amp;gt; &amp;ldquo;B&amp;rdquo; -&amp;gt; &amp;ldquo;C&amp;rdquo; -&amp;gt; &amp;ldquo;A&amp;rdquo;.
&amp;ldquo;B&amp;rdquo; -&amp;gt; &amp;ldquo;C&amp;rdquo; -&amp;gt; &amp;ldquo;A&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>剑指 Offer 58 - II. 左旋转字符串</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-58-ii.-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 30 Sep 2021 20:41:59 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-58-ii.-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/
难度： 简单
题目描述 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&amp;quot;abcdefg&amp;quot;和数字2，该函数将返回左旋转两位得到的结果&amp;quot;cdefgab&amp;quot;。
示例 1：  输入: s = &amp;ldquo;abcdefg&amp;rdquo;, k = 2
输出: &amp;ldquo;cdefgab&amp;rdquo;
 示例 2：  输入: s = &amp;ldquo;lrloseumgh&amp;rdquo;, k = 6
输出: &amp;ldquo;umghlrlose&amp;rdquo;
 限制：  1 &amp;lt;= k &amp;lt; s.length &amp;lt;= 10000  解题思路 暴力求解 每次循环移动一个字符，重复 n 次。
func reverseLeftWords(s string, n int) string { chars := []byte(s) for i := 0; i &amp;lt; n; i++ { char := s[0] for j := 0; j &amp;lt; len(s); j++ { chars[j] = chars[j+1] } chars[len(s)-1] = char } return string(chars) } 复杂度  时间复杂度：$ O(Ln), L = len(s) $ 空间复杂度：$ O(1) $  切片 移动后的结果为：前 n 个字符移动到字符串的尾部，使用切片即可。</description>
    </item>
    
    <item>
      <title>剑指 Offer 58 - I. 翻转单词顺序</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-58-i.-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Thu, 30 Sep 2021 20:21:30 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-58-i.-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/
难度： 简单
题目描述 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&amp;quot;I am a student. &amp;quot;，则输出&amp;quot;student. a am I&amp;quot;。
示例 1：  输入: &amp;ldquo;the sky is blue&amp;rdquo;
输出: &amp;ldquo;blue is sky the&amp;rdquo;
 示例 2：  输入: &amp;quot; hello world! &amp;quot;
输出: &amp;ldquo;world! hello&amp;rdquo;
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。
 示例 3：  输入: &amp;ldquo;a good example&amp;rdquo;
输出: &amp;ldquo;example good a&amp;rdquo;
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。
 说明：  无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。  解题思路 模拟 将整个句子识别拆分为单词数组，将整个单词数组反转，然后使用 &#39; &#39; 作为连接符将整个单词数组连接起来。
func reverseWords(s string) string { ss := make([]string, 0, 10) start := 0 for i := range s { if s[i] == &amp;#39; &amp;#39; { if start == i { start++ continue } ss = append(ss, s[start:i]) start = i+1 } } for i := 0; i &amp;lt; len(ss)/2; i++ { ss[i], ss[len(ss)-1-i] = ss[len(ss)-1-i], ss[i] } return strings.</description>
    </item>
    
    <item>
      <title>剑指 Offer 57 - II. 和为s的连续正数序列</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-57-ii.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</link>
      <pubDate>Thu, 30 Sep 2021 20:04:58 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-57-ii.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/
难度： 简单
题目描述 输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
示例 1：  输入： target = 9
输出： [[2,3,4],[4,5]]
 示例 2：  输入： target = 15
输出： [[1,2,3,4,5],[4,5,6],[7,8]]
 限制：  1 &amp;lt;= target &amp;lt;= 105  解题思路 双指针 使用两个指针 i 和 j 代表连续正整数区间的两个端点，另使用变量 sum 记录该段区间的和。
 当 sum 小于 target 时，j 移动； 当 sum 大于 target 时，i 移动； 当 sum 等于 target 时，将区间加入到结果队列中，i 移动。  遍历到 j 大于 target 时结束，返回
func findContinuousSequence(target int) [][]int { ans := make([][]int, 0, 1) sum := 1 for i, j := 1, 1; j &amp;lt; target; { if sum &amp;lt; target { j++ sum += j } else if sum &amp;gt; target { sum -= i i++ } else { t := make([]int, 0, j-i+1) for k := i; k &amp;lt;= j; k++ { t = append(t, k) } ans = append(ans, t) sum -= i i++ } } return ans } 复杂度  时间复杂度：$ O(target) $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>Leetcode 543. 二叉树的直径</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-543.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</link>
      <pubDate>Thu, 30 Sep 2021 12:00:42 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-543.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/diameter-of-binary-tree/
难度： 简单
题目描述 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例： 给定二叉树
 1 / \ 2 3 / \ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
注意：  两结点之间的路径长度是以它们之间边的数目表示。  解题思路 后序遍历 某个子树的最大直径或者为左右子树的最大直径，或者为跨越当前根结点的左右子树的高度和。
递归的遍历每棵子树，返回找到的最大直径。
func diameterOfBinaryTree(root *TreeNode) int { var dfs func(node *TreeNode) (int, int) dfs = func(node *TreeNode) (int, int) { if node == nil { return 0, 0 } lDepth, lMax := dfs(node.Left) rDepth, rMax := dfs(node.Right) depth := lDepth if depth &amp;lt; rDepth { depth = rDepth } max := lDepth + rDepth if max &amp;lt; lMax { max = lMax } if max &amp;lt; rMax { max = rMax } return depth+1, max } _, max := dfs(root) return max } 复杂度  时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\log{N}) $  </description>
    </item>
    
    <item>
      <title>Leetcode 199. 二叉树的右视图</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-199.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Thu, 30 Sep 2021 11:24:18 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-199.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-tree-right-side-view/
难度： 中等
题目描述 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
示例 1：  输入: [1,2,3,null,5,null,4]
输出: [1,3,4]
 示例 2：  输入: [1,null,3]
输出: [1,3]
 示例 3：  输入: []
输出: []
 提示：  二叉树的节点个数的范围是 [0,100] -100 &amp;lt;= Node.val &amp;lt;= 100   解题思路 先序遍历 先序遍历二叉树，同时传递深度信息，对于每个遍历到的结点，修改对应深度的结点为当前结点。
func rightSideView(root *TreeNode) []int { ans := make([]int, 0, 10) var dfs func(node *TreeNode, depth int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if depth == len(ans) { ans = append(ans, node.</description>
    </item>
    
    <item>
      <title>Leetcode 19. 删除链表的倒数第 N 个结点</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-19.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/</link>
      <pubDate>Thu, 30 Sep 2021 10:58:01 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-19.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/
难度： 中等
题目描述 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶： 你能尝试使用一趟扫描实现吗？
示例 1：  输入： head = [1,2,3,4,5], n = 2
输出： [1,2,3,5]
 示例 2：  输入： head = [1], n = 1
输出： []
 示例 3：  输入： head = [1,2], n = 1
输出： [1]
 提示：  链表中结点的数目为 sz 1 &amp;lt;= sz &amp;lt;= 30 0 &amp;lt;= Node.val &amp;lt;= 100 1 &amp;lt;= n &amp;lt;= sz  解题思路 计算链表长度 遍历一遍列表，得到链表长度，从而求得距离链表头的偏移量，再次遍历将其删除即可。</description>
    </item>
    
    <item>
      <title>Leetcode 46. 全排列</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-46.-%E5%85%A8%E6%8E%92%E5%88%97/</link>
      <pubDate>Thu, 30 Sep 2021 10:40:00 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-46.-%E5%85%A8%E6%8E%92%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/permutations/
难度： 中等
题目描述 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。
示例 1：  输入： nums = [1,2,3]
输出： [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
 示例 2：  输入： nums = [0,1]
输出： [[0,1],[1,0]]
 示例 3：  输入： nums = [1]
输出： [[1]]
 提示：  1 &amp;lt;= nums.length &amp;lt;= 6 -10 &amp;lt;= nums[i] &amp;lt;= 10 nums 中的所有整数 互不相同  解题思路 回溯 每次从可选数字中选出一个数，加入到栈中，直到栈中元素数量与原数组相同，则其为其中一个的全排列，加入到结果中，回溯，重复上述步骤，直到搜索到所有情况。
func permute(nums []int) [][]int { cnt := 1 for i := 2; i &amp;lt;= len(nums); i++ { cnt *= i } ans := make([][]int, 0, cnt) choice := make(map[int]struct{}) var backtracking func(stack []int) backtracking = func(stack []int) { if len(stack) == len(nums) { t := make([]int, len(stack)) copy(t, stack) ans = append(ans, t) return } for _, num := range nums { if _, ok := choice[num]; ok { continue } choice[num] = struct{}{} stack = append(stack, num) backtracking(stack) stack = stack[:len(stack)-1] delete(choice, num) } } backtracking(make([]int, 0, len(nums))) return ans } 复杂度  时间复杂度：$ O(N*N!</description>
    </item>
    
    <item>
      <title>Leetcode 223. 矩形面积</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-223.-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/</link>
      <pubDate>Thu, 30 Sep 2021 10:21:34 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-223.-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/</guid>
      <description>链接： https://leetcode-cn.com/problems/rectangle-area/
难度： 中等
题目描述 给你 二维 平面上两个 由直线构成的 矩形，请你计算并返回两个矩形覆盖的总面积。
每个矩形由其 左下 顶点和 右上 顶点坐标表示：
 第一个矩形由其左下顶点 (ax1, ay1) 和右上顶点 (ax2, ay2) 定义。 第二个矩形由其左下顶点 (bx1, by1) 和右上顶点 (bx2, by2) 定义。  示例 1：  输入： ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2
输出： 45
 示例 2：  输入： ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2</description>
    </item>
    
    <item>
      <title>剑指 Offer 56 - II. 数组中数字出现的次数 II</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-56-ii.-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-ii/</link>
      <pubDate>Wed, 29 Sep 2021 20:54:30 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-56-ii.-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/
难度： 中等
题目描述 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
示例 1：  输入： nums = [3,4,3,3]
输出： 4
 示例 2：  输入： nums = [9,1,7,9,7,9,7]
输出： 1
 限制：  1 &amp;lt;= nums.length &amp;lt;= 10000 1 &amp;lt;= nums[i] &amp;lt; 231  解题思路 哈希 使用哈希表记录每个数字出现的次数，找到出现次数为 1 的返回即可。
func singleNumber(nums []int) int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ } for num, v := range cnt { if v == 1 { return num } } return 0 } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 56 - I. 数组中数字出现的次数</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-56-i.-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</link>
      <pubDate>Wed, 29 Sep 2021 19:35:15 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-56-i.-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/
难度： 中等
题目描述 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是$O(n)$，空间复杂度是$O(1)$。
示例 1：  输入： nums = [4,1,4,6]
输出： [1,6] 或 [6,1]
 示例 2：  输入： nums = [1,2,10,4,1,4,3,3]
输出： [2,10] 或 [10,2]
 限制：  2 &amp;lt;= nums.length &amp;lt;= 10000  解题思路 异或 + 拆分 将整个数组进行异或操作，得到最后的两个数字的异或值。从其中找出为 1 的位，按照此位将数组中的数字分为两组，则同一对数字必然在同一组，不同的两个数在不同组，对两组分别求异或即可得出结果。
func singleNumbers(nums []int) []int { xor := 0 for _, num := range nums { xor ^= num } bit := 1 for ; xor&amp;amp;bit == 0; bit &amp;lt;&amp;lt;= 1 { } ans0 := 0 ans1 := 0 for _, num := range nums { if num&amp;amp;bit == 0 { ans0 ^= num } else { ans1 ^= num } } return []int{ans0, ans1} } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>Leetcode 437. 路径总和 III</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-437.-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-iii/</link>
      <pubDate>Tue, 28 Sep 2021 14:08:48 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-437.-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-iii/</guid>
      <description>链接： https://leetcode-cn.com/problems/path-sum-iii/
难度： 中等
题目描述 给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。
路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
示例 1：  输入： root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出： 3
解释： 和等于 8 的路径有 3 条，如图所示。
 示例 2：  输入： root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出： 3
 提示：  二叉树的节点个数的范围是 [0,1000] -109 &amp;lt;= Node.val &amp;lt;= 109 -1000 &amp;lt;= targetSum &amp;lt;= 1000  解题思路 深度优先搜索 + 前缀和 采用深度优先搜索，并将从根到当前结点的路径和保存到哈希表中，记录该和出现的数量。
每当到达一个新结点时，查找到该结点的前缀和减去 target 是否存在于路径中，存在将其次数累加进结果中，然后递归的处理子结点，也将查询结果累加进结果中。</description>
    </item>
    
    <item>
      <title>剑指 Offer 55 - II. 平衡二叉树</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-55-ii.-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 28 Sep 2021 13:21:08 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-55-ii.-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>链接： https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/
难度： 简单
题目描述 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
示例 1： 给定二叉树 [3,9,20,null,null,15,7]
 3 / \ 9 20 / \ 15 7 返回 true 。
示例 2： 给定二叉树 [1,2,2,3,3,null,null,4,4]
 1 / \ 2 2 / \ 3 3 / \ 4 4 返回 false 。
限制：  0 &amp;lt;= 树的结点个数 &amp;lt;= 10000  解题思路 深度优先搜索 递归的遍历每个结点的左右子树，当左右子树均为平衡树且左右子树的最大深度差值 ≤ 1 时，返回 true。
func isBalanced(root *TreeNode) bool { var dfs func(root *TreeNode) (int, bool) dfs = func(root *TreeNode) (int, bool) { if root == nil { return 0, true } leftDepth, leftBalance := dfs(root.</description>
    </item>
    
    <item>
      <title>剑指 Offer 55 - I. 二叉树的深度</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-55-i.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Tue, 28 Sep 2021 12:16:07 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-55-i.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/
难度： 简单
题目描述 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
例如：
给定二叉树 [3,9,20,null,null,15,7]，
 3 / \ 9 20 / \ 15 7 返回它的最大深度 3 。
提示：  节点总数 &amp;lt;= 10000  解题思路 深度优先搜索 递归的遍历每个结点的左右子树，获得子树最大深度，+1 后返回，当结点不存在时，树高为空
func maxDepth(root *TreeNode) int { if root == nil { return 0 } depth := maxDepth(root.Left) rDepth := maxDepth(root.Right) if depth &amp;lt; rDepth { depth = rDepth } return depth + 1 } 复杂度  时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\log{N}) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 53 - II. 0～n-1中缺失的数字</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-53-ii.-0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Tue, 28 Sep 2021 11:25:44 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-53-ii.-0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/
难度： 简单
题目描述 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。
示例 1：  输入: [0,1,3]
输出: 2
 示例 2：  输入: [0,1,2,3,4,5,6,7,9]
输出: 8
 提示：  1 &amp;lt;= 数组长度 &amp;lt;= 10000  解题思路 哈希 使用哈希表标识出现过数字，遍历数据，将位于数组中的数字添加到哈希表中，然后在哈希表中寻找没有出现过的数。
func missingNumber(nums []int) int { exist := make(map[int]struct{}) for _, num := range nums { exist[num] = struct{}{} } for i := 0; i &amp;lt; len(nums); i++ { if _, ok := exist[i]; !ok { return i } } return len(nums) } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  顺序查找 由于数组递增，只需要找到与下标不相同的数，返回其下标即可。</description>
    </item>
    
    <item>
      <title>剑指 Offer 32 - III. 从上到下打印二叉树 III</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-iii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/</link>
      <pubDate>Mon, 27 Sep 2021 19:19:06 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-iii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/</guid>
      <description>链接： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/
难度： 简单
题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
例如:
 给定二叉树: [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  返回其层次遍历结果：
 [ [3], [20,9], [15,7] ]  提示：  节点总数 &amp;lt;= 1000  解题思路 层序遍历 使用一个双端队列记录遍历到的结点，初始时根结点入队。
奇偶分离，偶数层从头至尾遍历完当前整层的所有元素，子结点先左后右从队尾入队；奇数层从尾至头遍历整层所有元素，子结点先右后左从队头入队。
每次遍历到的结点值加入到结果队列中，直至队列为空为止。
func levelOrder(root *TreeNode) [][]int { ans := make([][]int, 0) if root == nil { return ans } q := list.New() q.PushBack(root) for q.Len() &amp;gt; 0 { // 先偶数层 	tmp := make([]int, 0, 1) for i := q.</description>
    </item>
    
    <item>
      <title>剑指 Offer 32 - II. 从上到下打印二叉树 II</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-ii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/</link>
      <pubDate>Mon, 27 Sep 2021 19:05:28 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-ii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/
难度： 简单
题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
例如:
 给定二叉树: [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  返回其层次遍历结果：
 [ [3], [9,20], [15,7] ]  提示：  节点总数 &amp;lt;= 1000  解题思路 层序遍历 使用一个队列记录遍历到的结点，初始时根结点入队，每次从头至尾遍历完当前整层的所有元素，并加入到结果队列，按顺序依次将左右非空子结点入队，直到队列为空。
func levelOrder(root *TreeNode) [][]int { ans := make([][]int, 0) if root == nil { return ans } q := list.New() q.PushBack(root) for q.Len() &amp;gt; 0 { ans = append(ans, make([]int, 0, 1)) for i := q.</description>
    </item>
    
    <item>
      <title>剑指 Offer 32 - I. 从上到下打印二叉树</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-i.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 27 Sep 2021 18:48:47 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-i.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>链接： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/
难度： 中等
题目描述 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
例如:
给定二叉树: [3,9,20,null,null,15,7],
  3 / \ 9 20 / \ 15 7  返回：
 [3,9,20,15,7]
 提示：  节点总数 &amp;lt;= 1000  解题思路 层序遍历 使用一个队列记录遍历到的结点，初始时根结点入队，每次从队头取出一个结点，将其值加入到结果队列，并按顺序将左右非空子结点入队，直到队列为空。
func levelOrder(root *TreeNode) []int { ans := make([]int, 0) if root == nil { return ans } q := list.New() q.PushBack(root) for q.Len() &amp;gt; 0 { node := q.Front().Value.(*TreeNode) q.Remove(q.Front()) ans = append(ans, node.Val) if node.Left !</description>
    </item>
    
    <item>
      <title>剑指 Offer 14- II. 剪绳子 II</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii/</link>
      <pubDate>Mon, 27 Sep 2021 17:54:22 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/
难度： 中等
题目描述 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：  输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
 示例 2：  输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
 提示：  2 &amp;lt;= n &amp;lt;= 1000  解题思路 动态规划 使用 dp[i] 表示绳子长度为 i 时的最大乘积。则：</description>
    </item>
    
    <item>
      <title>剑指 Offer 14- I. 剪绳子</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90/</link>
      <pubDate>Mon, 27 Sep 2021 17:22:32 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90/</guid>
      <description>链接： https://leetcode-cn.com/problems/jian-sheng-zi-lcof/
难度： 中等
题目描述 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
示例 1：  输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
 示例 2：  输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
 提示：  2 &amp;lt;= n &amp;lt;= 58  解题思路 动态规划 使用 dp[i] 表示绳子长度为 i 时的最大乘积。则：</description>
    </item>
    
    <item>
      <title>Leetcode 371. 两整数之和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-371.-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Sun, 26 Sep 2021 09:38:03 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-371.-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/sum-of-two-integers/
难度： 中等
题目描述  给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。  示例 1：  输入： a = 1, b = 2
输出： 3
 示例 2：  输入： a = 2, b = 3
输出： 5
 提示：  -1000 &amp;lt;= a, b &amp;lt;= 1000  解题思路 位运算 以二进制位为单位进行运算，从最低位开始，使用位操作符诸位运算。
由于负数在计算机中存储的是补码，直接诸位求和即可，用 c 表示进位，利用 数字电路设计 得到计算方法如下：
 当前位计算结果为：$a\oplus b\oplus c$ 进位的计算结果为：$(a\oplus b)c + ab$  func getSum(a int, b int) int { c := 0 ans := 0 for bit := 1; bit !</description>
    </item>
    
    <item>
      <title>Leetcode 583. 两个字符串的删除操作</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-583.-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sat, 25 Sep 2021 10:46:36 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-583.-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/</guid>
      <description>链接： https://leetcode-cn.com/problems/delete-operation-for-two-strings/
难度： 中等
题目描述 给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。
示例：  输入: &amp;ldquo;sea&amp;rdquo;, &amp;ldquo;eat&amp;rdquo;
输出: 2
解释: 第一步将&amp;quot;sea&amp;quot;变为&amp;quot;ea&amp;quot;，第二步将&amp;quot;eat&amp;quot;变为&amp;quot;ea&amp;quot;
 提示：  给定单词的长度不超过500。 给定单词中的字符只含有小写字母。  **进阶：**你可以设计一个时间复杂度为 $O(n)$ 的解决方案吗？
解题思路 动态规划 最长公共子序列(LCS)的变种，求得最长公共子序列的长度，返回剩余字符的数量。
使用 dp[i][j] 表示分别以 i 和 j 为 word1 和 word2 前缀长度的最长公共子序列，其状态转移方程如下：
 初始时，dp[0][j] = dp[i][0] = 0 当 word1[i] = word2[j] 时，dp[i][j] = dp[i-1][j-1] + 1；否则，dp[i][j] = max(dp[i-1][j], dp[i][j-1])  func minDistance(word1 string, word2 string) int { dp := make([][]int, len(word1)+1) dp[0] = make([]int, len(word2)+1) for i := range word1 { dp[i+1] = make([]int, len(word2)+1) for j := range word2 { if word1[i] == word2[j] { dp[i+1][j+1] = dp[i][j] + 1 continue } dp[i+1][j+1] = dp[i+1][j] if dp[i+1][j+1] &amp;lt; dp[i][j+1] { dp[i+1][j+1] = dp[i][j+1] } } } return len(word1) + len(word2) - (dp[len(word1)][len(word2)] &amp;lt;&amp;lt; 1) } 复杂度  时间复杂度：$ O(NM), N = len(word1), M = len(word2) $ 空间复杂度：$ O(NM) $  动态规划 使用 dp[i][j] 表示分别以 i 和 j 为 word1 和 word2 前缀结尾的最少删除操作次数，其状态转移方程如下：</description>
    </item>
    
    <item>
      <title>Leetcode 430. 扁平化多级双向链表</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-430.-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 24 Sep 2021 10:35:19 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-430.-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/
难度： 中等
题目描述 多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。
给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。
示例1：  输入： head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
输出： [1,2,3,7,8,11,12,9,10,4,5,6]
解释：
输入的多级列表如下图所示：
扁平化后的链表如下图：
 示例 2：  输入： head = [1,2,null,3]
输出： [1,3,2]
解释：
输入的多级列表如下图所示：
 1---2---NULL | 3---NULL  示例 3：  输入： head = []
输出： []
 如何表示测试用例中的多级链表？ 以 示例 1 为例：
 1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULL 序列化其中的每一级之后：
[1,2,3,4,5,6,null] [7,8,9,10,null] [11,12,null] 为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。
[1,2,3,4,5,6,null] [null,null,7,8,9,10,null] [null,11,12,null] 合并所有序列化结果，并去除末尾的 null 。
[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] 提示：  节点数目不超过 1000 1 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title>Leetcode 326. 3的幂</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-326.-3%E7%9A%84%E5%B9%82/</link>
      <pubDate>Thu, 23 Sep 2021 14:50:23 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-326.-3%E7%9A%84%E5%B9%82/</guid>
      <description>链接： https://leetcode-cn.com/problems/power-of-three/
难度： 简单
题目描述 给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。
整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x
示例 1：  输入： n = 27
输出： true
 示例 2：  输入： n = 0
输出： false
 示例 3：  输入： n = 9
输出： true
 示例 4：  输入： n = 45
输出： false
 提示：  -231 &amp;lt;= n &amp;lt;= 231 - 1  解题思路 试除法 当当前数字可以被 3 的整除，则除以 3，知道不能被 3 整除为止。</description>
    </item>
    
    <item>
      <title>剑指 Offer 60. n个骰子的点数</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-60.-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</link>
      <pubDate>Wed, 22 Sep 2021 20:29:42 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-60.-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/
难度： 中等
题目描述 把 n 个骰子扔在地上，所有骰子朝上一面的点数之和为 s。输入 n，打印出 s 的所有可能的值出现的概率。
你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。
示例 1：  输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
 示例 2：  输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
 限制：  1 &amp;lt;= n &amp;lt;= 11  解题思路 动态规划 由于每个骰子的掷出的点数是独立的，使用 dp[i][j] 表示掷出 i 个骰子，点数之和为 j 的概率：
 初始，dp[0][0] = 1 后续，dp[i][j] = d[i-1][j-1] / 6 + dp[i-1][j-2] / 6 + ... + dp[i-1][j-6] / 6  使用滚动数组的方式降低空间复杂度。</description>
    </item>
    
    <item>
      <title>剑指 Offer 57. 和为s的两个数字</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-57.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</link>
      <pubDate>Wed, 22 Sep 2021 19:39:43 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-57.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/
难度： 简单
题目描述 输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。
示例 1：  输入： nums = [2,7,11,15], target = 9
输出： [2,7] 或者 [7,2]
 示例 2：  输入： nums = [10,26,30,31,47,60], target = 40
输出： [10,30] 或者 [30,10]
 限制：  1 &amp;lt;= nums.length &amp;lt;= 105 1 &amp;lt;= nums[i] &amp;lt;= 106  解题思路 哈希 使用哈希表记录每个数字是否出现过，遍历数组，计算对应的另一个数，若已出现过则返回这两个数。
func twoSum(nums []int, target int) []int { hash := make(map[int]struct{}) for _, num := range nums { if _, ok := hash[target-num]; ok { return []int{num, target - num} } hash[num] = struct{}{} } return make([]int, 0) } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  双指针 使用两个指针 i, j 从头尾分别向中间遍历：</description>
    </item>
    
    <item>
      <title>剑指 Offer 54. 二叉搜索树的第k大节点</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-54.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 22 Sep 2021 18:54:53 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-54.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/
难度： 简单
题目描述 给定一棵二叉搜索树，请找出其中第k大的节点。
示例 1：  输入: root = [3,1,4,null,2], k = 1
 3 / \ 1 4 \ 2 输出: 4
 示例 2：  输入: root = [5,3,6,2,4,null,null,1], k = 3
 5 / \ 3 6 / \ 2 4 / 1 输出: 4
 限制：  1 ≤ k ≤ 二叉搜索树元素个数  解题思路 中序遍历 二叉搜索树的中序遍历结果是有序的，可以先遍历右子树，这样遍历的结果是倒序的。
使用 cnt 记录当前遍历到的节点数量，每次遍历到结点时，其值加一。当 cnt 等于 k 时，记录此值，并通知上方已找到，提前返回。</description>
    </item>
    
    <item>
      <title>Leetcode 725. 分隔链表</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-725.-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 22 Sep 2021 14:11:15 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-725.-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/split-linked-list-in-parts/
难度： 中等
题目描述 给你一个头结点为 head 的单链表和一个整数 k ，请你设计一个算法将链表分隔为 k 个连续的部分。
每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。
这 k 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。
返回一个由上述 k 部分组成的数组。
示例 1：  输入： head = [1,2,3], k = 5
输出： [[1],[2],[3],[],[]]
解释：
第一个元素 output[0] 为 output[0].val = 1 ，output[0].next = null 。
最后一个元素 output[4] 为 null ，但它作为 ListNode 的字符串表示是 [] 。
 示例 2：  输入： head = [1,2,3,4,5,6,7,8,9,10], k = 3
输出： [[1,2,3,4],[5,6,7],[8,9,10]]
解释：
输入被分成了几个连续的部分，并且每部分的长度相差不超过 1 。前面部分的长度大于等于后面部分的长度。</description>
    </item>
    
    <item>
      <title>剑指 Offer 50. 第一个只出现一次的字符</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</link>
      <pubDate>Tue, 21 Sep 2021 23:36:33 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</guid>
      <description>链接： https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/
难度： 简单
题目描述 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。
示例 1：  输入： s = &amp;ldquo;abaccdeff&amp;rdquo;
输出： &amp;lsquo;b&amp;rsquo;
 示例 2：  输入： s = &amp;quot;&amp;quot;
输出： &#39; &#39;
 限制：  0 &amp;lt;= s 的长度 &amp;lt;= 50000  解题思路 哈希 + 两次遍历 第一次遍历，使用哈希表记录每个字符是否重复出现；第二次遍历，返回找到的第一个不重复的字符，找不到返回 &#39; &#39;。
func firstUniqChar(s string) byte { repeat := make(map[byte]bool) for i := range s { _, ok := repeat[s[i]] if !ok { repeat[s[i]] = false } else { repeat[s[i]] = true } } for i := range s { if !</description>
    </item>
    
    <item>
      <title>Leetcode 58. 最后一个单词的长度</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-58.-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Tue, 21 Sep 2021 22:30:53 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-58.-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</guid>
      <description>链接： https://leetcode-cn.com/problems/length-of-last-word/
难度： 简单
题目描述 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。
单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。
示例 1：  输入： s = &amp;ldquo;Hello World&amp;rdquo;
输出： 5
 示例 2：  输入： s = &amp;quot; fly me to the moon &amp;quot;
输出： 4
 示例 3：  输入： s = &amp;ldquo;luffy is still joyboy&amp;rdquo;
输出： 6
 提示：  1 &amp;lt;= s.length &amp;lt;= 104 s 仅有英文字母和空格 &#39; &#39; 组成 s 中至少存在一个单词  解题思路 倒序遍历 从尾到头倒序遍历，当字符为 &#39; &#39; 时，若长度为 0 ，说明是尾部空格，继续遍历；否则说明尾部单词遍历完毕，返回长度。</description>
    </item>
    
    <item>
      <title>剑指 Offer 49. 丑数</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-49.-%E4%B8%91%E6%95%B0/</link>
      <pubDate>Tue, 21 Sep 2021 17:50:14 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-49.-%E4%B8%91%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/chou-shu-lcof/
难度： 中等
题目描述 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。
示例：  输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
 说明：  1 是丑数。 n 不超过 1690。  解题思路 堆 + 哈希 维护一个小顶堆和哈希表，初始堆中元素为 1，每次弹出堆顶最小元素，然后将其分别乘以 2、3、5加入堆中，此处需要使用哈希表去重。
弹出的第 n 个数即为第 n 个丑数。
type MinHeap struct { sort.IntSlice } func (this *MinHeap) Push(x interface{}) { this.IntSlice = append(this.</description>
    </item>
    
    <item>
      <title>剑指 Offer 48. 最长不含重复字符的子字符串</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 21 Sep 2021 16:18:26 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/
难度： 中等
题目描述 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。
示例 1：  输入: &amp;ldquo;abcabcbb&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;ldquo;abc&amp;rdquo;，所以其长度为 3。
 示例 2：  输入: &amp;ldquo;bbbbb&amp;rdquo;
输出: 1
解释: 因为无重复字符的最长子串是 &amp;ldquo;b&amp;rdquo;，所以其长度为 1。
 示例 3：  输入: &amp;ldquo;pwwkew&amp;rdquo;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;ldquo;wke&amp;rdquo;，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，&amp;ldquo;pwke&amp;rdquo; 是一个子序列，不是子串。
 提示：  s.length &amp;lt;= 40000  解题思路 哈希 + 双指针 使用哈希表记录每个字符出现过下标，并记录有效数组开始的下标 start：当出现重复字符时，将 start 修正为重复字符出现的下一个下标。
func lengthOfLongestSubstring(s string) int { ans := 0 pos := make(map[byte]int) start := 0 for i := 0; i &amp;lt; len(s); i++ { p, ok := pos[s[i]] if ok &amp;amp;&amp;amp; start &amp;lt;= p { start = p + 1 } pos[s[i]] = i if ans &amp;lt; i-start+1 { ans = i - start + 1 } } return ans } 复杂度  时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 47. 礼物的最大价值</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-47.-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</link>
      <pubDate>Tue, 21 Sep 2021 15:11:53 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-47.-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</guid>
      <description>链接： https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/
难度： 中等
题目描述 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？
示例：  输入:
[ [1,3,1], [1,5,1], [4,2,1] ] 输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
 提示：  0 &amp;lt; grid.length &amp;lt;= 200 0 &amp;lt; grid[0].length &amp;lt;= 200  解题思路 动态规划 使用 dp[i][j] 记录到达位置 (i,j) 的最大值，则其只能从上边或者左边移动到当前位置，故状态转移方程为：
 dp[0][0] = grid[0][0] dp[i][j] = max(dp[i-1][j], dp[i, j-1]) + grid[i][j]  func maxValue(grid [][]int) int { dp := make([][]int, len(grid)) for i := 0; i &amp;lt; len(grid); i++ { dp[i] = make([]int, len(grid[0])) for j := 0; j &amp;lt; len(grid[0]); j++ { if i-1 &amp;gt;= 0 { dp[i][j] = dp[i-1][j] } if j-1 &amp;gt;= 0 &amp;amp;&amp;amp; dp[i][j] &amp;lt; dp[i][j-1] { dp[i][j] = dp[i][j-1] } dp[i][j] += grid[i][j] } } return dp[len(dp)-1][len(dp[0])-1] } 复杂度  时间复杂度：$ O(mn) $ 空间复杂度：$ O(mn) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 46. 把数字翻译成字符串</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 20 Sep 2021 20:51:55 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/
难度： 中等
题目描述 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。
示例：  输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是&amp;quot;bccfi&amp;quot;, &amp;ldquo;bwfi&amp;rdquo;, &amp;ldquo;bczi&amp;rdquo;, &amp;ldquo;mcfi&amp;quot;和&amp;quot;mzi&amp;rdquo;
 提示：  0 &amp;lt;= num &amp;lt; 231  解题思路 动态规划 使用 dp[i] 记录前缀数组可以表示方案的最大值。状态转移方程为：
 初始，dp[0] = 1； 如果，nums[i]nums[i+1] 可以翻译，则 dp[i+1] = dp[i] + dp[i-1]； 否则，dp[i+1] = dp[i]。  func translateNum(num int) int { s := strconv.FormatInt(int64(num), 10) dp := make([]int, len(s)) dp[0] = 1 for i := 0; i &amp;lt; len(s)-1; i++ { dp[i+1] = dp[i] if s[i] !</description>
    </item>
    
    <item>
      <title>剑指 Offer 45. 把数组排成最小的数</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-45.-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</link>
      <pubDate>Mon, 20 Sep 2021 19:50:47 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-45.-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/
难度： 中等
题目描述 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。
示例 1：  输入: [10,2]
输出: &amp;ldquo;102&amp;rdquo;
 示例 2：  输入: [3,30,34,5,9]
输出: &amp;ldquo;3033459&amp;rdquo;
 提示：  0 &amp;lt; nums.length &amp;lt;= 100  说明：  输出结果可能非常大，所以你需要返回一个字符串而不是整数 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0  解题思路 排序 对于两个数 x、y，若 xy &amp;lt; yx，则 x 必然在 y 的前面，证明如下：
 当这两个数相邻，则成立 两数不相邻，不妨设 xzy，则有 xz &amp;lt; zx，zy &amp;lt; yz，需要证明 xzy &amp;lt; yzx  xz &amp;lt; zx =&amp;gt; x * 10^len(x) + z &amp;lt; z * 10^len(z) + x zy &amp;lt; yz =&amp;gt; z * 10^len(z) + y &amp;lt; y * 10^len(y) + z 相加得到 x * 10^len(x) + y &amp;lt; y * 10^len(y) + z，即 xy &amp;lt; yx，所以 xzy &amp;lt; yzx成立。    按照上述方案自定义排序规则排序，之后按顺序拼接起来返回。</description>
    </item>
    
    <item>
      <title>剑指 Offer 44. 数字序列中某一位的数字</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-44.-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 20 Sep 2021 18:23:10 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-44.-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/
难度： 中等
题目描述 数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。
请写一个函数，求任意第n位对应的数字。
示例 1：  输入： n = 3
输出： 3
 示例 2：  输入： n = 11
输出： 0
 限制：  0 &amp;lt;= n &amp;lt; 231  解题思路 模拟 字符串按照数字顺序排列，其按照数字长度为 1、2、3、... 进行排列，可以利用这个规则求得 n 所在的那个数，进而求的该位对应的数字。
排除 0，则相同长度的数字所占的字符串长度为 9*基数*数字长度，（即9=9*1*1、90=9*10*2、900=9*100*3、...），通过覆盖范围的查找确定到 n 对应的数字长度和基数。
之后获取到 n 所在数字的偏移量，并求得该数，之后返回 n 对应位的数字即可。对输入 0 需要验证。
func findNthDigit(n int) int { base := 1 // 基数 10^N 	digit := 1 // 位数 10进制 	// 确定位数 	for ; n &amp;gt; base*9*digit; base, digit = 10*base, digit+1 { n -= base * 9 * digit } offset := (n - 1) / digit // 偏移量 	// 获取指定位数字 	ans := base + offset for i := digit - (n-1)%digit; i &amp;gt; 1; i-- { ans /= 10 } return ans % 10 } 复杂度  时间复杂度：$ O(\log{n}) $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 36. 二叉搜索树与双向链表</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-36.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 20 Sep 2021 17:20:45 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-36.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/
难度： 中等
题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。
为了让您更好地理解问题，以下面的二叉搜索树为例：
我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。
下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。
特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。
解题思路 深度优先搜索 二叉搜索树中序遍历后的结果即为有序的，采用中序遍历的方式搜索二叉树。
维护两个指针 head 和 tail ，分别指向当前遍历到的链表的头和尾。对于当前遍历到的结点，将其 left 指向 tail，同时 tail 的 right 指向当前结点，后 tail 变更为指向当前结点。
完成遍历后，修改头尾指针，使其构成环。
class Solution { public: Node *treeToDoublyList(Node *root) { if (root == nullptr) { return nullptr; } dfs(root); head-&amp;gt;left = tail; tail-&amp;gt;right = head; return head; } private: Node *head, *tail; void dfs(Node *node) { if(node == nullptr) { return; } dfs(node-&amp;gt;left); if (head == nullptr) { head = node; } if (tail == nullptr) { tail = node; } else { tail-&amp;gt;right = node; node-&amp;gt;left = tail; tail = node; } dfs(node-&amp;gt;right); } }; 复杂度  时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\log{N}) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 40. 最小的k个数</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Mon, 20 Sep 2021 16:17:39 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/
难度： 简单
题目描述 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。
示例 1：  输入： arr = [3,2,1], k = 2
输出： [1,2] 或者 [2,1]
 示例 2：  输入： arr = [0,1,2,1], k = 1
输出： [0]
 限制：  0 &amp;lt;= k &amp;lt;= arr.length &amp;lt;= 10000 0 &amp;lt;= arr[i] &amp;lt;= 10000  解题思路 排序 对数组进行排序，返回前 k 个数。
func getLeastNumbers(arr []int, k int) []int { sort.Ints(arr) return arr[:k] } 复杂度  时间复杂度：$ O(N\log{N}), N = len(arr) $ 空间复杂度：$ O(\log{N}) $  堆 使用大顶堆维护最小的 k 个数。遍历数组，当堆不满 k 时，入堆；否则，当前元素小于堆顶元素时，弹出最大元素，当前元素入堆。</description>
    </item>
    
    <item>
      <title>剑指 Offer 39. 数组中出现次数超过一半的数字</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-39.-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 20 Sep 2021 16:00:42 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-39.-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/
难度： 简单
题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
示例：  输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
输出: 2
 提示：  1 &amp;lt;= 数组长度 &amp;lt;= 50000  解题思路 哈希 遍历数组，用哈希表记录每个元素的出现次数，当超过半数时返回。
func majorityElement(nums []int) int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ if cnt[num] &amp;gt; len(nums)/2 { return num } } return 0 } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  排序 对数组排序，位于中间位置对必为多数元素。</description>
    </item>
    
    <item>
      <title>剑指 Offer 35. 复杂链表的复制</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-35.-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Mon, 20 Sep 2021 15:16:13 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-35.-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</guid>
      <description>链接： https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/
难度： 中等
题目描述 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。
示例 1：  输入： head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出： [[7,null],[13,0],[11,4],[10,2],[1,0]]
 示例 2：  输入： head = [[1,1],[2,1]]
输出： [[1,1],[2,1]]
 示例 3：  输入： head = [[3,null],[3,0],[3,null]]
输出： [[3,null],[3,0],[3,null]]
 示例 4:  输入： head = []
输出： []
解释： 给定的链表为空（空指针），因此返回 null
 提示：  -10000 &amp;lt;= Node.val &amp;lt;= 10000 Node.random 为空（null）或指向链表中的节点。 节点数目不超过 1000 。  解题思路 哈希 使用哈希表维护一个旧结点到新结点的映射，依次从前向后遍历链表，并逐一的构造新链表。</description>
    </item>
    
    <item>
      <title>剑指 Offer 34. 二叉树中和为某一值的路径</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-34.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Mon, 20 Sep 2021 14:55:24 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-34.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/
难度： 中等
题目描述 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。
示例： 给定如下二叉树，以及目标和 target = 22，
 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 返回:
[ [5,4,11,2], [5,8,4,5] ] 提示：  节点总数 &amp;lt;= 10000  解题思路 深度优先搜索 从根节点开始进行深度优先搜索，当整条路径上的结点值之和为 target 时，将其拷贝到结果队列中。
func pathSum(root *TreeNode, target int) [][]int { ans := make([][]int, 0) var dfs func(node *TreeNode, path []int, sum int) dfs = func(node *TreeNode, path []int, sum int) { if node == nil { return } path = append(path, node.</description>
    </item>
    
    <item>
      <title>剑指 Offer 33. 二叉搜索树的后序遍历序列</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-33.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 20 Sep 2021 13:56:50 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-33.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/
难度： 中等
题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都 互不相同。
参考以下这颗二叉搜索树：
 5 / \ 2 6 / \ 1 3 示例 1：  输入： [1,6,3,2,5]
输出： false
 示例 2：  输入： [1,3,2,6,5]
输出： true
 提示：  数组长度 &amp;lt;= 1000  解题思路 递归 对于一棵树的后续遍历序列，最后一个元素必然是根，然后向前遍历。根据二叉搜索树的性质，其右边元素一定大于根，而左边元素一定小于根，由此找到首个小于根的元素即为左右子树分界点。
若在左子树序列里存在一个大于根的结点，则返回 false，否则递归处理左右子树。
func verifyPostorder(postorder []int) bool { if len(postorder) &amp;lt;= 2 { return true } root := postorder[len(postorder)-1] split := len(postorder) - 2 for ; split &amp;gt;= 0 &amp;amp;&amp;amp; postorder[split] &amp;gt; root; split-- { } for i := 0; i &amp;lt; split; i++ { if postorder[i] &amp;gt; root { return false } } return verifyPostorder(postorder[:split+1]) &amp;amp;&amp;amp; verifyPostorder(postorder[split+1:len(postorder)-1]) } 复杂度  时间复杂度：$ O(N\log{N}), N = len(postorder) $ 空间复杂度：$ O(\log{N}) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 31. 栈的压入、弹出序列</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-31.-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 20 Sep 2021 13:01:33 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-31.-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/
难度： 中等
题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字 均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。
示例 1：  输入： pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出： true
解释： 我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -&amp;gt; 4,
push(5), pop() -&amp;gt; 5, pop() -&amp;gt; 3, pop() -&amp;gt; 2, pop() -&amp;gt; 1
 示例 2：  输入： pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出： false
解释： 1 不能在 2 之前弹出。
 提示：  0 &amp;lt;= pushed.</description>
    </item>
    
    <item>
      <title>剑指 Offer 30. 包含min函数的栈</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-30.-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</link>
      <pubDate>Mon, 20 Sep 2021 12:29:44 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-30.-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</guid>
      <description>链接： https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/
难度： 简单
题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 $O(1)$。
示例：  MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min(); &amp;ndash;&amp;gt; 返回 -3.
minStack.pop();
minStack.top(); &amp;ndash;&amp;gt; 返回 0.
minStack.min(); &amp;ndash;&amp;gt; 返回 -2.
 提示：  各函数的调用总次数不超过 20000 次  解题思路 双栈 当最小元素入栈后，后续压入的所有大于最小元素的元素，均不会影响 min 的值，除非压入更小的元素。同理，需要弹出最小元素，min 的值才会改变。故使用另一个栈 B 记录可能使得 min 改变的所有元素值。
 当一个元素入栈时，压入栈 A ，若此元素不大于栈 B 栈顶元素或栈 B 为空，同时需要压入栈 B； 当出栈时，弹出栈 A 栈顶元素，若该元素与栈 B 栈顶元素相同，栈 B 栈顶元素也弹出。  type MinStack struct { stack *list.</description>
    </item>
    
    <item>
      <title>剑指 Offer 29. 顺时针打印矩阵</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-29.-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Mon, 20 Sep 2021 11:07:24 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-29.-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</guid>
      <description>链接： https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/
难度： 简单
题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
示例 1：  输入： matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出： [1,2,3,6,9,8,7,4,5]
 示例 2：  输入： matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出： [1,2,3,4,8,12,11,10,9,5,6,7]
 限制：  0 &amp;lt;= matrix.length &amp;lt;= 100 0 &amp;lt;= matrix[i].length &amp;lt;= 100  解题思路 模拟 从 (0,0) 开始，按照 右 &amp;gt; 下 &amp;gt; 左 &amp;gt; 上 &amp;gt; 右 的顺序遍历，当下一步要超出范围时或已访问过时，变换遍历方向。
func spiralOrder(matrix [][]int) []int { if len(matrix) == 0 { return make([]int, 0) } visit := make([][]bool, len(matrix)) for i := range matrix { visit[i] = make([]bool, len(matrix[i])) } ans := make([]int, 0, len(matrix)*len(matrix[0])) directions := [4][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}} for i, j, direction := 0, 0, 0; len(ans) &amp;lt; cap(ans); i, j = i+directions[direction][0], j+directions[direction][1] { ans = append(ans, matrix[i][j]) visit[i][j] = true // 遍历方向修正 	nextI, nextJ := i+directions[direction][0], j+directions[direction][1] if nextI &amp;lt; 0 || nextI &amp;gt;= len(matrix) || nextJ &amp;lt; 0 || nextJ &amp;gt;= len(matrix[0]) || visit[nextI][nextJ] { direction = (direction + 1) % len(directions) } } return ans } 复杂度  时间复杂度：$ O(NM), N = len(matrix), M = len(N = len(matrix[i])) $ 空间复杂度：$ O(NM) $  层序遍历 将矩阵分解为一个个的环，每次只顺时针遍历环即可。</description>
    </item>
    
    <item>
      <title>剑指 Offer 28. 对称的二叉树</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-28.-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 19 Sep 2021 20:37:47 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-28.-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>链接： https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/
难度： 简单
题目描述 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
 1 / \ 2 2 / \ / \ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
 1 / \ 2 2 \ \ 3 3 示例 1：  输入： root = [1,2,2,3,4,4,3]
输出： true
 示例 2：  输入： root = [1,2,2,null,3,null,3]
输出： false
 限制：  0 &amp;lt;= 节点个数 &amp;lt;= 1000  解题思路 递归 递归遍历比较互为镜像的两个结点，不同则返回 false，相同则继续遍历比较子结点。
因为是镜像比较，所以左子树的左结点和右子树的右结点比较，而左子树的右结点和右子树的左结点比较。
func isSymmetric(root *TreeNode) bool { if root == nil { return true } var same func(node1, node2 *TreeNode) bool same = func(node1, node2 *TreeNode) bool { if node1 == nil &amp;amp;&amp;amp; node2 == nil { return true } if node1 == nil || node2 == nil || node1.</description>
    </item>
    
    <item>
      <title>剑指 Offer 27. 二叉树的镜像</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-27.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link>
      <pubDate>Sun, 19 Sep 2021 20:27:58 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-27.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/
难度： 简单
题目描述 请完成一个函数，输入一个二叉树，该函数输出它的镜像。
例如输入：
 4 / \ 2 7 / \ / \ 1 3 6 9 镜像输出：
 4 / \ 7 2 / \ / \ 9 6 3 1 示例：  输入： root = [4,2,7,1,3,6,9]
输出： [4,7,2,9,6,3,1]
 限制：  0 &amp;lt;= 节点个数 &amp;lt;= 1000  解题思路 递归 递归遍历所有的结点，交换左右子树。
func mirrorTree(root *TreeNode) *TreeNode { if root == nil { return nil } root.Left, root.</description>
    </item>
    
    <item>
      <title>剑指 Offer 26. 树的子结构</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-26.-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 19 Sep 2021 19:37:13 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-26.-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/
难度： 中等
题目描述 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
B是A的子结构， 即 A中有出现和B相同的结构和节点值。
例如: 给定的树 A:
 3 / \ 4 5 / \ 1 2 给定的树 B：
 4 / 1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
示例 1：  输入： A = [1,2,3], B = [3,1]
输出： false
 示例 2：  输入： A = [3,4,5,1,2], B = [4,1]
输出： true
 限制：  0 &amp;lt;= 节点个数 &amp;lt;= 10000  解题思路 深度优先搜索 在树 A 上进行 深度优先搜索（先序遍历），当子树根结点与 B 相同时，仍采用 深度优先搜索 的方式比较结构是否相同。</description>
    </item>
    
    <item>
      <title>剑指 Offer 25. 合并两个排序的链表</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-25.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 19 Sep 2021 19:23:38 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-25.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/
难度： 简单
题目描述 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的
示例：  输入： 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
输出： 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4
 限制：  0 &amp;lt;= 链表长度 &amp;lt;= 1000  解题思路 迭代 由于两个链表都是排好序的，所以每次只需要比较两个链表头，选择小的加入到结果队列即可。
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { ans := new(ListNode) for node := ans; l1 != nil || l2 != nil; node = node.Next { if l1 == nil { node.Next = l2 break } if l2 == nil { node.Next = l1 break } if l1.</description>
    </item>
    
    <item>
      <title>剑指 Offer 24. 反转链表</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-24.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 19 Sep 2021 18:31:45 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-24.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/
难度： 简单
题目描述 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。
示例：  输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL
输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL
 说明：  0 &amp;lt;= nums.length &amp;lt;= 50000 1 &amp;lt;= nums[i] &amp;lt;= 10000  解题思路 递归 利用调用栈记录上一个结点的信息，每次现将后续链表反转，得到反转链表的头部，然后通过当前结点的 Next 指针将当前节点添加到反转链表的尾部，注意还需要将当前节点的 Next 指针置空。
func reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } newHead := reverseList(head.Next) head.Next.Next = head head.Next = nil return newHead } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  双指针 链表是单向的，无法访问到上一个节点，所以使用两个指针 last 和 cur 记录当前结点和上一个结点。</description>
    </item>
    
    <item>
      <title>剑指 Offer 21. 调整数组顺序使奇数位于偶数前面</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-21.-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</link>
      <pubDate>Sun, 19 Sep 2021 18:13:45 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-21.-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</guid>
      <description>链接： https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/
难度： 简单
题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。
示例：  输入： nums = [1,2,3,4]
输出： [1,3,2,4]
注： [3,1,2,4] 也是正确的答案之一。
 说明：  0 &amp;lt;= nums.length &amp;lt;= 50000 1 &amp;lt;= nums[i] &amp;lt;= 10000  解题思路 双指针 使用两个指针 i 和 j 分别指向下一个奇数待插入的位置和当前遍历到的位置，一次遍历，遇到奇数时，i 、 j 指向的两个元素互换。
func exchange(nums []int) []int { for i, j := 0, 0; j &amp;lt; len(nums); j++ { if nums[j]&amp;amp;1 == 1 { nums[i], nums[j] = nums[j], nums[i] i++ } } return nums } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 20. 表示数值的字符串</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-20.-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sun, 19 Sep 2021 16:21:04 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-20.-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/
难度： 中等
题目描述 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。
数值（按顺序）可以分成以下几个部分：
 若干空格 一个 小数 或者 整数 （可选）一个 &#39;e&#39; 或 &#39;E&#39; ，后面跟着一个 整数 若干空格  小数（按顺序）可以分成以下几个部分：
 （可选）一个符号字符（&#39;+&#39; 或 &#39;-&#39;） 下述格式之一：  至少一位数字，后面跟着一个点 &#39;.&#39; 至少一位数字，后面跟着一个点 &#39;.&#39; ，后面再跟着至少一位数字 一个点 &#39;.&#39; ，后面跟着至少一位数字    整数（按顺序）可以分成以下几个部分：
 （可选）一个符号字符（&#39;+&#39; 或 &#39;-&#39;） 至少一位数字  部分数值列举如下：
 [&amp;quot;+100&amp;quot;, &amp;quot;5e2&amp;quot;, &amp;quot;-123&amp;quot;, &amp;quot;3.1416&amp;quot;, &amp;quot;-1E-16&amp;quot;, &amp;quot;0123&amp;quot;]  部分非数值列举如下：
 [&amp;quot;12e&amp;quot;, &amp;quot;1a3.14&amp;quot;, &amp;quot;1.2.3&amp;quot;, &amp;quot;+-5&amp;quot;, &amp;quot;12e+5.4&amp;quot;]  示例 1：  输入： s = &amp;ldquo;0&amp;rdquo;</description>
    </item>
    
    <item>
      <title>剑指 Offer 18. 删除链表的节点</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-18.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Sun, 19 Sep 2021 15:56:41 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-18.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/
难度： 简单
题目描述 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
返回删除后的链表的头节点。
注意： 此题对比原题有改动
示例 1：  输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 1 -&amp;gt; 9.
 示例 2：  输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&amp;gt; 5 -&amp;gt; 9.
 说明：  题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点  解题思路 顺序遍历 + 二级指针 顺序遍历该链表，当遇到目标结点时，将指向该节点的指针指向下一个结点。</description>
    </item>
    
    <item>
      <title>剑指 Offer 17. 打印从1到最大的n位数</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-17.-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Sun, 19 Sep 2021 15:44:19 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-17.-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/
难度： 简单
题目描述 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。
示例：  输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
 说明：  用返回一个整数列表来代替打印 n 为正整数  解题思路  求得上限 max，其值为 10n，然后将 [1,max) 之间的所有数依次按顺序添加到返回队列即可。
func printNumbers(n int) []int { max := 1 for ; n &amp;gt; 0; n-- { max *= 10 } ans := make([]int, 0, max) for i := 1; i &amp;lt; max; i++ { ans = append(ans, i) } return ans } 复杂度  时间复杂度：$ O(10^n) $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 16. 数值的整数次方</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</link>
      <pubDate>Sun, 19 Sep 2021 15:13:54 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/
难度： 中等
题目描述 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。
示例 1：  输入： x = 2.00000, n = 10
输出： 1024.00000
 示例 2：  输入： x = 2.10000, n = 3
输出： 9.26100
 示例 3：  输入： x = 2.00000, n = -2
输出： 0.25000
解释： 2-2 = 1/22 = 1/4 = 0.25
 提示：  -100.0 &amp;lt; x &amp;lt; 100.0 -231 &amp;lt;= n &amp;lt;= 231-1 -104 &amp;lt;= xn &amp;lt;= 104  解题思路 快速幂 $$ x^n = a_1x^1 * a_2x^2 * a_3x^4 * a_4x^8 * &amp;hellip; , 其中a_i\in(0,1) $$ 可以看出，$ a_i $ 就是 n 的二进制表示形式，而对应项的幂计算可由上一项乘自身求得，故可以依次枚举二进制的每一位，类乘求的结果。</description>
    </item>
    
    <item>
      <title>剑指 Offer 13. 机器人的运动范围</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</link>
      <pubDate>Sun, 19 Sep 2021 14:29:35 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</guid>
      <description>链接： https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/
难度： 中等
题目描述 地上有一个 m 行 n 列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0,0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
示例 1：  输入： m = 2, n = 3, k = 1
输出： 3
 示例 2：  输入： m = 3, n = 1, k = 0
输出： 1
 提示：  1 &amp;lt;= n,m &amp;lt;= 100 0 &amp;lt;= k &amp;lt;= 20  解题思路 深度优先搜索 从 [0,0] 开始进行深度优先搜索，当针对 k 进行剪枝时，整个矩阵是关于 (i,i) 对称的，所以可以限制搜索方向为右和下。</description>
    </item>
    
    <item>
      <title>Leetcode 650. 只有两个键的键盘</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-650.-%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/</link>
      <pubDate>Sun, 19 Sep 2021 12:56:28 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-650.-%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/</guid>
      <description>链接： https://leetcode-cn.com/problems/2-keys-keyboard/
难度： 中等
题目描述 最初记事本上只有一个字符 &#39;A&#39; 。你每次可以对这个记事本进行两种操作：
 Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。 Paste（粘贴）：粘贴 上一次 复制的字符。  给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 &#39;A&#39; 。返回能够打印出 n 个 &#39;A&#39; 的最少操作次数。
示例 1：  输入： 3
输出： 3
解释：
最初, 只有一个字符 &amp;lsquo;A&amp;rsquo;。
第 1 步, 使用 Copy All 操作。
第 2 步, 使用 Paste 操作来获得 &amp;lsquo;AA&amp;rsquo;。
第 3 步, 使用 Paste 操作来获得 &amp;lsquo;AAA&amp;rsquo;。
 示例 2：  输入： n = 1
输出： 0
 提示：  1 &amp;lt;= n &amp;lt;= 1000  解题思路 动态规划 为使得每次复制粘贴后的操作总次数最小，则对于复制的子字符串，也要求其操作次数最小，故可以用动态规划求解。</description>
    </item>
    
    <item>
      <title>剑指 Offer 12. 矩阵中的路径</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sat, 18 Sep 2021 17:25:16 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/
难度： 中等
题目描述 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。
单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
例如，在下面的 3×4 的矩阵中包含单词 &amp;ldquo;ABCCED&amp;rdquo;（单词中的字母已标出）。
示例 1：  输入： board = [[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;B&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;E&amp;rdquo;],[&amp;ldquo;S&amp;rdquo;,&amp;ldquo;F&amp;rdquo;,&amp;ldquo;C&amp;rdquo;,&amp;ldquo;S&amp;rdquo;],[&amp;ldquo;A&amp;rdquo;,&amp;ldquo;D&amp;rdquo;,&amp;ldquo;E&amp;rdquo;,&amp;ldquo;E&amp;rdquo;]], word = &amp;ldquo;ABCCED&amp;rdquo;
输出： true
 示例 2：  输入： board = [[&amp;ldquo;a&amp;rdquo;,&amp;ldquo;b&amp;rdquo;],[&amp;ldquo;c&amp;rdquo;,&amp;ldquo;d&amp;rdquo;]], word = &amp;ldquo;abcd&amp;rdquo;
输出： false
 提示：  1 &amp;lt;= board.length &amp;lt;= 200 1 &amp;lt;= board[i].length &amp;lt;= 200 board 和 word 仅由大小写英文字母组成  解题思路 深度优先搜索 遍历整个矩阵，从每个字符开始进行深度优先搜索，当无法找到下一个字符时，及时剪枝。</description>
    </item>
    
    <item>
      <title>Leetcode 292. Nim 游戏</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-292.-nim-%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Sat, 18 Sep 2021 16:47:38 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-292.-nim-%E6%B8%B8%E6%88%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/nim-game/
难度： 简单
题目描述 你和你的朋友，两个人一起玩 Nim 游戏：
 桌子上有一堆石头。 你们轮流进行自己的回合，你作为先手。 每一回合，轮到的人拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。  假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。
示例 1：  输入： n = 4
输出： false
解释： 如果堆中有 4 块石头，那么你永远不会赢得比赛；
因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。
 示例 2：  输入： n = 1
输出： true
 示例 3：  输入： n = 2
输出： true
 注意：  1 &amp;lt;= n &amp;lt;= 231 - 1  解题思路 推导 赢家必须要拿到最后1块石头，所以最后一次可以拿1～3块，则拿到第4块的石头的必输。</description>
    </item>
    
    <item>
      <title>剑指 Offer 11. 旋转数组的最小数字</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 17 Sep 2021 17:37:57 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/
难度： 简单
题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1：  输入： [3,4,5,1,2]
输出： 1
 示例 2：  输入： [2,2,2,0,1]
输出： 0
 提示：  1 &amp;lt;= values &amp;lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用  解题思路 遍历 顺序便利，找出最小值。
func minArray(numbers []int) int { min := math.MaxInt32 for _, num := range numbers { if min &amp;gt; num { min = num } } return min } 复杂度  时间复杂度：$ O(N), N = len(numbers) $ 空间复杂度：$ O(1) $  二分查找 对于数组，每次选出中间元素，和区间右端点比较：</description>
    </item>
    
    <item>
      <title>剑指 Offer 09. 用两个栈实现队列</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link>
      <pubDate>Fri, 17 Sep 2021 16:40:45 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/
难度： 简单
题目描述 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
示例 1：  输入：
[&amp;ldquo;CQueue&amp;rdquo;,&amp;ldquo;appendTail&amp;rdquo;,&amp;ldquo;deleteHead&amp;rdquo;,&amp;ldquo;deleteHead&amp;rdquo;]
[[],[3],[],[]]
输出： [null,null,3,-1]
 示例 2：  输入：
[&amp;ldquo;CQueue&amp;rdquo;,&amp;ldquo;deleteHead&amp;rdquo;,&amp;ldquo;appendTail&amp;rdquo;,&amp;ldquo;appendTail&amp;rdquo;,&amp;ldquo;deleteHead&amp;rdquo;,&amp;ldquo;deleteHead&amp;rdquo;]
[[],[],[5],[2],[],[]]
输出： [null,-1,null,null,5,2]
 提示：  1 &amp;lt;= values &amp;lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用  解题思路 出入分离 栈的特点是后进先出。想要取得头部元素，需要将整个栈中元素依次加入另一个栈中，此时，另一个栈中元素的出栈顺序即变成了先进先出。
故使用两个栈，将入栈和出栈的操作分离，分别对应到尾部栈和头部栈：
 当一个元素要入栈时，压入尾部栈； 当要出栈时，从头部栈弹出，若头部栈为空，则将尾部栈所有元素加入到头部栈。  type CQueue struct { frontStack *list.List backStack *list.List } func Constructor() CQueue { return CQueue{ frontStack: list.New(), backStack: list.</description>
    </item>
    
    <item>
      <title>Leetcode 36. 有效的数独</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-36.-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</link>
      <pubDate>Fri, 17 Sep 2021 11:22:25 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-36.-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/</guid>
      <description>链接： https://leetcode-cn.com/problems/valid-sudoku/
难度： 中等
题目描述 请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。
 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）  数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。
注意： 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。
示例 1：  输入： board =
[[&amp;quot;5&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;], ,[&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;], ,[&amp;quot;.&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;], ,[&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;], ,[&amp;quot;4&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;], ,[&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;], ,[&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;], ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;5&amp;quot;], ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;9&amp;quot;]] 输出： true
 示例 2：  输入： board =
[[&amp;quot;8&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;5&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;] ,[&amp;quot;4&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;3&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;1&amp;quot;] ,[&amp;quot;7&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;quot;6&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;5&amp;quot;] ,[&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;8&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;.&amp;quot;,&amp;quot;7&amp;quot;,&amp;quot;9&amp;quot;]] 输出： false
解释： 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。</description>
    </item>
    
    <item>
      <title>剑指 Offer 07. 重建二叉树</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Fri, 17 Sep 2021 10:45:40 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>链接： https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/
难度： 中等
题目描述 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。
假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
示例 1：  输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
 示例 2：  输入: preorder = [-1], inorder = [-1]
输出: [-1]
 提示：  0 &amp;lt;= 链表长度 &amp;lt;= 10000  解题思路 递归 二叉树的先序遍历的顺序是 根&amp;gt;左&amp;gt;右，而中序遍历顺序为 左&amp;gt;根&amp;gt;右。
故先序遍历的第一个结点即为 根结点，然后在中序遍历中找到根节点，其左侧所有元素位于为左子树，右侧所有元素在右子树。
左右子树均按照上述规则，递归地建立二叉树。
func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 { return nil } this := &amp;amp;TreeNode{ Val: preorder[0], } for i, val := range inorder { if val == preorder[0] { this.</description>
    </item>
    
    <item>
      <title>剑指 Offer 06. 从尾到头打印链表</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 16 Sep 2021 22:20:54 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/
难度： 简单
题目描述 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
示例：  输入： head = [1,3,2]
输出： [2,3,1]
 提示：  0 &amp;lt;= 链表长度 &amp;lt;= 10000  解题思路 递归 递归的添加当前节点的元素到子节点返回的数组后面。递归的终止条件为：当前元素不存在，返回空数组。
func reversePrint(head *ListNode) []int { if head == nil { return make([]int, 0) } return append(reversePrint(head.Next), head.Val) } 复杂度  时间复杂度：$ O(N), N = len(list) $ 空间复杂度：$ O(N) $  栈 遍历链表，依次压栈，之后反转栈中元素即可。
func reversePrint(head *ListNode) []int { if head == nil { return make([]int, 0) } return append(reversePrint(head.</description>
    </item>
    
    <item>
      <title>剑指 Offer 05. 替换空格</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</link>
      <pubDate>Thu, 16 Sep 2021 22:15:07 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</guid>
      <description>链接： https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/
难度： 简单
题目描述 请实现一个函数，把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;。
示例：  输入： s = &amp;ldquo;We are happy.&amp;rdquo;
输出： &amp;ldquo;We%20are%20happy.&amp;rdquo;
 提示：  0 &amp;lt;= s 的长度 &amp;lt;= 10000  解题思路 模拟 遍历原字符串，将每个字符加入到结果字符串的末尾，遇到 &#39; &#39; 需替换为 &amp;quot;%20&amp;quot;。
func replaceSpace(s string) string { t := make([]byte, 0, len(s)*3) for i := range s { if s[i] == &amp;#39; &amp;#39; { t = append(t, &amp;#34;%20&amp;#34;...) } else { t = append(t, s[i]) } } return string(t) } 复杂度  时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 04. 二维数组中的查找</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Thu, 16 Sep 2021 19:42:33 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/
难度： 中等
题目描述 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。
示例：  现有矩阵 matrix 如下：
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。
给定 target = 20，返回 false。
 提示：  0 &amp;lt;= n &amp;lt;= 1000 0 &amp;lt;= m &amp;lt;= 1000  解题思路 暴力求解 遍历整个二维数组，寻找该整数。
func findNumberIn2DArray(matrix [][]int, target int) bool { for _, line := range matrix { for _, cell := range line { if cell == target { return true } else if cell &amp;gt; target { break } } } return false } 复杂度  时间复杂度：$ O(nm) $ 空间复杂度：$ O(1) $  阶梯遍历 从矩阵右上角开始遍历：</description>
    </item>
    
    <item>
      <title>剑指 Offer 03. 数组中重复的数字</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Thu, 16 Sep 2021 19:19:47 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/
难度： 简单
题目描述 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
示例：  输入：
[2, 3, 1, 0, 2, 5, 3]
输出： 2 或 3
 提示：  2 &amp;lt;= n &amp;lt;= 100000  解题思路 哈希 使用哈希表记录数组中的元素是否出现过。遍历数组，如果出现过则返回；否则，在哈希表中标记该元素已出现。
func findRepeatNumber(nums []int) int { appear := make(map[int]struct{}) for _, num := range nums { if _, ok := appear[num]; ok { return num } appear[num] = struct{}{} } return 0 } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  </description>
    </item>
    
    <item>
      <title>Leetcode 162. 寻找峰值</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-162.-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</link>
      <pubDate>Wed, 15 Sep 2021 10:11:21 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-162.-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</guid>
      <description>链接： https://leetcode-cn.com/problems/find-peak-element/
难度： 中等
题目描述 峰值元素是指其值严格大于左右相邻值的元素。
给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
你可以假设 nums[-1] = nums[n] = -∞ 。
你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
示例 1：  输入： nums = [1,2,3,1]
输出： 2
解释： 3 是峰值元素，你的函数应该返回其索引 2。
 示例 2：  输入： nums = [1,2,1,3,5,6,4]
输出： 1 或 5
解释： 你的函数可以返回索引 1，其峰值元素为 2；
或者返回索引 5， 其峰值元素为 6。
 提示：  1 &amp;lt;= nums.length &amp;lt;= 1000 -231 &amp;lt;= nums[i] &amp;lt;= 231 - 1 对于所有有效的 i 都有 nums[i] !</description>
    </item>
    
    <item>
      <title>Leetcode 524. 通过删除字母匹配到字典里最长单词</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-524.-%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/</link>
      <pubDate>Tue, 14 Sep 2021 17:03:15 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-524.-%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/</guid>
      <description>链接： https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/
难度： 中等
题目描述 给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。
如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。
示例 1：  输入： s = &amp;ldquo;abpcplea&amp;rdquo;, dictionary = [&amp;ldquo;ale&amp;rdquo;,&amp;ldquo;apple&amp;rdquo;,&amp;ldquo;monkey&amp;rdquo;,&amp;ldquo;plea&amp;rdquo;]
输出： &amp;ldquo;apple&amp;rdquo;
 示例 2：  输入： s = &amp;ldquo;abpcplea&amp;rdquo;, dictionary = [&amp;ldquo;a&amp;rdquo;,&amp;ldquo;b&amp;rdquo;,&amp;ldquo;c&amp;rdquo;]
输出： &amp;ldquo;a&amp;rdquo;
 提示：  1 &amp;lt;= s.length &amp;lt;= 1000 1 &amp;lt;= dictionary.length &amp;lt;= 1000 1 &amp;lt;= dictionary[i].length &amp;lt;= 1000 s 和 dictionary[i] 仅由小写英文字母组成  解题思路 暴力求解 遍历字典，对于符合 s 的子序列的每个元素，记录最大长度的最小元素。
func findLongestWord(s string, dictionary []string) string { contains := func(s, sub string) bool { j := 0 for i := 0; i &amp;lt; len(s) &amp;amp;&amp;amp; j &amp;lt; len(sub); i++ { if s[i] == sub[j] { j++ } } if j == len(sub) { return true } return false } maxLen := 0 ans := &amp;#34;&amp;#34; for _, d := range dictionary { if contains(s, d) { if maxLen &amp;lt; len(d) { maxLen = len(d) ans = d } else if maxLen == len(d) &amp;amp;&amp;amp; ans &amp;gt; d { ans = d } } } return ans } 复杂度  时间复杂度：$ O(N*L), N = len(dictionary), L = max(dictionory[i]) $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>Leetcode 447. 回旋镖的数量</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-447.-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/</link>
      <pubDate>Mon, 13 Sep 2021 10:21:25 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-447.-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/number-of-boomerangs/
难度： 中等
题目描述 给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。
返回平面上所有回旋镖的数量。
示例 1：  输入： points = [[0,0],[1,0],[2,0]]
输出： 2
解释： 两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]
 示例 2：  输入： points = [[1,1],[2,2],[3,3]]
输出： 2
 示例 3：  输入： points = [[1,1]]
输出： 0
 提示：  n == points.</description>
    </item>
    
    <item>
      <title>Leetcode 678. 有效的括号字符串</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-678.-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sun, 12 Sep 2021 23:38:03 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-678.-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/valid-parenthesis-string/
难度： 中等
题目描述 给定一个只包含三种字符的字符串：( ，) 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：
 任何左括号 ( 必须有相应的右括号 )。 任何右括号 ) 必须有相应的左括号 ( 。 左括号 ( 必须在对应的右括号之前 )。 * 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。 一个空字符串也被视为有效字符串。  示例 1：  输入: &amp;ldquo;()&amp;rdquo;
输出: True
 示例 2：  输入: &amp;ldquo;(*)&amp;rdquo;
输出: True
 示例 3：  输入: &amp;ldquo;(*))&amp;rdquo;
输出: True
 注意：  字符串大小将在 [1，100] 范围内。  解题思路 栈 使用栈来进行括号的匹配:
 每当遇到 ( 和 * ，入栈； 当遇到 ) 时，优先从栈中寻找距栈顶最近的 ( ，以完成配对，然后该 ( 从栈中弹出；当不存在 ( 时，使用 * 代替 ( 配对并弹出，都不存在返回 false。  对字符串完成遍历后，栈中仅剩下 ( 和 * ，此时从栈顶开始，配对消除 (，能全部消除，返回 true，否则返回 false。</description>
    </item>
    
    <item>
      <title>Leetcode 1894. 找到需要补充粉笔的学生编号</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1894.-%E6%89%BE%E5%88%B0%E9%9C%80%E8%A6%81%E8%A1%A5%E5%85%85%E7%B2%89%E7%AC%94%E7%9A%84%E5%AD%A6%E7%94%9F%E7%BC%96%E5%8F%B7/</link>
      <pubDate>Fri, 10 Sep 2021 12:10:52 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1894.-%E6%89%BE%E5%88%B0%E9%9C%80%E8%A6%81%E8%A1%A5%E5%85%85%E7%B2%89%E7%AC%94%E7%9A%84%E5%AD%A6%E7%94%9F%E7%BC%96%E5%8F%B7/</guid>
      <description>链接： https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/
难度： 中等
题目描述 一个班级里有 n 个学生，编号为 0 到 n - 1 。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。
给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k 。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗 chalk[i] 支粉笔。如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要 补充 粉笔。
请你返回需要 补充 粉笔的学生 编号 。
示例 1：  输入： chalk = [5,1,5], k = 22
输出： 0
解释： 学生消耗粉笔情况如下：
 编号为 0 的学生使用 5 支粉笔，然后 k = 17 。 编号为 1 的学生使用 1 支粉笔，然后 k = 16 。 编号为 2 的学生使用 5 支粉笔，然后 k = 11 。 编号为 0 的学生使用 5 支粉笔，然后 k = 6 。 编号为 1 的学生使用 1 支粉笔，然后 k = 5 。 编号为 2 的学生使用 5 支粉笔，然后 k = 0 。</description>
    </item>
    
    <item>
      <title>Leetcode 1221. 分割平衡字符串</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1221.-%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Tue, 07 Sep 2021 09:47:34 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1221.-%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/
难度： 简单
题目描述 在一个 平衡字符串 中，&#39;L&#39; 和 &#39;R&#39; 字符的数量是相同的。
给你一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。
**注意：**分割得到的每个字符串都必须是平衡字符串。
返回可以通过分割得到的平衡字符串的 最大数量 。
示例 1：  输入： s = &amp;ldquo;RLRRLLRLRL&amp;rdquo;
输出： 4
解释： s 可以分割为 &amp;ldquo;RL&amp;rdquo;、&amp;ldquo;RRLL&amp;rdquo;、&amp;ldquo;RL&amp;rdquo;、&amp;ldquo;RL&amp;rdquo; ，每个子字符串中都包含相同数量的 &amp;lsquo;L&amp;rsquo; 和 &amp;lsquo;R&amp;rsquo; 。
 示例 2：  输入： s = &amp;ldquo;RLLLLRRRLR&amp;rdquo;
输出： 3
解释： s 可以分割为 &amp;ldquo;RL&amp;rdquo;、&amp;ldquo;LLLRRR&amp;rdquo;、&amp;ldquo;LR&amp;rdquo; ，每个子字符串中都包含相同数量的 &amp;lsquo;L&amp;rsquo; 和 &amp;lsquo;R&amp;rsquo; 。
 示例 3：  输入： s = &amp;ldquo;LLLLRRRR&amp;rdquo;
输出： 1
解释： s 只能保持原样 &amp;ldquo;LLLLRRRR&amp;rdquo;.
 示例 4：  输入： s = &amp;ldquo;RLRRRLLRLL&amp;rdquo;</description>
    </item>
    
    <item>
      <title>Leetcode 704. 二分查找</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-704.-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Mon, 06 Sep 2021 09:41:51 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-704.-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-search/
难度： 简单
题目描述 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
示例 1：  输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
 示例 2：  输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
 提示：  你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000] 之间。 nums 的每个元素都将在 [-9999, 9999] 之间。  解题思路 二分查找 func search(nums []int, target int) int { for l, r := 0, len(nums); l &amp;lt; r; { mid := (l + r) / 2 if target == nums[mid] { return mid } else if target &amp;lt; nums[mid] { r = mid } else { l = mid + 1 } } return -1 } 复杂度  时间复杂度：$ O(\log N), N = len(nums) $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>Leetcode 470. 用 Rand7() 实现 Rand10()</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-470.-%E7%94%A8-rand7-%E5%AE%9E%E7%8E%B0-rand10/</link>
      <pubDate>Sun, 05 Sep 2021 16:27:29 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-470.-%E7%94%A8-rand7-%E5%AE%9E%E7%8E%B0-rand10/</guid>
      <description>链接： https://leetcode-cn.com/problems/implement-rand10-using-rand7/
难度： 中等
题目描述 已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。
不要使用系统的 Math.random() 方法。
示例 1：  输入: 1
输出: [7]
 示例 2：  输入: 2
输出: [8,4]
 示例 3：  输入: 3
输出: [8,1,10]
 提示：  rand7 已定义。 传入参数: n 表示 rand10 的调用次数。  进阶：  rand7() 调用次数的 期望值 是多少 ? 你能否尽量少调用 rand7() ?  解题思路  rand7 函数等概率的生成 1~7 的随机数，为生成 1~10的随机数，需要等概率的生成 10 的倍数个随机数。</description>
    </item>
    
    <item>
      <title>剑指 Offer 10- I. 斐波那契数列</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</link>
      <pubDate>Sat, 04 Sep 2021 08:01:33 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/
难度： 简单
题目描述 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N &amp;gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
示例 1：  输入： n = 2
输出： 1
 示例 2：  输入： n = 5
输出： 5
 提示：  0 &amp;lt;= n &amp;lt;= 100  解题思路 动态规划 动态规划的状态转移方程已在题目中给出，使用三个变量降低空间复杂度。
func fib(n int) int { const MOD = 1e9 + 7 dp := []int{0, 1, 0} if n &amp;lt; 2 { return dp[n] } for i := 2; i &amp;lt;= n; i++ { dp[2] = (dp[0] + dp[1]) % MOD dp[0], dp[1] = dp[1], dp[2] } return dp[2] } 复杂度  时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>面试题 17.14. 最小K个数</title>
      <link>https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.14.-%E6%9C%80%E5%B0%8Fk%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Fri, 03 Sep 2021 11:30:22 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.14.-%E6%9C%80%E5%B0%8Fk%E4%B8%AA%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/smallest-k-lcci/
难度： 中等
题目描述 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。
示例：  输入： arr = [1,3,5,7,2,4,6,8], k = 4
输出： [1,2,3,4]
 提示：  0 &amp;lt;= len(arr) &amp;lt;= 100000 0 &amp;lt;= k &amp;lt;= min(100000, len(arr))  解题思路 排序 对原数组排序，返回前 k 个元素。
func smallestK(arr []int, k int) []int { sort.Ints(arr) return arr[:k] } 复杂度  时间复杂度：$ O(N\log N), N = len(arr) $ 空间复杂度：$ O(\log N) $  堆 构建一个大顶堆，保存前 k 个最小的数。遍历 arr 数组
 当堆中元素数量不足 k 时，入堆； 当堆中元素书数量为 k 时，与堆顶元素比较  当堆顶元素为较大时，弹出队顶元素，当前元素入堆 否则，忽略当前元素    遍历结束，返回堆中所有元素。</description>
    </item>
    
    <item>
      <title>剑指 Offer 22. 链表中倒数第k个节点</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-22.-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</link>
      <pubDate>Thu, 02 Sep 2021 09:29:06 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-22.-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/
难度： 简单
题目描述 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。
例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。
示例：  给定一个链表: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, 和 k = 2.
返回链表 4-&amp;gt;5.
 解题思路 顺序遍历 遍历一边链表，得到其长度 length，则 length - k 即为需要跳过的结点，重新遍历，跳过前 length - k 个结点。
func getKthFromEnd(head *ListNode, k int) *ListNode { length := 0 for node := head; node != nil; node = node.Next { length++ } node := head for i := length - k; i &amp;gt; 0; i-- { node = node.</description>
    </item>
    
    <item>
      <title>Leetcode 1109. 航班预订统计</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1109.-%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/</link>
      <pubDate>Tue, 31 Aug 2021 10:37:40 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1109.-%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/</guid>
      <description>链接： https://leetcode-cn.com/problems/corporate-flight-bookings/
难度： 中等
题目描述 这里有 n 个航班，它们分别从 1 到 n 进行编号。
有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。
请你返回一个长度为 n 的数组 answer，其中 answer[i] 是航班 i 上预订的座位总数。
示例 1：  输入： bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
输出： [10,55,45,25,25]
解释：
航班编号 1 2 3 4 5
预订记录 1 ：10 10
预订记录 2 ： 20 20</description>
    </item>
    
    <item>
      <title>Leetcode 528. 按权重随机选择</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-528.-%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9/</link>
      <pubDate>Mon, 30 Aug 2021 10:33:25 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-528.-%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9/</guid>
      <description>链接： https://leetcode-cn.com/problems/random-pick-with-weight/
难度： 中等
题目描述 给定一个正整数数组 w ，其中 w[i] 代表下标 i 的权重（下标从 0 开始），请写一个函数 pickIndex ，它可以随机地获取下标 i，选取下标 i 的概率与 w[i] 成正比。
例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。
也就是说，选取下标 i 的概率为 w[i] / sum(w) 。
示例 1：  输入：
[&amp;ldquo;Solution&amp;rdquo;,&amp;ldquo;pickIndex&amp;rdquo;]
[[[1]],[]]
输出：
[null,0]
解释：
Solution solution = new Solution([1]);
solution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。</description>
    </item>
    
    <item>
      <title>Leetcode 1588. 所有奇数长度子数组的和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1588.-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/</link>
      <pubDate>Sun, 29 Aug 2021 21:32:29 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1588.-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/
难度： 简单
题目描述 给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。
子数组 定义为原数组中的一个连续子序列。
请你返回 arr 中 所有奇数长度子数组的和 。
示例 1：  输入： arr = [1,4,2,5,3]
输出： 58
解释： 所有奇数长度子数组和它们的和为：
[1] = 1
[4] = 4
[2] = 2
[5] = 5
[3] = 3
[1,4,2] = 7
[4,2,5] = 11
[2,5,3] = 10
[1,4,2,5,3] = 15
我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58</description>
    </item>
    
    <item>
      <title>Leetcode 1480. 一维数组的动态和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1480.-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/</link>
      <pubDate>Sat, 28 Aug 2021 11:05:35 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1480.-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/running-sum-of-1d-array/
难度： 简单
题目描述 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。
请返回 nums 的动态和。
示例 1：  输入： nums = [1,2,3,4]
输出： [1,3,6,10]
解释： 动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。
 示例 2：  输入： nums = [1,1,1,1,1]
输出： [1,2,3,4,5]
解释： 动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。
 示例 3：  输入： nums = [3,1,2,10,1]
输出： [3,4,6,16,17]
 提示：  1 &amp;lt;= nums.length &amp;lt;= 1000 -106 &amp;lt;= nums[i] &amp;lt;= 106  解题思路 模拟 按照题目描述，依次求解动态和的每一项</description>
    </item>
    
    <item>
      <title>Leetcode 881. 救生艇</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-881.-%E6%95%91%E7%94%9F%E8%89%87/</link>
      <pubDate>Thu, 26 Aug 2021 18:56:34 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-881.-%E6%95%91%E7%94%9F%E8%89%87/</guid>
      <description>链接： https://leetcode-cn.com/problems/boats-to-save-people/
难度： 中等
题目描述 第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。
每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。
返回载到每一个人所需的最小船数。(保证每个人都能被船载)。
示例 1：  输入： people = [1,2], limit = 3
输出： 1
解释： 1 艘船载 (1, 2)
 示例 2：  输入： people = [3,2,2,1], limit = 3
输出： 3
解释： 3 艘船分别载 (1, 2), (2) 和 (3)
 示例 3：  输入： people = [3,5,3,4], limit = 5
输出： 4
解释： 4 艘船分别载 (3), (3), (4), (5)</description>
    </item>
    
    <item>
      <title>Leetcode 797. 所有可能的路径</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-797.-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Wed, 25 Aug 2021 22:05:55 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-797.-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/all-paths-from-source-to-target/
难度： 中等
题目描述 给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）
二维数组的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些节点，空就是没有下一个结点了。
译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。
示例 1：  输入： graph = [[1,2],[3],[3],[]]
输出： [[0,1,3],[0,2,3]]
解释： 有两条路径 0 -&amp;gt; 1 -&amp;gt; 3 和 0 -&amp;gt; 2 -&amp;gt; 3
 示例 2：  输入： graph = [[4,3,1],[3,2,4],[3],[4],[]]
输出： [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
 示例 3：  输入： graph = [[1],[]]
输出： [[0,1]]
 示例 4：  输入： graph = [[1,2,3],[2],[3],[]]</description>
    </item>
    
    <item>
      <title>Leetcode 1646. 获取生成数组中的最大值</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1646.-%E8%8E%B7%E5%8F%96%E7%94%9F%E6%88%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</link>
      <pubDate>Mon, 23 Aug 2021 10:49:08 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1646.-%E8%8E%B7%E5%8F%96%E7%94%9F%E6%88%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</guid>
      <description>链接： https://leetcode-cn.com/problems/throne-inheritance/
难度： 简单
题目描述 给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ：
 nums[0] = 0 nums[1] = 1 当 2 &amp;lt;= 2 * i &amp;lt;= n 时，nums[2 * i] = nums[i] 当 2 &amp;lt;= 2 * i + 1 &amp;lt;= n 时，nums[2 * i + 1] = nums[i] + nums[i + 1]  返回生成数组 nums 中的 最大 值。
示例 1：  输入： n = 7
输出： 3</description>
    </item>
    
    <item>
      <title>Leetcode 443. 压缩字符串</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-443.-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Sat, 21 Aug 2021 14:52:12 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-443.-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/string-compression/
难度： 中等
题目描述 给你一个字符数组 chars ，请使用下述算法压缩：
从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：
 如果这一组长度为 1 ，则将字符追加到 s 中。 否则，需要向 s 追加字符，后跟这一组的长度。  压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。
请在 修改完输入数组后 ，返回该数组的新长度。
你必须设计并实现一个只使用常量额外空间的算法来解决此问题。
示例 1：  输入： chars = [&amp;ldquo;a&amp;rdquo;,&amp;ldquo;a&amp;rdquo;,&amp;ldquo;b&amp;rdquo;,&amp;ldquo;b&amp;rdquo;,&amp;ldquo;c&amp;rdquo;,&amp;ldquo;c&amp;rdquo;,&amp;ldquo;c&amp;rdquo;]
输出： 返回 6 ，输入数组的前 6 个字符应该是：[&amp;ldquo;a&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;b&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;c&amp;rdquo;,&amp;ldquo;3&amp;rdquo;]
解释：
&amp;ldquo;aa&amp;rdquo; 被 &amp;ldquo;a2&amp;rdquo; 替代。&amp;ldquo;bb&amp;rdquo; 被 &amp;ldquo;b2&amp;rdquo; 替代。&amp;ldquo;ccc&amp;rdquo; 被 &amp;ldquo;c3&amp;rdquo; 替代。
 示例 2：  输入： chars = [&amp;ldquo;a&amp;rdquo;]</description>
    </item>
    
    <item>
      <title>Leetcode 541. 反转字符串 II</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-541.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-ii/</link>
      <pubDate>Fri, 20 Aug 2021 13:31:40 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-541.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/reverse-string-ii/
难度： 简单
题目描述 给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。
如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
示例 1：  输入： s = &amp;ldquo;abcdefg&amp;rdquo;, k = 2
输出： &amp;ldquo;bacdfeg&amp;rdquo;
 示例 2：  输入： s = &amp;ldquo;abcd&amp;rdquo;, k = 2
输出： &amp;ldquo;bacd&amp;rdquo;
 提示：  1 &amp;lt;= s.length &amp;lt;= 104 s 仅由小写英文组成 1 &amp;lt;= k &amp;lt;= 104  解题思路 模拟 以长度为 2k 为单位将字符串分割，对于每个区间，反转前 k 个字符。</description>
    </item>
    
    <item>
      <title>Leetcode 345. 反转字符串中的元音字母</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-345.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</link>
      <pubDate>Thu, 19 Aug 2021 10:40:59 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-345.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/</guid>
      <description>链接： https://leetcode-cn.com/problems/reverse-vowels-of-a-string/
难度： 简单
题目描述 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。
示例 1：  输入： &amp;ldquo;hello&amp;rdquo;
输出： &amp;ldquo;holle&amp;rdquo;
 示例 2：  输入： &amp;ldquo;leetcode&amp;rdquo;
输出： &amp;ldquo;leotcede&amp;rdquo;
 提示：  元音字母不包含字母 &amp;ldquo;y&amp;rdquo; 。  解题思路 双指针 使用两个指针 i, j 分别从字符串首尾向中间遍历：
 遇到非元音字母向中间靠拢； i, j 两个指针都指向元音字母时，交换两个指针指向的字母并向中靠拢  最终两个指针相遇时停止，元音字母反转完毕。
func reverseVowels(s string) string { t := []byte(s) isVowel := map[byte]bool{ &amp;#39;a&amp;#39;: true, &amp;#39;A&amp;#39;: true, &amp;#39;e&amp;#39;: true, &amp;#39;E&amp;#39;: true, &amp;#39;i&amp;#39;: true, &amp;#39;I&amp;#39;: true, &amp;#39;o&amp;#39;: true, &amp;#39;O&amp;#39;: true, &amp;#39;u&amp;#39;: true, &amp;#39;U&amp;#39;: true, } for i, j := 0, len(s)-1; i &amp;lt; j; { if !</description>
    </item>
    
    <item>
      <title>Leetcode 551. 学生出勤记录 I</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-551.-%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95-i/</link>
      <pubDate>Tue, 17 Aug 2021 10:51:13 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-551.-%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95-i/</guid>
      <description>链接： https://leetcode-cn.com/problems/student-attendance-record-i/
难度： 简单
题目描述   给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：
  &#39;A&#39;：Absent，缺勤
  &#39;L&#39;：Late，迟到
  &#39;P&#39;：Present，到场
  如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：
 按 总出勤 计，学生缺勤（&#39;A&#39;）严格 少于两天。 学生 不会 存在 连续 3 天或 3 天以上的迟到（&#39;L&#39;）记录。  如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。
示例 1：  输入： s = &amp;ldquo;PPALLP&amp;rdquo; 输出： true 解释： 学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。  示例 2：  输入： s = &amp;ldquo;PPALLL&amp;rdquo; 输出： false 解释： 学生最后三天连续迟到，所以不满足出勤奖励的条件。  提示：  1 &amp;lt;= s.</description>
    </item>
    
    <item>
      <title>Leetcode 526. 优美的排列</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-526.-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/</link>
      <pubDate>Mon, 16 Aug 2021 22:54:27 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-526.-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/beautiful-arrangement/
难度： 中等
题目描述 假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 &amp;lt;= i &amp;lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：
 第 i 位的数字能被 i 整除 i 能被第 i 位上的数字整除  现在给定一个整数 N，请问可以构造多少个优美的排列？
示例：  输入: 2
输出: 2
解释:
第 1 个优美的排列是 [1, 2]:
第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除
第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除
第 2 个优美的排列是 [2, 1]:
第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除
第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除
 说明：  N 是一个正整数，并且不会超过 15。  解题思路 回溯 使用一个数组 arr 记录该排列，另使用一个数组 choice 记录每个数字是否已经被填写到 arr 中。</description>
    </item>
    
    <item>
      <title>Leetcode 576. 出界的路径数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-576.-%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/</link>
      <pubDate>Sun, 15 Aug 2021 11:04:33 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-576.-%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/out-of-boundary-paths/
难度： 中等
题目描述 给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。
给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 + 7 取余 后的结果。
示例 1： &amp;lt;img src=&amp;quot;/img/576.out_of_boundary_paths_1.png&amp;quot;, width=&amp;ldquo;500px&amp;rdquo;&amp;gt;
 输入： m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0
输出： 6
 示例 2： &amp;lt;img src=&amp;quot;/img/576.out_of_boundary_paths_2.png&amp;quot;, width=&amp;ldquo;500px&amp;rdquo;&amp;gt;
 输入： m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1</description>
    </item>
    
    <item>
      <title>Leetcode 1583. 统计不开心的朋友</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1583.-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%BC%80%E5%BF%83%E7%9A%84%E6%9C%8B%E5%8F%8B/</link>
      <pubDate>Sat, 14 Aug 2021 10:51:40 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1583.-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%BC%80%E5%BF%83%E7%9A%84%E6%9C%8B%E5%8F%8B/</guid>
      <description>链接： https://leetcode-cn.com/problems/count-unhappy-friends/
难度： 中等
题目描述 给你一份 n 位朋友的亲近程度列表，其中 n 总是 偶数 。
对每位朋友 i，preferences[i] 包含一份 按亲近程度从高到低排列 的朋友列表。换句话说，排在列表前面的朋友与 i 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 0 到 n-1 之间的整数表示。
所有的朋友被分成几对，配对情况以列表 pairs 给出，其中 pairs[i] = [xi, yi] 表示 xi 与 yi 配对，且 yi 与 xi 配对。
但是，这样的配对情况可能会是其中部分朋友感到不开心。在 x 与 y 配对且 u 与 v 配对的情况下，如果同时满足下述两个条件，x 就会不开心：
 x 与 u 的亲近程度胜过 x 与 y，且 u 与 x 的亲近程度胜过 u 与 v  返回 不开心的朋友的数目 。
示例 1：  输入： n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]</description>
    </item>
    
    <item>
      <title>Leetcode 516. 最长回文子序列</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-516.-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Thu, 12 Aug 2021 11:16:23 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-516.-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/longest-palindromic-subsequence/
难度： 中等
题目描述 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。
子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。
示例 1：  输入： s = &amp;ldquo;bbbab&amp;rdquo;
输出： 4
解释： 一个可能的最长回文子序列为 &amp;ldquo;bbbb&amp;rdquo; 。
 示例 2：  输入： s = &amp;ldquo;cbbd&amp;rdquo;
输出： 2
解释： 一个可能的最长回文子序列为 &amp;ldquo;bb&amp;rdquo; 。
 注意：  1 &amp;lt;= s.length &amp;lt;= 1000 s 仅由小写英文字母组成  解题思路 动态规划 该题可以转化为寻找原字符串 s 和倒序字符串 s&#39; 的最长公共子序列问题。使用动态规划求解，dp[i][j] 表示以下标 i, j 结尾的前缀字串最长公共子序列的长度，状态转移方程如下：
 当 s[i] == s&#39;[j]，dp[i][j] = dp[i-1][j-1] + 1 当 s[i] == s&#39;[j]，dp[i][j] = max(dp[i-1][j], dp[i][j-1]  每次状态转移时仅依赖当前行和上一行，故可以使用滚动数组降低空间复杂度。</description>
    </item>
    
    <item>
      <title>Leetcode 413. 等差数列划分</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-413.-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/</link>
      <pubDate>Tue, 10 Aug 2021 10:42:43 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-413.-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/</guid>
      <description>链接： https://leetcode-cn.com/problems/arithmetic-slices/
难度： 中等
题目描述 如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。
例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。 给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。
子数组 是数组中的一个连续序列。
示例 1：  输入： nums = [1,2,3,4]
输出： 3
解释： nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。
 示例 2：  输入： nums = [1]
输出： 0
 提示：  1 &amp;lt;= nums.length &amp;lt;= 5000 -1000 &amp;lt;= nums[i] &amp;lt;= 1000  解题思路 数学 对于一个等差数列数组，其长度为 n (n ≥ 3)，其等差数列 子数组 的数量由长度为 3, .</description>
    </item>
    
    <item>
      <title>Leetcode 313. 超级丑数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-313.-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/</link>
      <pubDate>Mon, 09 Aug 2021 11:00:42 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-313.-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/super-ugly-number/
难度： 中等
题目描述 超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。
给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。
题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。
示例 1：  输入： n = 12, primes = [2,7,13,19]
输出： 32
解释： 给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。
 示例 2：  输入： n = 1, primes = [2,3,5]
输出： 1
解释： 1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。
 注意：  1 &amp;lt;= n &amp;lt;= 106 1 &amp;lt;= primes.</description>
    </item>
    
    <item>
      <title>Leetcode 1137. 第 N 个泰波那契数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1137.-%E7%AC%AC-n-%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</link>
      <pubDate>Sun, 08 Aug 2021 09:18:26 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1137.-%E7%AC%AC-n-%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/n-th-tribonacci-number/
难度： 简单
题目描述 泰波那契序列 Tn 定义如下： T0 = 0, T1 = 1, T2 = 1, 且在 n &amp;gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2
给你整数 n，请返回第 n 个泰波那契数 Tn 的值。
示例 1：  输入： n = 4
输出： 4
解释：
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
 示例 2：  输入： n = 25 输出： 1389537</description>
    </item>
    
    <item>
      <title>Leetcode 457. 环形数组是否存在循环</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-457.-%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Sat, 07 Aug 2021 19:33:30 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-457.-%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%BE%AA%E7%8E%AF/</guid>
      <description>链接： https://leetcode-cn.com/problems/circular-array-loop/
难度： 中等
题目描述 存在一个不含 0 的 环形 数组 nums ，每个 nums[i] 都表示位于下标 i 的角色应该向前或向后移动的下标个数：
 如果 nums[i] 是正数，向前 移动 nums[i] 步 如果 nums[i] 是负数，向后 移动 nums[i] 步  因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。
数组中的 循环 由长度为 k 的下标序列 seq ：
 遵循上述移动规则将导致重复下标序列 seq[0] -&amp;gt; seq[1] -&amp;gt; ... -&amp;gt; seq[k - 1] -&amp;gt; seq[0] -&amp;gt; ... 所有 nums[seq[j]] 应当不是 全正 就是 全负 k &amp;gt; 1  如果 nums 中存在循环，返回 true ；否则，返回 false 。</description>
    </item>
    
    <item>
      <title>Leetcode 802. 找到最终的安全状态</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-802.-%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/</link>
      <pubDate>Thu, 05 Aug 2021 14:10:25 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-802.-%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/</guid>
      <description>链接： https://leetcode-cn.com/problems/find-eventual-safe-states/
难度： 中等
题目描述 在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。
对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。
返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。
该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。
示例 1：  输入： graph = [[1,2],[2,3],[5],[0],[5],[],[]]
输出： [2,4,5,6]
解释： 示意图如上。
 示例 2：  输入： graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]
输出： [4]
 提示：  n == graph.length 1 &amp;lt;= n &amp;lt;= 104 0 &amp;lt;= graph[i].length &amp;lt;= n graph[i] 按严格递增顺序排列。 图中可能包含自环。 图中边的数目在范围 [1, 4 * 104] 内。  解题思路 深度优先搜索 通过分析题目得知，当图无环时，所有结点均为 安全 结点；当图有环时，无法到达环的结点属于 安全 结点。</description>
    </item>
    
    <item>
      <title>Leetcode 611. 有效三角形的个数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-611.-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Wed, 04 Aug 2021 10:42:47 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-611.-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/valid-triangle-number/
难度： 中等
题目描述 给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。
示例：  输入: [2,2,3,4]
输出: 3
解释:
有效的组合是:
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3
 注意：  数组长度不超过1000。 数组里整数的范围为 [0, 1000]。  解题思路 排序 + 二分查找 构成三角形的前提条件是两边之和小于第三边，也就是说，两个小边之和大于最长的那条边。
故，首先对数组进行排序，然后依次枚举两条小边 x 和 y ，其下标为 i 和 j (不妨假设 i ≤ i，则  x ≤ y)，即得到最大边的取值范围 x+y-1， 通过二分查找，找到其最大值的位置，与 j 相减即得到可取值的数量，求和。
func triangleNumber(nums []int) int { sort.Ints(nums) res := 0 for i := 0; i &amp;lt; len(nums)-2; i++ { if nums[i] == 0 { continue } for j := i + 1; j &amp;lt; len(nums)-1; j++ { pos := sort.</description>
    </item>
    
    <item>
      <title>Leetcode 743. 网络延迟时间</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-743.-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/</link>
      <pubDate>Tue, 03 Aug 2021 20:16:01 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-743.-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/</guid>
      <description>链接： https://leetcode-cn.com/problems/network-delay-time/
难度： 中等
题目描述 有 n 个网络节点，标记为 1 到 n 。
给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。
现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。
示例 1：  输入： times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
输出： 2
 示例 2：  输入： times = [[1,2,1]], n = 2, k = 1
输出： 1
 示例 3：  输入： times = [[1,2,1]], n = 2, k = 2</description>
    </item>
    
    <item>
      <title>Leetcode 581. 最短无序连续子数组</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-581.-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Tue, 03 Aug 2021 14:28:41 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-581.-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/
难度： 中等
题目描述 给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。
请你找出符合题意的 最短 子数组，并输出它的长度。
示例 1：  输入： nums = [2,6,4,8,10,9,15]
输出： 5
解释： 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。
 示例 2：  输入： nums = [1,2,3,4]
输出： 0
 示例 3：  输入： nums = [1]
输出： 0
 提示：  1 &amp;lt;= nums.length &amp;lt;= 104 -105 &amp;lt;= nums[i] &amp;lt;= 105  **进阶：**你可以设计一个时间复杂度为 $O(n)$ 的解决方案吗？
解题思路 排序 对于连续子数组以外的元素，其在排序前后位置不会改变，故可以将整个数组排序后，从头和尾开始，依次找到不变的元素加以排除，剩余元素就是 最短 连续子数组。</description>
    </item>
    
    <item>
      <title>Leetcode 1337. 矩阵中战斗力最弱的 K 行</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1337.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%88%98%E6%96%97%E5%8A%9B%E6%9C%80%E5%BC%B1%E7%9A%84-k-%E8%A1%8C/</link>
      <pubDate>Sun, 01 Aug 2021 09:54:54 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1337.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%88%98%E6%96%97%E5%8A%9B%E6%9C%80%E5%BC%B1%E7%9A%84-k-%E8%A1%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/
难度： 简单
题目描述 给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。
请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。
如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。
军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。
示例 1：  输入： mat =
[[1,1,0,0,0],
[1,1,1,1,0],
[1,0,0,0,0],
[1,1,0,0,0],
[1,1,1,1,1]],
k = 3
输出： [2,0,3]
解释：
每行中的军人数目： 行 0 -&amp;gt; 2
行 1 -&amp;gt; 4
行 2 -&amp;gt; 1
行 3 -&amp;gt; 2</description>
    </item>
    
    <item>
      <title>Leetcode 987. 二叉树的垂序遍历</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-987.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sat, 31 Jul 2021 12:57:30 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-987.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>链接： https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/
难度： 困难
题目描述 给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。
对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。
二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。
返回二叉树的 垂序遍历 序列。
示例 1：  输入： root = [3,9,20,null,null,15,7]
输出： [[9],[3,15],[20],[7]]
解释：
列 -1 ：只有结点 9 在此列中。
列 0 ：只有结点 3 和 15 在此列中，按从上到下顺序。
列 1 ：只有结点 20 在此列中。
列 2 ：只有结点 7 在此列中。
 示例 2：  输入： root = [1,2,3,4,5,6,7]</description>
    </item>
    
    <item>
      <title>Leetcode 171. Excel表列序号</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-171.-excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/</link>
      <pubDate>Fri, 30 Jul 2021 10:58:59 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-171.-excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/</guid>
      <description>链接： https://leetcode-cn.com/problems/excel-sheet-column-number/
难度： 简单
题目描述 给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。
例如，
 A -&amp;gt; 1
B -&amp;gt; 2
C -&amp;gt; 3
&amp;hellip;
Z -&amp;gt; 26
AA -&amp;gt; 27
AB -&amp;gt; 28
&amp;hellip;
 示例 1：  输入: columnTitle = &amp;ldquo;A&amp;rdquo;
输出: 1
 示例 2：  输入: columnTitle = &amp;ldquo;AB&amp;rdquo;
输出: 28
 示例 3：  输入: columnTitle = &amp;ldquo;ZY&amp;rdquo;
输出: 701
 示例 4：  输入: columnTitle = &amp;ldquo;FXSHRXW&amp;rdquo;</description>
    </item>
    
    <item>
      <title>Leetcode 1104. 二叉树寻路</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1104.-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%BB%E8%B7%AF/</link>
      <pubDate>Thu, 29 Jul 2021 20:22:11 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1104.-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%BB%E8%B7%AF/</guid>
      <description>链接： https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/
难度： 中等
题目描述 在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。
如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；
而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。
给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。
示例 1：  输入： label = 14
输出： [1,3,4,14]
 示例 2：  输入： label = 26
输出： [1,2,6,10,26]
 提示：  1 &amp;lt;= label &amp;lt;= 106  解题思路 推导 对于一个完全二叉树，可以快速找到子结点 x 的父结点是 x/2。该题描述的是完全二叉树的一种变种，仅是偶数行的结点整体进行了反转。
可以使用完全二叉树的编号，快速找到父结点，然后推导出在原二叉树中的原编号，加入到结果中。
对于反转后的某一层，其元素为公差为 1 的等差数列，某个数反转后的编号即为当前层首尾元素之和减去当前元素。
func pathInZigZagTree(label int) []int { layer := 0 // 层 	cnt := layer // 满二叉树结点数量 	for label &amp;gt; cnt { layer++ cnt = 2*(cnt+1) - 1 } idx := layer - 1 res := make([]int, layer) num := label // 完全二叉树编号 	if layer&amp;amp;1 == 0 { num = cnt/2 + 1 + cnt - label } for layer &amp;gt; 0 { if layer&amp;amp;1 == 0 { // 偶数层，转换 	res[idx] = cnt/2 + 1 + cnt - num } else { res[idx] = num } idx-- num /= 2 layer-- cnt /= 2 } return res } 复杂度  时间复杂度：$ O(logN)), N = label $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>Leetcode 863. 二叉树中所有距离为 K 的结点</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-863.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BA-k-%E7%9A%84%E7%BB%93%E7%82%B9/</link>
      <pubDate>Wed, 28 Jul 2021 11:09:17 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-863.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BA-k-%E7%9A%84%E7%BB%93%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/
难度： 中等
题目描述 给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。
返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。
示例：  输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2
输出：[7,4,1]
解释：
所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1
注意，输入的 &amp;ldquo;root&amp;rdquo; 和 &amp;ldquo;target&amp;rdquo; 实际上是树上的结点。
上面的输入仅仅是对这些对象进行了序列化描述。
 提示：  给定的树是非空的。 树上的每个结点都具有唯一的值 0 &amp;lt;= node.val &amp;lt;= 500 。 目标结点 target 是树上的结点。 0 &amp;lt;= K &amp;lt;= 1000  解题思路 深度优先搜索 一次遍历，找到结点 target，同时记录每个结点的父结点，使之构成一张无向图。
然后从 target 结点开始遍历图，找到所有距离为 K 的结点。</description>
    </item>
    
    <item>
      <title>Leetcode 671. 二叉树中第二小的节点</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-671.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Tue, 27 Jul 2021 10:31:04 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-671.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/
难度： 简单
题目描述 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。
更正式地说，root.val = min(root.left.val, root.right.val) 总成立。
给出这样的一个二叉树，你需要输出所有节点中的 第二小的值。如果第二小的值不存在的话，输出 -1 。
示例 1：  输入： root = [2,2,5,null,null,5,7]
输出： 5
解释： 最小的值是 2 ，第二小的值是 5 。
 示例 2：  输入： root = [2,2,2]
输出： -1
解释： 最小的值是 2, 但是不存在第二小的值。
 提示：  树中节点数目在范围 [1, 25] 内 1 &amp;lt;= Node.val &amp;lt;= 231 - 1 对于树中每个节点 root.val == min(root.left.val, root.right.val)  解题思路 深度优先搜索 据题意，树的根结点是最小值，故可以遍历整棵树，使用 min 记录最 第二小的值。</description>
    </item>
    
    <item>
      <title>Leetcode 1743. 从相邻元素对还原数组</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1743.-%E4%BB%8E%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E5%AF%B9%E8%BF%98%E5%8E%9F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sun, 25 Jul 2021 21:48:26 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1743.-%E4%BB%8E%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E5%AF%B9%E8%BF%98%E5%8E%9F%E6%95%B0%E7%BB%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/
难度： 中等
题目描述 存在一个由 n 个不同元素组成的整数数组 nums ，但你已经记不清具体内容。好在你还记得 nums 中的每一对相邻元素。
给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个 adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。
题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。这些相邻元素对可以 按任意顺序 出现。
返回 原始数组 nums 。如果存在多种解答，返回 其中任意一个 即可。
示例 1：  输入： adjacentPairs = [[2,1],[3,4],[3,2]]
输出： [1,2,3,4]
解释： 数组的所有相邻元素对都在 adjacentPairs 中。
特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。
 示例 2：  输入： adjacentPairs = [[4,-2],[1,4],[-3,1]]</description>
    </item>
    
    <item>
      <title>Leetcode 1736. 替换隐藏数字得到的最晚时间</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1736.-%E6%9B%BF%E6%8D%A2%E9%9A%90%E8%97%8F%E6%95%B0%E5%AD%97%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E6%99%9A%E6%97%B6%E9%97%B4/</link>
      <pubDate>Sat, 24 Jul 2021 12:24:31 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1736.-%E6%9B%BF%E6%8D%A2%E9%9A%90%E8%97%8F%E6%95%B0%E5%AD%97%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E6%99%9A%E6%97%B6%E9%97%B4/</guid>
      <description>链接： https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/
难度： 简单
题目描述 给你一个字符串 time ，格式为 hh:mm（小时：分钟），其中某几位数字被隐藏（用 ? 表示）。
有效的时间为 00:00 到 23:59 之间的所有时间，包括 00:00 和 23:59 。
替换 time 中隐藏的数字，返回你可以得到的最晚有效时间。
示例 1：  输入： time = &amp;ldquo;2?:?0&amp;rdquo;
输出： &amp;ldquo;23:50&amp;rdquo;
解释： 以数字 &amp;lsquo;2&amp;rsquo; 开头的最晚一小时是 23 ，以 &amp;lsquo;0&amp;rsquo; 结尾的最晚一分钟是 50
 示例 2：  输入： time = &amp;ldquo;0?:3?&amp;rdquo;
输出： &amp;ldquo;09:39&amp;rdquo;
 示例 3：  输入： time = &amp;ldquo;1?:22&amp;rdquo;
输出： &amp;ldquo;19:22&amp;rdquo;
 提示：  time 的格式为 hh:mm 题目数据保证你可以由输入的字符串生成有效的时间  解题思路 分类讨论 小时和分钟是完全独立的两个单元，分别针对这两个单元进行判断。</description>
    </item>
    
    <item>
      <title>Leetcode 1893. 检查是否区域内所有整数都被覆盖</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1893.-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%8C%BA%E5%9F%9F%E5%86%85%E6%89%80%E6%9C%89%E6%95%B4%E6%95%B0%E9%83%BD%E8%A2%AB%E8%A6%86%E7%9B%96/</link>
      <pubDate>Fri, 23 Jul 2021 10:32:17 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1893.-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%8C%BA%E5%9F%9F%E5%86%85%E6%89%80%E6%9C%89%E6%95%B4%E6%95%B0%E9%83%BD%E8%A2%AB%E8%A6%86%E7%9B%96/</guid>
      <description>链接： https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/
难度： 简单
题目描述 给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的 闭区间 。
如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个 区间覆盖，那么请你返回 true ，否则返回 false 。
已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti &amp;lt;= x &amp;lt;= endi ，那么我们称整数 x 被覆盖了。
示例 1：  输入： ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5
输出： true
解释： 2 到 5 的每个整数都被覆盖了：</description>
    </item>
    
    <item>
      <title>Leetcode 138. 复制带随机指针的链表</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-138.-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 22 Jul 2021 11:22:49 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-138.-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/copy-list-with-random-pointer/
难度： 中等
题目描述 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。
构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。
例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --&amp;gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --&amp;gt; y 。
返回复制链表的头节点。
用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：
 val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。  你的代码 只 接受原链表的头节点 head 作为传入参数。
示例 1：  输入： head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出： [[7,null],[13,0],[11,4],[10,2],[1,0]]</description>
    </item>
    
    <item>
      <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</link>
      <pubDate>Wed, 21 Jul 2021 10:43:36 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/
难度： 简单
题目描述 输入两个链表，找出它们的第一个公共节点。
如下面的两个链表：
在节点 c1 开始相交。
示例 1：  输入： intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出： Reference of the node with value = 8
输入解释： 相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
 示例 2：  输入： intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</description>
    </item>
    
    <item>
      <title>Leetcode 1877. 数组中最大数对和的最小值</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1877.-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AF%B9%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</link>
      <pubDate>Tue, 20 Jul 2021 09:55:22 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1877.-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AF%B9%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</guid>
      <description>链接： https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/
难度： 中等
题目描述 一个数对 (a,b) 的 数对和 等于 a + b 。最大数对和 是一个数对数组中最大的 数对和 。
比方说，如果我们有数对 (1,5) ，(2,3) 和 (4,4)，最大数对和 为 max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8 。 给你一个长度为 偶数 n 的数组 nums ，请你将 nums 中的元素分成 n / 2 个数对，使得：
 nums 中每个元素 恰好 在 一个 数对中，且 最大数对和 的值 最小 。  请你在最优数对划分的方案下，返回最小的 最大数对和 。
示例 1：  输入： nums = [3,5,2,3]
输出： 7
解释： 数组中的元素可以分为数对 (3,3) 和 (5,2) 。</description>
    </item>
    
    <item>
      <title>Leetcode 1838. 最高频元素的频数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1838.-%E6%9C%80%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E7%9A%84%E9%A2%91%E6%95%B0/</link>
      <pubDate>Mon, 19 Jul 2021 10:31:28 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1838.-%E6%9C%80%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E7%9A%84%E9%A2%91%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/
难度： 中等
题目描述 元素的 频数 是该元素在一个数组中出现的次数。
给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。
执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。
示例 1：  输入： nums = [1,2,4], k = 5
输出： 3
解释： 对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。
4 是数组中最高频元素，频数是 3 。
 示例 2：  输入： nums = [1,4,8,13], k = 5
输出： 2
解释： 存在多种最优解决方案：
 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。   示例 3：  输入： nums = [3,9,6], k = 2</description>
    </item>
    
    <item>
      <title>面试题 10.02. 变位词组</title>
      <link>https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-10.02.-%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84/</link>
      <pubDate>Sun, 18 Jul 2021 11:32:11 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-10.02.-%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/group-anagrams-lcci/
难度： 中等
题目描述 编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。
**注意：**本题相对原题稍作修改
示例：  输入: [&amp;ldquo;eat&amp;rdquo;, &amp;ldquo;tea&amp;rdquo;, &amp;ldquo;tan&amp;rdquo;, &amp;ldquo;ate&amp;rdquo;, &amp;ldquo;nat&amp;rdquo;, &amp;ldquo;bat&amp;rdquo;],
输出:
[
[&amp;ldquo;ate&amp;rdquo;,&amp;ldquo;eat&amp;rdquo;,&amp;ldquo;tea&amp;rdquo;],
[&amp;ldquo;nat&amp;rdquo;,&amp;ldquo;tan&amp;rdquo;],
[&amp;ldquo;bat&amp;rdquo;]
]
 解题思路 哈希 &amp;amp; 计数 对于每个字符串，使用数组统计每个字母出现的数字，两个同位词得出的统计数组必然相同，故用该数组作为 key
func groupAnagrams(strs []string) [][]string { cnt := func(s string) (cnt [26]int) { for i := range s { cnt[s[i]-&amp;#39;a&amp;#39;]++ } return } hash := make(map[[26]int][]string) for _, str := range strs { key := cnt(str) hash[key] = append(hash[key], str) } res := make([][]string, 0, len(hash)) for _, v := range hash { res = append(res, v) } return res } 复杂度  时间复杂度：$ O(NL), N = len(strs), L = max(len(str)) $ 空间复杂度：$ O(NL) $  哈希 &amp;amp; 排序 不同变位词中字母相同，所以将字符串按照字母排序后，其值也一定相同。故可以将其排序后的值作为哈希表的 key，并将其添加进 value 数组中。</description>
    </item>
    
    <item>
      <title>剑指 Offer 42. 连续子数组的最大和</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-42.-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</link>
      <pubDate>Sat, 17 Jul 2021 13:21:52 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-42.-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/
难度： 简单
题目描述 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。
要求时间复杂度为$O(n)$。
示例 1：  输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
 提示：  1 &amp;lt;= arr.length &amp;lt;= 105 -100 &amp;lt;= arr[i] &amp;lt;= 100  解题思路 动态规划 用 dp[i] 记录以 i 为结尾的连续子数组和的最大值，容易得到状态转移方程：
 dp[0] = nums[0] dp[i] = max(dp[i-1]+nums[i], nums[i])  由于每次转移仅涉及到前一个结果，使用变量代替数组降低空间复杂度
func maxSubArray(nums []int) int { if len(nums) == 0 { return 0 } dp := nums[0] max := dp for pre, i := 0, 1; i &amp;lt; len(nums); i++ { pre = dp if pre+nums[i] &amp;gt; nums[i] { dp = pre + nums[i] } else { dp = nums[i] } if max &amp;lt; dp { max = dp } } return max } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $  </description>
    </item>
    
    <item>
      <title>剑指 Offer 53 - I. 在排序数组中查找数字 I</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-53-i.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-i/</link>
      <pubDate>Fri, 16 Jul 2021 14:55:24 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-53-i.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-i/</guid>
      <description>链接： https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/
难度： 简单
题目描述 统计一个数字在排序数组中出现的次数。
示例 1：  输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
 示例 2：  输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
 提示：  0 &amp;lt;= 数组长度 &amp;lt;= 50000  解题思路 顺序查找 顺序遍历，统计数量 target。由于数组有序，当当前元素大于 target时，
func search(nums []int, target int) int { cnt := 0 for _, num := range nums { if num == target { cnt++ } else if num &amp;gt; target { break } } return cnt } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $  二分查找 二分查找，找到首个等于 target 的元素位置，依次向后遍历到元素不等于 target 为止，记录出现的次数。</description>
    </item>
    
    <item>
      <title>Leetcode 1846. 减小和重新排列数组后的最大元素</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1846.-%E5%87%8F%E5%B0%8F%E5%92%8C%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
      <pubDate>Thu, 15 Jul 2021 10:33:47 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1846.-%E5%87%8F%E5%B0%8F%E5%92%8C%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
      <description>链接： https://leetcode-cn.com/problems/maximum-element-after-decreasing-and-rearranging/
难度： 中等
题目描述 给你一个正整数数组 arr 。请你对 arr 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：
 arr 中 第一个 元素必须为 1 。 任意相邻两个元素的差的绝对值 小于等于 1 ，也就是说，对于任意的 1 &amp;lt;= i &amp;lt; arr.length （数组下标从 0 开始），都满足 abs(arr[i] - arr[i - 1]) &amp;lt;= 1 。abs(x) 为 x 的绝对值。  你可以执行以下 2 种操作任意次：
 减小 arr 中任意元素的值，使其变为一个 更小的正整数 。 重新排列 arr 中的元素，你可以以任意顺序重新排列。  请你返回执行以上操作后，在满足前文所述的条件下，arr 中可能的 最大值 。
示例 1：  输入： arr = [2,2,1,2,1]
输出： 2
解释：
我们可以重新排列 arr 得到 [1,2,2,2,1] ，该数组满足所有条件。</description>
    </item>
    
    <item>
      <title>Leetcode 1818. 绝对差值和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1818.-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E5%80%BC%E5%92%8C/</link>
      <pubDate>Wed, 14 Jul 2021 10:34:23 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1818.-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E5%80%BC%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/minimum-absolute-sum-difference/
难度： 中等
题目描述 给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。
数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|（0 &amp;lt;= i &amp;lt; n）的 总和（下标从 0 开始）。
你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。
在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 109 + 7 取余 后返回。
|x| 定义为：
 如果 x &amp;gt;= 0 ，值为 x ，或者 如果 x &amp;lt;= 0 ，值为 -x  示例 1：  输入： nums1 = [1,7,5], nums2 = [2,3,5]</description>
    </item>
    
    <item>
      <title>Leetcode 275. H 指数 II</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-275.-h-%E6%8C%87%E6%95%B0-ii/</link>
      <pubDate>Mon, 12 Jul 2021 10:50:26 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-275.-h-%E6%8C%87%E6%95%B0-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/h-index-ii/
难度： 中等
题目描述 给定一位研究者论文被引用次数的数组（被引用次数是非负整数）,数组已经按照 升序排列。编写一个方法，计算出研究者的 h 指数。
h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共 有 h 篇论文分别被引用了至少 h 次。且其余的 $N - h$ 篇论文每篇被引用次数 不超过 h 次。
例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。
示例：  输入： citations = [0,1,3,5,6]
输出： 3
解释： 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。
由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。
 **说明：**如果 h 有多种可能的值，h 指数是其中最大的那个。</description>
    </item>
    
    <item>
      <title>Leetcode 274. H 指数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-274.-h-%E6%8C%87%E6%95%B0/</link>
      <pubDate>Sun, 11 Jul 2021 12:04:41 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-274.-h-%E6%8C%87%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/h-index/
难度： 中等
题目描述 给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。
h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共 有 h 篇论文分别被引用了至少 h 次。且其余的 $N - h$ 篇论文每篇被引用次数 不超过 h 次。
例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。
示例：  输入： citations = [3,0,6,1,5]
输出： 3
解释： 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。
 **提示：**如果 h 有多种可能的值，h 指数是其中最大的那个。</description>
    </item>
    
    <item>
      <title>Leetcode 981. 基于时间的键值存储</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-981.-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/</link>
      <pubDate>Sat, 10 Jul 2021 11:47:18 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-981.-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/time-based-key-value-store/
难度： 中等
题目描述 创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作：
 set(string key, string value, int timestamp)  存储键 key、值 value，以及给定的时间戳 timestamp。
get(string key, int timestamp)  返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev &amp;lt;= timestamp。 如果有多个这样的值，则返回对应最大的 timestamp_prev 的那个值。 如果没有值，则返回空字符串（&amp;quot;&amp;quot;）。    示例1：  输入： inputs = [&amp;ldquo;TimeMap&amp;rdquo;,&amp;ldquo;set&amp;rdquo;,&amp;ldquo;get&amp;rdquo;,&amp;ldquo;get&amp;rdquo;,&amp;ldquo;set&amp;rdquo;,&amp;ldquo;get&amp;rdquo;,&amp;ldquo;get&amp;rdquo;], inputs = [[],[&amp;ldquo;foo&amp;rdquo;,&amp;ldquo;bar&amp;rdquo;,1],[&amp;ldquo;foo&amp;rdquo;,1],[&amp;ldquo;foo&amp;rdquo;,3],[&amp;ldquo;foo&amp;rdquo;,&amp;ldquo;bar2&amp;rdquo;,4],[&amp;ldquo;foo&amp;rdquo;,4],[&amp;ldquo;foo&amp;rdquo;,5]]
输出： [null,null,&amp;ldquo;bar&amp;rdquo;,&amp;ldquo;bar&amp;rdquo;,null,&amp;ldquo;bar2&amp;rdquo;,&amp;ldquo;bar2&amp;rdquo;]
解释：
TimeMap kv;
kv.set(&amp;ldquo;foo&amp;rdquo;, &amp;ldquo;bar&amp;rdquo;, 1); // 存储键 &amp;ldquo;foo&amp;rdquo; 和值 &amp;ldquo;bar&amp;rdquo; 以及时间戳 timestamp = 1
kv.get(&amp;ldquo;foo&amp;rdquo;, 1); // 输出 &amp;ldquo;bar&amp;rdquo;</description>
    </item>
    
    <item>
      <title>面试题 17.10. 主要元素</title>
      <link>https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.10.-%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/</link>
      <pubDate>Fri, 09 Jul 2021 10:46:07 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.10.-%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/</guid>
      <description>链接： https://leetcode-cn.com/problems/find-majority-element-lcci/
难度： 简单
题目描述 数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 $O(N)$ 、空间复杂度为 $O(1)$ 的解决方案。
示例 1：  输入： [1,2,5,9,5,9,5,5,5]
输出： 5
 示例 2：  输入： [3,2]
输出： -1
 示例 3：  输入： [2,2,1,1,1,2,2]
输出： 2
 解题思路 哈希计数 遍历数组，记录每个数出现的次数，直到某个数 num 出现的次数大于数组长度的一半则返回 num，否则返回 -1
func majorityElement(nums []int) int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ if cnt[num] &amp;gt; len(nums)/2 { return num } } return -1 } 复杂度  时间复杂度：$ O(N) $ 空间复杂度：$ O(N) $  排序 将数组排序，依次统计连续相同数字的数量，直到满足条件为止。</description>
    </item>
    
    <item>
      <title>Leetcode 930. 和相同的二元子数组</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-930.-%E5%92%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E5%85%83%E5%AD%90%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 08 Jul 2021 15:11:00 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-930.-%E5%92%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E5%85%83%E5%AD%90%E6%95%B0%E7%BB%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-subarrays-with-sum/
难度： 中等
题目描述 给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。
子数组 是数组的一段连续部分。
示例 1：  输入： nums = [1,0,1,0,1], goal = 2
输出： 4
解释：
有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]
 示例 2：  输入： nums = [0,0,0,0,0], goal = 0
输出： 15
 提示：  1 &amp;lt;= nums.length &amp;lt;= 3 * 104 nums[i] 不是 0 就是 1 0 &amp;lt;= goal &amp;lt;= nums.length  解题思路 哈希 假设满足条件的子数组下标为 [i, j) ，则以 i 和 j 为结尾的两个前缀数组的前缀和记作 sum[i]、sum[j] ，有 goal = sum[j] - sum[i]。</description>
    </item>
    
    <item>
      <title>Leetcode 1711. 大餐计数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1711.-%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/</link>
      <pubDate>Wed, 07 Jul 2021 10:28:11 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1711.-%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/count-good-meals/
难度： 中等
题目描述 大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。
你可以搭配 任意 两道餐品做一顿大餐。
给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i​​​​​​​​​​​​​​ 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。
注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。
示例 1：  输入： deliciousness = [1,3,5,7,9]
输出： 4
解释： 大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。
它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。
 示例 2:  输入： deliciousness = [1,1,1,3,3,3,7]
输出： 15
解释： 大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。</description>
    </item>
    
    <item>
      <title>Leetcode 1418. 点菜展示表</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1418.-%E7%82%B9%E8%8F%9C%E5%B1%95%E7%A4%BA%E8%A1%A8/</link>
      <pubDate>Tue, 06 Jul 2021 09:20:22 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1418.-%E7%82%B9%E8%8F%9C%E5%B1%95%E7%A4%BA%E8%A1%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant/
难度： 中等
题目描述 给你一个数组 orders ，表示客户在餐厅中完成的订单，确切地说， orders[i]=[customerNamei,tableNumberi,foodItemi] ，其中 customerNamei 是客户的姓名，tableNumberi 是客户所在餐桌的桌号，而 foodItemi 是客户点的餐品名称。
请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。
注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。
示例 1：  输入： orders = [[&amp;ldquo;David&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;ldquo;Ceviche&amp;rdquo;],[&amp;ldquo;Corina&amp;rdquo;,&amp;ldquo;10&amp;rdquo;,&amp;ldquo;Beef Burrito&amp;rdquo;],[&amp;ldquo;David&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;ldquo;Fried Chicken&amp;rdquo;],[&amp;ldquo;Carla&amp;rdquo;,&amp;ldquo;5&amp;rdquo;,&amp;ldquo;Water&amp;rdquo;],[&amp;ldquo;Carla&amp;rdquo;,&amp;ldquo;5&amp;rdquo;,&amp;ldquo;Ceviche&amp;rdquo;],[&amp;ldquo;Rous&amp;rdquo;,&amp;ldquo;3&amp;rdquo;,&amp;ldquo;Ceviche&amp;rdquo;]]
输出： [[&amp;ldquo;Table&amp;rdquo;,&amp;ldquo;Beef Burrito&amp;rdquo;,&amp;ldquo;Ceviche&amp;rdquo;,&amp;ldquo;Fried Chicken&amp;rdquo;,&amp;ldquo;Water&amp;rdquo;],[&amp;ldquo;3&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;2&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;],[&amp;ldquo;5&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;1&amp;rdquo;],[&amp;ldquo;10&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;0&amp;rdquo;,&amp;ldquo;0&amp;rdquo;]]
解释：
点菜展示表如下所示：
Table,Beef Burrito,Ceviche,Fried Chicken,Water
3 ,0 ,2 ,1 ,0
5 ,0 ,1 ,0 ,1
10 ,1 ,0 ,0 ,0
对于餐桌 3：David 点了 &amp;ldquo;Ceviche&amp;rdquo; 和 &amp;ldquo;Fried Chicken&amp;rdquo;，而 Rous 点了 &amp;ldquo;Ceviche&amp;rdquo;
而餐桌 5：Carla 点了 &amp;ldquo;Water&amp;rdquo; 和 &amp;ldquo;Ceviche&amp;rdquo;</description>
    </item>
    
    <item>
      <title>Leetcode 726. 原子的数量</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-726.-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F/</link>
      <pubDate>Mon, 05 Jul 2021 20:30:53 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-726.-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/number-of-atoms/
难度： 困难
题目描述 给定一个化学式 formula （作为字符串），返回每种原子的数量。
原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。
如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。
两个化学式连在一起是新的化学式。例如 H2O2He3Mg4 也是化学式。
一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。
给定一个化学式 formula ，返回所有原子的数量。格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。
示例1：  输入： formula = &amp;ldquo;H2O&amp;rdquo;
输出： &amp;ldquo;H2O&amp;rdquo;
解释：
原子的数量是 {&amp;lsquo;H&amp;rsquo;: 2, &amp;lsquo;O&amp;rsquo;: 1}。
 示例2：  输入： formula = &amp;ldquo;Mg(OH)2&amp;rdquo;
输出： &amp;ldquo;H2MgO2&amp;rdquo;
解释：
原子的数量是 {&amp;lsquo;H&amp;rsquo;: 2, &amp;lsquo;Mg&amp;rsquo;: 1, &amp;lsquo;O&amp;rsquo;: 2}。
 示例3：  输入： formula = &amp;ldquo;K4(ON(SO3)2)2&amp;rdquo;
输出： &amp;ldquo;K4N2O14S4&amp;rdquo;</description>
    </item>
    
    <item>
      <title>Leetcode 645. 错误的集合</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-645.-%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88/</link>
      <pubDate>Sun, 04 Jul 2021 10:12:40 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-645.-%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88/</guid>
      <description>链接： https://leetcode-cn.com/problems/set-mismatch/
难度： 简单
题目描述 集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。
给定一个数组 nums 代表了集合 S 发生错误后的结果。
请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。
示例 1：  输入： nums = [1,2,2,4]
输出： [2,3]
 示例 2：  输入： nums = [1,1]
输出： [1,2]
 提示：  2 &amp;lt;= nums.length &amp;lt;= 104 1 &amp;lt;= nums[i] &amp;lt;= 104  解题思路 哈希 利用哈希表记录每个数字是否出现，可以找到重复出现过的数字；遍历哈希表可以找到丢失的数字。
func findErrorNums(nums []int) []int { res := []int{0, 0} exist := make([]bool, len(nums)) for _, num := range nums { if exist[num-1] { res[0] = num } exist[num-1] = true } for num, ok := range exist { if !</description>
    </item>
    
    <item>
      <title>Leetcode 451. 根据字符出现频率排序</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-451.-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 03 Jul 2021 09:35:21 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-451.-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/sort-characters-by-frequency/
难度： 中等
题目描述 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。
示例1：  输入:
&amp;ldquo;tree&amp;rdquo;
输出:
&amp;ldquo;eert&amp;rdquo;
解释:
&amp;lsquo;e&amp;rsquo;出现两次，&amp;lsquo;r&amp;rsquo;和&amp;rsquo;t&amp;rsquo;都只出现一次。
因此&amp;rsquo;e&amp;rsquo;必须出现在&amp;rsquo;r&amp;rsquo;和&amp;rsquo;t&amp;rsquo;之前。此外，&amp;ldquo;eetr&amp;quot;也是一个有效的答案。
 示例2：  输入:
&amp;ldquo;cccaaa&amp;rdquo;
输出:
&amp;ldquo;cccaaa&amp;rdquo;
解释:
&amp;lsquo;c&amp;rsquo;和&amp;rsquo;a&amp;rsquo;都出现三次。此外，&amp;ldquo;aaaccc&amp;quot;也是有效的答案。
注意&amp;quot;cacaca&amp;quot;是不正确的，因为相同的字母必须放在一起。
 示例3：  输入:
&amp;ldquo;Aabb&amp;rdquo;
输出:
&amp;ldquo;bbAa&amp;rdquo;
解释:
此外，&amp;ldquo;bbaA&amp;quot;也是一个有效的答案，但&amp;quot;Aabb&amp;quot;是不正确的。
注意&amp;rsquo;A&amp;rsquo;和&amp;rsquo;a&amp;rsquo;被认为是两种不同的字符。
 解题思路 计数+排序 统计每个字符出现的次数，按照统计的次数对字符进行排序，然后按照字符顺序和数量展开。
func frequencySort(s string) string { cnt := make(map[byte]int) for i := 0; i &amp;lt; len(s); i++ { cnt[s[i]]++ } chars := make([]byte, 0, len(s)) for char := range cnt { chars = append(chars, char) } sort.</description>
    </item>
    
    <item>
      <title>Leetcode 1833. 雪糕的最大数量</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1833.-%E9%9B%AA%E7%B3%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/</link>
      <pubDate>Fri, 02 Jul 2021 10:28:04 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1833.-%E9%9B%AA%E7%B3%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/maximum-ice-cream-bars/
难度： 中等
题目描述 夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。
商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。
给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。
**注意：**Tony 可以按任意顺序购买雪糕。
示例 1：  输入： costs = [1,3,2,4,1], coins = 7
输出： 4
解释： Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7
 示例 2：  输入： costs = [10,6,8,7,7,8], coins = 5</description>
    </item>
    
    <item>
      <title>LCP 07. 传递信息</title>
      <link>https://xianlianghe0123.github.io/p/lcp-07.-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/</link>
      <pubDate>Thu, 01 Jul 2021 11:14:31 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/lcp-07.-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/</guid>
      <description>链接： https://leetcode-cn.com/problems/chuan-di-xin-xi/
难度： 简单
题目描述 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：
 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人  给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。
示例1：  输入： n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3
输出： 3
解释： 信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&amp;gt;2-&amp;gt;0-&amp;gt;4， 0-&amp;gt;2-&amp;gt;1-&amp;gt;4， 0-&amp;gt;2-&amp;gt;3-&amp;gt;4。</description>
    </item>
    
    <item>
      <title>剑指 Offer 37. 序列化二叉树</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-37.-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Wed, 30 Jun 2021 15:51:24 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-37.-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>链接： https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/
难度： 困难
题目描述 请实现两个函数，分别用来序列化和反序列化二叉树。
你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
**提示：**输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
示例1：  输入： root = [1,2,3,null,null,4,5]
输出： [1,2,3,null,null,4,5]
 解题思路 先序遍历 序列化时，先序遍历整个二叉树，将遍历到的每个结点按顺序加入列表中。需要将遍历到的空结点也加入到列表中，作为分割。
反序列化时，按照列表顺序构建二叉树，遇到空结点表示该分支已结束，回到另一个分支处，继续构造结点。
class Codec: def serialize(self, root): &amp;#34;&amp;#34;&amp;#34;Encodes a tree to a single string. :type root: TreeNode :rtype: str &amp;#34;&amp;#34;&amp;#34; list = [] def dfs(node): if node == None: list.append(&amp;#34;None&amp;#34;) else: list.append(str(node.val)) dfs(node.left) dfs(node.right) dfs(root) return &amp;#34;,&amp;#34;.join(list) def deserialize(self, data): &amp;#34;&amp;#34;&amp;#34;Decodes your encoded data to tree.</description>
    </item>
    
    <item>
      <title>Leetcode 168. Excel表列名称</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-168.-excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</link>
      <pubDate>Tue, 29 Jun 2021 10:26:51 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-168.-excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/excel-sheet-column-title/
难度： 简单
题目描述 给定一个正整数，返回它在 Excel 表中相对应的列名称。
例如，
 1 -&amp;gt; A
2 -&amp;gt; B
3 -&amp;gt; C
&amp;hellip;
26 -&amp;gt; Z
27 -&amp;gt; AA
28 -&amp;gt; AB
&amp;hellip;
 示例1：  输入: 1
输出: &amp;ldquo;A&amp;rdquo;
 示例2：  输入: 28
输出: &amp;ldquo;AB&amp;rdquo;
 示例3：  输入: 701
输出: &amp;ldquo;ZY&amp;rdquo;
 解题思路 数学 通过分析题意可以得知，该题是一个进制转换，将一个10进制的数转换为26进制。
通过数学方法，逐次模26取余数，即可求得倒序的26进制每一位，反转该序列即可求得转换后的数。
**注意：**该26进制从1开始计数，每次取模前应减1。
func convertToTitle(columnNumber int) string { res := make([]byte, 0, 10) for ; columnNumber &amp;gt; 0; columnNumber /= 26 { columnNumber = columnNumber - 1 res = append(res, &amp;#39;A&amp;#39;+byte((columnNumber)%26)) } for i := 0; i &amp;lt; len(res)/2; i++ { res[i], res[len(res)-1-i] = res[len(res)-1-i], res[i] } return string(res) } 复杂度  时间复杂度：O(log26columnNumber) 空间复杂度：O(log26columnNumber)  </description>
    </item>
    
    <item>
      <title>Leetcode 815. 公交路线</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-815.-%E5%85%AC%E4%BA%A4%E8%B7%AF%E7%BA%BF/</link>
      <pubDate>Mon, 28 Jun 2021 10:54:56 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-815.-%E5%85%AC%E4%BA%A4%E8%B7%AF%E7%BA%BF/</guid>
      <description>链接： https://leetcode-cn.com/problems/bus-routes/
难度： 困难
题目描述 给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。
 例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -&amp;gt; 5 -&amp;gt; 7 -&amp;gt; 1 -&amp;gt; 5 -&amp;gt; 7 -&amp;gt; 1 -&amp;gt; ... 这样的车站路线行驶。  现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。
求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。
示例 1：  输入： routes = [[1,2,7],[3,6,7]], source = 1, target = 6
输出： 2
解释： 最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。</description>
    </item>
    
    <item>
      <title>Leetcode 909. 蛇梯棋</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-909.-%E8%9B%87%E6%A2%AF%E6%A3%8B/</link>
      <pubDate>Sun, 27 Jun 2021 19:07:10 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-909.-%E8%9B%87%E6%A2%AF%E6%A3%8B/</guid>
      <description>链接： https://leetcode-cn.com/problems/snakes-and-ladders/
难度： 中等
题目描述 N x N 的棋盘 board 上，按从 1 到 N*N 的数字给方格编号，编号 从左下角开始，每一行交替方向。
例如，一块 6 x 6 大小的棋盘，编号如下：
r 行 c 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 board[r][c] != -1，那个蛇或梯子的目的地将会是 board[r][c]。
玩家从棋盘上的方格 1 （总是在最后一行、第一列）开始出发。
每一回合，玩家需要从当前方格 x 开始出发，按下述要求前进：
 选定目标方格：选择从编号 x+1，x+2，x+3，x+4，x+5，或者 x+6 的方格中选出一个目标方格 s ，目标方格的编号 &amp;lt;= N*N。  该选择模拟了掷骰子的情景，无论棋盘大小如何，你的目的地范围也只能处于区间 [x+1, x+6] 之间。   传送玩家：如果目标方格 S 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 S。 注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。  返回达到方格 N*N 所需的最少移动次数，如果不可能，则返回 -1。
示例：  输入： [
[-1,-1,-1,-1,-1,-1],
[-1,-1,-1,-1,-1,-1],</description>
    </item>
    
    <item>
      <title>Leetcode 752. 打开转盘锁</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-752.-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/</link>
      <pubDate>Fri, 25 Jun 2021 17:34:59 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-752.-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/</guid>
      <description>链接： https://leetcode-cn.com/problems/open-the-lock/
难度： 中等
题目描述 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39; 。每个拨轮可以自由旋转：例如把 &#39;9&#39; 变为 &#39;0&#39;，&#39;0&#39; 变为 &#39;9&#39; 。每次旋转都只能旋转一个拨轮的一位数字。
锁的初始数字为 &#39;0000&#39; ，一个代表四个拨轮的数字的字符串。
列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。
字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。
示例1：  输入： deadends = [&amp;ldquo;0201&amp;rdquo;,&amp;ldquo;0101&amp;rdquo;,&amp;ldquo;0102&amp;rdquo;,&amp;ldquo;1212&amp;rdquo;,&amp;ldquo;2002&amp;rdquo;], target = &amp;ldquo;0202&amp;rdquo;
输出： 6
解释：
可能的移动序列为 &amp;ldquo;0000&amp;rdquo; -&amp;gt; &amp;ldquo;1000&amp;rdquo; -&amp;gt; &amp;ldquo;1100&amp;rdquo; -&amp;gt; &amp;ldquo;1200&amp;rdquo; -&amp;gt; &amp;ldquo;1201&amp;rdquo; -&amp;gt; &amp;ldquo;1202&amp;rdquo; -&amp;gt; &amp;ldquo;0202&amp;rdquo;。
注意 &amp;ldquo;0000&amp;rdquo; -&amp;gt; &amp;ldquo;0001&amp;rdquo; -&amp;gt; &amp;ldquo;0002&amp;rdquo; -&amp;gt; &amp;ldquo;0102&amp;rdquo; -&amp;gt; &amp;ldquo;0202&amp;rdquo; 这样的序列是不能解锁的，</description>
    </item>
    
    <item>
      <title>剑指 Offer 15. 二进制中1的个数</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Wed, 23 Jun 2021 21:39:35 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/
难度： 简单
题目描述 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。
示例1：  输入： 00000000000000000000000000001011
输出： 3
解释： 输入的二进制串 00000000000000000000000000001011 中，共有三位为 &amp;lsquo;1&amp;rsquo;。
 示例 2：  输入： 00000000000000000000000010000000
输出： 1
解释： 输入的二进制串 00000000000000000000000010000000 中，共有一位为 &amp;lsquo;1&amp;rsquo;。
 示例 3：  输入： 11111111111111111111111111111101
输出： 31
解释： 输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &amp;lsquo;1&amp;rsquo;。
 提示：  输入必须是长度为 32 的 二进制串 。  解题思路 计数 每次统计最右边的一位，并向右移动一位。
func hammingWeight(num uint32) int { cnt := 0 for ; num !</description>
    </item>
    
    <item>
      <title>剑指 Offer 38. 字符串的排列</title>
      <link>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-38.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</link>
      <pubDate>Tue, 22 Jun 2021 21:43:40 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-38.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/
难度： 中等
题目描述 输入一个字符串，打印出该字符串中字符的所有排列。
你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。
示例1：  输入： s = &amp;ldquo;abc&amp;rdquo;
输出： [&amp;ldquo;abc&amp;rdquo;,&amp;ldquo;acb&amp;rdquo;,&amp;ldquo;bac&amp;rdquo;,&amp;ldquo;bca&amp;rdquo;,&amp;ldquo;cab&amp;rdquo;,&amp;ldquo;cba&amp;rdquo;]
 提示：  1 &amp;lt;= s 的长度 &amp;lt;= 8  解题思路 回溯 遍历未入栈字符列表，每次选取一个字符入栈，并标记此字符已经入栈，递归的寻找下一个字符，直到所有字符全部入栈，将结果加入集合中。
func permutation(s string) []string { only := make(map[string]bool) choice := make([]bool, len(s)) prefix := make([]byte, 0, len(s)) var backtrack func() backtrack = func() { if len(prefix) == len(s) { only[string(prefix)] = true return } for i := range choice { if choice[i] { continue } prefix = append(prefix, s[i]) choice[i] = true backtrack() choice[i] = false prefix = prefix[:len(prefix)-1] } } backtrack() res := make([]string, 0, 1&amp;lt;&amp;lt;(len(s)-1)) for k := range only { res = append(res, k) } return res } 复杂度  时间复杂度：O(N*N!</description>
    </item>
    
    <item>
      <title>Leetcode 401. 二进制手表</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-401.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/</link>
      <pubDate>Mon, 21 Jun 2021 21:27:36 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-401.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/binary-watch/
难度： 简单
题目描述 二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。
 例如，下面的二进制手表读取 &amp;quot;3:25&amp;quot; 。  给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。
小时不会以零开头：
 例如，&amp;quot;01:00&amp;quot; 是无效的时间，正确的写法应该是 &amp;quot;1:00&amp;quot; 。  分钟必须由两位数组成，可能会以零开头：
 例如，&amp;quot;10:2&amp;quot; 是无效的时间，正确的写法应该是 &amp;quot;10:02&amp;quot; 。  示例 1：  输入： turnedOn = 1
输出： [&amp;ldquo;0:01&amp;rdquo;,&amp;ldquo;0:02&amp;rdquo;,&amp;ldquo;0:04&amp;rdquo;,&amp;ldquo;0:08&amp;rdquo;,&amp;ldquo;0:16&amp;rdquo;,&amp;ldquo;0:32&amp;rdquo;,&amp;ldquo;1:00&amp;rdquo;,&amp;ldquo;2:00&amp;rdquo;,&amp;ldquo;4:00&amp;rdquo;,&amp;ldquo;8:00&amp;rdquo;]
 示例 2：  输入： turnedOn = 9
输出： []
 提示：  0 &amp;lt;= turnedOn &amp;lt;= 10  解题思路 穷举 枚举出所有小时和分钟的合法数，将符合条件的加入到结果列表中</description>
    </item>
    
    <item>
      <title>Leetcode 1600. 皇位继承顺序</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1600.-%E7%9A%87%E4%BD%8D%E7%BB%A7%E6%89%BF%E9%A1%BA%E5%BA%8F/</link>
      <pubDate>Sun, 20 Jun 2021 09:58:32 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1600.-%E7%9A%87%E4%BD%8D%E7%BB%A7%E6%89%BF%E9%A1%BA%E5%BA%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/throne-inheritance/
难度： 中等
题目描述 一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。
这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。
 Successor(x, curOrder):
如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：
如果 x 是国王，那么返回 null
否则，返回 Successor(x 的父亲, curOrder)
否则，返回 x 不在 curOrder 中最年长的孩子
 比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。
 一开始， curOrder 为 [&amp;ldquo;king&amp;rdquo;]. 调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 [&amp;quot;king&amp;quot;, &amp;quot;Alice&amp;quot;] 。 调用 Successor(Alice, curOrder) ，返回 Jack ，所以我们将 Jack 放入 curOrder 中，得到 [&amp;quot;king&amp;quot;, &amp;quot;Alice&amp;quot;, &amp;quot;Jack&amp;quot;] 。 调用 Successor(Jack, curOrder) ，返回 Bob ，所以我们将 Bob 放入 curOrder 中，得到 [&amp;quot;king&amp;quot;, &amp;quot;Alice&amp;quot;, &amp;quot;Jack&amp;quot;, &amp;quot;Bob&amp;quot;] 。 调用 Successor(Bob, curOrder) ，返回 null 。最终得到继承顺序为 [&amp;quot;king&amp;quot;, &amp;quot;Alice&amp;quot;, &amp;quot;Jack&amp;quot;, &amp;quot;Bob&amp;quot;] 。  通过以上的函数，我们总是能得到一个唯一的继承顺序。</description>
    </item>
    
    <item>
      <title>Leetcode 852. 山脉数组的峰顶索引</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-852.-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Tue, 15 Jun 2021 20:49:55 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-852.-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/</guid>
      <description>链接： https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/
难度： 简单
题目描述 符合下列属性的数组 arr 称为 山脉数组 ：
 arr.length &amp;gt;= 3 存在 i（0 &amp;lt; i &amp;lt; arr.length - 1）使得：  arr[0] &amp;lt; arr[1] &amp;lt; &amp;hellip; arr[i-1] &amp;lt; arr[i] arr[i] &amp;gt; arr[i+1] &amp;gt; &amp;hellip; &amp;gt; arr[arr.length - 1]    给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] &amp;lt; arr[1] &amp;lt; ... arr[i - 1] &amp;lt; arr[i] &amp;gt; arr[i + 1] &amp;gt; ... &amp;gt; arr[arr.length - 1] 的下标 i 。
示例 1：  输入： arr = [0,1,0]</description>
    </item>
    
    <item>
      <title>Leetcode 374. 猜数字大小</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-374.-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/</link>
      <pubDate>Mon, 14 Jun 2021 10:50:24 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-374.-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/guess-number-higher-or-lower/
难度： 简单
题目描述 猜数字游戏的规则如下：
 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。  你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：
 -1：我选出的数字比你猜的数字小 pick &amp;lt; num 1：我选出的数字比你猜的数字大 pick &amp;gt; num 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num  返回我选出的数字。
示例 1：  输入： n = 10, pick = 6
输出： 6
 示例 2：  输入： n = 1, pick = 1
输出： 1
 示例 3：  输入： n = 2, pick = 1</description>
    </item>
    
    <item>
      <title>Leetcode 278. 第一个错误的版本</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-278.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</link>
      <pubDate>Sun, 13 Jun 2021 10:25:24 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-278.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</guid>
      <description>链接： https://leetcode-cn.com/problems/first-bad-version/
难度： 简单
题目描述 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。
示例 1：  给定 n = 5，并且 version = 4 是第一个错误的版本。
调用 isBadVersion(3) -&amp;gt; false
调用 isBadVersion(5) -&amp;gt; true
调用 isBadVersion(4) -&amp;gt; true
所以，4 是第一个错误的版本。  解题思路 二分查找 对于连续的版本号 [i, j] 每次判断版本号 (i+j)/2 是否出错，未出错查找范围缩小到 [(i+j)/2+1, j]，出错缩小到 [i, (i+j)/2]，直到 i = j 即得到首个出错的版本号 i
func firstBadVersion(n int) int { var binSearch func(i, j int) int binSearch = func(i, j int) int { if i == j { return i } mid := (i + j) / 2 if isBadVersion(mid) { return binSearch(i, mid) } else { return binSearch(mid+1, j) } } return binSearch(1, n) } 复杂度  时间复杂度：O(logN) 空间复杂度：O(1)  </description>
    </item>
    
    <item>
      <title>Leetcode 279. 完全平方数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-279.-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</link>
      <pubDate>Fri, 11 Jun 2021 19:33:36 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-279.-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/perfect-squares/
难度： 中等
题目描述 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。
示例 1：  输入： n = 12
输出： 3
解释： 12 = 4 + 4 + 4
 示例 2：  输入： n = 13
输出： 2
解释： 13 = 4 + 9
 注意： 你可以假设：
 1 &amp;lt;= n &amp;lt;= 104  解题思路 动态规划 dp[i] 表示组成数字 i 的最少完全平方数，易得到状态转移方程：</description>
    </item>
    
    <item>
      <title>Leetcode 518. 零钱兑换 II</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-518.-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii/</link>
      <pubDate>Thu, 10 Jun 2021 10:35:20 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-518.-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/coin-change-2/
难度： 中等
题目描述 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。
示例 1：  输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
 示例 2：  输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。
 示例 3：  输入: amount = 10, coins = [10]
输出: 1
 注意： 你可以假设：
 0 &amp;lt;= amount (总金额) &amp;lt;= 5000 1 &amp;lt;= coin (硬币面额) &amp;lt;= 5000 硬币种类不超过 500 种 结果符合 32 位符号整数  解题思路 动态规划 dp[i][j] 表示前 i 种面额的硬币，组成总金额 j 的方案数，则可以得到状态转移方程：</description>
    </item>
    
    <item>
      <title>Leetcode 1049. 最后一块石头的重量 II</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1049.-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-ii/</link>
      <pubDate>Tue, 08 Jun 2021 11:35:42 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1049.-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/last-stone-weight-ii/
难度： 中等
题目描述 有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。
每一回合，从中选出 任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &amp;lt;= y。那么粉碎的可能结果如下：
 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。  最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。
示例 1：  输入： stones = [2,7,4,1,8,1]
输出： 1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</description>
    </item>
    
    <item>
      <title>Leetcode 494. 目标和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-494.-%E7%9B%AE%E6%A0%87%E5%92%8C/</link>
      <pubDate>Mon, 07 Jun 2021 20:34:13 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-494.-%E7%9B%AE%E6%A0%87%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/target-sum/
难度： 中等
题目描述 给你一个整数数组 nums 和一个整数 target 。
向数组中的每个整数前添加 &#39;+&#39; 或 &#39;-&#39; ，然后串联起所有整数，可以构造一个 表达式 ：
 例如，nums = [2, 1] ，可以在 2 之前添加 &#39;+&#39; ，在 1 之前添加 &#39;-&#39; ，然后串联起来得到表达式 &amp;quot;+2-1&amp;quot; 。  返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。
示例 1：  输入： nums = [1,1,1,1,1], target = 3
输出： 5
解释： 一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3</description>
    </item>
    
    <item>
      <title>Leetcode 474. 一和零</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-474.-%E4%B8%80%E5%92%8C%E9%9B%B6/</link>
      <pubDate>Sun, 06 Jun 2021 10:08:43 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-474.-%E4%B8%80%E5%92%8C%E9%9B%B6/</guid>
      <description>链接： https://leetcode-cn.com/problems/ones-and-zeroes/
难度： 中等
题目描述 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。
请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。
如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。
示例 1：  输入： strs = [&amp;ldquo;10&amp;rdquo;, &amp;ldquo;0001&amp;rdquo;, &amp;ldquo;111001&amp;rdquo;, &amp;ldquo;1&amp;rdquo;, &amp;ldquo;0&amp;rdquo;], m = 5, n = 3
输出： 4
解释： 最多有 5 个 0 和 3 个 1 的最大子集是 {&amp;ldquo;10&amp;rdquo;,&amp;ldquo;0001&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;} ，因此答案是 4 。
其他满足题意但较小的子集包括 {&amp;ldquo;0001&amp;rdquo;,&amp;ldquo;1&amp;rdquo;} 和 {&amp;ldquo;10&amp;rdquo;,&amp;ldquo;1&amp;rdquo;,&amp;ldquo;0&amp;rdquo;} 。{&amp;ldquo;111001&amp;rdquo;} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</description>
    </item>
    
    <item>
      <title>Leetcode 203. 移除链表元素</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-203.-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</link>
      <pubDate>Sat, 05 Jun 2021 22:26:23 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-203.-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</guid>
      <description>链接： https://leetcode-cn.com/problems/remove-linked-list-elements/
难度： 简单
题目描述 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
示例 1： &amp;lt;img src=&amp;ldquo;https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg&#34;, width=&amp;ldquo;500px&amp;rdquo;&amp;gt;
 输入： head = [1,2,6,3,4,5,6], val = 6
输出： [1,2,3,4,5]
 示例 2：  输入： head = [], val = 1
输出： []
 示例 3：  输入： head = [7,7,7,7], val = 7
输出： []
 提示：  列表中的节点在范围 [0, 10] 内 1 &amp;lt;= Node.val &amp;lt;= 50 0 &amp;lt;= k &amp;lt;= 50  解题思路 模拟 遍历整个链表，遇到值为 val 的结点，将其从链表中删除。</description>
    </item>
    
    <item>
      <title>Leetcode 160. 相交链表</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-160.-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 04 Jun 2021 17:53:32 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-160.-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</guid>
      <description>链接： https://leetcode-cn.com/problems/intersection-of-two-linked-lists/
难度： 简单
题目描述 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
图示两个链表在节点 c1 开始相交：
题目数据 保证 整个链式结构中不存在环。
注意，函数返回结果后，链表必须 保持其原始结构。
示例1：  输入： intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出： Intersected at &amp;lsquo;8&amp;rsquo;
解释： 相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
 示例2： &amp;lt;img src=&amp;ldquo;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png&#34;, width=&amp;ldquo;350px&amp;rdquo;&amp;gt;
 输入： intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</description>
    </item>
    
    <item>
      <title>Leetcode 525. 连续数组</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-525.-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 03 Jun 2021 22:32:03 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-525.-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/contiguous-array/
难度： 中等
题目描述 给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。
示例1：  输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量0和1的最长连续子数组。
 示例2：  输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。
 示例3：  输入： nums = [23,2,6,4,7], k = 13
输出： false
 提示：  1 &amp;lt;= nums.length &amp;lt;= 105 nums[i] 不是 0 就是 1  解题思路 前缀和+哈希 在一段区间内，对该段区间求和即可得出 1 的数量，用区间长度减去 1 的数量，就可以得到 0 的数量，可以用前缀和降低时间复杂度。</description>
    </item>
    
    <item>
      <title>Leetcode 523. 连续的子数组和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-523.-%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</link>
      <pubDate>Wed, 02 Jun 2021 22:51:40 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-523.-%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/continuous-subarray-sum/
难度： 中等
题目描述 给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：
子数组大小 至少为 2 ，且 子数组元素总和为 k 的倍数。 如果存在，返回 true ；否则，返回 false 。
如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。
示例1：  输入： nums = [23,2,4,6,7], k = 6
输出： true
解释： [2,4] 是一个大小为 2 的子数组，并且和为 6 。
 示例2：  输入： nums = [23,2,6,4,7], k = 6
输出： true
解释： [23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。</description>
    </item>
    
    <item>
      <title>Leetcode 1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1744.-%E4%BD%A0%E8%83%BD%E5%9C%A8%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E9%82%A3%E5%A4%A9%E5%90%83%E5%88%B0%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E7%B3%96%E6%9E%9C%E5%90%97/</link>
      <pubDate>Tue, 01 Jun 2021 22:35:59 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1744.-%E4%BD%A0%E8%83%BD%E5%9C%A8%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E9%82%A3%E5%A4%A9%E5%90%83%E5%88%B0%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E7%B3%96%E6%9E%9C%E5%90%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/
难度： 中等
题目描述 给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。
你按照如下规则进行一场游戏：
 你从第 0 天开始吃糖果。 你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。  请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。
请你返回得到的数组 answer 。
示例1：  输入： candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]</description>
    </item>
    
    <item>
      <title>Leetcode 342. 4的幂</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-342.-4%E7%9A%84%E5%B9%82/</link>
      <pubDate>Mon, 31 May 2021 22:42:12 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-342.-4%E7%9A%84%E5%B9%82/</guid>
      <description>链接： https://leetcode-cn.com/problems/power-of-four/
难度： 简单
题目描述 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。
整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x
示例 1：  输入： n = 16
输出： true
 示例 2：  输入： n = 5
输出： false
 示例 3：  输入： n = 1
输出： true
 提示：  -231 &amp;lt;= n &amp;lt;= 231 - 1&amp;gt;  解题思路 二进制 2 的幂其二进制表示为最高位为 1，后跟偶数个 0 的数，每次向右移位两位，最终结果为 1，即说明是 4 的幂。</description>
    </item>
    
    <item>
      <title>Leetcode 231. 2 的幂</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-231.-2-%E7%9A%84%E5%B9%82/</link>
      <pubDate>Sun, 30 May 2021 11:06:34 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-231.-2-%E7%9A%84%E5%B9%82/</guid>
      <description>链接： https://leetcode-cn.com/problems/power-of-two/
难度： 简单
题目描述 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。
如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。
示例 1：  输入： n = 1
输出： true
解释： 20 = 1
 示例 2：  输入： n = 16
输出： true
解释： 24 = 16
 示例 3：  输入： n = 3
输出： false
 示例 4：  输入： n = 4
输出： true</description>
    </item>
    
    <item>
      <title>Leetcode 477. 汉明距离总和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-477.-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/</link>
      <pubDate>Fri, 28 May 2021 17:37:15 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-477.-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/total-hamming-distance/
难度： 中等
题目描述 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
计算一个数组中，任意两个数之间汉明距离的总和。
示例：  输入: x = 1, y = 4
输出: 2
解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）
所以答案为：
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.
 注意：  数组中元素的范围为从 0 到 109。 数组的长度不超过 104。  解题思路 按位计数 当一对数字某一位上的两个数字不同时，汉明距离的总和才会加一。故可以统计数组中相同位的 0 和 1 的数量，相乘可统计当前位的汉明距离和。
func totalHammingDistance(nums []int) int { totalDistance := 0 for i := 1 &amp;lt;&amp;lt; 30; i &amp;gt; 0; i &amp;gt;&amp;gt;= 1 { ones := 0 zeros := 0 for _, num := range nums { if num&amp;amp;i == 0 { zeros++ } else { ones++ } } totalDistance += ones * zeros } return totalDistance } 复杂度  时间复杂度：O(N*B) 空间复杂度：O(1)  </description>
    </item>
    
    <item>
      <title>Leetcode 461. 汉明距离</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-461.-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Thu, 27 May 2021 23:17:23 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-461.-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</guid>
      <description>链接： https://leetcode-cn.com/problems/hamming-distance/
难度： 简单
题目描述 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。
给出两个整数 x 和 y，计算它们之间的汉明距离。
注意：  0 ≤ x, y &amp;lt; 231  示例：  输入: x = 1, y = 4
输出: 2
解释:
1 (0 0 0 1)
4 (0 1 0 0)
↑ ↑
上面的箭头指出了对应二进制位不同的位置。
 解题思路 异或 异或操作可以得出标记出两个数二进制位不同的位置，然后统计数量即可。
func hammingDistance(x int, y int) int { distance := 0 for xor := x ^ y; xor != 0; xor &amp;gt;&amp;gt;= 1 { distance += xor &amp;amp; 1 } return distance } 复杂度  时间复杂度：O(logB) 空间复杂度：O(1)  </description>
    </item>
    
    <item>
      <title>Leetcode 1190. 反转每对括号间的子串</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1190.-%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Wed, 26 May 2021 23:59:13 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1190.-%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%90%E4%B8%B2/</guid>
      <description>链接： https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/
难度： 中等
题目描述 给出一个字符串 s（仅含有小写英文字母和括号）。
请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。
注意，您的结果中 不应 包含任何括号。
示例1：  输入： s = &amp;ldquo;(abcd)&amp;rdquo;
输出： &amp;ldquo;dcba&amp;rdquo;
 示例 2：  输入： s = &amp;ldquo;(u(love)i)&amp;rdquo;
输出： &amp;ldquo;iloveu&amp;rdquo;
 示例 3：  输入： s = &amp;ldquo;(ed(et(oc))el)&amp;rdquo;
输出： &amp;ldquo;leetcode&amp;rdquo;
 示例 4：  输入： s = &amp;ldquo;a(bcdefghijkl(mno)p)q&amp;rdquo;
输出： &amp;ldquo;apmnolkjihgfedcbq&amp;rdquo;
 提示：  0 &amp;lt;= s.length &amp;lt;= 2000 s 中只有小写英文字母和括号 我们确保所有括号都是成对出现的  解题思路 栈 利用栈来进行每一次的反转：
 当遇到非 ) 时，入栈； 当遇到 ) 时，依次从栈中取出元素加入一个队列，直到取出 ( 时为止，再将队列中的元素全部入栈，即先完成了内层括号的反转。  依次执行上述逻辑，直到遍历到字符串结尾，栈中元素即为反转后的结果。</description>
    </item>
    
    <item>
      <title>Leetcode 1707. 与数组中元素的最大异或值</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1707.-%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/</link>
      <pubDate>Sun, 23 May 2021 09:17:20 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1707.-%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/</guid>
      <description>链接： https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/
难度： 困难
题目描述 给你一个由非负整数组成的数组 nums 。另有一个查询数组 queries ，其中 queries[i] = [xi, mi] 。
第 i 个查询的答案是 xi 和任何 nums 数组中不超过 mi 的元素按位异或（XOR）得到的最大值。换句话说，答案是 max(nums[j] XOR xi) ，其中所有 j 均满足 nums[j] &amp;lt;= mi 。如果 nums 中的所有元素都大于 mi，最终答案就是 -1 。
返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。
示例1：  输入： nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]
输出： [3,3,7]
解释：
 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。 1 XOR 2 = 3.</description>
    </item>
    
    <item>
      <title>Leetcode 1035. 不相交的线</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1035.-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF/</link>
      <pubDate>Fri, 21 May 2021 23:42:03 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1035.-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF/</guid>
      <description>链接： https://leetcode-cn.com/problems/uncrossed-lines/
难度： 中等
题目描述 在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。
现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：
 nums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。
以这种方法绘制线条，并返回可以绘制的最大连线数。
示例1：  输入： nums1 = [1,4,2], nums2 = [1,2,4]
输出： 2
解释： 可以画出两条不交叉的线，如上图所示。
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。
 示例2：  输入： nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]
输出： 3
 示例3:  输入： nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]
输出： 2
 提示：  1 &amp;lt;= nums1.</description>
    </item>
    
    <item>
      <title>Leetcode 692. 前K个高频单词</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-692.-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/</link>
      <pubDate>Thu, 20 May 2021 21:45:44 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-692.-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/</guid>
      <description>链接： https://leetcode-cn.com/problems/top-k-frequent-words/
难度： 中等
题目描述 给一非空的单词列表，返回前 k 个出现次数最多的单词。
返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。
示例1：  输入: [&amp;ldquo;i&amp;rdquo;, &amp;ldquo;love&amp;rdquo;, &amp;ldquo;leetcode&amp;rdquo;, &amp;ldquo;i&amp;rdquo;, &amp;ldquo;love&amp;rdquo;, &amp;ldquo;coding&amp;rdquo;], k = 2
输出: [&amp;ldquo;i&amp;rdquo;, &amp;ldquo;love&amp;rdquo;]
解析: &amp;ldquo;i&amp;rdquo; 和 &amp;ldquo;love&amp;rdquo; 为出现次数最多的两个单词，均为2次。
注意，按字母顺序 &amp;ldquo;i&amp;rdquo; 在 &amp;ldquo;love&amp;rdquo; 之前。
 示例2：  输入: [&amp;ldquo;the&amp;rdquo;, &amp;ldquo;day&amp;rdquo;, &amp;ldquo;is&amp;rdquo;, &amp;ldquo;sunny&amp;rdquo;, &amp;ldquo;the&amp;rdquo;, &amp;ldquo;the&amp;rdquo;, &amp;ldquo;the&amp;rdquo;, &amp;ldquo;sunny&amp;rdquo;, &amp;ldquo;is&amp;rdquo;, &amp;ldquo;is&amp;rdquo;], k = 4
输出: [&amp;ldquo;the&amp;rdquo;, &amp;ldquo;is&amp;rdquo;, &amp;ldquo;sunny&amp;rdquo;, &amp;ldquo;day&amp;rdquo;]
解析: &amp;ldquo;the&amp;rdquo;, &amp;ldquo;is&amp;rdquo;, &amp;ldquo;sunny&amp;rdquo; 和 &amp;ldquo;day&amp;rdquo; 是出现次数最多的四个单词，
出现次数依次为 4, 3, 2 和 1 次。</description>
    </item>
    
    <item>
      <title>Leetcode 1738. 找出第 K 大的异或坐标值</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1738.-%E6%89%BE%E5%87%BA%E7%AC%AC-k-%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96%E5%9D%90%E6%A0%87%E5%80%BC/</link>
      <pubDate>Wed, 19 May 2021 22:46:08 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1738.-%E6%89%BE%E5%87%BA%E7%AC%AC-k-%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96%E5%9D%90%E6%A0%87%E5%80%BC/</guid>
      <description>链接： https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/
难度： 中等
题目描述 给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。
矩阵中坐标 (a, b) 的 值 可由对所有满足 0 &amp;lt;= i &amp;lt;= a &amp;lt; m 且 0 &amp;lt;= j &amp;lt;= b &amp;lt; n 的元素 matrix[i][j]（下标从 0 开始计数）执行异或运算得到。
请你找出 matrix 的所有坐标中第 k 大的值（k 的值从 1 开始计数）。
示例1：  输入： matrix = [[5,2],[1,6]], k = 1
输出： 7
解释： 坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。
 示例2：  输入： matrix = [[5,2],[1,6]], k = 2</description>
    </item>
    
    <item>
      <title>Leetcode 1442. 形成两个异或相等数组的三元组数目</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1442.-%E5%BD%A2%E6%88%90%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%88%96%E7%9B%B8%E7%AD%89%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE/</link>
      <pubDate>Tue, 18 May 2021 22:40:57 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1442.-%E5%BD%A2%E6%88%90%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%88%96%E7%9B%B8%E7%AD%89%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE/</guid>
      <description>链接： https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/
难度： 中等
题目描述 给你一个整数数组 arr 。
现需要从数组中取三个下标 i、j 和 k ，其中 (0 &amp;lt;= i &amp;lt; j &amp;lt;= k &amp;lt; arr.length) 。
a 和 b 定义如下：
 a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1] b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k] 注意：^ 表示 按位异或 操作。  请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。
示例1：  输入： arr = [2,3,1,6,7]</description>
    </item>
    
    <item>
      <title>Leetcode 993. 二叉树的堂兄弟节点</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-993.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/</link>
      <pubDate>Mon, 17 May 2021 09:29:10 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-993.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/cousins-in-binary-tree/
难度： 简单
题目描述 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。
如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。
我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。
只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。
示例1： &amp;lt;img src=&amp;ldquo;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png&#34;, width=&amp;ldquo;180px&amp;rdquo;&amp;gt;
 输入： root = [1,2,3,4], x = 4, y = 3
输出： false
 示例2： &amp;lt;img src=&amp;ldquo;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png&#34;, width=&amp;ldquo;201px&amp;rdquo;&amp;gt;
 输入： root = [1,2,3,null,4,null,5], x = 5, y = 4
输出： true
 示例3： &amp;lt;img src=&amp;ldquo;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png&#34;, width=&amp;ldquo;156px&amp;rdquo;&amp;gt;</description>
    </item>
    
    <item>
      <title>Leetcode 421. 数组中两个数的最大异或值</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-421.-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/</link>
      <pubDate>Sun, 16 May 2021 22:31:57 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-421.-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/</guid>
      <description>链接： https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/
难度： 中等
题目描述 给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j &amp;lt; n 。
**进阶：**你可以在 O(n) 的时间解决这个问题吗？
示例1：  输入： nums = [3,10,5,25,2,8]
输出： 28
解释： 最大运算结果是 5 XOR 25 = 28.
 示例2：  输入： nums = [0]
输出： 0
 示例3：  输入： nums = [2,4]
输出： 6
 示例4：  输入： nums = [8,10,2]
输出： 10
 示例5：  输入： nums = [14,70,53,83,49,91,36,80,92,51,66,70]</description>
    </item>
    
    <item>
      <title>Leetcode 12. 整数转罗马数字</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-12.-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 14 May 2021 17:30:13 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-12.-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/integer-to-roman/
难度： 中等
题目描述 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。
字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</description>
    </item>
    
    <item>
      <title>Leetcode 1269. 停在原地的方案数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1269.-%E5%81%9C%E5%9C%A8%E5%8E%9F%E5%9C%B0%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/</link>
      <pubDate>Thu, 13 May 2021 23:12:12 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1269.-%E5%81%9C%E5%9C%A8%E5%8E%9F%E5%9C%B0%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/
难度： 困难
题目描述 有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。
每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。
给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。
由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。
示例1：  输入： steps = 3, arrLen = 2
输出： 4
解释： 3 步后，总共有 4 种不同的方法可以停在索引 0 处。
向右，向左，不动
不动，向右，向左
向右，不动，向左
不动，不动，不动
 示例2：  输入： steps = 2, arrLen = 4
输出： 2
解释： 2 步后，总共有 2 种不同的方法可以停在索引 0 处。
向右，向左</description>
    </item>
    
    <item>
      <title>Leetcode 1310. 子数组异或查询</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1310.-%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Wed, 12 May 2021 23:14:18 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1310.-%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2/</guid>
      <description>链接： https://leetcode-cn.com/problems/xor-queries-of-a-subarray/
难度： 中等
题目描述 有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。
对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。
并返回一个包含给定查询 queries 所有结果的数组。
示例1：  输入： arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]
输出： [2,7,14,8]
解释：
数组中元素的二进制表示形式是：
1 = 0001
3 = 0011
4 = 0100
8 = 1000
查询的 XOR 值为：
[0,1] = 1 xor 3 = 2
[1,2] = 3 xor 4 = 7</description>
    </item>
    
    <item>
      <title>Leetcode 1734. 解码异或后的排列</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1734.-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97/</link>
      <pubDate>Tue, 11 May 2021 19:55:25 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1734.-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97/</guid>
      <description>链接： https://leetcode-cn.com/problems/decode-xored-permutation/
难度： 中等
题目描述 给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。
它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。
给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。
示例1：  输入： encoded = [3,1]
输出： [1,2,3]
解释： 如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]
 示例2：  输入： encoded = [6,5,4,6]</description>
    </item>
    
    <item>
      <title>Leetcode 872. 叶子相似的树</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-872.-%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91/</link>
      <pubDate>Mon, 10 May 2021 23:30:50 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-872.-%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91/</guid>
      <description>链接： https://leetcode-cn.com/problems/leaf-similar-trees/
难度： 简单
题目描述 请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。
举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。
如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。
如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。
示例1：  输入： root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]
输出： true
 示例2：  输入： root1 = [1], root2 = [1]
输出： true
 示例3：  输入： root1 = [1], root2 = [2]
输出： false
 示例4：  输入： root1 = [1,2], root2 = [2,2]</description>
    </item>
    
    <item>
      <title>Leetcode 1486. 数组异或操作</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1486.-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Fri, 07 May 2021 17:05:42 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1486.-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/</guid>
      <description>链接： https://leetcode-cn.com/problems/xor-operation-in-an-array/
难度： 简单
题目描述 给你两个整数，n 和 start 。
数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。
请返回 nums 中所有元素按位异或（XOR）后得到的结果。
示例1：  输入： n = 5, start = 0
输出： 8
解释： 数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。
&amp;ldquo;^&amp;rdquo; 为按位异或 XOR 运算符。
 示例2：  输入： n = 4, start = 3</description>
    </item>
    
    <item>
      <title>Leetcode 1720. 解码异或后的数组</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1720.-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 06 May 2021 23:09:07 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1720.-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84/</guid>
      <description>链接： https://leetcode-cn.com/problems/decode-xored-array/
难度： 中等
题目描述 未知 整数数组 arr 由 n 个非负整数组成。
经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。
给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。
请解码返回原数组 arr 。可以证明答案存在并且是唯一的。
示例1：  输入： encoded = [1,2,3], first = 1
输出： [1,0,2,1]
解释： 若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]</description>
    </item>
    
    <item>
      <title>Leetcode 740. 删除并获得点数</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-740.-%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/</link>
      <pubDate>Wed, 05 May 2021 23:47:15 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-740.-%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/</guid>
      <description>链接： https://leetcode-cn.com/problems/delete-and-earn/
难度： 中等
题目描述 给你一个整数数组 nums ，你可以对它进行一些操作。
每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。
开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。
示例1：  输入： nums = [3,4,2]
输出： 6
解释： 删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。
 示例2：  输入： nums = [2,2,3,3,3,4]
输出： 9
解释： 删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。</description>
    </item>
    
    <item>
      <title>Leetcode 7. 整数反转</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-7.-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</link>
      <pubDate>Mon, 03 May 2021 11:57:39 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-7.-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</guid>
      <description>链接： https://leetcode-cn.com/problems/reverse-integer/
难度： 简单
题目描述 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。
示例1：  输入： x = 123
输出： 321
 示例2：  输入： x = -123
输出： -321
 示例3：  输入： x = 120
输出： 21
 示例4：  输入： x = 0
输出： 0
 提示：  -231 &amp;lt;= x &amp;lt;= 231 - 14  解题思路 双指针 直接数字逐位反转，当数字为十位数时，32位整数无法存储，需要做一次溢位判断：</description>
    </item>
    
    <item>
      <title>Leetcode 554. 砖墙</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-554.-%E7%A0%96%E5%A2%99/</link>
      <pubDate>Sun, 02 May 2021 10:03:17 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-554.-%E7%A0%96%E5%A2%99/</guid>
      <description>链接： https://leetcode-cn.com/problems/brick-wall/
难度： 中等
题目描述 你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。
你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。
给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。
示例1： &amp;lt;img src=&amp;ldquo;https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg&#34;, width=&amp;ldquo;493px&amp;rdquo;&amp;gt;
 输入： wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]
输出： 2
 示例2：  输入： wall = [[1],[1],[1]]
输出： 3
 提示：  n == wall.length 1 &amp;lt;= n &amp;lt;= 104 1 &amp;lt;= wall[i].length &amp;lt;= 104 1 &amp;lt;= sum(wall[i].length) &amp;lt;= 2 * 104 对于每一行 i ，sum(wall[i]) 应当是相同的 1 &amp;lt;= wall[i][j] &amp;lt;= 231 - 1  解题思路 计数 以每一行起点为 0 坐标，可以使得同一列的缝隙唯一标识，从而标记出所有缝隙的列坐标。</description>
    </item>
    
    <item>
      <title>Leetcode 690. 员工的重要性</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-690.-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</link>
      <pubDate>Sat, 01 May 2021 21:20:28 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-690.-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/</guid>
      <description>链接： https://leetcode-cn.com/problems/employee-importance/
难度： 简单
题目描述 给定一个保存员工信息的数据结构，它包含了员工 唯一的 id ，重要度 和 直系下属的 id 。
比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在员工 1 的数据结构中。
现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。
示例：  输入： [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1</description>
    </item>
    
    <item>
      <title>Leetcode 137. 只出现一次的数字 II</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-137.-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-ii/</link>
      <pubDate>Fri, 30 Apr 2021 18:18:49 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-137.-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-ii/</guid>
      <description>链接： https://leetcode-cn.com/problems/single-number-ii/
难度： 中等
题目描述 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。
示例1：  输入： nums = [2,2,3,2] 输出： 3
 示例2：  输入： nums = [0,1,0,1,0,1,99] 输出： 99
 提示：  1 &amp;lt;= nums.length &amp;lt;= 3 * 104 -231 &amp;lt;= nums[i] &amp;lt;= 231 - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次  **进阶：**你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
解题思路 哈希 统计每个数出现的次数，然后找出其中只出现一次的数
func singleNumber(nums []int) int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ } for k, v := range cnt { if v == 1 { return k } } return 0 } 复杂度  时间复杂度：O(N) 空间复杂度：O(N)  排序 将整个数组排序，没三个一组进行首尾比较，相同继续，不同返回。</description>
    </item>
    
    <item>
      <title>Leetcode 403. 青蛙过河</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-403.-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/</link>
      <pubDate>Thu, 29 Apr 2021 14:21:06 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-403.-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/</guid>
      <description>链接： https://leetcode-cn.com/problems/frog-jump/
难度： 困难
题目描述 一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。
给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。
开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。
如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。
示例1：  输入： stones = [0,1,3,5,6,8,12,17]
输出： true
解释： 青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</description>
    </item>
    
    <item>
      <title>Leetcode 633. 平方数之和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-633.-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Wed, 28 Apr 2021 22:46:56 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-633.-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/sum-of-square-numbers/
难度： 中等
题目描述 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。
示例1：  输入： c = 5
输出： true
解释： 1 * 1 + 2 * 2 = 5
 示例2：  输入： c = 3
输出： false
 示例3：  输入： c = 4
输出： true
 示例4：  输入： c = 2
输出： true
 示例5：  输入： c = 1 输出： true</description>
    </item>
    
    <item>
      <title>Leetcode 938. 二叉搜索树的范围和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-938.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</link>
      <pubDate>Tue, 27 Apr 2021 10:31:11 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-938.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/range-sum-of-bst/
难度： 简单
题目描述 给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。
示例1：  输入： root = [10,5,15,3,7,null,18], low = 7, high = 15
输出： 32
 示例2：  输入： root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10
输出： 23
 提示：  树中节点数目在范围 [1, 2 * 104] 内 1 &amp;lt;= Node.val &amp;lt;= 105 1 &amp;lt;= low &amp;lt;= high &amp;lt;= 105 所有 Node.val 互不相同  解题思路 深度优先搜索 不同于一般搜索树的搜索，该搜索需要遍历整颗树，以累计求和，必要部分需要剪枝加快遍历速度。
搜索时需要区分三种情况：
 当前结点值 val &amp;lt; low 时，左子树均不满足条件，继续搜索右子树； 当前结点值 val &amp;gt; high 时，右子树均不满足条件，继续搜索左子树； 其余情况，累加当前结点值，无法剪枝，左右子树都需要继续搜索。  func rangeSumBST(root *TreeNode, low int, high int) int { sum := 0 var search func(node *TreeNode) search = func(node *TreeNode) { if node == nil { return } if node.</description>
    </item>
    
    <item>
      <title>Leetcode 1011. 在 D 天内送达包裹的能力</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-1011.-%E5%9C%A8-d-%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/</link>
      <pubDate>Mon, 26 Apr 2021 11:10:26 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-1011.-%E5%9C%A8-d-%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/</guid>
      <description>链接： https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/
难度： 中等
题目描述 传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。
传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。
返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。
示例1：  输入： weights = [1,2,3,4,5,6,7,8,9,10], D = 5
输出： 15
解释：
船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
第 1 天：1, 2, 3, 4, 5
第 2 天：6, 7
第 3 天：8
第 4 天：9
第 5 天：10
请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。
 示例2：  输入： weights = [3,2,2,4,1,4], D = 3</description>
    </item>
    
    <item>
      <title>Leetcode 897. 递增顺序搜索树</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-897.-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sun, 25 Apr 2021 11:41:33 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-897.-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>链接： https://leetcode-cn.com/problems/increasing-order-search-tree/
难度： 简单
题目描述 给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。
示例1：  输入： root = [5,3,6,2,4,null,8,1,null,null,null,7,9]
输出： [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
 示例2：  输入： root = [5,1,7]
输出： [1,null,5,null,7]
 提示：  树中节点数的取值范围是 [1, 100] 0 &amp;lt;= Node.val &amp;lt;= 1000  解题思路 新建树 重新构造一棵树，中序遍历原树的每个结点，将其加入到新树的右结点中。
func increasingBST(root *TreeNode) *TreeNode { newRoot := new(TreeNode) newNode := newRoot var InorderTraversal func(node *TreeNode) InorderTraversal = func(node *TreeNode) { if node == nil { return } InorderTraversal(node.Left) newNode.Right = &amp;amp;TreeNode{ Val: node.</description>
    </item>
    
    <item>
      <title>Leetcode 377. 组合总和 Ⅳ</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-377.-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</link>
      <pubDate>Sat, 24 Apr 2021 21:50:28 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-377.-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/combination-sum-iv/ 难度： 中等
题目描述 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。
题目数据保证答案符合 32 位整数范围。
示例1：  输入： nums = [1,2,3], target = 4
输出： 7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
 示例2：  输入： nums = [9], target = 3
输出： 0
 提示：  1 &amp;lt;= nums.length &amp;lt;= 200 1 &amp;lt;= nums[i] &amp;lt;= 1000 nums 中的所有元素 互不相同 1 &amp;lt;= target &amp;lt;= 1000  解题思路 动态规划 用 dp[i] 表示当 i 作为 target 时，排列方案的数量。当 dp[i] 不为 0 时，不妨假设排列的做后一位数字为 num，则 i-num 的排列数为 dp[i-num] ，容易得知状态转移方程：</description>
    </item>
    
    <item>
      <title>Leetcode 363. 矩形区域不超过 K 的最大数值和</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-363.-%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87-k-%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC%E5%92%8C/</link>
      <pubDate>Thu, 22 Apr 2021 10:41:53 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-363.-%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87-k-%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC%E5%92%8C/</guid>
      <description>链接： https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/
难度： 困难
题目描述 给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。
题目数据保证总会存在一个数值和不超过 k 的矩形区域。
示例1：  输入： matrix = [[1,0,1],[0,-2,3]], k = 2
输出： 2
解释： 蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。
 示例2：  输入： matrix = [[2,2,-1]], k = 3
输出： 3
 提示：  m == matrix.length n == matrix[i].length -100 &amp;lt;= matrix[i][j] &amp;lt;= 100 -105 &amp;lt;= k &amp;lt;= 105  解题思路 暴力求解 以每个元素为起点，求解</description>
    </item>
    
    <item>
      <title>Leetcode 91. 解码方式</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-91.-%E8%A7%A3%E7%A0%81%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Wed, 21 Apr 2021 10:35:45 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-91.-%E8%A7%A3%E7%A0%81%E6%96%B9%E5%BC%8F/</guid>
      <description>链接： https://leetcode-cn.com/problems/decode-ways/
难度： 中等
题目描述 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
&#39;A&#39; -&amp;gt; 1 &#39;B&#39; -&amp;gt; 2 ... &#39;Z&#39; -&amp;gt; 26 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，&amp;quot;11106&amp;quot; 可以映射为：
 &amp;quot;AAJF&amp;quot; ，将消息分组为 (1 1 10 6) &amp;quot;KJF&amp;quot; ，将消息分组为 (11 10 6)  注意，消息不能分组为 (1 11 06) ，因为 &amp;quot;06&amp;quot; 不能映射为 &amp;quot;F&amp;quot; ，这是由于 &amp;quot;6&amp;quot; 和 &amp;quot;06&amp;quot; 在映射中并不等价。
给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
题目数据保证答案肯定是一个 32 位 的整数。
示例1：  输入： s = &amp;ldquo;12&amp;rdquo;
输出： 2</description>
    </item>
    
    <item>
      <title>Leetcode 165. 比较版本号</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-165.-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</link>
      <pubDate>Tue, 20 Apr 2021 20:33:19 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-165.-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/</guid>
      <description>链接： https://leetcode-cn.com/problems/compare-version-numbers/
难度： 中等
题目描述 给你两个版本号 version1 和 version2 ，请你比较它们。
版本号由一个或多个修订号组成，各修订号由一个 &#39;.&#39; 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。
比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 &amp;lt; 1 。
返回规则如下：
 如果 version1 &amp;gt; version2 返回 1， 如果 version1 &amp;lt; version2 返回 -1， 除此之外返回 0。  示例1：  输入： version1 = &amp;ldquo;1.</description>
    </item>
    
    <item>
      <title>Leetcode 28. 实现 strStr()</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-28.-%E5%AE%9E%E7%8E%B0-strstr/</link>
      <pubDate>Tue, 20 Apr 2021 17:21:05 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-28.-%E5%AE%9E%E7%8E%B0-strstr/</guid>
      <description>链接： https://leetcode-cn.com/problems/implement-strstr/
难度： 简单
题目描述 实现 strStr() 函数。
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。
说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。
示例1：  输入： haystack = &amp;ldquo;hello&amp;rdquo;, needle = &amp;ldquo;ll&amp;rdquo;
输出： 2
 示例2：  输入： haystack = &amp;ldquo;aaaaa&amp;rdquo;, needle = &amp;ldquo;bba&amp;rdquo;
输出： -1
 示例3：  输入： haystack = &amp;ldquo;&amp;rdquo;, needle = &amp;quot;&amp;quot;</description>
    </item>
    
    <item>
      <title>Leetcode 27. 移除元素</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-27.-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</link>
      <pubDate>Mon, 19 Apr 2021 10:34:28 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-27.-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</guid>
      <description>链接： https://leetcode-cn.com/problems/remove-element/
难度： 简单
题目描述 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
说明： 为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &amp;lt; len; i++) { print(nums[i]); } 示例1：  输入： nums = [3,2,2,3], val = 3
输出： 2, nums = [2,2]
解释： 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</description>
    </item>
    
    <item>
      <title>Leetcode 26. 删除有序数组中的重复项</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-26.-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Sun, 18 Apr 2021 10:52:18 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-26.-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>链接： https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/
难度： 简单
题目描述 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
说明： 为什么返回数值是整数，但输出的答案是数组呢?
请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。
你可以想象内部操作如下:
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i &amp;lt; len; i++) { print(nums[i]); } 示例1：  输入： nums = [1,1,2]
输出： 2, nums = [1,2]
解释： 函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
 示例2：  输入： nums = [0,0,1,1,1,2,2,3,3,4]</description>
    </item>
    
    <item>
      <title>Leetcode 220. 存在重复元素 III</title>
      <link>https://xianlianghe0123.github.io/p/leetcode-220.-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-iii/</link>
      <pubDate>Sat, 17 Apr 2021 20:58:46 +0800</pubDate>
      
      <guid>https://xianlianghe0123.github.io/p/leetcode-220.-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-iii/</guid>
      <description>链接： https://leetcode-cn.com/problems/contains-duplicate-iii/
难度： 中等
题目描述 给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) &amp;lt;= t ，同时又满足 abs(i - j) &amp;lt;= k 。
如果存在则返回 true，不存在返回 false。
示例：  输入： nums = [1,2,3,1], k = 3, t = 0
输出： true
 示例：  输入： nums = [1,0,1,1], k = 1, t = 2
输出： true
 示例：  输入： nums = [1,5,9,1,5,9], k = 2, t = 3</description>
    </item>
    
  </channel>
</rss>
