[{"content":"链接： https://leetcode-cn.com/problems/sum-of-two-integers/\n难度： 中等\n题目描述  给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。  示例 1：  输入： a = 1, b = 2\n输出： 3\n 示例 2：  输入： a = 2, b = 3\n输出： 5\n 提示：  -1000 \u0026lt;= a, b \u0026lt;= 1000  解题思路 位运算 以二进制位为单位进行运算，从最低位开始，使用位操作符诸位运算。\n由于负数在计算机中存储的是补码，直接诸位求和即可，用 c 表示进位，利用 数字电路设计 得到计算方法如下：\n 当前位计算结果为：$a\\oplus b\\oplus c$ 进位的计算结果为：$(a\\oplus b)c + ab$  func getSum(a int, b int) int { c := 0 ans := 0 for bit := 1; bit != 0; bit \u0026lt;\u0026lt;= 1 { ans |= (a ^ b ^ c) \u0026amp; bit c = (((a ^ b) \u0026amp; c) | (a \u0026amp; b)) \u0026amp; bit \u0026lt;\u0026lt; 1 } return ans } 复杂度  时间复杂度：$ O(\\log{MaxInt}) $ 空间复杂度：$ O(1) $  ","date":"2021-09-26T09:38:03+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-371.-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/","title":"Leetcode 371. 两整数之和"},{"content":"链接： https://leetcode-cn.com/problems/delete-operation-for-two-strings/\n难度： 中等\n题目描述 给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。\n示例：  输入: \u0026ldquo;sea\u0026rdquo;, \u0026ldquo;eat\u0026rdquo;\n输出: 2\n解释: 第一步将\u0026quot;sea\u0026quot;变为\u0026quot;ea\u0026quot;，第二步将\u0026quot;eat\u0026quot;变为\u0026quot;ea\u0026quot;\n 提示：  给定单词的长度不超过500。 给定单词中的字符只含有小写字母。  **进阶：**你可以设计一个时间复杂度为 $O(n)$ 的解决方案吗？\n解题思路 动态规划 最长公共子序列(LCS)的变种，求得最长公共子序列的长度，返回剩余字符的数量。\n使用 dp[i][j] 表示分别以 i 和 j 为 word1 和 word2 前缀长度的最长公共子序列，其状态转移方程如下：\n 初始时，dp[0][j] = dp[i][0] = 0 当 word1[i] = word2[j] 时，dp[i][j] = dp[i-1][j-1] + 1；否则，dp[i][j] = max(dp[i-1][j], dp[i][j-1])  func minDistance(word1 string, word2 string) int { dp := make([][]int, len(word1)+1) dp[0] = make([]int, len(word2)+1) for i := range word1 { dp[i+1] = make([]int, len(word2)+1) for j := range word2 { if word1[i] == word2[j] { dp[i+1][j+1] = dp[i][j] + 1 continue } dp[i+1][j+1] = dp[i+1][j] if dp[i+1][j+1] \u0026lt; dp[i][j+1] { dp[i+1][j+1] = dp[i][j+1] } } } return len(word1) + len(word2) - (dp[len(word1)][len(word2)] \u0026lt;\u0026lt; 1) } 复杂度  时间复杂度：$ O(NM), N = len(word1), M = len(word2) $ 空间复杂度：$ O(NM) $  动态规划 使用 dp[i][j] 表示分别以 i 和 j 为 word1 和 word2 前缀结尾的最少删除操作次数，其状态转移方程如下：\n 初始时，dp[0][j] = j, dp[i][0] = i 当 word1[i] = word2[j] 时，dp[i][j] = dp[i-1][j-1]；否则，dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1。  func minDistance(word1 string, word2 string) int { dp := make([][]int, len(word1)+1) dp[0] = make([]int, len(word2)+1) for j := range word2 { dp[0][j+1] = j+1 } for i := range word1 { dp[i+1] = make([]int, len(word2)+1) dp[i+1][0] = i+1 for j := range word2 { if word1[i] == word2[j] { dp[i+1][j+1] = dp[i][j] continue } dp[i+1][j+1] = dp[i+1][j] if dp[i+1][j+1] \u0026gt; dp[i][j+1] { dp[i+1][j+1] = dp[i][j+1] } dp[i+1][j+1]++ } } return dp[len(word1)][len(word2)] } 复杂度  时间复杂度：$ O(NM), N = len(word1), M = len(word2) $ 空间复杂度：$ O(NM) $  ","date":"2021-09-25T10:46:36+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-583.-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/","title":"Leetcode 583. 两个字符串的删除操作"},{"content":"链接： https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/\n难度： 中等\n题目描述 多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。\n给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。\n示例1：  输入： head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n输出： [1,2,3,7,8,11,12,9,10,4,5,6]\n解释：\n输入的多级列表如下图所示：\n扁平化后的链表如下图：\n 示例 2：  输入： head = [1,2,null,3]\n输出： [1,3,2]\n解释：\n输入的多级列表如下图所示：\n 1---2---NULL | 3---NULL  示例 3：  输入： head = []\n输出： []\n 如何表示测试用例中的多级链表？ 以 示例 1 为例：\n 1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULL 序列化其中的每一级之后：\n[1,2,3,4,5,6,null] [7,8,9,10,null] [11,12,null] 为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。\n[1,2,3,4,5,6,null] [null,null,7,8,9,10,null] [null,11,12,null] 合并所有序列化结果，并去除末尾的 null 。\n[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] 提示：  节点数目不超过 1000 1 \u0026lt;= Node.val \u0026lt;= 105  解题思路 深度优先搜索 采用深度优先搜索，遍历当前链表，当遇到 Child 非空时，优先遍历 Child 链表，每次遍历结束返回链表尾部的指针。\n遍历完成 Child 后，将 Next 结点连接到返回的尾部，并将 Child 的头结点时候连接到当前节点。\nfunc flatten(root *Node) *Node { var dfs func(head *Node) *Node dfs = func(head *Node) *Node { tail := head for node := head; node != nil; node = node.Next { if node.Child != nil { tail := dfs(node.Child) if node.Next != nil { tail.Next = node.Next node.Next.Prev = tail } node.Next = node.Child node.Child.Prev = node node.Child = nil } tail = node } return tail } dfs(root) return root } 复杂度  时间复杂度：$ O(N), N = size(List) $ 空间复杂度：$ O(\\log{N}) $  ","date":"2021-09-24T10:35:19+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-430.-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","title":"Leetcode 430. 扁平化多级双向链表"},{"content":"链接： https://leetcode-cn.com/problems/power-of-three/\n难度： 简单\n题目描述 给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。\n整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x\n示例 1：  输入： n = 27\n输出： true\n 示例 2：  输入： n = 0\n输出： false\n 示例 3：  输入： n = 9\n输出： true\n 示例 4：  输入： n = 45\n输出： false\n 提示：  -231 \u0026lt;= n \u0026lt;= 231 - 1  解题思路 试除法 当当前数字可以被 3 的整除，则除以 3，知道不能被 3 整除为止。\n若最后值为 1，返回 true；否则，返回 false。\n对 ≤ 0 的值一开始进行特判，返回 false。\nfunc isPowerOfThree(n int) bool { if n \u0026lt;= 0 { return false } for n%3 == 0 { n /= 3 } return n == 1 } 复杂度  时间复杂度：$ O(\\log{n}) $ 空间复杂度：$ O(1) $  ","date":"2021-09-23T14:50:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-326.-3%E7%9A%84%E5%B9%82/","title":"Leetcode 326. 3的幂"},{"content":"链接： https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/\n难度： 中等\n题目描述 把 n 个骰子扔在地上，所有骰子朝上一面的点数之和为 s。输入 n，打印出 s 的所有可能的值出现的概率。\n你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。\n示例 1：  输入: 1\n输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]\n 示例 2：  输入: 2\n输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]\n 限制：  1 \u0026lt;= n \u0026lt;= 11  解题思路 动态规划 由于每个骰子的掷出的点数是独立的，使用 dp[i][j] 表示掷出 i 个骰子，点数之和为 j 的概率：\n 初始，dp[0][0] = 1 后续，dp[i][j] = \u0008d[i-1][j-1] / 6 + dp[i-1][j-2] / 6 + ... + dp[i-1][j-6] / 6  使用滚动数组的方式降低空间复杂度。\nfunc dicesProbability(n int) []float64 { dp := []float64{1} for i := 1; i \u0026lt;= n; i++ { dpNew := make([]float64, len(dp)+5) for j := range dp { for k := j; k \u0026lt; j+6; k++ { dpNew[k] += dp[j] / 6 } } dp = dpNew } return dp } 复杂度  时间复杂度：$ O(n^2) $ 空间复杂度：$ O(n) $  ","date":"2021-09-22T20:29:42+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-60.-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/","title":"剑指 Offer 60. n个骰子的点数"},{"content":"链接： https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/\n难度： 简单\n题目描述 输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。\n示例 1：  输入： nums = [2,7,11,15], target = 9\n输出： [2,7] 或者 [7,2]\n 示例 2：  输入： nums = [10,26,30,31,47,60], target = 40\n输出： [10,30] 或者 [30,10]\n 限制：  1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 106  解题思路 哈希 使用哈希表记录每个数字是否出现过，遍历数组，计算对应的另一个数，若已出现过则返回这两个数。\nfunc twoSum(nums []int, target int) []int { hash := make(map[int]struct{}) for _, num := range nums { if _, ok := hash[target-num]; ok { return []int{num, target - num} } hash[num] = struct{}{} } return make([]int, 0) } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  双指针 使用两个指针 i, j 从头尾分别向中间遍历：\n 当 nums[i] + nums[j] = target 时，返回； 当 nums[i] + nums[j] \u0026lt; target 时，i + 1； 当 nums[i] + nums[j] \u0026gt; target 时，j + 1。  当两个指针相交的时候，结束遍历。\nfunc twoSum(nums []int, target int) []int { for i, j := 0, len(nums)-1; i \u0026lt; j; { if nums[i]+nums[j] == target { return []int{nums[i], nums[j]} } else if nums[i]+nums[j] \u0026lt; target { i++ } else { j-- } } return make([]int, 0) } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $  ","date":"2021-09-22T19:39:43+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-57.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/","title":"剑指 Offer 57. 和为s的两个数字"},{"content":"链接： https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/\n难度： 简单\n题目描述 给定一棵二叉搜索树，请找出其中第k大的节点。\n示例 1：  输入: root = [3,1,4,null,2], k = 1\n 3 / \\ 1 4 \\ 2 输出: 4\n 示例 2：  输入: root = [5,3,6,2,4,null,null,1], k = 3\n 5 / \\ 3 6 / \\ 2 4 / 1 输出: 4\n 限制：  1 ≤ k ≤ 二叉搜索树元素个数  解题思路 中序遍历 二叉搜索树的中序遍历结果是有序的，可以先遍历右子树，这样遍历的结果是倒序的。\n使用 cnt 记录当前遍历到的节点数量，每次遍历到结点时，其值加一。当 cnt 等于 k 时，记录此值，并通知上方已找到，提前返回。\nfunc kthLargest(root *TreeNode, k int) int { cnt := 0 ans := 0 var dfs func(node *TreeNode) bool dfs = func(node *TreeNode) bool { if node == nil { return false } if dfs(node.Right) { return true } cnt++ if cnt == k { ans = node.Val return true } return dfs(node.Left) } dfs(root) return ans } 复杂度  时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $  ","date":"2021-09-22T18:54:53+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-54.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/","title":"剑指 Offer 54. 二叉搜索树的第k大节点"},{"content":"链接： https://leetcode-cn.com/problems/split-linked-list-in-parts/\n难度： 中等\n题目描述 给你一个头结点为 head 的单链表和一个整数 k ，请你设计一个算法将链表分隔为 k 个连续的部分。\n每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。\n这 k 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。\n返回一个由上述 k 部分组成的数组。\n示例 1：  输入： head = [1,2,3], k = 5\n输出： [[1],[2],[3],[],[]]\n解释：\n第一个元素 output[0] 为 output[0].val = 1 ，output[0].next = null 。\n最后一个元素 output[4] 为 null ，但它作为 ListNode 的字符串表示是 [] 。\n 示例 2：  输入： head = [1,2,3,4,5,6,7,8,9,10], k = 3\n输出： [[1,2,3,4],[5,6,7],[8,9,10]]\n解释：\n输入被分成了几个连续的部分，并且每部分的长度相差不超过 1 。前面部分的长度大于等于后面部分的长度。\n 提示：  链表中节点的数目在范围 [0, 1000] 0 \u0026lt;= Node.val \u0026lt;= 1000 1 \u0026lt;= k \u0026lt;= 50  解题思路 二分查找 遍历一遍链表，获得链表长度。\n使用当前长度 length 除以当前需要划分的段数 k 得到当前段长度 split，注意，当 length % k 不为 0 时，split 需要 +1，然后将指针向后移动 split 即指向下一个段开始位置。\n重复以上步骤知道 k 为 0。\nfunc splitListToParts(head *ListNode, k int) []*ListNode { length := 0 for node := head; node != nil; node = node.Next { length++ } ans := make([]*ListNode, 0, k) for ;k != 0; k-- { split := length/k if length%k != 0 { split++ } length -= split ans = append(ans, head) for i := 0; i \u0026lt; split \u0026amp;\u0026amp; head != nil ; i++ { t := head head = head.Next if i+1 == split { t.Next = nil } } } return ans } 复杂度  时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(1) $  ","date":"2021-09-22T14:11:15+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-725.-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/","title":"Leetcode 725. 分隔链表"},{"content":"链接： https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/\n难度： 简单\n题目描述 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。\n示例 1：  输入： s = \u0026ldquo;abaccdeff\u0026rdquo;\n输出： \u0026lsquo;b\u0026rsquo;\n 示例 2：  输入： s = \u0026quot;\u0026quot;\n输出： ' '\n 限制：  0 \u0026lt;= s 的长度 \u0026lt;= 50000  解题思路 哈希 + 两次遍历 第一次遍历，使用哈希表记录每个字符是否重复出现；第二次遍历，返回找到的第一个不重复的字符，找不到返回 ' '。\nfunc firstUniqChar(s string) byte { repeat := make(map[byte]bool) for i := range s { _, ok := repeat[s[i]] if !ok { repeat[s[i]] = false } else { repeat[s[i]] = true } } for i := range s { if !repeat[s[i]] { return s[i] } } return \u0026#39; \u0026#39; } 复杂度  时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $  哈希 + 队列 使用哈希表记录每个字符是否重复出现，使用队列记录字符出现的顺序。\n当每个字符第一次出现时，加入队列，当队列头部元素重复时，弹出直至队列头部元素不重复。\n最后队列中有元素返回头部元素，否则返回 ' '\nfunc firstUniqChar(s string) byte { l := list.New() repeat := make(map[byte]bool) for i := range s { r, ok := repeat[s[i]] if !ok { repeat[s[i]] = false l.PushBack(s[i]) continue } if !r { repeat[s[i]] = true } for l.Len() \u0026gt; 0 \u0026amp;\u0026amp; repeat[l.Front().Value.(byte)] { l.Remove(l.Front()) } } if l.Len() \u0026gt; 0 { return l.Front().Value.(byte) } return \u0026#39; \u0026#39; } 复杂度  时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $  ","date":"2021-09-21T23:36:33+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/","title":"剑指 Offer 50. 第一个只出现一次的字符"},{"content":"链接： https://leetcode-cn.com/problems/length-of-last-word/\n难度： 简单\n题目描述 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。\n单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。\n示例 1：  输入： s = \u0026ldquo;Hello World\u0026rdquo;\n输出： 5\n 示例 2：  输入： s = \u0026quot; fly me to the moon \u0026quot;\n输出： 4\n 示例 3：  输入： s = \u0026ldquo;luffy is still joyboy\u0026rdquo;\n输出： 6\n 提示：  1 \u0026lt;= s.length \u0026lt;= 104 s 仅有英文字母和空格 ' ' 组成 s 中至少存在一个单词  解题思路 倒序遍历 从尾到头倒序遍历，当字符为 ' ' 时，若长度为 0 ，说明是尾部空格，继续遍历；否则说明尾部单词遍历完毕，返回长度。\nfunc lengthOfLastWord(s string) int { ans := 0 for i := len(s)-1; i \u0026gt;= 0; i-- { if s[i] == \u0026#39; \u0026#39; { if ans == 0 { continue } break } ans++ } return ans } 复杂度  时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $  ","date":"2021-09-21T22:30:53+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-58.-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/","title":"Leetcode 58. 最后一个单词的长度"},{"content":"链接： https://leetcode-cn.com/problems/chou-shu-lcof/\n难度： 中等\n题目描述 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。\n示例：  输入: n = 10\n输出: 12\n解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。\n 说明：  1 是丑数。 n 不超过 1690。  解题思路 堆 + 哈希 维护一个小顶堆和哈希表，初始堆中元素为 1，每次弹出堆顶最小元素，然后将其分别乘以 2、3、5加入堆中，此处需要使用哈希表去重。\n弹出的第 n 个数即为第 n 个丑数。\ntype MinHeap struct { sort.IntSlice } func (this *MinHeap) Push(x interface{}) { this.IntSlice = append(this.IntSlice, x.(int)) } func (this *MinHeap) Pop() interface{} { x := this.IntSlice[this.Len()-1] this.IntSlice = this.IntSlice[:this.Len()-1] return x } func nthUglyNumber(n int) int { exist := make(map[int]struct{}) factors := []int{2,3,5} h := \u0026amp;MinHeap{ IntSlice: make([]int, 0, n*3), } heap.Push(h, 1) ans := 0 for i := 0; i \u0026lt; n; i++ { ans = heap.Pop(h).(int) for _, factor := range factors { if _, ok := exist[ans*factor]; !ok { heap.Push(h, ans*factor) exist[ans*factor] = struct{}{} } } } return ans } 复杂度  时间复杂度：$ O(n\\log{n}) $ 空间复杂度：$ O(n) $  动态规划 使用 dp[i] 记录第 i 个丑数，由于无法界定 dp[i] 通过哪个丑数转移而来，另外还需要使用三个指针 p2、p3、p5 表示下一个丑数是当前指针指向的丑数乘以对应的质因数 2、3、5，从中找到最小的丑数 dp[i]，并将可以求得 dp[i] 的所有指针的对应下标记增加 1。\n 初始时，dp[0] = 1, p2 = p3 = p5 = 1 dp[i] = min(dp[p2]*2, dp[p3]*3, dp[p5]*5)  func nthUglyNumber(n int) int { dp := make([]int, n) dp[0] = 1 for i := 0; i \u0026lt; n; i++ { t2, t3, t5 = dp[p2]*2, dp[p3]*3, dp[p5]*5 dp[i] = t2 if dp[i] \u0026gt; t3 { dp[i] = t3 } if dp[i] \u0026gt; t5 { dp[i] = t5 } if dp[i] == t2 { p2++ } if dp[i] == t3 { p3++ } if dp[i] == t5 { p5++ } } return dp[n-1] } 复杂度  时间复杂度：$ O(n) $ 空间复杂度：$ O(n) $  ","date":"2021-09-21T17:50:14+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-49.-%E4%B8%91%E6%95%B0/","title":"剑指 Offer 49. 丑数"},{"content":"链接： https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/\n难度： 中等\n题目描述 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。\n示例 1：  输入: \u0026ldquo;abcabcbb\u0026rdquo;\n输出: 3\n解释: 因为无重复字符的最长子串是 \u0026ldquo;abc\u0026rdquo;，所以其长度为 3。\n 示例 2：  输入: \u0026ldquo;bbbbb\u0026rdquo;\n输出: 1\n解释: 因为无重复字符的最长子串是 \u0026ldquo;b\u0026rdquo;，所以其长度为 1。\n 示例 3：  输入: \u0026ldquo;pwwkew\u0026rdquo;\n输出: 3\n解释: 因为无重复字符的最长子串是 \u0026ldquo;wke\u0026rdquo;，所以其长度为 3。\n请注意，你的答案必须是 子串 的长度，\u0026ldquo;pwke\u0026rdquo; 是一个子序列，不是子串。\n 提示：  s.length \u0026lt;= 40000  解题思路 哈希 + 双指针 使用哈希表记录每个字符出现过下标，并记录有效数组开始的下标 start：当出现重复字符时，将 start 修正为重复字符出现的下一个下标。\nfunc lengthOfLongestSubstring(s string) int { ans := 0 pos := make(map[byte]int) start := 0 for i := 0; i \u0026lt; len(s); i++ { p, ok := pos[s[i]] if ok \u0026amp;\u0026amp; start \u0026lt;= p { start = p + 1 } pos[s[i]] = i if ans \u0026lt; i-start+1 { ans = i - start + 1 } } return ans } 复杂度  时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $  ","date":"2021-09-21T16:18:26+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"剑指 Offer 48. 最长不含重复字符的子字符串"},{"content":"链接： https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/\n难度： 中等\n题目描述 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\n示例：  输入:\n[ [1,3,1], [1,5,1], [4,2,1] ] 输出: 12\n解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物\n 提示：  0 \u0026lt; grid.length \u0026lt;= 200 0 \u0026lt; grid[0].length \u0026lt;= 200  解题思路 动态规划 使用 dp[i][j] 记录到达位置 (i,j) 的最大值，则其只能从上边或者左边移动到当前位置，故状态转移方程为：\n dp[0][0] = grid[0][0] dp[i][j] = max(dp[i-1][j], dp[i, j-1]) + grid[i][j]  func maxValue(grid [][]int) int { dp := make([][]int, len(grid)) for i := 0; i \u0026lt; len(grid); i++ { dp[i] = make([]int, len(grid[0])) for j := 0; j \u0026lt; len(grid[0]); j++ { if i-1 \u0026gt;= 0 { dp[i][j] = dp[i-1][j] } if j-1 \u0026gt;= 0 \u0026amp;\u0026amp; dp[i][j] \u0026lt; dp[i][j-1] { dp[i][j] = dp[i][j-1] } dp[i][j] += grid[i][j] } } return dp[len(dp)-1][len(dp[0])-1] } 复杂度  时间复杂度：$ O(mn) $ 空间复杂度：$ O(mn) $  ","date":"2021-09-21T15:11:53+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-47.-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/","title":"剑指 Offer 47. 礼物的最大价值"},{"content":"链接： https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/\n难度： 中等\n题目描述 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。\n示例：  输入: 12258\n输出: 5\n解释: 12258有5种不同的翻译，分别是\u0026quot;bccfi\u0026quot;, \u0026ldquo;bwfi\u0026rdquo;, \u0026ldquo;bczi\u0026rdquo;, \u0026ldquo;mcfi\u0026quot;和\u0026quot;mzi\u0026rdquo;\n 提示：  0 \u0026lt;= num \u0026lt; 231  解题思路 动态规划 使用 dp[i] 记录前缀数组可以表示方案的最大值。状态转移方程为：\n 初始，dp[0] = 1； 如果，nums[i]nums[i+1] 可以翻译，则 dp[i+1] = dp[i] + dp[i-1]； 否则，dp[i+1] = dp[i]。  func translateNum(num int) int { s := strconv.FormatInt(int64(num), 10) dp := make([]int, len(s)) dp[0] = 1 for i := 0; i \u0026lt; len(s)-1; i++ { dp[i+1] = dp[i] if s[i] != \u0026#39;0\u0026#39; \u0026amp;\u0026amp; (s[i]-\u0026#39;0\u0026#39;)*10+(s[i+1]-\u0026#39;0\u0026#39;) \u0026lt; 26 { if i-1 \u0026gt;= 0 { dp[i+1] += dp[i-1] } else { dp[i+1]++ } } } return dp[len(s)-1] } 复杂度  时间复杂度：$ O(N), N = digits(num) $ 空间复杂度：$ O(N) $  ","date":"2021-09-20T20:51:55+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"剑指 Offer 46. 把数字翻译成字符串"},{"content":"链接： https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/\n难度： 中等\n题目描述 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\n示例 1：  输入: [10,2]\n输出: \u0026ldquo;102\u0026rdquo;\n 示例 2：  输入: [3,30,34,5,9]\n输出: \u0026ldquo;3033459\u0026rdquo;\n 提示：  0 \u0026lt; nums.length \u0026lt;= 100  说明：  输出结果可能非常大，所以你需要返回一个字符串而不是整数 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0  解题思路 排序 对于两个数 x、y，若 xy \u0026lt; yx，则 x 必然在 y 的前面，证明如下：\n 当这两个数相邻，则成立 两数不相邻，不妨设 xzy，则有 xz \u0026lt; zx，zy \u0026lt; yz，需要证明 xzy \u0026lt; yzx  xz \u0026lt; zx =\u0026gt; x * 10^len(x) + z \u0026lt; z * 10^len(z) + x zy \u0026lt; yz =\u0026gt; z * 10^len(z) + y \u0026lt; y * 10^len(y) + z 相加得到 x * 10^len(x) + y \u0026lt; y * 10^len(y) + z，即 xy \u0026lt; yx，所以 xzy \u0026lt; yzx成立。    按照上述方案自定义排序规则排序，之后按顺序拼接起来返回。\nfunc minNumber(nums []int) string { sort.Slice(nums, func(i, j int) bool { return fmt.Sprintf(\u0026#34;%d%d\u0026#34;, nums[i], nums[j]) \u0026lt; fmt.Sprintf(\u0026#34;%d%d\u0026#34;, nums[j], nums[i]) }) ans := make([]byte, 0, len(nums)*5) for _, num := range nums { ans = append(ans, strconv.FormatInt(int64(num), 10)...) } return string(ans) } 复杂度  时间复杂度：$ O(N\\log{N}), N = len(nums) $ 空间复杂度：$ O(\\log{N}) $  ","date":"2021-09-20T19:50:47+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-45.-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/","title":"剑指 Offer 45. 把数组排成最小的数"},{"content":"链接： https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/\n难度： 中等\n题目描述 数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。\n请写一个函数，求任意第n位对应的数字。\n示例 1：  输入： n = 3\n输出： 3\n 示例 2：  输入： n = 11\n输出： 0\n 限制：  0 \u0026lt;= n \u0026lt; 231  解题思路 模拟 字符串按照数字顺序排列，其按照数字长度为 1、2、3、... 进行排列，可以利用这个规则求得 n 所在的那个数，进而求的该位对应的数字。\n排除 0，则相同长度的数字所占的字符串长度为 9*基数*数字长度，（即9=9*1*1、90=9*10*2、900=9*100*3、...），通过覆盖范围的查找确定到 n 对应的数字长度和基数。\n之后获取到 n 所在数字的偏移量，并求得该数，之后返回 n 对应位的数字即可。对输入 0 需要验证。\nfunc findNthDigit(n int) int { base := 1 // 基数 10^N \tdigit := 1 // 位数 10进制 \t// 确定位数 \tfor ; n \u0026gt; base*9*digit; base, digit = 10*base, digit+1 { n -= base * 9 * digit } offset := (n - 1) / digit // 偏移量 \t// 获取指定位数字 \tans := base + offset for i := digit - (n-1)%digit; i \u0026gt; 1; i-- { ans /= 10 } return ans % 10 } 复杂度  时间复杂度：$ O(\\log{n}) $ 空间复杂度：$ O(1) $  ","date":"2021-09-20T18:23:10+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-44.-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/","title":"剑指 Offer 44. 数字序列中某一位的数字"},{"content":"链接： https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/\n难度： 中等\n题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。\n为了让您更好地理解问题，以下面的二叉搜索树为例：\n我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。\n下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。\n特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。\n解题思路 深度优先搜索 二叉搜索树中序遍历后的结果即为有序的，采用中序遍历的方式搜索二叉树。\n维护两个指针 head 和 tail ，分别指向当前遍历到的链表的头和尾。对于当前遍历到的结点，将其 left 指向 tail，同时 tail 的 right 指向当前结点，后 tail 变更为指向当前结点。\n完成遍历后，修改头尾指针，使其构成环。\nclass Solution { public: Node *treeToDoublyList(Node *root) { if (root == nullptr) { return nullptr; } dfs(root); head-\u0026gt;left = tail; tail-\u0026gt;right = head; return head; } private: Node *head, *tail; void dfs(Node *node) { if(node == nullptr) { return; } dfs(node-\u0026gt;left); if (head == nullptr) { head = node; } if (tail == nullptr) { tail = node; } else { tail-\u0026gt;right = node; node-\u0026gt;left = tail; tail = node; } dfs(node-\u0026gt;right); } }; 复杂度  时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $  ","date":"2021-09-20T17:20:45+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-36.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","title":"剑指 Offer 36. 二叉搜索树与双向链表"},{"content":"链接： https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/\n难度： 简单\n题目描述 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。\n示例 1：  输入： arr = [3,2,1], k = 2\n输出： [1,2] 或者 [2,1]\n 示例 2：  输入： arr = [0,1,2,1], k = 1\n输出： [0]\n 限制：  0 \u0026lt;= k \u0026lt;= arr.length \u0026lt;= 10000 0 \u0026lt;= arr[i] \u0026lt;= 10000  解题思路 排序 对数组进行排序，返回前 k 个数。\nfunc getLeastNumbers(arr []int, k int) []int { sort.Ints(arr) return arr[:k] } 复杂度  时间复杂度：$ O(N\\log{N}), N = len(arr) $ 空间复杂度：$ O(\\log{N}) $  堆 使用大顶堆维护最小的 k 个数。遍历数组，当堆不满 k 时，入堆；否则，当前元素小于堆顶元素时，弹出最大元素，当前元素入堆。\n如此，始终保持堆中的即为当前最小的 k 个数，遍历结束返回堆中所有元素即可。\ntype MaxHeap struct { sort.IntSlice } func (this *MaxHeap) Less(i, j int) bool { return this.IntSlice.Less(j, i) } func (this *MaxHeap) Push(x interface{}) { this.IntSlice = append(this.IntSlice, x.(int)) } func (this *MaxHeap) Pop() interface{} { x := this.IntSlice[0] this.IntSlice = this.IntSlice[:this.Len()-1] return x } func (this *MaxHeap) Top() int { return this.IntSlice[0] } func getLeastNumbers(arr []int, k int) []int { h := \u0026amp;MaxHeap{IntSlice: make([]int, 0, k)} for _, num := range arr { if h.Len() \u0026lt; k { heap.Push(h, num) } else if h.Len() \u0026gt; 0 \u0026amp;\u0026amp; h.Top() \u0026gt; num { heap.Pop(h) heap.Push(h, num) } } return h.IntSlice } 复杂度  时间复杂度：$ O(N\\log{k}), N = len(arr) $ 空间复杂度：$ O(k) $  快速选择 利用快排思想，找出第 k 大的数，则返回从该数开始到头的部分即可。\nfunc getLeastNumbers(arr []int, k int) []int { pos := 0 for i := range arr { if arr[i] \u0026lt;= arr[len(arr)-1] { arr[i], arr[pos] = arr[pos], arr[i] pos++ } } if pos == k { return arr[:k] } else if pos \u0026lt; k { return append(arr[:pos], getLeastNumbers(arr[pos:], k-pos)...) } return getLeastNumbers(arr[:pos-1], k) } 复杂度  时间复杂度：$ O(N), N = len(arr) $ 空间复杂度：$ O(\\log{N}) $  ","date":"2021-09-20T16:17:39+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/","title":"剑指 Offer 40. 最小的k个数"},{"content":"链接： https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/\n难度： 简单\n题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n示例：  输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]\n输出: 2\n 提示：  1 \u0026lt;= 数组长度 \u0026lt;= 50000  解题思路 哈希 遍历数组，用哈希表记录每个元素的出现次数，当超过半数时返回。\nfunc majorityElement(nums []int) int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ if cnt[num] \u0026gt; len(nums)/2 { return num } } return 0 } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  排序 对数组排序，位于中间位置对必为多数元素。\nfunc majorityElement(nums []int) int { sort.Ints(nums) return nums[len(nums)/2] } 复杂度  时间复杂度：$ O(N\\log{N}), N = len(nums) $ 空间复杂度：$ O(\\log{N}) $  摩尔投票算法 每次将不同的两个数消除，最终剩下的数即为主要元素。\nfunc majorityElement(nums []int) int { major := 0 cnt := 0 for _, num := range nums { if cnt == 0 { major = num cnt++ } else if major != num { cnt-- } else { cnt++ } } return major } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  ","date":"2021-09-20T16:00:42+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-39.-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/","title":"剑指 Offer 39. 数组中出现次数超过一半的数字"},{"content":"链接： https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/\n难度： 中等\n题目描述 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。\n示例 1：  输入： head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出： [[7,null],[13,0],[11,4],[10,2],[1,0]]\n 示例 2：  输入： head = [[1,1],[2,1]]\n输出： [[1,1],[2,1]]\n 示例 3：  输入： head = [[3,null],[3,0],[3,null]]\n输出： [[3,null],[3,0],[3,null]]\n 示例 4:  输入： head = []\n输出： []\n解释： 给定的链表为空（空指针），因此返回 null\n 提示：  -10000 \u0026lt;= Node.val \u0026lt;= 10000 Node.random 为空（null）或指向链表中的节点。 节点数目不超过 1000 。  解题思路 哈希 使用哈希表维护一个旧结点到新结点的映射，依次从前向后遍历链表，并逐一的构造新链表。\n首先先从哈希表中获取新结点，若不存在，需要构造新结点，并将其加入到哈希表中。\nfunc copyRandomList(head *Node) *Node { m := make(map[*Node]*Node) newHead := new(Node) for node := newHead; head != nil; head, node = head.Next, node.Next { // 获取 Next 指针指向结点 \tt, ok := m[head] if !ok { t = \u0026amp;Node{ Val: head.Val, } m[head] = t } // 获取 Random 指针指向结点 \tif head.Random != nil { random, ok := m[head.Random] if !ok { random = \u0026amp;Node{ Val: head.Random.Val, } m[head.Random] = random } t.Random = random } node.Next = t } return newHead.Next } 复杂度  时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(N) $  分裂 在原来链表的基础上，将每个结点裂变出一个新结点，形成如 A-\u0026gt;A'-\u0026gt;B-\u0026gt;B'-\u0026gt;…… 的结构，修正每个新结点的 random 指针为原结点的下一个结点，然后将原链表拆分，即得到结果。\nfunc copyRandomList(head *Node) *Node { if head == nil { return nil } // 分裂 \tfor node := head; node != nil; node = node.Next.Next { node.Next = \u0026amp;Node{ Val: node.Val, Next: node.Next, Random: node.Random, } } // random 修正 \tfor node := head; node != nil; node = node.Next.Next { if node.Random != nil { node.Next.Random = node.Random.Next } } // 分离 \tnewHead := head.Next for oldNode, newNode := head, newHead; oldNode != nil; oldNode, newNode = oldNode.Next, newNode.Next { oldNode.Next = newNode.Next if newNode.Next != nil { newNode.Next = newNode.Next.Next } } return newHead } 复杂度  时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(1) $  ","date":"2021-09-20T15:16:13+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-35.-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/","title":"剑指 Offer 35. 复杂链表的复制"},{"content":"链接： https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/\n难度： 中等\n题目描述 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。\n示例： 给定如下二叉树，以及目标和 target = 22，\n 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回:\n[ [5,4,11,2], [5,8,4,5] ] 提示：  节点总数 \u0026lt;= 10000  解题思路 深度优先搜索 从根节点开始进行深度优先搜索，当整条路径上的结点值之和为 target 时，将其拷贝到结果队列中。\nfunc pathSum(root *TreeNode, target int) [][]int { ans := make([][]int, 0) var dfs func(node *TreeNode, path []int, sum int) dfs = func(node *TreeNode, path []int, sum int) { if node == nil { return } path = append(path, node.Val) sum += node.Val if node.Left == nil \u0026amp;\u0026amp; node.Right == nil { if sum == target { ans = append(ans, make([]int, len(path))) copy(ans[len(ans)-1], path) } return } dfs(node.Left, path, sum) dfs(node.Right, path, sum) } dfs(root, []int{}, 0) return ans } 复杂度  时间复杂度：$ O(N\\log{N}), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $  ","date":"2021-09-20T14:55:24+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-34.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/","title":"剑指 Offer 34. 二叉树中和为某一值的路径"},{"content":"链接： https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/\n难度： 中等\n题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都 互不相同。\n参考以下这颗二叉搜索树：\n 5 / \\ 2 6 / \\ 1 3 示例 1：  输入： [1,6,3,2,5]\n输出： false\n 示例 2：  输入： [1,3,2,6,5]\n输出： true\n 提示：  数组长度 \u0026lt;= 1000  解题思路 递归 对于一棵树的后续遍历序列，最后一个元素必然是根，然后向前遍历。根据二叉搜索树的性质，其右边元素一定大于根，而左边元素一定小于根，由此找到首个小于根的元素即为左右子树分界点。\n若在左子树序列里存在一个大于根的结点，则返回 false，否则递归处理左右子树。\nfunc verifyPostorder(postorder []int) bool { if len(postorder) \u0026lt;= 2 { return true } root := postorder[len(postorder)-1] split := len(postorder) - 2 for ; split \u0026gt;= 0 \u0026amp;\u0026amp; postorder[split] \u0026gt; root; split-- { } for i := 0; i \u0026lt; split; i++ { if postorder[i] \u0026gt; root { return false } } return verifyPostorder(postorder[:split+1]) \u0026amp;\u0026amp; verifyPostorder(postorder[split+1:len(postorder)-1]) } 复杂度  时间复杂度：$ O(N\\log{N}), N = len(postorder) $ 空间复杂度：$ O(\\log{N}) $  ","date":"2021-09-20T13:56:50+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-33.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/","title":"剑指 Offer 33. 二叉搜索树的后序遍历序列"},{"content":"链接： https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/\n难度： 中等\n题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字 均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。\n示例 1：  输入： pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n输出： true\n解释： 我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -\u0026gt; 4,\npush(5), pop() -\u0026gt; 5, pop() -\u0026gt; 3, pop() -\u0026gt; 2, pop() -\u0026gt; 1\n 示例 2：  输入： pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n输出： false\n解释： 1 不能在 2 之前弹出。\n 提示：  0 \u0026lt;= pushed.length == popped.length \u0026lt;= 1000 0 \u0026lt;= pushed[i], popped[i] \u0026lt; 1000 pushed 是 popped 的排列。  解题思路 模拟 使用一个栈模拟操作。遍历 pushed，将当前元素压栈，由于元素各不相同，随后将栈与 popped 对照，逐一地相同元素弹出。\n最终栈为空则返回 true，否则返回 false。\nfunc validateStackSequences(pushed []int, popped []int) bool { stack := make([]int, 0, len(pushed)) for i, j := 0, 0; i \u0026lt; len(pushed); i++ { stack = append(stack, pushed[i]) for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; stack[len(stack)-1] == popped[j] { stack = stack[:len(stack)-1] j++ } } return len(stack) == 0 } 复杂度  时间复杂度：$ O(N), N = len(pushed) $ 空间复杂度：$ O(N) $  ","date":"2021-09-20T13:01:33+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-31.-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/","title":"剑指 Offer 31. 栈的压入、弹出序列"},{"content":"链接： https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/\n难度： 简单\n题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 $O(1)$。\n示例：  MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.min(); \u0026ndash;\u0026gt; 返回 -3.\nminStack.pop();\nminStack.top(); \u0026ndash;\u0026gt; 返回 0.\nminStack.min(); \u0026ndash;\u0026gt; 返回 -2.\n 提示：  各函数的调用总次数不超过 20000 次  解题思路 双栈 当最小元素入栈后，后续压入的所有大于最小元素的元素，均不会影响 min 的值，除非压入更小的元素。同理，需要弹出最小元素，min 的值才会改变。故使用另一个栈 B 记录可能使得 min 改变的所有元素值。\n 当一个元素入栈时，压入栈 A ，若此元素不大于栈 B 栈顶元素或栈 B 为空，同时需要压入栈 B； 当出栈时，弹出栈 A 栈顶元素，若该元素与栈 B 栈顶元素相同，栈 B 栈顶元素也弹出。  type MinStack struct { stack *list.List minStack *list.List } func Constructor() MinStack { return MinStack{ stack: list.New(), minStack: list.New(), } } func (this *MinStack) Push(x int) { this.stack.PushBack(x) if this.minStack.Len() == 0 || this.minStack.Back().Value.(int) \u0026gt;= x { this.minStack.PushBack(x) } } func (this *MinStack) Pop() { e := this.stack.Back() this.stack.Remove(e) if this.minStack.Back().Value == e.Value { this.minStack.Remove(this.minStack.Back()) } } func (this *MinStack) Top() int { return this.stack.Back().Value.(int) } func (this *MinStack) Min() int { return this.minStack.Back().Value.(int) } 复杂度  时间复杂度：  Push：$ O(1) $ Pop：$ O(1) $ Min：$ O(1) $ Top：$ O(1) $   空间复杂度：$ O(N) $  ","date":"2021-09-20T12:29:44+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-30.-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","title":"剑指 Offer 30. 包含min函数的栈"},{"content":"链接： https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/\n难度： 简单\n题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。\n示例 1：  输入： matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出： [1,2,3,6,9,8,7,4,5]\n 示例 2：  输入： matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n输出： [1,2,3,4,8,12,11,10,9,5,6,7]\n 限制：  0 \u0026lt;= matrix.length \u0026lt;= 100 0 \u0026lt;= matrix[i].length \u0026lt;= 100  解题思路 模拟 从 (0,0) 开始，按照 右 \u0026gt; 下 \u0026gt; 左 \u0026gt; 上 \u0026gt; 右 的顺序遍历，当下一步要超出范围时或已访问过时，变换遍历方向。\nfunc spiralOrder(matrix [][]int) []int { if len(matrix) == 0 { return make([]int, 0) } visit := make([][]bool, len(matrix)) for i := range matrix { visit[i] = make([]bool, len(matrix[i])) } ans := make([]int, 0, len(matrix)*len(matrix[0])) directions := [4][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}} for i, j, direction := 0, 0, 0; len(ans) \u0026lt; cap(ans); i, j = i+directions[direction][0], j+directions[direction][1] { ans = append(ans, matrix[i][j]) visit[i][j] = true // 遍历方向修正 \tnextI, nextJ := i+directions[direction][0], j+directions[direction][1] if nextI \u0026lt; 0 || nextI \u0026gt;= len(matrix) || nextJ \u0026lt; 0 || nextJ \u0026gt;= len(matrix[0]) || visit[nextI][nextJ] { direction = (direction + 1) % len(directions) } } return ans } 复杂度  时间复杂度：$ O(NM), N = len(matrix), M = len(N = len(matrix[i])) $ 空间复杂度：$ O(NM) $  层序遍历 将矩阵分解为一个个的环，每次只顺时针遍历环即可。\nfunc spiralOrder(matrix [][]int) []int { if len(matrix) == 0 { return make([]int, 0) } ans := make([]int, 0, len(matrix)*len(matrix[0])) for up, down, left, right := 0, len(matrix)-1, 0, len(matrix[0])-1; up \u0026lt;= down \u0026amp;\u0026amp; left \u0026lt;= right; up, down, left, right = up+1, down-1, left+1, right-1 { for i := left; i \u0026lt;= right; i++ { ans = append(ans, matrix[up][i]) } for i := up + 1; i \u0026lt;= down; i++ { ans = append(ans, matrix[i][right]) } if up != down \u0026amp;\u0026amp; left != right { for i := right - 1; i \u0026gt;= left; i-- { ans = append(ans, matrix[down][i]) } for i := down - 1; i \u0026gt; up; i-- { ans = append(ans, matrix[i][left]) } } } return ans } 复杂度  时间复杂度：$ O(NM), N = len(matrix), M = len(N = len(matrix[i])) $ 空间复杂度：$ O(1) $  ","date":"2021-09-20T11:07:24+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-29.-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/","title":"剑指 Offer 29. 顺时针打印矩阵"},{"content":"链接： https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/\n难度： 简单\n题目描述 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n 1 / \\ 2 2 \\ \\ 3 3 示例 1：  输入： root = [1,2,2,3,4,4,3]\n输出： true\n 示例 2：  输入： root = [1,2,2,null,3,null,3]\n输出： false\n 限制：  0 \u0026lt;= 节点个数 \u0026lt;= 1000  解题思路 递归 递归遍历比较互为镜像的两个结点，不同则返回 false，相同则继续遍历比较子结点。\n因为是镜像比较，所以左子树的左结点和右子树的右结点比较，而左子树的右结点和右子树的左结点比较。\nfunc isSymmetric(root *TreeNode) bool { if root == nil { return true } var same func(node1, node2 *TreeNode) bool same = func(node1, node2 *TreeNode) bool { if node1 == nil \u0026amp;\u0026amp; node2 == nil { return true } if node1 == nil || node2 == nil || node1.Val != node2.Val { return false } return same(node1.Left, node2.Right) \u0026amp;\u0026amp; same(node1.Right, node2.Left) } return same(root.Left, root.Right) } 复杂度  时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $  ","date":"2021-09-19T20:37:47+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-28.-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"剑指 Offer 28. 对称的二叉树"},{"content":"链接： https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/\n难度： 简单\n题目描述 请完成一个函数，输入一个二叉树，该函数输出它的镜像。\n例如输入：\n 4 / \\ 2 7 / \\ / \\ 1 3 6 9 镜像输出：\n 4 / \\ 7 2 / \\ / \\ 9 6 3 1 示例：  输入： root = [4,2,7,1,3,6,9]\n输出： [4,7,2,9,6,3,1]\n 限制：  0 \u0026lt;= 节点个数 \u0026lt;= 1000  解题思路 递归 递归遍历所有的结点，交换左右子树。\nfunc mirrorTree(root *TreeNode) *TreeNode { if root == nil { return nil } root.Left, root.Right = mirrorTree(root.Right), mirrorTree(root.Left) return root } 复杂度  时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $  ","date":"2021-09-19T20:27:58+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-27.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/","title":"剑指 Offer 27. 二叉树的镜像"},{"content":"链接： https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/\n难度： 中等\n题目描述 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)\nB是A的子结构， 即 A中有出现和B相同的结构和节点值。\n例如: 给定的树 A:\n 3 / \\ 4 5 / \\ 1 2 给定的树 B：\n 4 / 1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。\n示例 1：  输入： A = [1,2,3], B = [3,1]\n输出： false\n 示例 2：  输入： A = [3,4,5,1,2], B = [4,1]\n输出： true\n 限制：  0 \u0026lt;= 节点个数 \u0026lt;= 10000  解题思路 深度优先搜索 在树 A 上进行 深度优先搜索（先序遍历），当子树根结点与 B 相同时，仍采用 深度优先搜索 的方式比较结构是否相同。\nfunc isSubStructure(A *TreeNode, B *TreeNode) bool { if B == nil { return false } var same func(node1, node2 *TreeNode) bool same = func(node1, node2 *TreeNode) bool { if node2 == nil { return true } if node1 == nil { return false } if node1.Val != node2.Val { return false } return same(node1.Left, node2.Left) \u0026amp;\u0026amp; same(node1.Right, node2.Right) } var dfs func(node *TreeNode) bool dfs = func(node *TreeNode) bool { if node == nil { return false } if node.Val == B.Val \u0026amp;\u0026amp; same(node, B) { return true } return dfs(node.Left) || dfs(node.Right) } return dfs(A) } 复杂度  时间复杂度：$ O(NM), N = size(TreeA), M = size(TreeB) $ 空间复杂度：$ O(\\log{N}) $  ","date":"2021-09-19T19:37:13+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-26.-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/","title":"剑指 Offer 26. 树的子结构"},{"content":"链接： https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/\n难度： 简单\n题目描述 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的\n示例：  输入： 1-\u0026gt;2-\u0026gt;4, 1-\u0026gt;3-\u0026gt;4\n输出： 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4\n 限制：  0 \u0026lt;= 链表长度 \u0026lt;= 1000  解题思路 迭代 由于两个链表都是排好序的，所以每次只需要比较两个链表头，选择小的加入到结果队列即可。\nfunc mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { ans := new(ListNode) for node := ans; l1 != nil || l2 != nil; node = node.Next { if l1 == nil { node.Next = l2 break } if l2 == nil { node.Next = l1 break } if l1.Val \u0026lt; l2.Val { node.Next = l1 l1 = l1.Next } else { node.Next = l2 l2 = l2.Next } } return ans.Next } 复杂度  时间复杂度：$ O(N+M), N = len(List1), M = len(List2) $ 空间复杂度：$ O(1) $  递归 同迭代思路，使用递归实现。\nfunc mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.Val \u0026lt; l2.Val { l1.Next = mergeTwoLists(l1.Next, l2) return l1 } l2.Next = mergeTwoLists(l1, l2.Next) return l2 } 复杂度  时间复杂度：$ O(N+M), N = len(List1), M = len(List2) $ 空间复杂度：$ O(N+M) $  ","date":"2021-09-19T19:23:38+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-25.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/","title":"剑指 Offer 25. 合并两个排序的链表"},{"content":"链接： https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/\n难度： 简单\n题目描述 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n示例：  输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL\n输出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL\n 说明：  0 \u0026lt;= nums.length \u0026lt;= 50000 1 \u0026lt;= nums[i] \u0026lt;= 10000  解题思路 递归 利用调用栈记录上一个结点的信息，每次现将后续链表反转，得到反转链表的头部，然后通过当前结点的 Next 指针将当前节点添加到反转链表的尾部，注意还需要将当前节点的 Next 指针置空。\nfunc reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } newHead := reverseList(head.Next) head.Next.Next = head head.Next = nil return newHead } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  双指针 链表是单向的，无法访问到上一个节点，所以使用两个指针 last 和 cur 记录当前结点和上一个结点。\n遍历链表，逐一的将当前节点的 Next 指针指向 last，last 和 cur 前进一步。最终当 cur 为 nil 时，返回 last\nfunc reverseList(head *ListNode) *ListNode { last := (*ListNode)(nil) for cur := head; cur != nil; cur.Next, last, cur = last, cur, cur.Next { } return last } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $  ","date":"2021-09-19T18:31:45+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-24.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","title":"剑指 Offer 24. 反转链表"},{"content":"链接： https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/\n难度： 简单\n题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。\n示例：  输入： nums = [1,2,3,4]\n输出： [1,3,2,4]\n注： [3,1,2,4] 也是正确的答案之一。\n 说明：  0 \u0026lt;= nums.length \u0026lt;= 50000 1 \u0026lt;= nums[i] \u0026lt;= 10000  解题思路 双指针 使用两个指针 i 和 j 分别指向下一个奇数待插入的位置和当前遍历到的位置，一次遍历，遇到奇数时，i 、 j 指向的两个元素互换。\nfunc exchange(nums []int) []int { for i, j := 0, 0; j \u0026lt; len(nums); j++ { if nums[j]\u0026amp;1 == 1 { nums[i], nums[j] = nums[j], nums[i] i++ } } return nums } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $  ","date":"2021-09-19T18:13:45+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-21.-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/","title":"剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"},{"content":"链接： https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/\n难度： 中等\n题目描述 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。\n数值（按顺序）可以分成以下几个部分：\n 若干空格 一个 小数 或者 整数 （可选）一个 'e' 或 'E' ，后面跟着一个 整数 若干空格  小数（按顺序）可以分成以下几个部分：\n （可选）一个符号字符（'+' 或 '-'） 下述格式之一：  至少一位数字，后面跟着一个点 '.' 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字 一个点 '.' ，后面跟着至少一位数字    整数（按顺序）可以分成以下几个部分：\n （可选）一个符号字符（'+' 或 '-'） 至少一位数字  部分数值列举如下：\n [\u0026quot;+100\u0026quot;, \u0026quot;5e2\u0026quot;, \u0026quot;-123\u0026quot;, \u0026quot;3.1416\u0026quot;, \u0026quot;-1E-16\u0026quot;, \u0026quot;0123\u0026quot;]  部分非数值列举如下：\n [\u0026quot;12e\u0026quot;, \u0026quot;1a3.14\u0026quot;, \u0026quot;1.2.3\u0026quot;, \u0026quot;+-5\u0026quot;, \u0026quot;12e+5.4\u0026quot;]  示例 1：  输入： s = \u0026ldquo;0\u0026rdquo;\n输出： true\n 示例 2：  输入： s = \u0026ldquo;e\u0026rdquo;\n输出： false\n 示例 3：  输入： s = \u0026ldquo;.\u0026rdquo;\n输出： false\n 示例 4：  输入： s = \u0026quot; .1 \u0026quot;\n输出： true\n 说明：  1 \u0026lt;= s.length \u0026lt;= 20 s 仅含英文字母（大写和小写），数字（0-9），加号 '+' ，减号 '-' ，空格 ' ' 或者点 '.' 。  解题思路 确定有限状态自动机 从头开始遍历字符串，需要依次判断每个字符加入后，能否满足条件；不包含此字符的前缀必然是有效的前缀，一但该字符加入后，若失效，则终止，返回 false；有效继续执行，知道最终停止，返回结果。可以用 确定有限状态自动机 求解。\n如字符串 \u0026quot; ±123.456E±789 \u0026quot;，可以分为一下几个部分：开始空格、正负号、整数部分、小数点、小数部分、E、指数符号、指数部分、结束空格。\n针对以上的几个部分进行挖掘得到状态定义和转移规则：\n状态定义：\n   状态枚举 描述     Unknown 未知   Start 开始   Sign 正负号   IntNum 整数部分   DotWithoutNum 无整数部分的小数点   DotNum 小数部分   E e或E   IndexSign 指数部分正负号   IndexNum 指数部分   End 结束    状态转移表：\n    Start Sign IntNum DotWithoutNum DotNum E IndexSign IndexNum End     Start ✔️ ✔️ ✔️ ✔️        Sign   ✔️ ✔️        IntNum   ✔️  ✔️ ✔️   ✔️   DotWithoutNum     ✔️       DotNum     ✔️ ✔️   ✔️   E       ✔️ ✔️    IndexSign        ✔️    IndexNum        ✔️ ✔️   End         ✔️    func isNumber(s string) bool { const ( Unknown = iota Start Sign IntNum DotWithoutNum DotNum E IndexSign IndexNum End ) trans := map[int]map[int]bool{ Start: {Start: true, Sign: true, IntNum: true, DotWithoutNum: true}, Sign: {IntNum: true, DotWithoutNum: true}, IntNum: {IntNum: true, DotNum: true, E: true, End: true}, DotWithoutNum: {DotNum: true}, DotNum: {DotNum: true, E: true, End: true}, E: {IndexSign: true, IndexNum: true}, IndexSign: {IndexNum: true}, IndexNum: {IndexNum: true, End: true}, End: {End: true}, } status := Start for i := 0; i \u0026lt; len(s); i++ { nextStatus := Unknown switch s[i] { case \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;: switch status { case Start, Sign, IntNum: nextStatus = IntNum case E, IndexSign, IndexNum: nextStatus = IndexNum case DotWithoutNum, DotNum: nextStatus = DotNum } case \u0026#39;.\u0026#39;: switch status { case IntNum: nextStatus = DotNum case Start, Sign: nextStatus = DotWithoutNum } case \u0026#39;e\u0026#39;, \u0026#39;E\u0026#39;: nextStatus = E case \u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;: switch status { case E: nextStatus = IndexSign case Start: nextStatus = Sign } case \u0026#39; \u0026#39;: switch status { case IntNum, DotNum, IndexNum: nextStatus = End case Start: nextStatus = Start case End: nextStatus = End } } if !trans[status][nextStatus] { return false } status = nextStatus } return trans[status][End] } 复杂度  时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $  ","date":"2021-09-19T16:21:04+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-20.-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"剑指 Offer 20. 表示数值的字符串"},{"content":"链接： https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/\n难度： 简单\n题目描述 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。\n返回删除后的链表的头节点。\n注意： 此题对比原题有改动\n示例 1：  输入: head = [4,5,1,9], val = 5\n输出: [4,1,9]\n解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -\u0026gt; 1 -\u0026gt; 9.\n 示例 2：  输入: head = [4,5,1,9], val = 1\n输出: [4,5,9]\n解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -\u0026gt; 5 -\u0026gt; 9.\n 说明：  题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点  解题思路 顺序遍历 + 二级指针 顺序遍历该链表，当遇到目标结点时，将指向该节点的指针指向下一个结点。\nfunc deleteNode(head *ListNode, val int) *ListNode { for node := \u0026amp;head; (*node) != nil; node = \u0026amp;(*node).Next { if (*node).Val == val { (*node) = (*node).Next break } } return head } 复杂度  时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(1) $  ","date":"2021-09-19T15:56:41+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-18.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/","title":"剑指 Offer 18. 删除链表的节点"},{"content":"链接： https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/\n难度： 简单\n题目描述 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。\n示例：  输入: n = 1\n输出: [1,2,3,4,5,6,7,8,9]\n 说明：  用返回一个整数列表来代替打印 n 为正整数  解题思路  求得上限 max，其值为 10n，然后将 [1,max) 之间的所有数依次按顺序添加到返回队列即可。\nfunc printNumbers(n int) []int { max := 1 for ; n \u0026gt; 0; n-- { max *= 10 } ans := make([]int, 0, max) for i := 1; i \u0026lt; max; i++ { ans = append(ans, i) } return ans } 复杂度  时间复杂度：$ O(10^n) $ 空间复杂度：$ O(1) $  ","date":"2021-09-19T15:44:19+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-17.-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/","title":"剑指 Offer 17. 打印从1到最大的n位数"},{"content":"链接： https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/\n难度： 中等\n题目描述 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。\n示例 1：  输入： x = 2.00000, n = 10\n输出： 1024.00000\n 示例 2：  输入： x = 2.10000, n = 3\n输出： 9.26100\n 示例 3：  输入： x = 2.00000, n = -2\n输出： 0.25000\n解释： 2-2 = 1/22 = 1/4 = 0.25\n 提示：  -100.0 \u0026lt; x \u0026lt; 100.0 -231 \u0026lt;= n \u0026lt;= 231-1 -104 \u0026lt;= xn \u0026lt;= 104  解题思路 快速幂 $$ x^n = a_1x^1 * a_2x^2 * a_3x^4 * a_4x^8 * \u0026hellip; , 其中a_i\\in(0,1) $$ 可以看出，$ a_i $ 就是 n 的二进制表示形式，而对应项的幂计算可由上一项乘自身求得，故可以依次枚举二进制的每一位，类乘求的结果。\n注意初始 n 为负数的情况,需要进行转化。\nfunc myPow(x float64, n int) float64 { ans := float64(1) pow := float64(x) if n \u0026lt; 0 { pow = 1 / pow n = -n } for ; n != 0; n \u0026gt;\u0026gt;= 1 { if n\u0026amp;1 == 1 { ans *= pow } pow *= pow } return ans } 复杂度  时间复杂度：$ O(\\log{n}) $ 空间复杂度：$ O(1) $  ","date":"2021-09-19T15:13:54+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/","title":"剑指 Offer 16. 数值的整数次方"},{"content":"链接： https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/\n难度： 中等\n题目描述 地上有一个 m 行 n 列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0,0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n示例 1：  输入： m = 2, n = 3, k = 1\n输出： 3\n 示例 2：  输入： m = 3, n = 1, k = 0\n输出： 1\n 提示：  1 \u0026lt;= n,m \u0026lt;= 100 0 \u0026lt;= k \u0026lt;= 20  解题思路 深度优先搜索 从 [0,0] 开始进行深度优先搜索，当针对 k 进行剪枝时，整个矩阵是关于 (i,i) 对称的，所以可以限制搜索方向为右和下。\nfunc movingCount(m int, n int, k int) int { visit := make(map[[2]int]struct{}) var dfs func(i, j int) int dfs = func(i, j int) int { // 越界 \tif i \u0026gt;= m || j \u0026gt;= n { return 0 } // 剪枝 \tif _, ok := visit[[2]int{i, j}]; ok { return 0 } sum := 0 for t1, t2 := i, j; t1 \u0026gt; 0 || t2 \u0026gt; 0; t1, t2 = t1/10, t2/10 { sum += t1%10 + t2%10 } if sum \u0026gt; k { return 0 } // 继续遍历 \tvisit[[2]int{i, j}] = struct{}{} return 1 + dfs(i+1, j) + dfs(i, j+1) } return dfs(0, 0) } 复杂度  时间复杂度：$ O(mn) $ 空间复杂度：$ O(mn) $  ","date":"2021-09-19T14:29:35+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/","title":"剑指 Offer 13. 机器人的运动范围"},{"content":"链接： https://leetcode-cn.com/problems/2-keys-keyboard/\n难度： 中等\n题目描述 最初记事本上只有一个字符 'A' 。你每次可以对这个记事本进行两种操作：\n Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。 Paste（粘贴）：粘贴 上一次 复制的字符。  给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A' 。返回能够打印出 n 个 'A' 的最少操作次数。\n示例 1：  输入： 3\n输出： 3\n解释：\n最初, 只有一个字符 \u0026lsquo;A\u0026rsquo;。\n第 1 步, 使用 Copy All 操作。\n第 2 步, 使用 Paste 操作来获得 \u0026lsquo;AA\u0026rsquo;。\n第 3 步, 使用 Paste 操作来获得 \u0026lsquo;AAA\u0026rsquo;。\n 示例 2：  输入： n = 1\n输出： 0\n 提示：  1 \u0026lt;= n \u0026lt;= 1000  解题思路 动态规划 为使得每次复制粘贴后的操作总次数最小，则对于复制的子字符串，也要求其操作次数最小，故可以用动态规划求解。\n使用 dp[i] 表示打印出 i 的字符时，所需的最小操作次数，则：\n 初始时，dp[1] = 0； 对于 i 的每个因数 j，dp[i] = min(dp[j]+i/j)。  最终得到 n 个字符的最小操作次数 dp[n]\nfunc minSteps(n int) int { dp := make([]int, n+1) for i := 2; i \u0026lt;= n; i++ { for j := int(math.Sqrt(float64(i))); j \u0026gt;= 1; j-- { if i%j == 0 { min := dp[j] + i/j if j \u0026gt; 1 \u0026amp;\u0026amp; min \u0026gt; dp[i/j]+j { min = dp[i/j] + j } if dp[i] == 0 || dp[i] \u0026gt; min { dp[i] = min } } } } return dp[n] } 复杂度  时间复杂度：$ O(n\\sqrt{n}) $ 空间复杂度：$ O(n) $  ","date":"2021-09-19T12:56:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-650.-%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/","title":"Leetcode 650. 只有两个键的键盘"},{"content":"链接： https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/\n难度： 中等\n题目描述 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n例如，在下面的 3×4 的矩阵中包含单词 \u0026ldquo;ABCCED\u0026rdquo;（单词中的字母已标出）。\n示例 1：  输入： board = [[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;B\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;E\u0026rdquo;],[\u0026ldquo;S\u0026rdquo;,\u0026ldquo;F\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;S\u0026rdquo;],[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;D\u0026rdquo;,\u0026ldquo;E\u0026rdquo;,\u0026ldquo;E\u0026rdquo;]], word = \u0026ldquo;ABCCED\u0026rdquo;\n输出： true\n 示例 2：  输入： board = [[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;],[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;d\u0026rdquo;]], word = \u0026ldquo;abcd\u0026rdquo;\n输出： false\n 提示：  1 \u0026lt;= board.length \u0026lt;= 200 1 \u0026lt;= board[i].length \u0026lt;= 200 board 和 word 仅由大小写英文字母组成  解题思路 深度优先搜索 遍历整个矩阵，从每个字符开始进行深度优先搜索，当无法找到下一个字符时，及时剪枝。\nfunc exist(board [][]byte, word string) bool { direction := [][]int{ {-1, 0}, {1, 0}, {0, -1}, {0, 1}, } var dfs func(i, j, length int) bool dfs = func(i, j, length int) bool { // 查找到字符串尾 \tif length == len(word) { return true } // 越界检查 \tif i \u0026lt; 0 || i \u0026gt;= len(board) || j \u0026lt; 0 || j \u0026gt;= len(board[0]) { return false } // 剪枝 \tif board[i][j] == \u0026#39;.\u0026#39; || board[i][j] != word[length] { return false } for _, d := range direction { t := board[i][j] board[i][j] = \u0026#39;.\u0026#39; // 遍历标记，防止重复遍历 \tif dfs(i+d[0], j+d[1], length+1) { return true } board[i][j] = t // 恢复遍历前状态 \t} return false } for i := range board { for j := range board[i] { if dfs(i, j, 0) { return true } } } return false } 复杂度  时间复杂度：$ O(mnS), S = len(word) $ 空间复杂度：$ O(S) $  ","date":"2021-09-18T17:25:16+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/","title":"剑指 Offer 12. 矩阵中的路径"},{"content":"链接： https://leetcode-cn.com/problems/nim-game/\n难度： 简单\n题目描述 你和你的朋友，两个人一起玩 Nim 游戏：\n 桌子上有一堆石头。 你们轮流进行自己的回合，你作为先手。 每一回合，轮到的人拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。  假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。\n示例 1：  输入： n = 4\n输出： false\n解释： 如果堆中有 4 块石头，那么你永远不会赢得比赛；\n因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。\n 示例 2：  输入： n = 1\n输出： true\n 示例 3：  输入： n = 2\n输出： true\n 注意：  1 \u0026lt;= n \u0026lt;= 231 - 1  解题思路 推导 赢家必须要拿到最后1块石头，所以最后一次可以拿1～3块，则拿到第4块的石头的必输。\n赢家可以拿到第5块石头，逼对家拿第4块石头，则可知拿到第8块石头的必输。9、13\u0026hellip;同理，拿到4的倍数的玩家必输。\n若初始石头数量是4的倍数，则先手必败；否则，必胜。\nfunc canWinNim(n int) bool { if n % 4 == 0 { return false } return true } 复杂度  时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $  ","date":"2021-09-18T16:47:38+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-292.-nim-%E6%B8%B8%E6%88%8F/","title":"Leetcode 292. Nim 游戏"},{"content":"链接： https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/\n难度： 简单\n题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1：  输入： [3,4,5,1,2]\n输出： 1\n 示例 2：  输入： [2,2,2,0,1]\n输出： 0\n 提示：  1 \u0026lt;= values \u0026lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用  解题思路 遍历 顺序便利，找出最小值。\nfunc minArray(numbers []int) int { min := math.MaxInt32 for _, num := range numbers { if min \u0026gt; num { min = num } } return min } 复杂度  时间复杂度：$ O(N), N = len(numbers) $ 空间复杂度：$ O(1) $  二分查找 对于数组，每次选出中间元素，和区间右端点比较：\n 若大于右端点，则最小值不在左半区间，从右半区间查找 若小于右端点，则最小值不在右半区间，从左半区间查找 若等于右端点，则无法界定最小值在那半边区间，故使得右端点缩进1  直到区间仅剩一个数，返回。\nfunc minArray(numbers []int) int { if len(numbers) == 0 { return 0 } l, r := 0, len(numbers)-1 for l \u0026lt; r { mid := (l + r) / 2 if numbers[mid] \u0026lt; numbers[r] { r = mid } else if numbers[mid] \u0026gt; numbers[r] { l = mid + 1 } else { r-- } } return numbers[l] } 复杂度  时间复杂度：$ O(\\log N), N = len(numbers) $ 空间复杂度：$ O(1) $  ","date":"2021-09-17T17:37:57+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/","title":"剑指 Offer 11. 旋转数组的最小数字"},{"content":"链接： https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/\n难度： 简单\n题目描述 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n示例 1：  输入：\n[\u0026ldquo;CQueue\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;]\n[[],[3],[],[]]\n输出： [null,null,3,-1]\n 示例 2：  输入：\n[\u0026ldquo;CQueue\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;]\n[[],[],[5],[2],[],[]]\n输出： [null,-1,null,null,5,2]\n 提示：  1 \u0026lt;= values \u0026lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用  解题思路 出入分离 栈的特点是后进先出。想要取得头部元素，需要将整个栈中元素依次加入另一个栈中，此时，另一个栈中元素的出栈顺序即变成了先进先出。\n故使用两个栈，将入栈和出栈的操作分离，分别对应到尾部栈和头部栈：\n 当一个元素要入栈时，压入尾部栈； 当要出栈时，从头部栈弹出，若头部栈为空，则将尾部栈所有元素加入到头部栈。  type CQueue struct { frontStack *list.List backStack *list.List } func Constructor() CQueue { return CQueue{ frontStack: list.New(), backStack: list.New(), } } func (this *CQueue) AppendTail(value int) { this.backStack.PushBack(value) } func (this *CQueue) DeleteHead() int { if this.frontStack.Len() == 0 { if this.backStack.Len() == 0 { return -1 } for this.backStack.Len() \u0026gt; 0 { v := this.backStack.Back() this.backStack.Remove(v) this.frontStack.PushBack(v.Value) } } front := this.frontStack.Back() this.frontStack.Remove(front) return front.Value.(int) } 复杂度  时间复杂度：  AppendTail：$ O(1) $ DeleteHead：$ O(1) $   空间复杂度：$ O(N) $  ","date":"2021-09-17T16:40:45+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","title":"剑指 Offer 09. 用两个栈实现队列"},{"content":"链接： https://leetcode-cn.com/problems/valid-sudoku/\n难度： 中等\n题目描述 请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。\n 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）  数独部分空格内已填入了数字，空白格用 '.' 表示。\n注意： 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。\n示例 1：  输入： board =\n[[\u0026quot;5\u0026quot;,\u0026quot;3\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;7\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;], ,[\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;9\u0026quot;,\u0026quot;5\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;], ,[\u0026quot;.\u0026quot;,\u0026quot;9\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;], ,[\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;3\u0026quot;], ,[\u0026quot;4\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;3\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;1\u0026quot;], ,[\u0026quot;7\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;2\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;], ,[\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;2\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;], ,[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;4\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;9\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;5\u0026quot;], ,[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;7\u0026quot;,\u0026quot;9\u0026quot;]] 输出： true\n 示例 2：  输入： board =\n[[\u0026quot;8\u0026quot;,\u0026quot;3\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;7\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;] ,[\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;9\u0026quot;,\u0026quot;5\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;] ,[\u0026quot;.\u0026quot;,\u0026quot;9\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;] ,[\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;3\u0026quot;] ,[\u0026quot;4\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;3\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;1\u0026quot;] ,[\u0026quot;7\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;2\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;] ,[\u0026quot;.\u0026quot;,\u0026quot;6\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;2\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;] ,[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;4\u0026quot;,\u0026quot;1\u0026quot;,\u0026quot;9\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;5\u0026quot;] ,[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;8\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;7\u0026quot;,\u0026quot;9\u0026quot;]] 输出： false\n解释： 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。\n 提示：  board.length == 9 board[i].length == 9 board[i][j] 是一位数字或者 '.'  解题思路 哈希 遍历 board，将坐标映射到行、列、九宫格，使用哈希表记录，验证是否有效。\nfunc isValidSudoku(board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { var ( rowExist [9]bool colExist [9]bool SquareExist [9]bool ) for j := 0; j \u0026lt; 9; j++ { if board[i][j] != \u0026#39;.\u0026#39; { if rowExist[board[i][j]-\u0026#39;1\u0026#39;] { return false } rowExist[board[i][j]-\u0026#39;1\u0026#39;] = true } if board[j][i] != \u0026#39;.\u0026#39; { if colExist[board[j][i]-\u0026#39;1\u0026#39;] { return false } colExist[board[j][i]-\u0026#39;1\u0026#39;] = true } if board[i/3*3+j/3][i%3*3+j%3] != \u0026#39;.\u0026#39; { if SquareExist[board[i/3*3+j/3][i%3*3+j%3]-\u0026#39;1\u0026#39;] { return false } SquareExist[board[i/3*3+j/3][i%3*3+j%3]-\u0026#39;1\u0026#39;] = true } } } return true } 复杂度  时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $  ","date":"2021-09-17T11:22:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-36.-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/","title":"Leetcode 36. 有效的数独"},{"content":"链接： https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/\n难度： 中等\n题目描述 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。\n假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n示例 1：  输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n输出: [3,9,20,null,null,15,7]\n 示例 2：  输入: preorder = [-1], inorder = [-1]\n输出: [-1]\n 提示：  0 \u0026lt;= 链表长度 \u0026lt;= 10000  解题思路 递归 二叉树的先序遍历的顺序是 根\u0026gt;左\u0026gt;右，而中序遍历顺序为 左\u0026gt;根\u0026gt;右。\n故先序遍历的第一个结点即为 根结点，然后在中序遍历中找到根节点，其左侧所有元素位于为左子树，右侧所有元素在右子树。\n左右子树均按照上述规则，递归地建立二叉树。\nfunc buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 { return nil } this := \u0026amp;TreeNode{ Val: preorder[0], } for i, val := range inorder { if val == preorder[0] { this.Left = buildTree(preorder[1:i+1], inorder[:i]) this.Right = buildTree(preorder[i+1:], inorder[i+1:]) } } return this } 复杂度  时间复杂度：$ O(N\\log N), N = size(Tree) $ 空间复杂度：$ O(\\log N) $  ","date":"2021-09-17T10:45:40+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"剑指 Offer 07. 重建二叉树"},{"content":"链接： https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/\n难度： 简单\n题目描述 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n示例：  输入： head = [1,3,2]\n输出： [2,3,1]\n 提示：  0 \u0026lt;= 链表长度 \u0026lt;= 10000  解题思路 递归 递归的添加当前节点的元素到子节点返回的数组后面。递归的终止条件为：当前元素不存在，返回空数组。\nfunc reversePrint(head *ListNode) []int { if head == nil { return make([]int, 0) } return append(reversePrint(head.Next), head.Val) } 复杂度  时间复杂度：$ O(N), N = len(list) $ 空间复杂度：$ O(N) $  栈 遍历链表，依次压栈，之后反转栈中元素即可。\nfunc reversePrint(head *ListNode) []int { if head == nil { return make([]int, 0) } return append(reversePrint(head.Next), head.Val) } 复杂度  时间复杂度：$ O(N), N = len(list) $ 空间复杂度：$ O(N) $  ","date":"2021-09-16T22:20:54+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/","title":"剑指 Offer 06. 从尾到头打印链表"},{"content":"链接： https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/\n难度： 简单\n题目描述 请实现一个函数，把字符串 s 中的每个空格替换成\u0026quot;%20\u0026quot;。\n示例：  输入： s = \u0026ldquo;We are happy.\u0026rdquo;\n输出： \u0026ldquo;We%20are%20happy.\u0026rdquo;\n 提示：  0 \u0026lt;= s 的长度 \u0026lt;= 10000  解题思路 模拟 遍历原字符串，将每个字符加入到结果字符串的末尾，遇到 ' ' 需替换为 \u0026quot;%20\u0026quot;。\nfunc replaceSpace(s string) string { t := make([]byte, 0, len(s)*3) for i := range s { if s[i] == \u0026#39; \u0026#39; { t = append(t, \u0026#34;%20\u0026#34;...) } else { t = append(t, s[i]) } } return string(t) } 复杂度  时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $  ","date":"2021-09-16T22:15:07+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/","title":"剑指 Offer 05. 替换空格"},{"content":"链接： https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/\n难度： 中等\n题目描述 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n示例：  现有矩阵 matrix 如下：\n[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。\n给定 target = 20，返回 false。\n 提示：  0 \u0026lt;= n \u0026lt;= 1000 0 \u0026lt;= m \u0026lt;= 1000  解题思路 暴力求解 遍历整个二维数组，寻找该整数。\nfunc findNumberIn2DArray(matrix [][]int, target int) bool { for _, line := range matrix { for _, cell := range line { if cell == target { return true } else if cell \u0026gt; target { break } } } return false } 复杂度  时间复杂度：$ O(nm) $ 空间复杂度：$ O(1) $  阶梯遍历 从矩阵右上角开始遍历：\n 等于 target，则返回； 大于 target，则向左移动一列； 小于 target，则向下移动一行。  func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } i, j := 0, len(matrix[0])-1 for i \u0026lt; len(matrix) \u0026amp;\u0026amp; j \u0026gt;= 0 { if matrix[i][j] == target { return true } else if matrix[i][j] \u0026lt; target { i++ } else { j-- } } return false } 复杂度  时间复杂度：$ O(n+m) $ 空间复杂度：$ O(1) $  ","date":"2021-09-16T19:42:33+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","title":"剑指 Offer 04. 二维数组中的查找"},{"content":"链接： https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/\n难度： 简单\n题目描述 找出数组中重复的数字。\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n示例：  输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出： 2 或 3\n 提示：  2 \u0026lt;= n \u0026lt;= 100000  解题思路 哈希 使用哈希表记录数组中的元素是否出现过。遍历数组，如果出现过则返回；否则，在哈希表中标记该元素已出现。\nfunc findRepeatNumber(nums []int) int { appear := make(map[int]struct{}) for _, num := range nums { if _, ok := appear[num]; ok { return num } appear[num] = struct{}{} } return 0 } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  ","date":"2021-09-16T19:19:47+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","title":"剑指 Offer 03. 数组中重复的数字"},{"content":"链接： https://leetcode-cn.com/problems/find-peak-element/\n难度： 中等\n题目描述 峰值元素是指其值严格大于左右相邻值的元素。\n给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。\n你可以假设 nums[-1] = nums[n] = -∞ 。\n你必须实现时间复杂度为 O(log n) 的算法来解决此问题。\n示例 1：  输入： nums = [1,2,3,1]\n输出： 2\n解释： 3 是峰值元素，你的函数应该返回其索引 2。\n 示例 2：  输入： nums = [1,2,1,3,5,6,4]\n输出： 1 或 5\n解释： 你的函数可以返回索引 1，其峰值元素为 2；\n或者返回索引 5， 其峰值元素为 6。\n 提示：  1 \u0026lt;= nums.length \u0026lt;= 1000 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 对于所有有效的 i 都有 nums[i] != nums[i + 1]  解题思路 暴力求解 遍历数组，每个元素均和左右侧元素比较找出峰值元素，边界元素需要特判。\nfunc findPeakElement(nums []int) int { for i, num := range nums { if (i == 0 || (i \u0026gt; 0 \u0026amp;\u0026amp; num \u0026gt; nums[i-1])) \u0026amp;\u0026amp; (i == len(nums)-1 || (i \u0026lt; len(nums)-1 \u0026amp;\u0026amp; num \u0026gt; nums[i+1])) { return i } } return 0 } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $  二分查找 每次使用区间的中间变量与其左边的值比较：\n 当大于左边的值时，说明又半区间有峰值元素 否则，说明左半区间有峰值元素  重复上述步骤，直到区间只剩下一个元素，则返回此峰值元素。\nfunc findPeakElement(nums []int) int { for l, r := 0, len(nums); l \u0026lt; r; { if l+1 == r { return l } mid := (l + r) / 2 if mid == 0 || (mid \u0026gt; 0 \u0026amp;\u0026amp; nums[mid] \u0026gt; nums[mid-1]) { l = mid } else { r = mid } } return 0 } 复杂度  时间复杂度：$ O(\\log N), N = len(nums) $ 空间复杂度：$ O(1) $  ","date":"2021-09-15T10:11:21+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-162.-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/","title":"Leetcode 162. 寻找峰值"},{"content":"链接： https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/\n难度： 中等\n题目描述 给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。\n如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。\n示例 1：  输入： s = \u0026ldquo;abpcplea\u0026rdquo;, dictionary = [\u0026ldquo;ale\u0026rdquo;,\u0026ldquo;apple\u0026rdquo;,\u0026ldquo;monkey\u0026rdquo;,\u0026ldquo;plea\u0026rdquo;]\n输出： \u0026ldquo;apple\u0026rdquo;\n 示例 2：  输入： s = \u0026ldquo;abpcplea\u0026rdquo;, dictionary = [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;c\u0026rdquo;]\n输出： \u0026ldquo;a\u0026rdquo;\n 提示：  1 \u0026lt;= s.length \u0026lt;= 1000 1 \u0026lt;= dictionary.length \u0026lt;= 1000 1 \u0026lt;= dictionary[i].length \u0026lt;= 1000 s 和 dictionary[i] 仅由小写英文字母组成  解题思路 暴力求解 遍历字典，对于符合 s 的子序列的每个元素，记录最大长度的最小元素。\nfunc findLongestWord(s string, dictionary []string) string { contains := func(s, sub string) bool { j := 0 for i := 0; i \u0026lt; len(s) \u0026amp;\u0026amp; j \u0026lt; len(sub); i++ { if s[i] == sub[j] { j++ } } if j == len(sub) { return true } return false } maxLen := 0 ans := \u0026#34;\u0026#34; for _, d := range dictionary { if contains(s, d) { if maxLen \u0026lt; len(d) { maxLen = len(d) ans = d } else if maxLen == len(d) \u0026amp;\u0026amp; ans \u0026gt; d { ans = d } } } return ans } 复杂度  时间复杂度：$ O(N*L), N = len(dictionary), L = max(dictionory[i]) $ 空间复杂度：$ O(1) $  ","date":"2021-09-14T17:03:15+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-524.-%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/","title":"Leetcode 524. 通过删除字母匹配到字典里最长单词"},{"content":"链接： https://leetcode-cn.com/problems/number-of-boomerangs/\n难度： 中等\n题目描述 给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。\n返回平面上所有回旋镖的数量。\n示例 1：  输入： points = [[0,0],[1,0],[2,0]]\n输出： 2\n解释： 两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]\n 示例 2：  输入： points = [[1,1],[2,2],[3,3]]\n输出： 2\n 示例 3：  输入： points = [[1,1]]\n输出： 0\n 提示：  n == points.length 1 \u0026lt;= n \u0026lt;= 500 points[i].length == 2 -104 \u0026lt;= xi, yi \u0026lt;= 104 所有点都 互不相同  解题思路 哈希 使用哈希表 cnt[p][d] 记录记录距离点 p 距离为 d 的点的距离，依次求得两个点之间的距离，并记录到哈希表。\n遍历哈希表，对于每个 p 和 d ，将可选点的排列数累加进到结果中。\nfunc numberOfBoomerangs(points [][]int) int { cnt := make(map[int]map[int]int) for i := range points { cnt[i] = make(map[int]int) } for i := 0; i \u0026lt; len(points)-1; i++ { for j := i + 1; j \u0026lt; len(points); j++ { distance := (points[i][0]-points[j][0])*(points[i][0]-points[j][0]) + (points[i][1]-points[j][1])*(points[i][1]-points[j][1]) cnt[i][distance]++ cnt[j][distance]++ } } ans := 0 for _, p := range cnt { for _, v := range p { ans += v * (v - 1) } } return ans } 复杂度  时间复杂度：$ O(N^2), N = len(points) $ 空间复杂度：$ O(N^2) $  ","date":"2021-09-13T10:21:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-447.-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/","title":"Leetcode 447. 回旋镖的数量"},{"content":"链接： https://leetcode-cn.com/problems/valid-parenthesis-string/\n难度： 中等\n题目描述 给定一个只包含三种字符的字符串：( ，) 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：\n 任何左括号 ( 必须有相应的右括号 )。 任何右括号 ) 必须有相应的左括号 ( 。 左括号 ( 必须在对应的右括号之前 )。 * 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。 一个空字符串也被视为有效字符串。  示例 1：  输入: \u0026ldquo;()\u0026rdquo;\n输出: True\n 示例 2：  输入: \u0026ldquo;(*)\u0026rdquo;\n输出: True\n 示例 3：  输入: \u0026ldquo;(*))\u0026rdquo;\n输出: True\n 注意：  字符串大小将在 [1，100] 范围内。  解题思路 栈 使用栈来进行括号的匹配:\n 每当遇到 ( 和 * ，入栈； 当遇到 ) 时，优先从栈中寻找距栈顶最近的 ( ，以完成配对，然后该 ( 从栈中弹出；当不存在 ( 时，使用 * 代替 ( 配对并弹出，都不存在返回 false。  对字符串完成遍历后，栈中仅剩下 ( 和 * ，此时从栈顶开始，配对消除 (，能全部消除，返回 true，否则返回 false。\nfunc checkValidString(s string) bool { stack := make([]byte, 0, len(s)) for i := 0; i \u0026lt; len(s); i++ { switch s[i] { case \u0026#39;*\u0026#39;, \u0026#39;(\u0026#39;: stack = append(stack, s[i]) case \u0026#39;)\u0026#39;: if len(stack) == 0 { return false } // 优先配对 ( \tj := len(stack) - 1 for ; j \u0026gt;= 0; j-- { if stack[j] == \u0026#39;(\u0026#39; { stack = append(stack[:j], stack[j+1:]...) break } } // 无 ( 使用 * 配对 \tif j \u0026lt; 0 { stack = stack[:len(stack)-1] } } } stars := 0 // 消除 ( \tfor i := len(stack) - 1; i \u0026gt;= 0; i-- { switch stack[i] { case \u0026#39;*\u0026#39;: stars++ case \u0026#39;(\u0026#39;: if stars \u0026gt; 0 { stars-- } else { return false } } } return true } 复杂度  时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(N) $  ","date":"2021-09-12T23:38:03+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-678.-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 678. 有效的括号字符串"},{"content":"链接： https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/\n难度： 中等\n题目描述 一个班级里有 n 个学生，编号为 0 到 n - 1 。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。\n给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k 。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗 chalk[i] 支粉笔。如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要 补充 粉笔。\n请你返回需要 补充 粉笔的学生 编号 。\n示例 1：  输入： chalk = [5,1,5], k = 22\n输出： 0\n解释： 学生消耗粉笔情况如下：\n 编号为 0 的学生使用 5 支粉笔，然后 k = 17 。 编号为 1 的学生使用 1 支粉笔，然后 k = 16 。 编号为 2 的学生使用 5 支粉笔，然后 k = 11 。 编号为 0 的学生使用 5 支粉笔，然后 k = 6 。 编号为 1 的学生使用 1 支粉笔，然后 k = 5 。 编号为 2 的学生使用 5 支粉笔，然后 k = 0 。\n编号为 0 的学生没有足够的粉笔，所以他需要补充粉笔。   示例 2：  输入： chalk = [3,4,1,2], k = 25\n输出： 1\n解释： 学生消耗粉笔情况如下：\n 编号为 0 的学生使用 3 支粉笔，然后 k = 22 。 编号为 1 的学生使用 4 支粉笔，然后 k = 18 。 编号为 2 的学生使用 1 支粉笔，然后 k = 17 。 编号为 3 的学生使用 2 支粉笔，然后 k = 15 。 编号为 0 的学生使用 3 支粉笔，然后 k = 12 。 编号为 1 的学生使用 4 支粉笔，然后 k = 8 。 编号为 2 的学生使用 1 支粉笔，然后 k = 7 。 编号为 3 的学生使用 2 支粉笔，然后 k = 5 。 编号为 0 的学生使用 3 支粉笔，然后 k = 2 。\n编号为 1 的学生没有足够的粉笔，所以他需要补充粉笔。   提示：  chalk.length == n 1 \u0026lt;= n \u0026lt;= 105 1 \u0026lt;= chalk[i] \u0026lt;= 105 1 \u0026lt;= k \u0026lt;= 109  解题思路 遍历优化 遍历 chalk 数组，求得完成一轮需要的粉笔数量 sum，用 k 模 sum ，得到最后一轮所需的粉笔数量，然后再次遍历 chalk，将粉笔用光，返回。\nfunc chalkReplacer(chalk []int, k int) int { sum := 0 for _, c := range chalk { sum += c } k %= sum for i, c := range chalk { k -= c if k \u0026lt; 0 { return i } } return 0 } 复杂度  时间复杂度：$ O(N), N = len(chalk) $ 空间复杂度：$ O(1) $  前缀和 + 二分查找 求得 chalk 数组的前缀和，同样用 k 模 整个数组的和 得到最后一轮所需的粉笔数量 k'，采用二分查找，找到首个小于 k' 的前缀和位置并返回。\nfunc chalkReplacer(chalk []int, k int) int { for i := 1; i \u0026lt; len(chalk); i++ { chalk[i] = chalk[i-1] + chalk[i] } k %= chalk[len(chalk)-1] return sort.Search(len(chalk), func(i int) bool { return chalk[i] \u0026gt; k }) } 复杂度  时间复杂度：$ O(N), N = len(chalk) $ 空间复杂度：$ O(1) $  ","date":"2021-09-10T12:10:52+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1894.-%E6%89%BE%E5%88%B0%E9%9C%80%E8%A6%81%E8%A1%A5%E5%85%85%E7%B2%89%E7%AC%94%E7%9A%84%E5%AD%A6%E7%94%9F%E7%BC%96%E5%8F%B7/","title":"Leetcode 1894. 找到需要补充粉笔的学生编号"},{"content":"链接： https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/\n难度： 简单\n题目描述 在一个 平衡字符串 中，'L' 和 'R' 字符的数量是相同的。\n给你一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。\n**注意：**分割得到的每个字符串都必须是平衡字符串。\n返回可以通过分割得到的平衡字符串的 最大数量 。\n示例 1：  输入： s = \u0026ldquo;RLRRLLRLRL\u0026rdquo;\n输出： 4\n解释： s 可以分割为 \u0026ldquo;RL\u0026rdquo;、\u0026ldquo;RRLL\u0026rdquo;、\u0026ldquo;RL\u0026rdquo;、\u0026ldquo;RL\u0026rdquo; ，每个子字符串中都包含相同数量的 \u0026lsquo;L\u0026rsquo; 和 \u0026lsquo;R\u0026rsquo; 。\n 示例 2：  输入： s = \u0026ldquo;RLLLLRRRLR\u0026rdquo;\n输出： 3\n解释： s 可以分割为 \u0026ldquo;RL\u0026rdquo;、\u0026ldquo;LLLRRR\u0026rdquo;、\u0026ldquo;LR\u0026rdquo; ，每个子字符串中都包含相同数量的 \u0026lsquo;L\u0026rsquo; 和 \u0026lsquo;R\u0026rsquo; 。\n 示例 3：  输入： s = \u0026ldquo;LLLLRRRR\u0026rdquo;\n输出： 1\n解释： s 只能保持原样 \u0026ldquo;LLLLRRRR\u0026rdquo;.\n 示例 4：  输入： s = \u0026ldquo;RLRRRLLRLL\u0026rdquo;\n输出： 2\n解释： s 可以分割为 \u0026ldquo;RL\u0026rdquo;、\u0026ldquo;RRRLLRLL\u0026rdquo; ，每个子字符串中都包含相同数量的 \u0026lsquo;L\u0026rsquo; 和 \u0026lsquo;R\u0026rsquo; 。\n 提示：  1 \u0026lt;= s.length \u0026lt;= 1000 s[i] = \u0026lsquo;L\u0026rsquo; 或 \u0026lsquo;R\u0026rsquo; s 是一个 平衡 字符串  解题思路 贪心 为使得分割后的平衡字符串数量最大，应按最小粒度进行分割。可以采用贪心策略，从前向后遍历原字符串，每当构成平衡字符串时，进行一次分割。\nfunc balancedStringSplit(s string) int { split := 0 balance := 0 for i := 0; i \u0026lt; len(s); i++ { switch s[i] { case \u0026#39;L\u0026#39;: balance-- case \u0026#39;R\u0026#39;: balance++ } if balance == 0 { split++ } } return split } 复杂度  时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $  ","date":"2021-09-07T09:47:34+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1221.-%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 1221. 分割平衡字符串"},{"content":"链接： https://leetcode-cn.com/problems/binary-search/\n难度： 简单\n题目描述 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例 1：  输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n 示例 2：  输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n 提示：  你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000] 之间。 nums 的每个元素都将在 [-9999, 9999] 之间。  解题思路 二分查找 func search(nums []int, target int) int { for l, r := 0, len(nums); l \u0026lt; r; { mid := (l + r) / 2 if target == nums[mid] { return mid } else if target \u0026lt; nums[mid] { r = mid } else { l = mid + 1 } } return -1 } 复杂度  时间复杂度：$ O(\\log N), N = len(nums) $ 空间复杂度：$ O(1) $  ","date":"2021-09-06T09:41:51+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-704.-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","title":"Leetcode 704. 二分查找"},{"content":"链接： https://leetcode-cn.com/problems/implement-rand10-using-rand7/\n难度： 中等\n题目描述 已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。\n不要使用系统的 Math.random() 方法。\n示例 1：  输入: 1\n输出: [7]\n 示例 2：  输入: 2\n输出: [8,4]\n 示例 3：  输入: 3\n输出: [8,1,10]\n 提示：  rand7 已定义。 传入参数: n 表示 rand10 的调用次数。  进阶：  rand7() 调用次数的 期望值 是多少 ? 你能否尽量少调用 rand7() ?  解题思路  rand7 函数等概率的生成 1~7 的随机数，为生成 1~10的随机数，需要等概率的生成 10 的倍数个随机数。\n将两次调用 rand7 生成的随机数相乘，将等概率的生成 49 个随机数，将最后 9 个数排除，则前 40 个数字的生成是等概率的，通过简单的模运算即可得到 1~10 的随机数。\n每次生成最后的九个随机数时，重新进行上述步骤，直到生成前 40 个随机数为止。\n期望：\n容易求得前 i 次未生成的概率为$(\\frac{9}{49})^i$，\n则第 i 次生成的概率为$\\frac{40}{49}(\\frac{9}{49})^{i-1}$，调用 rand7 的次数为$2i\\frac{40}{49}(\\frac{9}{49})^{i-1}$\n所以调用期望为:\n$$ E = \\sum_{i=1}^{+\\infty}2i(\\frac{9}{49})^{i-1}\\frac{40}{49} = 2*\\frac{40}{49}\\sum_{i=1}^{+\\infty}i(\\frac{9}{49})^{i-1} $$\n令 $S_n = \\sum\\limits_{i=1}^{n}i(\\frac{9}{49})^{i-1}$，$\\frac{9}{49}S_{n-1} = \\sum\\limits_{i=1}^{n}i(\\frac{9}{49})^{i}$\n$$ S_n - \\frac{9}{49}S_{n-1} = \\frac{40}{49}S_{n-1} = \\sum\\limits_{i=1}^{n}(\\frac{9}{49})^{i-1} - n(\\frac{9}{49}^n) = \\frac{1-(\\frac{9}{49})^n}{1-\\frac{9}{49}} - n(\\frac{9}{49})^n $$\n故 $S_n = \\frac{\\frac{1-(\\frac{9}{49})^n}{1-\\frac{9}{49}} - n(\\frac{9}{49})^n}{\\frac{40}{49}}$\n$$ E = 2*\\frac{40}{49}\\lim_{n\\to+\\infty}S_n = 2\\lim_{n\\to+\\infty}\\frac{1-(\\frac{9}{49})^n}{1-\\frac{9}{49}} - n(\\frac{9}{49})^n = 2.45 $$\n可以生成的期望为：2\nfunc rand10() int { for { pos := 7*(rand7()-1) + rand7() if pos \u0026lt;= 40 { return pos%10 + 1 } } } 复杂度  时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $  ","date":"2021-09-05T16:27:29+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-470.-%E7%94%A8-rand7-%E5%AE%9E%E7%8E%B0-rand10/","title":"Leetcode 470. 用 Rand7() 实现 Rand10()"},{"content":"链接： https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/\n难度： 简单\n题目描述 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：\nF(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N \u0026gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n示例 1：  输入： n = 2\n输出： 1\n 示例 2：  输入： n = 5\n输出： 5\n 提示：  0 \u0026lt;= n \u0026lt;= 100  解题思路 动态规划 动态规划的状态转移方程已在题目中给出，使用三个变量降低空间复杂度。\nfunc fib(n int) int { const MOD = 1e9 + 7 dp := []int{0, 1, 0} if n \u0026lt; 2 { return dp[n] } for i := 2; i \u0026lt;= n; i++ { dp[2] = (dp[0] + dp[1]) % MOD dp[0], dp[1] = dp[1], dp[2] } return dp[2] } 复杂度  时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $  ","date":"2021-09-04T08:01:33+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","title":"剑指 Offer 10- I. 斐波那契数列"},{"content":"链接： https://leetcode-cn.com/problems/smallest-k-lcci/\n难度： 中等\n题目描述 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。\n示例：  输入： arr = [1,3,5,7,2,4,6,8], k = 4\n输出： [1,2,3,4]\n 提示：  0 \u0026lt;= len(arr) \u0026lt;= 100000 0 \u0026lt;= k \u0026lt;= min(100000, len(arr))  解题思路 排序 对原数组排序，返回前 k 个元素。\nfunc smallestK(arr []int, k int) []int { sort.Ints(arr) return arr[:k] } 复杂度  时间复杂度：$ O(N\\log N), N = len(arr) $ 空间复杂度：$ O(\\log N) $  堆 构建一个大顶堆，保存前 k 个最小的数。遍历 arr 数组\n 当堆中元素数量不足 k 时，入堆； 当堆中元素书数量为 k 时，与堆顶元素比较  当堆顶元素为较大时，弹出队顶元素，当前元素入堆 否则，忽略当前元素    遍历结束，返回堆中所有元素。\ntype MaxHeap struct { sort.IntSlice } func (this *MaxHeap) Less(i, j int) bool { return !this.IntSlice.Less(i, j) } func (this *MaxHeap) Push(elem interface{}) { this.IntSlice = append(this.IntSlice, elem.(int)) } func (this *MaxHeap) Pop() interface{} { t := this.IntSlice[len(this.IntSlice)-1] this.IntSlice = this.IntSlice[:len(this.IntSlice)-1] return t } func smallestK(arr []int, k int) []int { if k == 0 { return []int{} } h := \u0026amp;MaxHeap{ IntSlice: make([]int, 0, k), } for _, num := range arr { if h.Len() \u0026lt; k { heap.Push(h, num) } else if h.IntSlice[0] \u0026gt; num { heap.Pop(h) heap.Push(h, num) } } return h.IntSlice } 复杂度  时间复杂度：$ O(N\\log k), N = len(arr) $ 空间复杂度：$ O(k) $  快速选择 使用快速排序的思路，找到第 k 大的数，则包括其在内的所有左边的书即构成了结果集合。\nfunc smallestK(arr []int, k int) []int { var f func(l, r int) f = func(l, r int) { if l \u0026gt;= r { return } target := arr[r-1] lt := l for i := l; i \u0026lt; r; i++ { if arr[i] \u0026lt;= target { arr[lt], arr[i] = arr[i], arr[lt] lt++ } } if lt \u0026lt; k { f(lt, r) } else if lt \u0026gt; k { f(0, lt-1) } } f(0, len(arr)) return arr[:k] } 复杂度  时间复杂度：$ O(N), N = len(arr) $ 空间复杂度：$ O(\\log N) $  ","date":"2021-09-03T11:30:22+08:00","permalink":"https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.14.-%E6%9C%80%E5%B0%8Fk%E4%B8%AA%E6%95%B0/","title":"面试题 17.14. 最小K个数"},{"content":"链接： https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/\n难度： 简单\n题目描述 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。\n例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。\n示例：  给定一个链表: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, 和 k = 2.\n返回链表 4-\u0026gt;5.\n 解题思路 顺序遍历 遍历一边链表，得到其长度 length，则 length - k 即为需要跳过的结点，重新遍历，跳过前 length - k 个结点。\nfunc getKthFromEnd(head *ListNode, k int) *ListNode { length := 0 for node := head; node != nil; node = node.Next { length++ } node := head for i := length - k; i \u0026gt; 0; i-- { node = node.Next } return node } 复杂度  时间复杂度：$ O(N), N = len(head) $ 空间复杂度：$ O(1) $  ","date":"2021-09-02T09:29:06+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-22.-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","title":"剑指 Offer 22. 链表中倒数第k个节点"},{"content":"链接： https://leetcode-cn.com/problems/corporate-flight-bookings/\n难度： 中等\n题目描述 这里有 n 个航班，它们分别从 1 到 n 进行编号。\n有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。\n请你返回一个长度为 n 的数组 answer，其中 answer[i] 是航班 i 上预订的座位总数。\n示例 1：  输入： bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\n输出： [10,55,45,25,25]\n解释：\n航班编号 1 2 3 4 5\n预订记录 1 ：10 10\n预订记录 2 ： 20 20\n预订记录 3 ： 25 25 25 25\n总座位数： 10 55 45 25 25\n因此，answer = [10,55,45,25,25]\n 示例 2：  输入： bookings = [[1,2,10],[2,2,15]], n = 2\n输出： [10,25]\n解释：\n航班编号 1 2\n预订记录 1 ：10 10\n预订记录 2 ： 15\n总座位数： 10 25\n因此，answer = [10,25]\n 提示：  1 \u0026lt;= n \u0026lt;= 2 * 104 1 \u0026lt;= bookings.length \u0026lt;= 2 * 104 bookings[i].length == 3 1 \u0026lt;= firsti \u0026lt;= lasti \u0026lt;= n 1 \u0026lt;= seatsi \u0026lt;= 104  解题思路 暴力求解 遍历 bookings 列表，将 first 到 last 的 seats 累加到对应的航班中。\nfunc corpFlightBookings(bookings [][]int, n int) []int { ans := make([]int, n) for _, booking := range bookings { for i := booking[0] - 1; i \u0026lt; booking[1]; i++ { ans[i] += booking[2] } } return ans } 复杂度  时间复杂度：$ O(Mn), M = len(bookings) $ 空间复杂度：$ O(1) $  查分数组 使用差分数组，ans[i] 保存与 ans[i-1] 的差值，每次即可进行区间操作：\n对 firsti 加上 seatsi，然后对 lasti+1 减去 seatsi，表示对区间 [firsti, lasti] 加上seatsi\nfunc corpFlightBookings(bookings [][]int, n int) []int { ans := make([]int, n) for _, booking := range bookings { ans[booking[0]-1] += booking[2] if booking[1] \u0026lt; n { ans[booking[1]] -= booking[2] } } for i := 1; i \u0026lt; n; i++ { ans[i] += ans[i-1] } return ans } 复杂度  时间复杂度：$ O(M+n), M = len(bookings) $ 空间复杂度：$ O(1) $  ","date":"2021-08-31T10:37:40+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1109.-%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/","title":"Leetcode 1109. 航班预订统计"},{"content":"链接： https://leetcode-cn.com/problems/random-pick-with-weight/\n难度： 中等\n题目描述 给定一个正整数数组 w ，其中 w[i] 代表下标 i 的权重（下标从 0 开始），请写一个函数 pickIndex ，它可以随机地获取下标 i，选取下标 i 的概率与 w[i] 成正比。\n例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。\n也就是说，选取下标 i 的概率为 w[i] / sum(w) 。\n示例 1：  输入：\n[\u0026ldquo;Solution\u0026rdquo;,\u0026ldquo;pickIndex\u0026rdquo;]\n[[[1]],[]]\n输出：\n[null,0]\n解释：\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。\n 示例 2：  输入：\n[\u0026ldquo;Solution\u0026rdquo;,\u0026ldquo;pickIndex\u0026rdquo;,\u0026ldquo;pickIndex\u0026rdquo;,\u0026ldquo;pickIndex\u0026rdquo;,\u0026ldquo;pickIndex\u0026rdquo;,\u0026ldquo;pickIndex\u0026rdquo;]\n[[[1,3]],[],[],[],[],[]]\n输出：\n[null,1,1,1,1,0]\n解释：\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。\n由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0] \u0026hellip;\u0026hellip;\n诸若此类。\n 提示：  1 \u0026lt;= w.length \u0026lt;= 10000 1 \u0026lt;= w[i] \u0026lt;= 105 pickIndex 将被调用不超过 10000 次  解题思路 前缀和 Constructor ，求的数组 w 的总和 sum，并构造一个生成器。 PickIndex，使用生成器得到一个位于区间 [0,sum) 的随机数 r ，依次遍历 w 数组，计算前缀和，直到前缀和大于 r 时，返回该下标。\ntype Solution struct { r *rand.Rand w []int sum int } func Constructor(w []int) Solution { sum := 0 for _, t := range w { sum += t } return Solution{ r: rand.New(rand.NewSource(time.Now().UnixNano())), w: w, sum: sum, } } func (this *Solution) PickIndex() int { r := rand.Intn(this.sum) preSum := 0 for i, t := range this.w { preSum += t if r \u0026lt; preSum { return i } } return 0 } 复杂度  时间复杂度：  Constructor ：$ O(N), N = len(w) $ PickIndex ：$ O(N) $   空间复杂度：$ O(N) $  优化(二分查找) 初始化时，构造出前缀和数组，每次生成时即可采用二分查找。\ntype Solution struct { r *rand.Rand sum []int } func Constructor(w []int) Solution { prefixSum := make([]int, len(w)) prefixSum[0] = w[0] for i := 1; i \u0026lt; len(w); i++ { prefixSum[i] += prefixSum[i-1] + w[i] } return Solution{ r: rand.New(rand.NewSource(time.Now().UnixNano())), sum: prefixSum, } } func (this *Solution) PickIndex() int { r := rand.Intn(this.sum[len(this.sum)-1]) return sort.Search(len(this.sum)-1, func(i int) bool { return r \u0026lt; this.sum[i] }) } 复杂度  时间复杂度：  Constructor ：$ O(N), N = len(w) $ PickIndex ：$ O(\\log\\ N) $   空间复杂度：$ O(N) $  ","date":"2021-08-30T10:33:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-528.-%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9/","title":"Leetcode 528. 按权重随机选择"},{"content":"链接： https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/\n难度： 简单\n题目描述 给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。\n子数组 定义为原数组中的一个连续子序列。\n请你返回 arr 中 所有奇数长度子数组的和 。\n示例 1：  输入： arr = [1,4,2,5,3]\n输出： 58\n解释： 所有奇数长度子数组和它们的和为：\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\n我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58\n 示例 2：  输入： arr = [1,2]\n输出： 3\n解释： 总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。\n 示例 3：  输入： arr = [10,11,12]\n输出： 66\n 提示：  1 \u0026lt;= arr.length \u0026lt;= 100 1 \u0026lt;= arr[i] \u0026lt;= 1000  解题思路 暴力求解 枚举出所有奇数子数组的 [i, j]，求得子数组的和，累加进结果中。\nfunc sumOddLengthSubarrays(arr []int) int { sum := 0 for i := 0; i \u0026lt; len(arr); i++ { for j := i; j \u0026lt; len(arr); j += 2 { t := 0 for k := i; k \u0026lt;= j; k++ { t += arr[k] } sum += t } } return sum } 复杂度  时间复杂度：$ O(N^3), N = len(arr) $ 空间复杂度：$ O(1) $  前缀和 依次枚举出所有子数组的开始下标 i，对于每个 i ，遍历其后元素，求得子数组的和，每当子数组长度为奇数时，将该数组的和累加进结果中。\nfunc sumOddLengthSubarrays(arr []int) int { sum := 0 for i := 0; i \u0026lt; len(arr); i++ { t := 0 for j := i; j \u0026lt; len(arr); j++ { t += arr[j] if (j-i)\u0026amp;1 == 0 { sum += t } } } return sum } 复杂度  时间复杂度：$ O(N^2), N = len(arr) $ 空间复杂度：$ O(1) $  ","date":"2021-08-29T21:32:29+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1588.-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/","title":"Leetcode 1588. 所有奇数长度子数组的和"},{"content":"链接： https://leetcode-cn.com/problems/running-sum-of-1d-array/\n难度： 简单\n题目描述 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。\n请返回 nums 的动态和。\n示例 1：  输入： nums = [1,2,3,4]\n输出： [1,3,6,10]\n解释： 动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。\n 示例 2：  输入： nums = [1,1,1,1,1]\n输出： [1,2,3,4,5]\n解释： 动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。\n 示例 3：  输入： nums = [3,1,2,10,1]\n输出： [3,4,6,16,17]\n 提示：  1 \u0026lt;= nums.length \u0026lt;= 1000 -106 \u0026lt;= nums[i] \u0026lt;= 106  解题思路 模拟 按照题目描述，依次求解动态和的每一项\nfunc runningSum(nums []int) []int { sum := make([]int, len(nums)) for i := 0; i \u0026lt; len(nums); i++ { for j := 0; j \u0026lt;= i; j++ { sum[i] += nums[j] } } return sum } 复杂度  时间复杂度：$ O(N^2), N = len(nums) $ 空间复杂度：$ O(1) $  动态规划 使用 sum[i] 记录第 i 项动态和，则可以得出：sum[i] = sum[i-1] + nums[i]，依次向后求解。\nfunc runningSum(nums []int) []int { sum := make([]int, len(nums)) sum[0] = nums[0] for i := 1; i \u0026lt; len(nums); i++ { sum[i] = sum[i-1] + nums[i] } return sum } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ​  ","date":"2021-08-28T11:05:35+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1480.-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/","title":"Leetcode 1480. 一维数组的动态和"},{"content":"链接： https://leetcode-cn.com/problems/boats-to-save-people/\n难度： 中等\n题目描述 第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。\n每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。\n返回载到每一个人所需的最小船数。(保证每个人都能被船载)。\n示例 1：  输入： people = [1,2], limit = 3\n输出： 1\n解释： 1 艘船载 (1, 2)\n 示例 2：  输入： people = [3,2,2,1], limit = 3\n输出： 3\n解释： 3 艘船分别载 (1, 2), (2) 和 (3)\n 示例 3：  输入： people = [3,5,3,4], limit = 5\n输出： 4\n解释： 4 艘船分别载 (3), (3), (4), (5)\n 提示：  1 \u0026lt;= people.length \u0026lt;= 50000 1 \u0026lt;= people[i] \u0026lt;= limit \u0026lt;= 30000  解题思路 排序 + 贪心 由于每艘船最多仅能搭乘两人，可以按照体重排序，每次选出最重的和最轻的两个人，尝试能否同乘一条船：\n 当可以同乘一条船时，所需船数量加一，从剩余人中继续挑选； 当无法同乘一条船时，最重的那个人需要独自乘坐一条船，所需船数量加一，轻的人回到队列中  最终使得所有人都乘到船为止，返回所需船的数量。\nfunc numRescueBoats(people []int, limit int) int { boats := 0 sort.Ints(people) for i, j := 0, len(people)-1; i \u0026lt;= j; boats++ { if people[i]+people[j] \u0026lt;= limit { i++ j-- } else { j-- } } return boats } 复杂度  时间复杂度：$ O(N\\log\\ N), N = len(people) $ 空间复杂度：$ O(\\log\\ N) $  ","date":"2021-08-26T18:56:34+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-881.-%E6%95%91%E7%94%9F%E8%89%87/","title":"Leetcode 881. 救生艇"},{"content":"链接： https://leetcode-cn.com/problems/all-paths-from-source-to-target/\n难度： 中等\n题目描述 给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）\n二维数组的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些节点，空就是没有下一个结点了。\n译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。\n示例 1：  输入： graph = [[1,2],[3],[3],[]]\n输出： [[0,1,3],[0,2,3]]\n解释： 有两条路径 0 -\u0026gt; 1 -\u0026gt; 3 和 0 -\u0026gt; 2 -\u0026gt; 3\n 示例 2：  输入： graph = [[4,3,1],[3,2,4],[3],[4],[]]\n输出： [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n 示例 3：  输入： graph = [[1],[]]\n输出： [[0,1]]\n 示例 4：  输入： graph = [[1,2,3],[2],[3],[]]\n输出： [[0,1,2,3],[0,2,3],[0,3]]\n 示例 5：  输入： graph = [[1,3],[2],[3],[]]\n输出： [[0,1,2,3],[0,3]]\n 提示：  n == graph.length 2 \u0026lt;= n \u0026lt;= 15 0 \u0026lt;= graph[i][j] \u0026lt; n graph[i][j] != i（即，不存在自环） graph[i] 中的所有元素 互不相同 保证输入为 有向无环图（DAG）  解题思路 深度优先搜索 采用深度优先搜索，每次将遍历到的结点入栈，直到到达终点，将栈内的路径加入到结果集中。\nfunc allPathsSourceTarget(graph [][]int) [][]int { res := make([][]int, 0, len(graph)) path := make([]int, len(graph)) var dfs func(i int, depth int) dfs = func(i int, depth int) { if depth == len(graph) { return } path[depth] = i // 到达终点，加入结果 \tif i == len(graph)-1 { t := make([]int, depth+1) copy(t, path[:depth+1]) res = append(res, t) return } // 遍历下一个结点 \tfor _, next := range graph[i] { dfs(next, depth+1) } } dfs(0, 0) return res } 复杂度  时间复杂度：$ O(n) $ 空间复杂度：$ O(n) $  ","date":"2021-08-25T22:05:55+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-797.-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/","title":"Leetcode 797. 所有可能的路径"},{"content":"链接： https://leetcode-cn.com/problems/throne-inheritance/\n难度： 简单\n题目描述 给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ：\n nums[0] = 0 nums[1] = 1 当 2 \u0026lt;= 2 * i \u0026lt;= n 时，nums[2 * i] = nums[i] 当 2 \u0026lt;= 2 * i + 1 \u0026lt;= n 时，nums[2 * i + 1] = nums[i] + nums[i + 1]  返回生成数组 nums 中的 最大 值。\n示例 1：  输入： n = 7\n输出： 3\n解释： 根据规则：\nnums[0] = 0\nnums[1] = 1\nnums[(1 * 2) = 2] = nums[1] = 1\nnums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\nnums[(2 * 2) = 4] = nums[2] = 1\nnums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\nnums[(3 * 2) = 6] = nums[3] = 2\nnums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\n因此，nums = [0,1,1,2,1,3,2,3]，最大值 3\n 示例 2：  输入： n = 2\n输出： 1\n解释： 根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1\n 示例 3：  输入： n = 3\n输出： 2\n解释： 根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2\n 提示：  0 \u0026lt;= n \u0026lt;= 100  解题思路 模拟 按照题设公式，依次求得每个元素的值，返回最大值。\nfunc getMaximumGenerated(n int) int { if n \u0026lt;= 1 { return n } max := 0 nums := make([]int, n+1) nums[0] = 0 nums[1] = 1 for i := 2; i \u0026lt;= n; i++ { if i\u0026amp;1 == 0 { nums[i] = nums[i/2] } else { nums[i] = nums[i/2] + nums[i/2+1] } if max \u0026lt; nums[i] { max = nums[i] } } return max } 复杂度  时间复杂度：$ O(n) $ 空间复杂度：$ O(n) $  ","date":"2021-08-23T10:49:08+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1646.-%E8%8E%B7%E5%8F%96%E7%94%9F%E6%88%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","title":"Leetcode 1646. 获取生成数组中的最大值"},{"content":"链接： https://leetcode-cn.com/problems/string-compression/\n难度： 中等\n题目描述 给你一个字符数组 chars ，请使用下述算法压缩：\n从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：\n 如果这一组长度为 1 ，则将字符追加到 s 中。 否则，需要向 s 追加字符，后跟这一组的长度。  压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。\n请在 修改完输入数组后 ，返回该数组的新长度。\n你必须设计并实现一个只使用常量额外空间的算法来解决此问题。\n示例 1：  输入： chars = [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;c\u0026rdquo;,\u0026ldquo;c\u0026rdquo;,\u0026ldquo;c\u0026rdquo;]\n输出： 返回 6 ，输入数组的前 6 个字符应该是：[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;c\u0026rdquo;,\u0026ldquo;3\u0026rdquo;]\n解释：\n\u0026ldquo;aa\u0026rdquo; 被 \u0026ldquo;a2\u0026rdquo; 替代。\u0026ldquo;bb\u0026rdquo; 被 \u0026ldquo;b2\u0026rdquo; 替代。\u0026ldquo;ccc\u0026rdquo; 被 \u0026ldquo;c3\u0026rdquo; 替代。\n 示例 2：  输入： chars = [\u0026ldquo;a\u0026rdquo;]\n输出： 返回 1 ，输入数组的前 1 个字符应该是：[\u0026ldquo;a\u0026rdquo;]\n解释：\n没有任何字符串被替代。\n 示例 3：  输入： chars = [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;]\n输出： 返回 4 ，输入数组的前 4 个字符应该是：[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;2\u0026rdquo;]。\n解释：\n由于字符 \u0026ldquo;a\u0026rdquo; 不重复，所以不会被压缩。\u0026ldquo;bbbbbbbbbbbb\u0026rdquo; 被 “b12” 替代。\n注意每个数字在数组中都有它自己的位置。\n 提示：  1 \u0026lt;= chars.length \u0026lt;= 2000 chars[i] 可以是小写英文字母、大写英文字母、数字或符号  解题思路 双指针 使用两个指针，分别指向当前遍历到的位置和当前压缩数组的尾部，向后遍历数组，统计每组相同字符出现的次数，计算得到该组压缩后的长度，添加到压缩数组的尾部。\nfunc compress(chars []byte) int { res := 0 cnt := 1 // 当前组数量 \tfor i, c := range chars { // 当前组结束 \tif i == len(chars)-1 || c != chars[i+1] { chars[res] = c res++ // 写入出现次数 \tif cnt \u0026gt; 1 { digits := make([]byte, 0, 4) for ; cnt \u0026gt; 0; cnt /= 10 { digits = append(digits, byte(\u0026#39;0\u0026#39;+cnt%10)) } for j := len(digits) - 1; j \u0026gt;= 0; j-- { chars[res] = digits[j] res++ } } cnt = 1 } else { cnt++ } } return res } 复杂度  时间复杂度：$ O(N), N = len(chars) $ 空间复杂度：$ O(1) $  ","date":"2021-08-21T14:52:12+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-443.-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 443. 压缩字符串"},{"content":"链接： https://leetcode-cn.com/problems/reverse-string-ii/\n难度： 简单\n题目描述 给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。\n如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n示例 1：  输入： s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2\n输出： \u0026ldquo;bacdfeg\u0026rdquo;\n 示例 2：  输入： s = \u0026ldquo;abcd\u0026rdquo;, k = 2\n输出： \u0026ldquo;bacd\u0026rdquo;\n 提示：  1 \u0026lt;= s.length \u0026lt;= 104 s 仅由小写英文组成 1 \u0026lt;= k \u0026lt;= 104  解题思路 模拟 以长度为 2k 为单位将字符串分割，对于每个区间，反转前 k 个字符。\n对于尾部需进行特判，反转区间不足 k 时，反转到尾部为止。\nfunc reverseStr(s string, k int) string { t := []byte(s) for i := 0; i \u0026lt;= len(t); i += (k \u0026lt;\u0026lt; 1) { // 尾部判定 \ttail := i + k if len(t) \u0026lt; i+k { tail = len(t) } for l, r := i, tail-1; l \u0026lt; r; l, r = l+1, r-1 { t[l], t[r] = t[r], t[l] } } return string(t) } 复杂度  时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $  ","date":"2021-08-20T13:31:40+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-541.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-ii/","title":"Leetcode 541. 反转字符串 II"},{"content":"链接： https://leetcode-cn.com/problems/reverse-vowels-of-a-string/\n难度： 简单\n题目描述 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。\n示例 1：  输入： \u0026ldquo;hello\u0026rdquo;\n输出： \u0026ldquo;holle\u0026rdquo;\n 示例 2：  输入： \u0026ldquo;leetcode\u0026rdquo;\n输出： \u0026ldquo;leotcede\u0026rdquo;\n 提示：  元音字母不包含字母 \u0026ldquo;y\u0026rdquo; 。  解题思路 双指针 使用两个指针 i, j 分别从字符串首尾向中间遍历：\n 遇到非元音字母向中间靠拢； i, j 两个指针都指向元音字母时，交换两个指针指向的字母并向中靠拢  最终两个指针相遇时停止，元音字母反转完毕。\nfunc reverseVowels(s string) string { t := []byte(s) isVowel := map[byte]bool{ \u0026#39;a\u0026#39;: true, \u0026#39;A\u0026#39;: true, \u0026#39;e\u0026#39;: true, \u0026#39;E\u0026#39;: true, \u0026#39;i\u0026#39;: true, \u0026#39;I\u0026#39;: true, \u0026#39;o\u0026#39;: true, \u0026#39;O\u0026#39;: true, \u0026#39;u\u0026#39;: true, \u0026#39;U\u0026#39;: true, } for i, j := 0, len(s)-1; i \u0026lt; j; { if !isVowel[t[i]] { i++ continue } if !isVowel[t[j]] { j-- continue } t[i], t[j] = t[j], t[i] i++ j-- } return string(t) } 复杂度  时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $  ","date":"2021-08-19T10:40:59+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-345.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/","title":"Leetcode 345. 反转字符串中的元音字母"},{"content":"链接： https://leetcode-cn.com/problems/student-attendance-record-i/\n难度： 简单\n题目描述   给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：\n  'A'：Absent，缺勤\n  'L'：Late，迟到\n  'P'：Present，到场\n  如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：\n 按 总出勤 计，学生缺勤（'A'）严格 少于两天。 学生 不会 存在 连续 3 天或 3 天以上的迟到（'L'）记录。  如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。\n示例 1：  输入： s = \u0026ldquo;PPALLP\u0026rdquo; 输出： true 解释： 学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。  示例 2：  输入： s = \u0026ldquo;PPALLL\u0026rdquo; 输出： false 解释： 学生最后三天连续迟到，所以不满足出勤奖励的条件。  提示：  1 \u0026lt;= s.length \u0026lt;= 1000 s[i] 为 'A'、'L' 或 'P'  解题思路 计数 遍历字符串，每次针对缺和迟到做如下处理:\n 每次遇到 'A' , 缺勤次数+1； 每次遇到 'L' , 迟到次数+1，由于连续迟到才会得不到奖励，故每当遇到 'A' 和 'P' 时，连续迟到次数会被打断，故将连续迟到次数清 0。  每次循环后判断缺勤次数和连续迟到次数，以确定能否得到奖励\nfunc checkRecord(s string) bool { absent := 0 late := 0 for i := range s { switch s[i] { case \u0026#39;A\u0026#39;: absent++ late = 0 case \u0026#39;L\u0026#39;: late++ case \u0026#39;P\u0026#39;: late = 0 } if absent \u0026gt;= 2 || late \u0026gt;= 3 { return false } } return true } 复杂度  时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $  ","date":"2021-08-17T10:51:13+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-551.-%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95-i/","title":"Leetcode 551. 学生出勤记录 I"},{"content":"链接： https://leetcode-cn.com/problems/beautiful-arrangement/\n难度： 中等\n题目描述 假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 \u0026lt;= i \u0026lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：\n 第 i 位的数字能被 i 整除 i 能被第 i 位上的数字整除  现在给定一个整数 N，请问可以构造多少个优美的排列？\n示例：  输入: 2\n输出: 2\n解释:\n第 1 个优美的排列是 [1, 2]:\n第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除\n第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除\n第 2 个优美的排列是 [2, 1]:\n第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除\n第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除\n 说明：  N 是一个正整数，并且不会超过 15。  解题思路 回溯 使用一个数组 arr 记录该排列，另使用一个数组 choice 记录每个数字是否已经被填写到 arr 中。\n从下标 1 开始，依次选择数字填入到 arr，直到填满数组或者无法找到符合要求的数字，回溯。每次填满数字时，排列数+1。\nfunc countArrangement(n int) int { arr := make([]int, n+1) choice := make([]bool, n+1) res := 0 for idx := 1; idx \u0026gt; 0; { find := false // 是否找到满足田间的数 \tchoice[arr[idx]] = false // 当前数未选择 \t// 寻找下一个数 \tfor num := arr[idx] + 1; num \u0026lt;= n; num++ { if !choice[num] \u0026amp;\u0026amp; (num%idx == 0 || idx%num == 0) { choice[num] = true // 已选择 \tarr[idx] = num // 填入 \tidx++ find = true /// 已找到 \tbreak } } if !find { // 未找到满足条件的数 \tarr[idx] = 0 choice[arr[idx]] = false // 当前数未选择 \tidx-- // 回溯 \t} else if idx \u0026gt; n { // 已填满，回溯 \tidx-- // 回溯 \tchoice[arr[idx]] = false // 当前数未选择 \tres++ // 排列数 +1 \t} } return res } 复杂度  时间复杂度：$ O(n!) $ 空间复杂度：$ O(n) $  ","date":"2021-08-16T22:54:27+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-526.-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/","title":"Leetcode 526. 优美的排列"},{"content":"链接： https://leetcode-cn.com/problems/out-of-boundary-paths/\n难度： 中等\n题目描述 给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。\n给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 + 7 取余 后的结果。\n示例 1： \u0026lt;img src=\u0026quot;/img/576.out_of_boundary_paths_1.png\u0026quot;, width=\u0026ldquo;500px\u0026rdquo;\u0026gt;\n 输入： m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\n输出： 6\n 示例 2： \u0026lt;img src=\u0026quot;/img/576.out_of_boundary_paths_2.png\u0026quot;, width=\u0026ldquo;500px\u0026rdquo;\u0026gt;\n 输入： m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1\n输出： 12\n 提示：  1 \u0026lt;= m, n \u0026lt;= 50 0 \u0026lt;= maxMove \u0026lt;= 50 0 \u0026lt;= startRow \u0026lt; m 0 \u0026lt;= startColumn \u0026lt; n  解题思路 动态规划 使用 dp[move][row][col] 记录移动 move 次后，球位于第 row 行 col 列的方案数量。由于球只能来自周围的单元格，易得状态转移方程：\n dp[startRow][startColumn] = 1 dp[move+1][row][col] = dp[move][row-1][col] + dp[move][row+1][col] + dp[move][row][col-1] + dp[move][row][col1]  由于每次依赖上一次移动，使用滚动数组以降低空间复杂度。 此外，每次移动时，需要进行边界判断，每当可以移出边界时，累加进结果中。\nfunc findPaths(m int, n int, maxMove int, startRow int, startColumn int) int { const MOD = 1e9 + 7 dpCur := make([][]int, m) dpNext := make([][]int, m) for i := 0; i \u0026lt; m; i++ { dpCur[i] = make([]int, n) dpNext[i] = make([]int, n) } dpCur[startRow][startColumn] = 1 res := 0 for move := 0; move \u0026lt; maxMove; move++ { for row := 0; row \u0026lt; m; row++ { for col := 0; col \u0026lt; n; col++ { dpNext[row][col] = 0 for _, offset := range [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} { // 在边界内 \tif row+offset[0] \u0026gt;= 0 \u0026amp;\u0026amp; row+offset[0] \u0026lt; m \u0026amp;\u0026amp; col+offset[1] \u0026gt;= 0 \u0026amp;\u0026amp; col+offset[1] \u0026lt; n { dpNext[row][col] = (dpNext[row][col] + dpCur[row+offset[0]][col+offset[1]]) % MOD } else { res = (res + dpCur[row][col]) % MOD } } } } dpCur, dpNext = dpNext, dpCur fmt.Println(dpCur, res) } return res } 复杂度  时间复杂度：$ O(maxMovemn) $ 空间复杂度：$ O(m*n) $  ","date":"2021-08-15T11:04:33+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-576.-%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/","title":"Leetcode 576. 出界的路径数"},{"content":"链接： https://leetcode-cn.com/problems/count-unhappy-friends/\n难度： 中等\n题目描述 给你一份 n 位朋友的亲近程度列表，其中 n 总是 偶数 。\n对每位朋友 i，preferences[i] 包含一份 按亲近程度从高到低排列 的朋友列表。换句话说，排在列表前面的朋友与 i 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 0 到 n-1 之间的整数表示。\n所有的朋友被分成几对，配对情况以列表 pairs 给出，其中 pairs[i] = [xi, yi] 表示 xi 与 yi 配对，且 yi 与 xi 配对。\n但是，这样的配对情况可能会是其中部分朋友感到不开心。在 x 与 y 配对且 u 与 v 配对的情况下，如果同时满足下述两个条件，x 就会不开心：\n x 与 u 的亲近程度胜过 x 与 y，且 u 与 x 的亲近程度胜过 u 与 v  返回 不开心的朋友的数目 。\n示例 1：  输入： n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]\n输出： 2\n解释：\n朋友 1 不开心，因为：\n 1 与 0 配对，但 1 与 3 的亲近程度比 1 与 0 高，且 3 与 1 的亲近程度比 3 与 2 高。\n朋友 3 不开心，因为： 3 与 2 配对，但 3 与 1 的亲近程度比 3 与 2 高，且 1 与 3 的亲近程度比 1 与 0 高。\n朋友 0 和 2 都是开心的。   示例 2：  输入： n = 2, preferences = [[1], [0]], pairs = [[1, 0]]\n输出： 0\n解释： 朋友 0 和 1 都开心。\n 示例 3：  输入： n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]\n输出： 4\n 提示：  2 \u0026lt;= n \u0026lt;= 500 n 是偶数 preferences.length == n preferences[i].length == n - 1 0 \u0026lt;= preferences[i][j] \u0026lt;= n - 1 preferences[i] 不包含 i preferences[i] 中的所有值都是独一无二的 pairs.length == n/2 pairs[i].length == 2 xi != yi 0 \u0026lt;= xi, yi \u0026lt;= n - 1 每位朋友都 恰好 被包含在一对中  解题思路 模拟 对于每一个元素 xi，找出所有比其配对元素 yi 更亲近的所有元素，判断这些元素与 xi 的亲近程度是否高于自己的配对元素。\nfunc unhappyFriends(n int, preferences [][]int, pairs [][]int) int { // 记录每个元素的配对元素 \tpair := make([]int, n) for _, p := range pairs { pair[p[0]] = p[1] pair[p[1]] = p[0] } // 记录连个元素间的亲近程度 \tcloser := make([][]int, n) for i, others := range preferences { closer[i] = make([]int, n) for j, other := range others { closer[i][other] = j } } unhappy := 0 for k, v := range pair { // 寻找更亲近的元素 p \tfor _, p := range preferences[k] { if p == v { break } // p 与当前元素 k 的亲近程度更高, k 不开心 \tif closer[p][k] \u0026lt; closer[p][pair[p]] { unhappy++ break } } } return unhappy } 复杂度  时间复杂度：$ O(n^2) $ 空间复杂度：$ O(n^2) $  ","date":"2021-08-14T10:51:40+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1583.-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%BC%80%E5%BF%83%E7%9A%84%E6%9C%8B%E5%8F%8B/","title":"Leetcode 1583. 统计不开心的朋友"},{"content":"链接： https://leetcode-cn.com/problems/longest-palindromic-subsequence/\n难度： 中等\n题目描述 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。\n子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。\n示例 1：  输入： s = \u0026ldquo;bbbab\u0026rdquo;\n输出： 4\n解释： 一个可能的最长回文子序列为 \u0026ldquo;bbbb\u0026rdquo; 。\n 示例 2：  输入： s = \u0026ldquo;cbbd\u0026rdquo;\n输出： 2\n解释： 一个可能的最长回文子序列为 \u0026ldquo;bb\u0026rdquo; 。\n 注意：  1 \u0026lt;= s.length \u0026lt;= 1000 s 仅由小写英文字母组成  解题思路 动态规划 该题可以转化为寻找原字符串 s 和倒序字符串 s' 的最长公共子序列问题。使用动态规划求解，dp[i][j] 表示以下标 i, j 结尾的前缀字串最长公共子序列的长度，状态转移方程如下：\n 当 s[i] == s'[j]，dp[i][j] = dp[i-1][j-1] + 1 当 s[i] == s'[j]，dp[i][j] = max(dp[i-1][j], dp[i][j-1]  每次状态转移时仅依赖当前行和上一行，故可以使用滚动数组降低空间复杂度。\nfunc longestPalindromeSubseq(s string) int { dp := [][]int{ make([]int, len(s)+1), make([]int, len(s)+1), } last := 1 cur := 0 for i := 0; i \u0026lt; len(s); i++ { cur, last = last, cur for j := 0; j \u0026lt; len(s); j++ { if s[i] == s[len(s)-1-j] { dp[cur][j+1] = dp[last][j] + 1 } else if dp[cur][j] \u0026gt; dp[last][j+1] { dp[cur][j+1] = dp[cur][j] } else { dp[cur][j+1] = dp[last][j+1] } } } return dp[cur][len(s)] } 复杂度  时间复杂度：$ O(N^2), N = len(s) $ 空间复杂度：$ O(N) $  ","date":"2021-08-12T11:16:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-516.-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/","title":"Leetcode 516. 最长回文子序列"},{"content":"链接： https://leetcode-cn.com/problems/arithmetic-slices/\n难度： 中等\n题目描述 如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。\n例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。 给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。\n子数组 是数组中的一个连续序列。\n示例 1：  输入： nums = [1,2,3,4]\n输出： 3\n解释： nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。\n 示例 2：  输入： nums = [1]\n输出： 0\n 提示：  1 \u0026lt;= nums.length \u0026lt;= 5000 -1000 \u0026lt;= nums[i] \u0026lt;= 1000  解题思路 数学 对于一个等差数列数组，其长度为 n (n ≥ 3)，其等差数列 子数组 的数量由长度为 3, ..., n 的子数组构成，对应的 子数组 数量为 n-2, ..., 1，其构成等差数列，故总数量为$\\sum\\limits_{i=1}^{n-2}i = \\frac{(n-2+1)(n-2)}{2} = \\frac{(n-1)(n-2)}{2}$\n子数组 为等差数列，则其 父数组 也必须为等差数列。遍历整个数组，找到所有的等差数列父数组，对于子数组的数量求和。\nfunc numberOfArithmeticSlices(nums []int) int { res := 0 n := 1 // 初始只有一个元素 \td := 0 // 公差 \tfor i := 1; i \u0026lt; len(nums); i++ { if d == nums[i]-nums[i-1] { // 与之前元素构成等差数列 \tn++ } else { // 与之前元素不构成等差数列 \t// 累加前一个等差数列 子数组 数量 \tif n \u0026gt;= 3 { res += (n - 2) * (n - 1) / 2 } // 初始化公差 \u0026amp; 元素数量 \td = nums[i] - nums[i-1] n = 2 } } // 遍历结束，判定尾部等差数列 \tif n \u0026gt;= 3 { res += (n - 2) * (n - 1) / 2 } return res } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $  ","date":"2021-08-10T10:42:43+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-413.-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/","title":"Leetcode 413. 等差数列划分"},{"content":"链接： https://leetcode-cn.com/problems/super-ugly-number/\n难度： 中等\n题目描述 超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。\n给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。\n题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。\n示例 1：  输入： n = 12, primes = [2,7,13,19]\n输出： 32\n解释： 给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。\n 示例 2：  输入： n = 1, primes = [2,3,5]\n输出： 1\n解释： 1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。\n 注意：  1 \u0026lt;= n \u0026lt;= 106 1 \u0026lt;= primes.length \u0026lt;= 100 2 \u0026lt;= primes[i] \u0026lt;= 1000 题目数据 保证 primes[i] 是一个质数 primes 中的所有值都 互不相同 ，且按 递增顺序 排列  解题思路 堆 + 哈希 使用小顶堆维护超级丑数，初始时，仅有一个超级丑数 1，每次取出最小的超级丑数，依次乘以 primes 中的每个元素并入堆。为防止重复元素入堆，使用哈希表进行记录去重。\n重复上述步骤 n 次，即得到了第 n 个最小的超级丑数。\ntype MinHeap struct { sort.IntSlice } func (m *MinHeap) Push(x interface{}) { m.IntSlice = append(m.IntSlice, x.(int)) } func (m *MinHeap) Pop() interface{} { t := m.IntSlice[len(m.IntSlice)-1] m.IntSlice = m.IntSlice[:len(m.IntSlice)-1] return t } func nthSuperUglyNumber(n int, primes []int) int { appear := make(map[int]struct{}) minHeap := \u0026amp;MinHeap{IntSlice: make([]int, 0, len(primes)*n)} heap.Push(minHeap, 1) appear[1] = struct{}{} x := 1 for i := 0; i \u0026lt; n; i++ { x = heap.Pop(minHeap).(int) for _, p := range primes { if _, ok := appear[p*x]; !ok { heap.Push(minHeap, p*x) appear[p*x] = struct{}{} } } } return x } 复杂度  时间复杂度：$ O(nP\\log(nP)), P = len(primes) $ 空间复杂度：$ O(nP) $  ","date":"2021-08-09T11:00:42+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-313.-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/","title":"Leetcode 313. 超级丑数"},{"content":"链接： https://leetcode-cn.com/problems/n-th-tribonacci-number/\n难度： 简单\n题目描述 泰波那契序列 Tn 定义如下： T0 = 0, T1 = 1, T2 = 1, 且在 n \u0026gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2\n给你整数 n，请返回第 n 个泰波那契数 Tn 的值。\n示例 1：  输入： n = 4\n输出： 4\n解释：\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4\n 示例 2：  输入： n = 25 输出： 1389537\n 提示：  0 \u0026lt;= n \u0026lt;= 37 答案保证是一个 32 位整数，即 answer \u0026lt;= 231 - 1。  解题思路 动态规划 初始 t[0] = 0, t[1] = 1, t[2] = 1，依次向后递推计算，直到 t[n]。\n由于每次仅涉及前三个变量，可以复用以降低空间复杂度。\nfunc tribonacci(n int) int { if n == 0 { return 0 } if n == 1 || n == 2 { return 1 } t0 := 0 t1 := 1 t2 := 1 t := 0 for i := 3; i \u0026lt;= n; i++ { t = t0 + t1 + t2 t0 = t1 t1 = t2 t2 = t } return t } 复杂度  时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $  ","date":"2021-08-08T09:18:26+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1137.-%E7%AC%AC-n-%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/","title":"Leetcode 1137. 第 N 个泰波那契数"},{"content":"链接： https://leetcode-cn.com/problems/circular-array-loop/\n难度： 中等\n题目描述 存在一个不含 0 的 环形 数组 nums ，每个 nums[i] 都表示位于下标 i 的角色应该向前或向后移动的下标个数：\n 如果 nums[i] 是正数，向前 移动 nums[i] 步 如果 nums[i] 是负数，向后 移动 nums[i] 步  因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。\n数组中的 循环 由长度为 k 的下标序列 seq ：\n 遵循上述移动规则将导致重复下标序列 seq[0] -\u0026gt; seq[1] -\u0026gt; ... -\u0026gt; seq[k - 1] -\u0026gt; seq[0] -\u0026gt; ... 所有 nums[seq[j]] 应当不是 全正 就是 全负 k \u0026gt; 1  如果 nums 中存在循环，返回 true ；否则，返回 false 。\n示例 1：  输入： nums = [2,-1,1,2,2]\n输出： true\n解释： 存在循环，按下标 0 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 0 。循环长度为 3 。\n 示例 2：  输入： nums = [-1,2]\n输出： false\n解释： 按下标 1 -\u0026gt; 1 -\u0026gt; 1 \u0026hellip; 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。\n 示例 3：  输入： nums = [-2,1,-1,-2,-2]\n输出： false\n解释： 按下标 1 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; \u0026hellip; 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。\n所有 nums[seq[j]] 应当不是全正就是全负。\n 提示：  1 \u0026lt;= nums.length \u0026lt;= 5000 -1000 \u0026lt;= nums[i] \u0026lt;= 1000 nums[i] != 0  解题思路 快慢指针 使用快慢指针依次遍历，若有环，则快慢指针最后会相遇。遍历时注意移动方向要一致。\nfunc circularArrayLoop(nums []int) bool { visit := make([]bool, len(nums)) for i := 0; i \u0026lt; len(nums); i++ { if visit[i] { continue } slow := i visit[slow] = true fast := ((slow+nums[slow])%len(nums) + len(nums)) % len(nums) if nums[slow]*nums[fast] \u0026lt; 0 || visit[fast] { continue } for slow != fast { // 快指针前进两步 \tnext := ((fast+nums[fast])%len(nums) + len(nums)) % len(nums) if next == fast || nums[fast]*nums[next] \u0026lt; 0 { break } fast = next next = ((fast+nums[fast])%len(nums) + len(nums)) % len(nums) if next == fast || nums[fast]*nums[next] \u0026lt; 0 { break } fast = next // 慢指针前进一步 \tslow = ((slow+nums[slow])%len(nums) + len(nums)) % len(nums) if visit[slow] { break } visit[slow] = true } if slow == fast { return true } } return false } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $  ","date":"2021-08-07T19:33:30+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-457.-%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%BE%AA%E7%8E%AF/","title":"Leetcode 457. 环形数组是否存在循环"},{"content":"链接： https://leetcode-cn.com/problems/find-eventual-safe-states/\n难度： 中等\n题目描述 在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。\n对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。\n返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。\n该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。\n示例 1：  输入： graph = [[1,2],[2,3],[5],[0],[5],[],[]]\n输出： [2,4,5,6]\n解释： 示意图如上。\n 示例 2：  输入： graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n输出： [4]\n 提示：  n == graph.length 1 \u0026lt;= n \u0026lt;= 104 0 \u0026lt;= graph[i].length \u0026lt;= n graph[i] 按严格递增顺序排列。 图中可能包含自环。 图中边的数目在范围 [1, 4 * 104] 内。  解题思路 深度优先搜索 通过分析题目得知，当图无环时，所有结点均为 安全 结点；当图有环时，无法到达环的结点属于 安全 结点。\n通过一次深度优先搜索找到环上的结点，找出能到达环结点的所有结点，剩余结点即为 安全 结点。\nfunc eventualSafeNodes(graph [][]int) []int { const ( ALREADY_VISIT = -1 NOT_VISIT = 0 VISIT = 1 ARRIVE_RING = 2 ) attrs := make([]int, len(graph)) var dfs func(node int) bool dfs = func(node int) bool { switch attrs[node] { case ALREADY_VISIT: return false case NOT_VISIT: attrs[node] = VISIT case VISIT: attrs[node] = ARRIVE_RING return true case ARRIVE_RING: return true } // 遍历后续结点，是否可以可到达环 \tarriveRing := false for _, next := range graph[node] { arriveRing = arriveRing || dfs(next) } // 后续有结点可到达环，则当前结点也可以到达环 \tif arriveRing { attrs[node] = ARRIVE_RING } // 已访问过的结点，防止重复遍历 \tif attrs[node] == VISIT { attrs[node] = ALREADY_VISIT } return arriveRing } // dfs 遍历图 \tfor i := 0; i \u0026lt; len(graph); i++ { if attrs[i] == NOT_VISIT { dfs(i) } } // 遍历寻找安全结点 \tres := make([]int, 0, len(graph)) for i, attr := range attrs { if attr != ARRIVE_RING { res = append(res, i) } } return res } 复杂度  时间复杂度：$ O(n+E), E = size(edges) $ 空间复杂度：$ O(n) $  ","date":"2021-08-05T14:10:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-802.-%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/","title":"Leetcode 802. 找到最终的安全状态"},{"content":"链接： https://leetcode-cn.com/problems/valid-triangle-number/\n难度： 中等\n题目描述 给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。\n示例：  输入: [2,2,3,4]\n输出: 3\n解释:\n有效的组合是:\n2,3,4 (使用第一个 2)\n2,3,4 (使用第二个 2)\n2,2,3\n 注意：  数组长度不超过1000。 数组里整数的范围为 [0, 1000]。  解题思路 排序 + 二分查找 构成三角形的前提条件是两边之和小于第三边，也就是说，两个小边之和大于最长的那条边。\n故，首先对数组进行排序，然后依次枚举两条小边 x 和 y ，其下标为 i 和 j (不妨假设 i ≤ i，则  x ≤ y)，即得到最大边的取值范围 x+y-1， 通过二分查找，找到其最大值的位置，与 j 相减即得到可取值的数量，求和。\nfunc triangleNumber(nums []int) int { sort.Ints(nums) res := 0 for i := 0; i \u0026lt; len(nums)-2; i++ { if nums[i] == 0 { continue } for j := i + 1; j \u0026lt; len(nums)-1; j++ { pos := sort.SearchInts(nums, nums[i]+nums[j]) pos-- if pos-j \u0026gt; 0 { res += pos - j } } } return res } 复杂度  时间复杂度：$ O(N^2\\log\\ N), N = len(nums) $ 空间复杂度：$ O(\\log\\ N) $  排序 + 双指针 接上题排序的思路，仍然枚举两条小边，不同的是，每次记录上次可以取得最大边的下标 k，上次每次 j 增加时，相应的扩展 k，省去二分查找的时间。\nfunc triangleNumber(nums []int) int { sort.Ints(nums) res := 0 for i := 0; i \u0026lt; len(nums)-2; i++ { if nums[i] == 0 { continue } for j, k := i+1, i+1; j \u0026lt; len(nums)-1; j++ { for ; k+1 \u0026lt; len(nums) \u0026amp;\u0026amp; nums[k+1] \u0026lt; nums[i]+nums[j]; k++ { } res += k - j } } return res } 复杂度  时间复杂度：$ O(N^2), N = len(nums) $ 空间复杂度：$ O(\\log\\ N) $  ","date":"2021-08-04T10:42:47+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-611.-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/","title":"Leetcode 611. 有效三角形的个数"},{"content":"链接： https://leetcode-cn.com/problems/network-delay-time/\n难度： 中等\n题目描述 有 n 个网络节点，标记为 1 到 n 。\n给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。\n现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。\n示例 1：  输入： times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\n输出： 2\n 示例 2：  输入： times = [[1,2,1]], n = 2, k = 1\n输出： 1\n 示例 3：  输入： times = [[1,2,1]], n = 2, k = 2\n输出： -1\n 提示：  1 \u0026lt;= k \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= times.length \u0026lt;= 6000 times[i].length == 3 1 \u0026lt;= ui, vi \u0026lt;= n ui != vi 0 \u0026lt;= wi \u0026lt;= 100 所有 (ui, vi) 对都 互不相同（即，不含重复边）  解题思路 迪杰斯特拉算法 + 堆 典型的单源最短路径问题，求解到所有结点的最短距离中的最大值，采用迪杰斯特拉算法，使用堆维护结点列表，降低算法复杂度。\ntype NextNode struct { To int // 下一个结点 \tWeight int // 权，距离 } // 小顶堆，距离源结点距离 type MinHeap struct { Edges []*NextNode } func (m *MinHeap) Len() int { return len(m.Edges) } func (m *MinHeap) Swap(i, j int) { m.Edges[i], m.Edges[j] = m.Edges[j], m.Edges[i] } func (m *MinHeap) Less(i, j int) bool { return m.Edges[i].Weight \u0026lt; m.Edges[j].Weight } func (m *MinHeap) Push(x interface{}) { m.Edges = append(m.Edges, x.(*NextNode)) } func (m *MinHeap) Pop() interface{} { t := m.Edges[m.Len()-1] m.Edges = m.Edges[:m.Len()-1] return t } func networkDelayTime(times [][]int, n int, k int) int { // 初始化结点能到达的其他结点 \tedges := make(map[int][]*NextNode) for _, time := range times { edges[time[0]-1] = append(edges[time[0]-1], \u0026amp;NextNode{ To: time[1] - 1, Weight: time[2], }) } // 堆初始化，源结点入堆 \tminHeap := \u0026amp;MinHeap{Edges: make([]*NextNode, 0, len(times))} minHeap.Push(\u0026amp;NextNode{ To: k - 1, Weight: 0, }) isVisit := make(map[int]struct{}) // 是否已访问 \tdistance := make([]int, n) // 距离源结点的距离 \t// 初始化为无穷大 \tfor i := range distance { distance[i] = math.MaxInt32 } distance[k-1] = 0 // 源结点为0 \tfor minHeap.Len() \u0026gt; 0 { // 获取距离最近的结点 \tnode := heap.Pop(minHeap).(*NextNode) // 己达结点，得到了最小值，跳过 \tif _, ok := isVisit[node.To]; ok { continue } // 访问结点 \tisVisit[node.To] = struct{}{} // 可达结点入堆 \tfor _, e := range edges[node.To] { // 己达结点 \tif _, ok := isVisit[e.To]; ok { continue } // 求解下一个结点更小距离并入堆 \tif distance[e.To] \u0026gt; e.Weight+distance[node.To] { distance[e.To] = e.Weight + distance[node.To] fmt.Println(e.To, distance[e.To]) } heap.Push(minHeap, \u0026amp;NextNode{ To: e.To, Weight: distance[e.To], }) } } // 有结点不可达 \tif len(isVisit) \u0026lt; n { return -1 } // 遍历找到所有结点最短距离的最大值，返回 \tmin := -1 for _, d := range distance { if min \u0026lt; d { min = d } } return min } 复杂度  时间复杂度：$ O(E(n+\\log\\ E)), E = len(times) $ 空间复杂度：$ O(n+E) $  ","date":"2021-08-03T20:16:01+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-743.-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/","title":"Leetcode 743. 网络延迟时间"},{"content":"链接： https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/\n难度： 中等\n题目描述 给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。\n请你找出符合题意的 最短 子数组，并输出它的长度。\n示例 1：  输入： nums = [2,6,4,8,10,9,15]\n输出： 5\n解释： 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。\n 示例 2：  输入： nums = [1,2,3,4]\n输出： 0\n 示例 3：  输入： nums = [1]\n输出： 0\n 提示：  1 \u0026lt;= nums.length \u0026lt;= 104 -105 \u0026lt;= nums[i] \u0026lt;= 105  **进阶：**你可以设计一个时间复杂度为 $O(n)$ 的解决方案吗？\n解题思路 排序 对于连续子数组以外的元素，其在排序前后位置不会改变，故可以将整个数组排序后，从头和尾开始，依次找到不变的元素加以排除，剩余元素就是 最短 连续子数组。\nfunc findUnsortedSubarray(nums []int) int { sortedNum := make([]int, len(nums)) copy(sortedNum, nums) sort.Ints(sortedNum) l := len(nums) for i := 0; i \u0026lt; len(nums) \u0026amp;\u0026amp; nums[i] == sortedNum[i]; i++ { l-- } if l == 0 { return 0 } for i := len(nums) - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] == sortedNum[i]; i-- { l-- } return l } 复杂度  时间复杂度：$ O(N\\log\\ N), N = len(nums) $ 空间复杂度：$ O(N) $  确定边界 设 min 和 max 为目标数组的最大值和最小值，则该数组左边的所有元素均小于 min，而右边的所有元素均大于 max。\n 可以从左向右遍历，同时记录遍历到的最大值，每当当前值小于最大值时，需要扩展右边界，最后确定右边界； 同理，从右向左遍历，同时记录遍历到的最小值，每当当前值大于最小值时 需要扩展左边界， 最后确定左边界。  通过比较左右边界，得到数组长度。\nfunc findUnsortedSubarray(nums []int) int { max := nums[0] right := 0 for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt;= max { max = nums[i] } else { right = i } } min := nums[len(nums)-1] left := len(nums) - 1 for i := len(nums) - 1; i \u0026gt;= 0; i-- { if nums[i] \u0026lt;= min { min = nums[i] } else { left = i } } if right \u0026lt;= left { return 0 } return right - left + 1 } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $  ","date":"2021-08-03T14:28:41+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-581.-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/","title":"Leetcode 581. 最短无序连续子数组"},{"content":"链接： https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/\n难度： 简单\n题目描述 给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。\n请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。\n如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。\n军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。\n示例 1：  输入： mat =\n[[1,1,0,0,0],\n[1,1,1,1,0],\n[1,0,0,0,0],\n[1,1,0,0,0],\n[1,1,1,1,1]],\nk = 3\n输出： [2,0,3]\n解释：\n每行中的军人数目： 行 0 -\u0026gt; 2\n行 1 -\u0026gt; 4\n行 2 -\u0026gt; 1\n行 3 -\u0026gt; 2\n行 4 -\u0026gt; 5\n从最弱到最强对这些行排序后得到 [2,0,3,1,4]\n 示例 2：  输入： mat =\n[[1,0,0,0],\n[1,1,1,1],\n[1,0,0,0],\n[1,0,0,0]],\nk = 2\n输出： [0,2]\n解释：\n每行中的军人数目： 行 0 -\u0026gt; 1\n行 1 -\u0026gt; 4\n行 2 -\u0026gt; 1\n行 3 -\u0026gt; 1\n从最弱到最强对这些行排序后得到 [0,2,3,1]\n 提示：  m == mat.length n == mat[i].length 2 \u0026lt;= n, m \u0026lt;= 100 1 \u0026lt;= k \u0026lt;= m matrix[i][j] 不是 0 就是 1  解题思路 排序 以行为单位，记录每一行军人的数量及行号，按战力从小到大排序，返回前 k 个最弱战力的行号。\nfunc kWeakestRows(mat [][]int, k int) []int { type Node struct { Row int Soldier int } nodes := make([]*Node, 0, len(mat)) for i := range mat { node := \u0026amp;Node{ Row: i, Soldier: 0, } for _, p := range mat[i] { if p == 1 { node.Soldier++ } else { break } } nodes = append(nodes, node) } sort.Slice(nodes, func(i, j int) bool { if nodes[i].Soldier \u0026lt; nodes[j].Soldier { return true } else if nodes[i].Soldier \u0026gt; nodes[j].Soldier { return false } else { return nodes[i].Row \u0026lt; nodes[j].Row } }) res := make([]int, 0, k) for i := 0; i \u0026lt; k; i++ { res = append(res, nodes[i].Row) } return res } 复杂度  时间复杂度：$ O(MN+M\\log\\ M), M = rows, N = cols $ 空间复杂度：$ O(M) $  排序 + 二分查找 在上述题解的基础上，由于军人始终排在平民前面，可以用二分查找降低时间复杂度。\nfunc kWeakestRows(mat [][]int, k int) []int { type Node struct { Row int Soldier int } nodes := make([]*Node, 0, len(mat)) for i := range mat { nodes = append(nodes, \u0026amp;Node{ Row: i, Soldier: sort.Search(len(mat[i]), func(j int) bool { return mat[i][j] == 0 })}, ) } sort.Slice(nodes, func(i, j int) bool { if nodes[i].Soldier \u0026lt; nodes[j].Soldier { return true } else if nodes[i].Soldier \u0026gt; nodes[j].Soldier { return false } else { return nodes[i].Row \u0026lt; nodes[j].Row } }) res := make([]int, 0, k) for i := 0; i \u0026lt; k; i++ { res = append(res, nodes[i].Row) } return res } 复杂度  时间复杂度：$ O(M\\log\\ N+M\\log\\ M), M = rows, N = cols $ 空间复杂度：$ O(M) $  ","date":"2021-08-01T09:54:54+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1337.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%88%98%E6%96%97%E5%8A%9B%E6%9C%80%E5%BC%B1%E7%9A%84-k-%E8%A1%8C/","title":"Leetcode 1337. 矩阵中战斗力最弱的 K 行"},{"content":"链接： https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/\n难度： 困难\n题目描述 给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。\n对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。\n二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。\n返回二叉树的 垂序遍历 序列。\n示例 1：  输入： root = [3,9,20,null,null,15,7]\n输出： [[9],[3,15],[20],[7]]\n解释：\n列 -1 ：只有结点 9 在此列中。\n列 0 ：只有结点 3 和 15 在此列中，按从上到下顺序。\n列 1 ：只有结点 20 在此列中。\n列 2 ：只有结点 7 在此列中。\n 示例 2：  输入： root = [1,2,3,4,5,6,7]\n输出： [[4],[2],[1,5,6],[3],[7]]\n解释：\n列 -2 ：只有结点 4 在此列中。\n列 -1 ：只有结点 2 在此列中。\n列 0 ：结点 1 、5 和 6 都在此列中。\n1 在上面，所以它出现在前面。\n5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。\n列 1 ：只有结点 3 在此列中。\n列 2 ：只有结点 7 在此列中。\n 示例 3：  输入： root = [1,2,3,4,6,5,7]\n输出： [[4],[2],[1,5,6],[3],[7]]\n解释：\n这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。\n因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。\n 提示：  树中结点数目总数在范围 [1, 1000] 内 0 \u0026lt;= Node.val \u0026lt;= 1000  解题思路 深度优先搜索+哈希 结果是以列为单位返回，使用哈希表记录相同列的结点信息。每一列又需要自上而下返回，还需要记录每个结点的深度。\n采用深度优先搜索遍历此树，初始时深度 depth = 0，列 col = 0，每当遍历子结点时depth + 1；当遍历左子结点时 col - 1，右子结点 col + 1。将深度和结点值一起加入到哈希表。\n遍历完成过后，对于每一列进行排序，深度优先，当深度相同，值小的优先。\n按照列从小到大，依次构造结果队列并返回。\nfunc verticalTraversal(root *TreeNode) [][]int { type Node struct { Val int Depth int } verticalNodes := make(map[int][]*Node) var dfs func(node *TreeNode, depth int, col int) dfs = func(node *TreeNode, depth int, col int) { if node == nil { return } verticalNodes[col] = append(verticalNodes[col], \u0026amp;Node{ Val: node.Val, Depth: depth, }) dfs(node.Left, depth+1, col-1) dfs(node.Right, depth+1, col+1) } dfs(root, 0, 0) cols := make([]int, 0, len(verticalNodes)) for col, nodes := range verticalNodes { cols = append(cols, col) sort.Slice(nodes, func(i, j int) bool { if nodes[i].Depth \u0026lt; nodes[j].Depth { return true } else if nodes[i].Depth \u0026gt; nodes[j].Depth { return false } else { if nodes[i].Val \u0026lt; nodes[j].Val { return true } else { return false } } }) } sort.Ints(cols) res := make([][]int, 0, len(verticalNodes)) for _, col := range cols { t := make([]int, 0, len(verticalNodes[col])) for _, node := range verticalNodes[col] { t = append(t, node.Val) } res = append(res, t) } return res } 复杂度  时间复杂度：$ O(N\\log_\\ N), N = size(Tree) $ 空间复杂度：$ O(N) $  ","date":"2021-07-31T12:57:30+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-987.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86/","title":"Leetcode 987. 二叉树的垂序遍历"},{"content":"链接： https://leetcode-cn.com/problems/excel-sheet-column-number/\n难度： 简单\n题目描述 给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。\n例如，\n A -\u0026gt; 1\nB -\u0026gt; 2\nC -\u0026gt; 3\n\u0026hellip;\nZ -\u0026gt; 26\nAA -\u0026gt; 27\nAB -\u0026gt; 28\n\u0026hellip;\n 示例 1：  输入: columnTitle = \u0026ldquo;A\u0026rdquo;\n输出: 1\n 示例 2：  输入: columnTitle = \u0026ldquo;AB\u0026rdquo;\n输出: 28\n 示例 3：  输入: columnTitle = \u0026ldquo;ZY\u0026rdquo;\n输出: 701\n 示例 4：  输入: columnTitle = \u0026ldquo;FXSHRXW\u0026rdquo;\n输出: 2147483647\n 解题思路 数学 进制转换，将一个26进制的数转换为10进制。\nfunc titleToNumber(columnTitle string) int { res := 0 for i := 0; i \u0026lt; len(columnTitle); i++ { res = res*26 + int(columnTitle[i]-\u0026#39;A\u0026#39;+1) } return res } 复杂度  时间复杂度：$ O(N) , N = len(columnTitle) $ 空间复杂度：$ O(1) $  ","date":"2021-07-30T10:58:59+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-171.-excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/","title":"Leetcode 171. Excel表列序号"},{"content":"链接： https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/\n难度： 中等\n题目描述 在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。\n如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；\n而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。\n给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。\n示例 1：  输入： label = 14\n输出： [1,3,4,14]\n 示例 2：  输入： label = 26\n输出： [1,2,6,10,26]\n 提示：  1 \u0026lt;= label \u0026lt;= 106  解题思路 推导 对于一个完全二叉树，可以快速找到子结点 x 的父结点是 x/2。该题描述的是完全二叉树的一种变种，仅是偶数行的结点整体进行了反转。\n可以使用完全二叉树的编号，快速找到父结点，然后推导出在原二叉树中的原编号，加入到结果中。\n对于反转后的某一层，其元素为公差为 1 的等差数列，某个数反转后的编号即为当前层首尾元素之和减去当前元素。\nfunc pathInZigZagTree(label int) []int { layer := 0 // 层 \tcnt := layer // 满二叉树结点数量 \tfor label \u0026gt; cnt { layer++ cnt = 2*(cnt+1) - 1 } idx := layer - 1 res := make([]int, layer) num := label // 完全二叉树编号 \tif layer\u0026amp;1 == 0 { num = cnt/2 + 1 + cnt - label } for layer \u0026gt; 0 { if layer\u0026amp;1 == 0 { // 偶数层，转换 \tres[idx] = cnt/2 + 1 + cnt - num } else { res[idx] = num } idx-- num /= 2 layer-- cnt /= 2 } return res } 复杂度  时间复杂度：$ O(logN)), N = label $ 空间复杂度：$ O(1) $  ","date":"2021-07-29T20:22:11+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1104.-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%BB%E8%B7%AF/","title":"Leetcode 1104. 二叉树寻路"},{"content":"链接： https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/\n难度： 中等\n题目描述 给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。\n返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。\n示例：  输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2\n输出：[7,4,1]\n解释：\n所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1\n注意，输入的 \u0026ldquo;root\u0026rdquo; 和 \u0026ldquo;target\u0026rdquo; 实际上是树上的结点。\n上面的输入仅仅是对这些对象进行了序列化描述。\n 提示：  给定的树是非空的。 树上的每个结点都具有唯一的值 0 \u0026lt;= node.val \u0026lt;= 500 。 目标结点 target 是树上的结点。 0 \u0026lt;= K \u0026lt;= 1000  解题思路 深度优先搜索 一次遍历，找到结点 target，同时记录每个结点的父结点，使之构成一张无向图。\n然后从 target 结点开始遍历图，找到所有距离为 K 的结点。\n注意，不要重复遍历，并进行剪枝。\nfunc distanceK(root *TreeNode, target *TreeNode, k int) []int { father := make(map[*TreeNode]*TreeNode) var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node.Left != nil { father[node.Left] = node dfs(node.Left) } if node.Right != nil { father[node.Right] = node dfs(node.Right) } } dfs(root) res := make([]int, 0, len(father)) // from 防止重复搜索 \tvar search func(node, from *TreeNode, distance int) search = func(node, from *TreeNode, distance int) { if node == nil { return } if distance \u0026gt;= k { res = append(res, node.Val) return } if father[node] != from { search(father[node], node, distance+1) } if node.Left != from { search(node.Left, node, distance+1) } if node.Right != from { search(node.Right, node, distance+1) } } search(target, nil, 0) return res } 复杂度  时间复杂度：$ O(N), N = size(Tree)$ 空间复杂度：$ O(N) $  ","date":"2021-07-28T11:09:17+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-863.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BA-k-%E7%9A%84%E7%BB%93%E7%82%B9/","title":"Leetcode 863. 二叉树中所有距离为 K 的结点"},{"content":"链接： https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/\n难度： 简单\n题目描述 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。\n更正式地说，root.val = min(root.left.val, root.right.val) 总成立。\n给出这样的一个二叉树，你需要输出所有节点中的 第二小的值。如果第二小的值不存在的话，输出 -1 。\n示例 1：  输入： root = [2,2,5,null,null,5,7]\n输出： 5\n解释： 最小的值是 2 ，第二小的值是 5 。\n 示例 2：  输入： root = [2,2,2]\n输出： -1\n解释： 最小的值是 2, 但是不存在第二小的值。\n 提示：  树中节点数目在范围 [1, 25] 内 1 \u0026lt;= Node.val \u0026lt;= 231 - 1 对于树中每个节点 root.val == min(root.left.val, root.right.val)  解题思路 深度优先搜索 据题意，树的根结点是最小值，故可以遍历整棵树，使用 min 记录最 第二小的值。\n对于每个结点，当该结点的数值小于 min，并且不与根结点相同时，更新 min，一次遍历完成得到 第二小的值。\nfunc findSecondMinimumValue(root *TreeNode) int { max := -1 // 遍历 \tvar dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } if (max == -1 || max \u0026gt; node.Val) \u0026amp;\u0026amp; node.Val != root.Val { max = node.Val } dfs(node.Left) dfs(node.Right) } dfs(root) return max } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(logN) $  ","date":"2021-07-27T10:31:04+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-671.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/","title":"Leetcode 671. 二叉树中第二小的节点"},{"content":"链接： https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/\n难度： 中等\n题目描述 存在一个由 n 个不同元素组成的整数数组 nums ，但你已经记不清具体内容。好在你还记得 nums 中的每一对相邻元素。\n给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个 adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。\n题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。这些相邻元素对可以 按任意顺序 出现。\n返回 原始数组 nums 。如果存在多种解答，返回 其中任意一个 即可。\n示例 1：  输入： adjacentPairs = [[2,1],[3,4],[3,2]]\n输出： [1,2,3,4]\n解释： 数组的所有相邻元素对都在 adjacentPairs 中。\n特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。\n 示例 2：  输入： adjacentPairs = [[4,-2],[1,4],[-3,1]]\n输出： [-2,4,1,-3]\n解释： 数组中可能存在负数。\n另一种解答是 [-3,1,4,-2] ，也会被视作正确答案。\n 示例 3：  输入： adjacentPairs = [[100000,-100000]]\n输出： [100000,-100000]\n 提示：  nums.length == n adjacentPairs.length == n - 1 adjacentPairs[i].length == 2 2 \u0026lt;= n \u0026lt;= 105 -105 \u0026lt;= nums[i], ui, vi \u0026lt;= 105 题目数据保证存在一些以 adjacentPairs 作为元素对的数组 nums  解题思路 哈希 原数组中的元素没有重复的，所以在 adjacentPairs 中，除了收尾两个元素仅出现一次，其余元素均出现两次。\n使用哈希表记录从一个结点能到达的下一个结点，遍历哈希表找到首结点，依次向后从哈希表中查找可达的下一个结点，构建原数组。\nfunc restoreArray(adjacentPairs [][]int) []int { to := make(map[int][]int) for _, pair := range adjacentPairs { to[pair[0]] = append(to[pair[0]], pair[1]) to[pair[1]] = append(to[pair[1]], pair[0]) } res := make([]int, len(adjacentPairs)+1) for k, v := range to { if len(v) == 1 { res[0] = k res[1] = v[0] break } } for i := 2; i \u0026lt; len(res); i++ { next := to[res[i-1]] if next[0] != res[i-2] { res[i] = next[0] } else { res[i] = next[1] } } return res } 复杂度  时间复杂度：$ O(N), N = len(adjacentPairs) $ 空间复杂度：$ O(N) $  ","date":"2021-07-25T21:48:26+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1743.-%E4%BB%8E%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E5%AF%B9%E8%BF%98%E5%8E%9F%E6%95%B0%E7%BB%84/","title":"Leetcode 1743. 从相邻元素对还原数组"},{"content":"链接： https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/\n难度： 简单\n题目描述 给你一个字符串 time ，格式为 hh:mm（小时：分钟），其中某几位数字被隐藏（用 ? 表示）。\n有效的时间为 00:00 到 23:59 之间的所有时间，包括 00:00 和 23:59 。\n替换 time 中隐藏的数字，返回你可以得到的最晚有效时间。\n示例 1：  输入： time = \u0026ldquo;2?:?0\u0026rdquo;\n输出： \u0026ldquo;23:50\u0026rdquo;\n解释： 以数字 \u0026lsquo;2\u0026rsquo; 开头的最晚一小时是 23 ，以 \u0026lsquo;0\u0026rsquo; 结尾的最晚一分钟是 50\n 示例 2：  输入： time = \u0026ldquo;0?:3?\u0026rdquo;\n输出： \u0026ldquo;09:39\u0026rdquo;\n 示例 3：  输入： time = \u0026ldquo;1?:22\u0026rdquo;\n输出： \u0026ldquo;19:22\u0026rdquo;\n 提示：  time 的格式为 hh:mm 题目数据保证你可以由输入的字符串生成有效的时间  解题思路 分类讨论 小时和分钟是完全独立的两个单元，分别针对这两个单元进行判断。\n小时的有效范围为 00 ~ 23，十位和个位相互影响：\n 当十位为 ? 时，若个位小于 4 或者个位也为 ?，则可以取到 2；否则取 1 当个位为 ? 时，若十位为 2，则只能取到3；否则取 9  分钟的有效范围为 00 ~ 59，十位和个位互不影响：\n 当十位为 ? 时，取 5 当个位为 ? 时，取 9  func maximumTime(time string) string { res := []byte(time) // 小时 \tif res[0] == \u0026#39;?\u0026#39; { if res[1] == \u0026#39;?\u0026#39; || res[1] \u0026lt; \u0026#39;4\u0026#39; { res[0] = \u0026#39;2\u0026#39; } else { res[0] = \u0026#39;1\u0026#39; } } if res[1] == \u0026#39;?\u0026#39; { if res[0] == \u0026#39;2\u0026#39; { res[1] = \u0026#39;3\u0026#39; } else { res[1] = \u0026#39;9\u0026#39; } } //分钟 \tif res[3] == \u0026#39;?\u0026#39; { res[3] = \u0026#39;5\u0026#39; } if res[4] == \u0026#39;?\u0026#39; { res[4] = \u0026#39;9\u0026#39; } return string(res) } 复杂度  时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $  ","date":"2021-07-24T12:24:31+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1736.-%E6%9B%BF%E6%8D%A2%E9%9A%90%E8%97%8F%E6%95%B0%E5%AD%97%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E6%99%9A%E6%97%B6%E9%97%B4/","title":"Leetcode 1736. 替换隐藏数字得到的最晚时间"},{"content":"链接： https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/\n难度： 简单\n题目描述 给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的 闭区间 。\n如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个 区间覆盖，那么请你返回 true ，否则返回 false 。\n已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti \u0026lt;= x \u0026lt;= endi ，那么我们称整数 x 被覆盖了。\n示例 1：  输入： ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5\n输出： true\n解释： 2 到 5 的每个整数都被覆盖了：\n 2 被第一个区间覆盖。 3 和 4 被第二个区间覆盖。 5 被第三个区间覆盖   示例 2：  输入： ranges = [[1,10],[10,20]], left = 21, right = 21\n输出： false\n解释： 21 没有被任何一个区间覆盖。\n 提示：  1 \u0026lt;= ranges.length \u0026lt;= 50 1 \u0026lt;= starti \u0026lt;= endi \u0026lt;= 50 1 \u0026lt;= left \u0026lt;= right \u0026lt;= 50  解题思路 暴力求解 对于区间内的每个数字，遍历 range，判断其是否被覆盖，不被覆盖返回 false，被覆盖继续执行下一轮循环。\nfunc isCovered(ranges [][]int, left int, right int) bool { Outer: for i := left; i \u0026lt;= right; i++ { for _, r := range ranges { if i \u0026gt;= r[0] \u0026amp;\u0026amp; i \u0026lt;= r[1] { continue Outer } } return false } return true } 复杂度  时间复杂度：$ O(NM), N = len(ranges), M = right-left+1 $ 空间复杂度：$ O(1) $  哈希 直接记录被覆盖的数，然后遍历 [left, right] ，判断该区间内的数是否全部被覆盖。\nfunc isCovered(ranges [][]int, left int, right int) bool { isCover := [51]bool{} for _, r := range ranges { for i := r[0]; i \u0026lt;= r[1]; i++ { isCover[i] = true } } for i := left; i \u0026lt;= right; i++ { if !isCover[i] { return false } } return true } 复杂度  时间复杂度：$ O(NS+M), N = len(ranges), S = scope, M = right-left+1 $ 空间复杂度：$ O(S) $  ","date":"2021-07-23T10:32:17+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1893.-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%8C%BA%E5%9F%9F%E5%86%85%E6%89%80%E6%9C%89%E6%95%B4%E6%95%B0%E9%83%BD%E8%A2%AB%E8%A6%86%E7%9B%96/","title":"Leetcode 1893. 检查是否区域内所有整数都被覆盖"},{"content":"链接： https://leetcode-cn.com/problems/copy-list-with-random-pointer/\n难度： 中等\n题目描述 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。\n构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。\n例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --\u0026gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --\u0026gt; y 。\n返回复制链表的头节点。\n用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：\n val：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。  你的代码 只 接受原链表的头节点 head 作为传入参数。\n示例 1：  输入： head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出： [[7,null],[13,0],[11,4],[10,2],[1,0]]\n 示例 2：  输入： head = [[1,1],[2,1]]\n输出： [[1,1],[2,1]]\n 示例 3：  输入： head = [[3,null],[3,0],[3,null]]\n输出： [[3,null],[3,0],[3,null]]\n 示例 4:  输入： head = []\n输出： []\n解释： 给定的链表为空（空指针），因此返回 null\n 提示：  0 \u0026lt;= n \u0026lt;= 1000 -10000 \u0026lt;= Node.val \u0026lt;= 10000 Node.random 为空（null）或指向链表中的节点。  解题思路 哈希 使用哈希表维护一个旧结点到新结点的映射，依次从前向后遍历链表，并逐一的构造新结点。\n构造每个新结点时，需要额外维护 random 指针，可以在构造后即进行维护。\n 每遍历到一个新结点时，可能已经在维护之前的 random 指针时已构造，故需要先从哈希表中查找，查找到即使用新结点，没查找到构造新结点。 维护 random 指针时，结点可能已经在遍历时构造，也需要优先查找。  经过一次遍历，即可完成原链表的深拷贝。\nfunc copyRandomList(head *Node) *Node { mapping := make(map[*Node]*Node) newHead := new(Node) node := newHead for ; head != nil; head = head.Next { // 优先查找，可能已被random构造 \tnewNode, ok := mapping[head] if !ok { newNode = \u0026amp;Node{ Val: head.Val, Next: nil, Random: nil, } mapping[head] = newNode } node.Next = newNode node = node.Next // random 指针更新 \tif head.Random != nil { randomNode, ok := mapping[head.Random] if !ok { randomNode = \u0026amp;Node{ Val: head.Random.Val, Next: nil, Random: nil, } mapping[head.Random] = randomNode } node.Random = randomNode } } return newHead.Next } 复杂度  时间复杂度：$ O(N), N = len(list) $ 空间复杂度：$ O(N) $  分裂 在原来链表的基础上，将每个结点裂变出一个新结点，形成如 A-\u0026gt;A'-\u0026gt;B-\u0026gt;B'-\u0026gt;…… 的结构，修正每个新结点的 random 指针为原结点的下一个结点，然后将原链表拆分，即得到结果。\nfunc copyRandomList(head *Node) *Node { if head == nil { return nil } // 裂变 结点 \tfor node := head; node != nil; node = node.Next.Next { node.Next = \u0026amp;Node{ Val: node.Val, Next: node.Next, Random: node.Random, } } // 修正 random \tfor node := head; node != nil; node = node.Next.Next { if node.Random != nil { node.Next.Random = node.Next.Random.Next } } // 拆分链表 \tnewHead := head.Next for node, newNode := head, newHead; node != nil; node, newNode = node.Next, newNode.Next { node.Next = node.Next.Next if node.Next != nil { newNode.Next = newNode.Next.Next } } return newHead } 复杂度  时间复杂度：$ O(N), N = len(list) $ 空间复杂度：$ O(1) $  ","date":"2021-07-22T11:22:49+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-138.-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/","title":"Leetcode 138. 复制带随机指针的链表"},{"content":"链接： https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/\n难度： 简单\n题目描述 输入两个链表，找出它们的第一个公共节点。\n如下面的两个链表：\n在节点 c1 开始相交。\n示例 1：  输入： intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出： Reference of the node with value = 8\n输入解释： 相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n 示例 2：  输入： intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出： Reference of the node with value = 2\n输入解释： 相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n 示例 3：  输入： intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出： null\n输入解释： 从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n解释： 这两个链表不相交，因此返回 null。\n 注意：  如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 $O(n)$ 时间复杂度，且仅用 $O(1)$ 内存。  解题思路 哈希 遍历链表 List1，记录其所有的结点，然后遍历链表 List2 ，查找在第一个链表中首次出现的结点并返回，查找不到返回空。\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode { exist := make(map[*ListNode]bool) for ;headA != nil;headA = headA.Next { exist[headA] = true } for ;headB != nil;headB = headB.Next { if exist[headB] { return headB } } return nil } 复杂度  时间复杂度：$ O(N+M), N = len(List1), M = len(List2) $ 空间复杂度：$ O(N)$  双指针 两个链表从第一个公共结点开始，后续的结点都是相同的，可以将两个链表的尾部对齐，将长的链表截断，然后依次两两结点比较即可。\n为确认截断位置，需要遍历一遍两个链表。不妨假设长的链表为 List1， 短的为 List2。\n 使用两个指针 node1、node2 分别同时对 List1 和 List2 进行遍历。 List2 首先被遍历完，此时 List1 剩余未遍历完的结点数量即为 List1 需要截断的数量。此时，直接将 node2 指向 List1 头结点。 当 node1 遍历到尾部时候，node2恰到达截断位置，故将 node1 指向 List2 头结点`，即完成对齐，继续向后遍历查找相同结点。 当 node1 == node2 时，查找结束，或者找到了公共结点，或者没找到node1、node2均为空，返回 node1 即可  当两个链表等长时候，相当于已经完成了对齐，跳过了第一阶段，直接遍历即可。\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode { for node1, node2 := headA, headB;; { if node1 == node2 { return node1 } if node1 == nil { node1 = headB } else { node1 = node1.Next } if node2 == nil { node2 = headA } else { node2 = node2.Next } } } 复杂度  时间复杂度：$ O(N+M), N = len(List1), M = len(List2) $ 空间复杂度：$ O(1) $  ","date":"2021-07-21T10:43:36+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/","title":"剑指 Offer 52. 两个链表的第一个公共节点"},{"content":"链接： https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/\n难度： 中等\n题目描述 一个数对 (a,b) 的 数对和 等于 a + b 。最大数对和 是一个数对数组中最大的 数对和 。\n比方说，如果我们有数对 (1,5) ，(2,3) 和 (4,4)，最大数对和 为 max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8 。 给你一个长度为 偶数 n 的数组 nums ，请你将 nums 中的元素分成 n / 2 个数对，使得：\n nums 中每个元素 恰好 在 一个 数对中，且 最大数对和 的值 最小 。  请你在最优数对划分的方案下，返回最小的 最大数对和 。\n示例 1：  输入： nums = [3,5,2,3]\n输出： 7\n解释： 数组中的元素可以分为数对 (3,3) 和 (5,2) 。\n最大数对和为 max(3+3, 5+2) = max(6, 7) = 7 。\n 示例 2：  输入： nums = [3,5,4,2,4,6]\n输出： 8\n解释： 数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2) 。\n最大数对和为 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8 。\n 提示：  n == nums.length 2 \u0026lt;= n \u0026lt;= 105 n 是偶数 1 \u0026lt;= nums[i] \u0026lt;= 105  解题思路 排序 为使得 最大数对和 最小，应让最大值和最小值成对，次大值和次小值成对……，以此类推。\n经过一次排序，可以快速地找出每一组数对，并记录最大数对和。\nfunc minPairSum(nums []int) int { sort.Ints(nums) max := 0 for i := 0; i \u0026lt; len(nums)/2; i++ { if max \u0026lt; nums[i]+nums[len(nums)-1-i] { max = nums[i] + nums[len(nums)-1-i] } } return max } 复杂度  时间复杂度：$ O(NlogN), N = len(nums) $ 空间复杂度：$ O(logN) $  ","date":"2021-07-20T09:55:22+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1877.-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AF%B9%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","title":"Leetcode 1877. 数组中最大数对和的最小值"},{"content":"链接： https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/\n难度： 中等\n题目描述 元素的 频数 是该元素在一个数组中出现的次数。\n给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。\n执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。\n示例 1：  输入： nums = [1,2,4], k = 5\n输出： 3\n解释： 对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。\n4 是数组中最高频元素，频数是 3 。\n 示例 2：  输入： nums = [1,4,8,13], k = 5\n输出： 2\n解释： 存在多种最优解决方案：\n 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。   示例 3：  输入： nums = [3,9,6], k = 2\n输出： 1\n 提示：  1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 105 1 \u0026lt;= k \u0026lt;= 105  解题思路 排序 \u0026amp; 滑动窗口 假设经过变换后 x 的频数最多，则对于原数组来说，每次优先让小于 x 且最接近 x 的数字变换为 x，消耗的 k 最小， 可以使得 x 的频数最大。\n为快速确定数字与 x 的接近程度，可以对数组进行一次排序。\n后续需要的是确定这个 x：对于每个元素 num，将能变换的全变换为 num 后，统计频数。按照上述思路，完成变换后的数字在数组中是连续的，故可以使用滑动窗口降低时间复杂度。\n使用 [l, r) 记录滑动窗口的左右边界，每次判断右边界直到到达数组尾：\n 每次变换为 nums[r] 时，需要将滑动数组内的数字全部变换为 nums[r]，需要的变换次数为 need = (nums[r] - nums[r-1]) * (r - l); 当 need 大于等于剩余次数时，右边界 r 向右扩展，剩余次数减去 need; 当 need 小于剩余次数时，左边界 l 向右收缩，剩余次数加上 nums[r-1] - nums[l]。  右边界 r 到达数组结尾时，滑动窗口完成滑动，其中滑动窗口的最大长度 r - l 即为数组中最高频元素的 最大可能频数。\nfunc maxFrequency(nums []int, k int) int { sort.Ints(nums) max := 1 for l, r := 0, 1; r \u0026lt; len(nums); { need := (nums[r] - nums[r-1]) * (r - l) // 扩展 \tif k \u0026gt;= need { k -= need r++ } else { // 收缩 \tif r-1 \u0026gt; l { k += nums[r-1] - nums[l] } l++ } if max \u0026lt; r-l { max = r - l } } return max } 复杂度  时间复杂度：$ O(NlogN), N = len(nums) $ 空间复杂度：$ O(logN) $  ","date":"2021-07-19T10:31:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1838.-%E6%9C%80%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E7%9A%84%E9%A2%91%E6%95%B0/","title":"Leetcode 1838. 最高频元素的频数"},{"content":"链接： https://leetcode-cn.com/problems/group-anagrams-lcci/\n难度： 中等\n题目描述 编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。\n**注意：**本题相对原题稍作修改\n示例：  输入: [\u0026ldquo;eat\u0026rdquo;, \u0026ldquo;tea\u0026rdquo;, \u0026ldquo;tan\u0026rdquo;, \u0026ldquo;ate\u0026rdquo;, \u0026ldquo;nat\u0026rdquo;, \u0026ldquo;bat\u0026rdquo;],\n输出:\n[\n[\u0026ldquo;ate\u0026rdquo;,\u0026ldquo;eat\u0026rdquo;,\u0026ldquo;tea\u0026rdquo;],\n[\u0026ldquo;nat\u0026rdquo;,\u0026ldquo;tan\u0026rdquo;],\n[\u0026ldquo;bat\u0026rdquo;]\n]\n 解题思路 哈希 \u0026amp; 计数 对于每个字符串，使用数组统计每个字母出现的数字，两个同位词得出的统计数组必然相同，故用该数组作为 key\nfunc groupAnagrams(strs []string) [][]string { cnt := func(s string) (cnt [26]int) { for i := range s { cnt[s[i]-\u0026#39;a\u0026#39;]++ } return } hash := make(map[[26]int][]string) for _, str := range strs { key := cnt(str) hash[key] = append(hash[key], str) } res := make([][]string, 0, len(hash)) for _, v := range hash { res = append(res, v) } return res } 复杂度  时间复杂度：$ O(NL), N = len(strs), L = max(len(str)) $ 空间复杂度：$ O(NL) $  哈希 \u0026amp; 排序 不同变位词中字母相同，所以将字符串按照字母排序后，其值也一定相同。故可以将其排序后的值作为哈希表的 key，并将其添加进 value 数组中。\nfunc groupAnagrams(strs []string) [][]string { hash := make(map[string][]string) for _, str := range strs { t := []byte(str) sort.Slice(t, func(i, j int) bool { return t[i] \u0026lt; t[j] }) hash[string(t)] = append(hash[string(t)], str) } res := make([][]string, 0, len(hash)) for _, v := range hash { res = append(res, v) } return res } 复杂度  时间复杂度：$ O(NLlogL), N = len(strs), L = max(len(str)) $ 空间复杂度：$ O(NL) $  ","date":"2021-07-18T11:32:11+08:00","permalink":"https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-10.02.-%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84/","title":"面试题 10.02. 变位词组"},{"content":"链接： https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/\n难度： 简单\n题目描述 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。\n要求时间复杂度为$O(n)$。\n示例 1：  输入: nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n 提示：  1 \u0026lt;= arr.length \u0026lt;= 105 -100 \u0026lt;= arr[i] \u0026lt;= 100  解题思路 动态规划 用 dp[i] 记录以 i 为结尾的连续子数组和的最大值，容易得到状态转移方程：\n dp[0] = nums[0] dp[i] = max(dp[i-1]+nums[i], nums[i])  由于每次转移仅涉及到前一个结果，使用变量代替数组降低空间复杂度\nfunc maxSubArray(nums []int) int { if len(nums) == 0 { return 0 } dp := nums[0] max := dp for pre, i := 0, 1; i \u0026lt; len(nums); i++ { pre = dp if pre+nums[i] \u0026gt; nums[i] { dp = pre + nums[i] } else { dp = nums[i] } if max \u0026lt; dp { max = dp } } return max } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $  ","date":"2021-07-17T13:21:52+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-42.-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/","title":"剑指 Offer 42. 连续子数组的最大和"},{"content":"链接： https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/\n难度： 简单\n题目描述 统计一个数字在排序数组中出现的次数。\n示例 1：  输入: nums = [5,7,7,8,8,10], target = 8\n输出: 2\n 示例 2：  输入: nums = [5,7,7,8,8,10], target = 6\n输出: 0\n 提示：  0 \u0026lt;= 数组长度 \u0026lt;= 50000  解题思路 顺序查找 顺序遍历，统计数量 target。由于数组有序，当当前元素大于 target时，\nfunc search(nums []int, target int) int { cnt := 0 for _, num := range nums { if num == target { cnt++ } else if num \u0026gt; target { break } } return cnt } 复杂度  时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $  二分查找 二分查找，找到首个等于 target 的元素位置，依次向后遍历到元素不等于 target 为止，记录出现的次数。\nfunc search(nums []int, target int) int { pos := len(nums) for l, r := 0, len(nums)-1; l \u0026lt;= r; { if l == r { pos = l break } mid := (l + r) / 2 if nums[mid] \u0026lt; target { l = mid + 1 } else { r = mid } } cnt := 0 for i := pos; i \u0026lt; len(nums) \u0026amp;\u0026amp; nums[i] == target; i++ { cnt++ } return cnt } 复杂度  时间复杂度：$ O(logN), N = len(nums) $ 空间复杂度：$ O(1) $  ","date":"2021-07-16T14:55:24+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-53-i.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-i/","title":"剑指 Offer 53 - I. 在排序数组中查找数字 I"},{"content":"链接： https://leetcode-cn.com/problems/maximum-element-after-decreasing-and-rearranging/\n难度： 中等\n题目描述 给你一个正整数数组 arr 。请你对 arr 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：\n arr 中 第一个 元素必须为 1 。 任意相邻两个元素的差的绝对值 小于等于 1 ，也就是说，对于任意的 1 \u0026lt;= i \u0026lt; arr.length （数组下标从 0 开始），都满足 abs(arr[i] - arr[i - 1]) \u0026lt;= 1 。abs(x) 为 x 的绝对值。  你可以执行以下 2 种操作任意次：\n 减小 arr 中任意元素的值，使其变为一个 更小的正整数 。 重新排列 arr 中的元素，你可以以任意顺序重新排列。  请你返回执行以上操作后，在满足前文所述的条件下，arr 中可能的 最大值 。\n示例 1：  输入： arr = [2,2,1,2,1]\n输出： 2\n解释：\n我们可以重新排列 arr 得到 [1,2,2,2,1] ，该数组满足所有条件。\narr 中最大元素为 2 。\n 示例 2：  输入： arr = [100,1,1000]\n输出： 3\n解释：\n一个可行的方案如下：\n 重新排列 arr 得到 [1,100,1000] 。 将第二个元素减小为 2 。 将第三个元素减小为 3 。\n现在 arr = [1,2,3] ，满足所有条件。\narr 中最大元素为 3 。   示例 3：  输入： arr = [1,2,3,4,5] 输出： 5 解释： 数组已经满足所有条件，最大元素为 5\n 提示：  1 \u0026lt;= arr.length \u0026lt;= 105 1 \u0026lt;= arr[i] \u0026lt;= 109  解题思路 排序 先将数组排序，并令arr[0] = 1，然后逐一地调整后续元素，其值为上个元素值加一。当遇到小于等于前一个值的元素时，从当前元素重新开始调整，直至遍历结束，返回尾部元素。\nfunc maximumElementAfterDecrementingAndRearranging(arr []int) int { sort.Ints(arr) arr[0] = 1 for i := 1; i \u0026lt; len(arr); i++ { if arr[i] \u0026gt; arr[i-1] { arr[i] = arr[i-1] + 1 } } return arr[len(arr)-1] } 复杂度  时间复杂度：$ O(NlogN), N = len(arr) $ 空间复杂度：$ O(logN) $  ","date":"2021-07-15T10:33:47+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1846.-%E5%87%8F%E5%B0%8F%E5%92%8C%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/","title":"Leetcode 1846. 减小和重新排列数组后的最大元素"},{"content":"链接： https://leetcode-cn.com/problems/minimum-absolute-sum-difference/\n难度： 中等\n题目描述 给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。\n数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|（0 \u0026lt;= i \u0026lt; n）的 总和（下标从 0 开始）。\n你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。\n在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 109 + 7 取余 后返回。\n|x| 定义为：\n 如果 x \u0026gt;= 0 ，值为 x ，或者 如果 x \u0026lt;= 0 ，值为 -x  示例 1：  输入： nums1 = [1,7,5], nums2 = [2,3,5]\n输出： 3\n解释： 有两种可能的最优方案：\n 将第二个元素替换为第一个元素：[1,7,5] =\u0026gt; [1,1,5] ，或者 将第二个元素替换为第三个元素：[1,7,5] =\u0026gt; [1,5,5]\n两种方案的绝对差值和都是 |1-2| + (|1-3| 或者 |5-3|) + |5-5| = 3   示例 2：  输入： nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]\n输出： 0\n解释： nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0\n 示例 3：  输入： nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]\n输出： 20\n解释： 将第一个元素替换为第二个元素：[1,10,4,4,2,7] =\u0026gt; [10,10,4,4,2,7]\n绝对差值和为 |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20\n 提示：  n == nums1.length n == nums2.length 1 \u0026lt;= n \u0026lt;= 105 1 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 105  解题思路 排序 \u0026amp; 二分查找 不妨设用 nums1[j] 替换了 nums1[i]，使得绝对差值和最小化。替换前之差为 |nums1[i] - nums2[i]|，替换之后为 |nums1[j] - nums2[i]|，则其替换后绝对差值和的缩小量即为 |nums1[i] - nums2[i]| - |nums1[j] - nums2[i]|，要求该缩小量最大。\n通过上式观察得出：对于每个 i，前一项 |nums1[i] - nums2[i]| 确定不变，唯一的变量即在 j，需要找出使得 |nums1[j] - nums2[i]| 最小的 j，也就是找出 nums1 中与 nums2[i] 最接近的值。\n对于每个 i，通过二分查找的方法，找出最接近的 j。一次遍历完成后，得到最大的缩小量的最大值 max，用原始绝对差值和减去 max 即得到 最小化 绝对差值和。\n二分查找时，当不存在与 nums2[i] 相等的值时，需要找寻最接近的值，此时查找终止条件为仅剩两个元素，因为最接近的值可能大于 nums2[i]，也可能小于 nums2[i]，需要对两个元素均进行判断。\nfunc minAbsoluteSumDiff(nums1 []int, nums2 []int) int { const MOD = 1e9 + 7 // 求绝对值 \tdiff := func(x, y int) int { d := x - y if d \u0026lt; 0 { d = -d } return d } // nums1排序 \tsortedNums1 := make([]int, len(nums1)) copy(sortedNums1, nums1) sort.Ints(sortedNums1) sum := 0 // 绝对差只和 \tmax := 0 // 最小化缩小量最大值 \tfor i := range nums2 { absDiff := diff(nums1[i], nums2[i]) sum %= MOD sum += absDiff // 求和 \t// 二分查找确定最小化缩小量 \tfor l, r := 0, len(sortedNums1)-1; l \u0026lt; r; { // l, r 最接近nums2[i] \tif l+1 == r { dl := diff(sortedNums1[l], nums2[i]) dr := diff(sortedNums1[r], nums2[i]) if dl \u0026lt; dr { if max \u0026lt; absDiff-dl { max = absDiff - dl } } else { if max \u0026lt; absDiff-dr { max = absDiff - dr } } break } mid := (l + r) / 2 // 与nums2相等，已找到 \tif sortedNums1[mid] == nums2[i] { if max \u0026lt; absDiff { max = absDiff } break } else if sortedNums1[mid] \u0026gt; nums2[i] { r = mid } else { l = mid } } } return (sum + MOD - max) % MOD } 复杂度  时间复杂度：$ O(NlogN),N=len(nums1) $ 空间复杂度：$ O(N) $  ","date":"2021-07-14T10:34:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1818.-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E5%80%BC%E5%92%8C/","title":"Leetcode 1818. 绝对差值和"},{"content":"链接： https://leetcode-cn.com/problems/h-index-ii/\n难度： 中等\n题目描述 给定一位研究者论文被引用次数的数组（被引用次数是非负整数）,数组已经按照 升序排列。编写一个方法，计算出研究者的 h 指数。\nh 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共 有 h 篇论文分别被引用了至少 h 次。且其余的 $N - h$ 篇论文每篇被引用次数 不超过 h 次。\n例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。\n示例：  输入： citations = [0,1,3,5,6]\n输出： 3\n解释： 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。\n由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。\n **说明：**如果 h 有多种可能的值，h 指数是其中最大的那个。\n进阶：  这是 H 指数 的延伸题目，本题中的 citations 数组是保证有序的。 你可以优化你的算法到对数时间复杂度吗？  解题思路 顺序查找 解题思路同 Leetcode 274. H 指数，由于已经排好序，只需要从后往前查找即可。\nfunc hIndex(citations []int) int { for i := len(citations) - 1; i \u0026gt;= 0; i-- { if citations[i] \u0026lt; len(citations)-i { return len(citations) - 1 - i } } return len(citations) } 复杂度  时间复杂度：$ O(N), N=len(citations) $ 空间复杂度：$ O(1) $  二分查找 用 [l, r] 作为二分查找的区间下标，每次用区间中位数 citations[mid] 与到数组末尾的距离 len(citations)-mid 相比:\n 当 citations[mid] \u0026lt; len(citations)-l 时，不满足条件，需要继续到右侧查找，令 l = mid+1； 当 citations[mid] ≥ len(citations)-l 时，len(citations)-mid 是一个满足条件的 h，但不确定是否为最大的 h，需要保留并继续到右侧查找，令 r = mid。  遍历到 l = r 时，仅剩一个元素 citations[mid]，当其 ≥ len(citations)-l，len(citations)-l即为最大 h，返回；否则，说明找不到符合条件的 h,返回 0。\nfunc hIndex(citations []int) int { for l, r := 0, len(citations)-1; ; { if l == r { if citations[l] \u0026gt;= len(citations)-l { return len(citations) - l } else { return 0 } } mid := (l + r) / 2 if citations[mid] \u0026lt; len(citations)-mid { l = mid + 1 } else { r = mid } } } 复杂度  时间复杂度：$ O(logN), N=len(citations) $ 空间复杂度：$ O(1) $  ","date":"2021-07-12T10:50:26+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-275.-h-%E6%8C%87%E6%95%B0-ii/","title":"Leetcode 275. H 指数 II"},{"content":"链接： https://leetcode-cn.com/problems/h-index/\n难度： 中等\n题目描述 给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。\nh 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共 有 h 篇论文分别被引用了至少 h 次。且其余的 $N - h$ 篇论文每篇被引用次数 不超过 h 次。\n例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。\n示例：  输入： citations = [3,0,6,1,5]\n输出： 3\n解释： 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。\n由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。\n **提示：**如果 h 有多种可能的值，h 指数是其中最大的那个。\n解题思路 排序 按照每篇论文被引用次数从多到少排序，依次遍历直到首次找到第 i 篇论文，其被引用次数 \u0026lt; i，则说明其前面的论文被引用数均 ≥ i-1，且其前一篇恰好时第 i-1 篇，返回 i-1。\n当遍历完整个数组均为找到时，表明最后一篇被引用数仍 ≥ len(citations)，返回 len(citations)。\nfunc hIndex(citations []int) int { sort.Sort(sort.Reverse(sort.IntSlice(citations))) for i, num := range citations { if num \u0026lt; i+1 { return i } } return len(citations) } 复杂度  时间复杂度：$ O(NlogN), N=len(citations) $ 空间复杂度：$ O(logN) $  ","date":"2021-07-11T12:04:41+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-274.-h-%E6%8C%87%E6%95%B0/","title":"Leetcode 274. H 指数"},{"content":"链接： https://leetcode-cn.com/problems/time-based-key-value-store/\n难度： 中等\n题目描述 创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作：\n set(string key, string value, int timestamp)  存储键 key、值 value，以及给定的时间戳 timestamp。\nget(string key, int timestamp)  返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev \u0026lt;= timestamp。 如果有多个这样的值，则返回对应最大的 timestamp_prev 的那个值。 如果没有值，则返回空字符串（\u0026quot;\u0026quot;）。    示例1：  输入： inputs = [\u0026ldquo;TimeMap\u0026rdquo;,\u0026ldquo;set\u0026rdquo;,\u0026ldquo;get\u0026rdquo;,\u0026ldquo;get\u0026rdquo;,\u0026ldquo;set\u0026rdquo;,\u0026ldquo;get\u0026rdquo;,\u0026ldquo;get\u0026rdquo;], inputs = [[],[\u0026ldquo;foo\u0026rdquo;,\u0026ldquo;bar\u0026rdquo;,1],[\u0026ldquo;foo\u0026rdquo;,1],[\u0026ldquo;foo\u0026rdquo;,3],[\u0026ldquo;foo\u0026rdquo;,\u0026ldquo;bar2\u0026rdquo;,4],[\u0026ldquo;foo\u0026rdquo;,4],[\u0026ldquo;foo\u0026rdquo;,5]]\n输出： [null,null,\u0026ldquo;bar\u0026rdquo;,\u0026ldquo;bar\u0026rdquo;,null,\u0026ldquo;bar2\u0026rdquo;,\u0026ldquo;bar2\u0026rdquo;]\n解释：\nTimeMap kv;\nkv.set(\u0026ldquo;foo\u0026rdquo;, \u0026ldquo;bar\u0026rdquo;, 1); // 存储键 \u0026ldquo;foo\u0026rdquo; 和值 \u0026ldquo;bar\u0026rdquo; 以及时间戳 timestamp = 1\nkv.get(\u0026ldquo;foo\u0026rdquo;, 1); // 输出 \u0026ldquo;bar\u0026rdquo;\nkv.get(\u0026ldquo;foo\u0026rdquo;, 3); // 输出 \u0026ldquo;bar\u0026rdquo; 因为在时间戳 3 和时间戳 2 处没有对应 \u0026ldquo;foo\u0026rdquo; 的值，所以唯一的值位于时间戳 1 处（即 \u0026gt; \u0026ldquo;bar\u0026rdquo;）\nkv.set(\u0026ldquo;foo\u0026rdquo;, \u0026ldquo;bar2\u0026rdquo;, 4);\nkv.get(\u0026ldquo;foo\u0026rdquo;, 4); // 输出 \u0026ldquo;bar2\u0026rdquo;\nkv.get(\u0026ldquo;foo\u0026rdquo;, 5); // 输出 \u0026ldquo;bar2\u0026rdquo;\n 示例2：  输入： inputs = [\u0026ldquo;TimeMap\u0026rdquo;,\u0026ldquo;set\u0026rdquo;,\u0026ldquo;set\u0026rdquo;,\u0026ldquo;get\u0026rdquo;,\u0026ldquo;get\u0026rdquo;,\u0026ldquo;get\u0026rdquo;,\u0026ldquo;get\u0026rdquo;,\u0026ldquo;get\u0026rdquo;], inputs = [[],[\u0026ldquo;love\u0026rdquo;,\u0026ldquo;high\u0026rdquo;,10],[\u0026ldquo;love\u0026rdquo;,\u0026ldquo;low\u0026rdquo;,20],[\u0026ldquo;love\u0026rdquo;,5],[\u0026ldquo;love\u0026rdquo;,10],[\u0026ldquo;love\u0026rdquo;,15],[\u0026ldquo;love\u0026rdquo;,20],[\u0026ldquo;love\u0026rdquo;,25]]\n输出： [null,null,null,\u0026quot;\u0026quot;,\u0026ldquo;high\u0026rdquo;,\u0026ldquo;high\u0026rdquo;,\u0026ldquo;low\u0026rdquo;,\u0026ldquo;low\u0026rdquo;]\n 提示：  所有的键/值字符串都是小写的。 所有的键/值字符串长度都在 [1, 100] 范围内。 所有 TimeMap.set 操作中的时间戳 timestamps 都是严格递增的。 1 \u0026lt;= timestamp \u0026lt;= 107 TimeMap.set 和 TimeMap.get 函数在每个测试用例中将（组合）调用总计 120000 次。  解题思路 哈希+二分查找 利用哈希表作为存储。每个 key 记录按照 timestamp 顺序记录的数组，数组元素记录 value 和 timestamp 。\n Set ，由于 timestamp 严格递增，只需将 value 和 timestamp 添加到对应数组的尾部； Get ，利用数组的有序性，使用二分查找，找到不大于 timestamp 的首个值。  type Value struct { value string timestamp int } type TimeMap struct { hash map[string][]*Value } /** Initialize your data structure here. */ func Constructor() TimeMap { return TimeMap{ hash: make(map[string][]*Value), } } func (this *TimeMap) Set(key string, value string, timestamp int) { this.hash[key] = append(this.hash[key], \u0026amp;Value{ value: value, timestamp: timestamp, }) } func (this *TimeMap) Get(key string, timestamp int) string { t := this.hash[key] l, r := 0, len(t) for l \u0026lt; r { if l+1 == r { if t[l].timestamp \u0026lt;= timestamp { return t[l].value } else { return \u0026#34;\u0026#34; } } mid := (l + r) / 2 if t[mid].timestamp \u0026gt; timestamp { r = mid } else { l = mid } } return \u0026#34;\u0026#34; } 复杂度  时间复杂度：  Set：$ O(1) $ Get：$ O(logN), N=len(keys) $   空间复杂度：$ O(N) $  ","date":"2021-07-10T11:47:18+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-981.-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/","title":"Leetcode 981. 基于时间的键值存储"},{"content":"链接： https://leetcode-cn.com/problems/find-majority-element-lcci/\n难度： 简单\n题目描述 数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 $O(N)$ 、空间复杂度为 $O(1)$ 的解决方案。\n示例 1：  输入： [1,2,5,9,5,9,5,5,5]\n输出： 5\n 示例 2：  输入： [3,2]\n输出： -1\n 示例 3：  输入： [2,2,1,1,1,2,2]\n输出： 2\n 解题思路 哈希计数 遍历数组，记录每个数出现的次数，直到某个数 num 出现的次数大于数组长度的一半则返回 num，否则返回 -1\nfunc majorityElement(nums []int) int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ if cnt[num] \u0026gt; len(nums)/2 { return num } } return -1 } 复杂度  时间复杂度：$ O(N) $ 空间复杂度：$ O(N) $  排序 将数组排序，依次统计连续相同数字的数量，直到满足条件为止。\nfunc majorityElement(nums []int) int { if len(nums) == 1 { return nums[0] } sort.Ints(nums) cnt := 1 for i := 1; i \u0026lt; len(nums); i++ { if nums[i] == nums[i-1] { cnt++ if cnt \u0026gt; len(nums)/2 { return nums[i] } } else { cnt = 1 } } return -1 } 复杂度  时间复杂度：$ O(NlogN) $ 空间复杂度：$ O(1) $  摩尔投票算法 这一算法应用的问题原型是在集合中寻找可能存在的多数元素，这一元素在输入的序列重复出现并占到了序列元素的一半以上。\n假设存在占到序列元素一半以上的众数，每次将两个不相同的两个数消除，直到最后剩下的数字即为该数。\n如果一个序列中没有占到多数的元素，那么第一次的结果就可能是无效的随机元素，所以在第一遍遍历之后应该再进行一个遍历以统计第一次算法遍历的结果出现次数，以确定其是否占到了序列元素的一半以上。\n算法步骤如下：\n 用 major 和 cnt 记录主要元素和其数量，初始 cnt 为 0； 当 cnt 数量为 0 时，将 major 设置为当前元素； 当当前元素 num 和 major 不同时，cnt 减一； 当当前元素 num 和 major 相同时，cnt 加一； 一次遍历后，major 即为选出来的元素； 二次遍历统计 major，验证其是否占到了序列元素的一半以上。  func majorityElement(nums []int) int { major := 0 cnt := 0 for _, num := range nums { if cnt == 0 { major = num cnt++ continue } if num == major { cnt++ } else { cnt-- } } cnt = 0 for _, num := range nums { if num == major { cnt++ } } if cnt \u0026gt; len(nums)/2 { return major } return -1 } 复杂度  时间复杂度：$ O(N) $ 空间复杂度：$ O(1) $  ","date":"2021-07-09T10:46:07+08:00","permalink":"https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.10.-%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/","title":"面试题 17.10. 主要元素"},{"content":"链接： https://leetcode-cn.com/problems/binary-subarrays-with-sum/\n难度： 中等\n题目描述 给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。\n子数组 是数组的一段连续部分。\n示例 1：  输入： nums = [1,0,1,0,1], goal = 2\n输出： 4\n解释：\n有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]\n 示例 2：  输入： nums = [0,0,0,0,0], goal = 0\n输出： 15\n 提示：  1 \u0026lt;= nums.length \u0026lt;= 3 * 104 nums[i] 不是 0 就是 1 0 \u0026lt;= goal \u0026lt;= nums.length  解题思路 哈希 假设满足条件的子数组下标为 [i, j) ，则以 i 和 j 为结尾的两个前缀数组的前缀和记作 sum[i]、sum[j] ，有 goal = sum[j] - sum[i]。\n将上式变换为：sum[i] = sum[j] - goal ，故可以用哈希表记录前缀和出现的次数，当遍历到 j 时，将 sum[j] 出现的次数加入到结果中。\nfunc numSubarraysWithSum(nums []int, goal int) int { cnt := make(map[int]int) res := 0 sum := 0 for _, num := range nums { cnt[sum]++ sum += num res += cnt[sum-goal] } return res } 复杂度  时间复杂度：$ O(N), N=len(nums) $ 空间复杂度：$ O(N) $  ","date":"2021-07-08T15:11:00+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-930.-%E5%92%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E5%85%83%E5%AD%90%E6%95%B0%E7%BB%84/","title":"Leetcode 930. 和相同的二元子数组"},{"content":"链接： https://leetcode-cn.com/problems/count-good-meals/\n难度： 中等\n题目描述 大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。\n你可以搭配 任意 两道餐品做一顿大餐。\n给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i​​​​​​​​​​​​​​ 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。\n注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。\n示例 1：  输入： deliciousness = [1,3,5,7,9]\n输出： 4\n解释： 大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。\n它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。\n 示例 2:  输入： deliciousness = [1,1,1,3,3,3,7]\n输出： 15\n解释： 大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。\n 提示：  1 \u0026lt;= deliciousness.length \u0026lt;= 105 0 \u0026lt;= deliciousness[i] \u0026lt;= 220  解题思路 哈希计数 通过哈希表 foodCnt 记录每个美味程度的菜品数量。\n对于每个美味程度 d，可以求得与其组成大餐的另一道菜品的所有美味程度 power - d，将 foodCnt[d]*foodCnt[power-d]\u0008 即可得到这两种美味程度组成的大餐数量\n上述方式可能会重复计算，有两个地方需要特殊处理：\n 当 d == power -d 时，问题变成了从 foodCnt[d] 道菜品中找出两个不同的菜品，这是个组合问题，其结果为 foodCnt[d]*(foodCnt[d]-1)/2； 第一次选中 d，和第一次选中 power-d 存在重复计算，可以限制 power-d \u0026gt;= d，则仅计算依次。  func countPairs(deliciousness []int) int { const MOD = 1e9 + 7 sum := 0 foodCnt := make(map[int]int) for _, d := range deliciousness { foodCnt[d]++ } for d, cnt := range foodCnt { for power := 1; power \u0026lt; math.MaxInt32 \u0026amp;\u0026amp; power \u0026gt; 0; power \u0026lt;\u0026lt;= 1 { another := power - d if another \u0026lt; d || foodCnt[another] == 0 { continue } if another == d { sum += cnt * (cnt - 1) / 2 % MOD } else { sum += (foodCnt[another] * cnt) % MOD } sum %= MOD } } return sum } 复杂度  时间复杂度：$ O(NlogB), N=len(deliciousness) B=max(deliciousness[i])$ 空间复杂度：O(N)  ","date":"2021-07-07T10:28:11+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1711.-%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/","title":"Leetcode 1711. 大餐计数"},{"content":"链接： https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant/\n难度： 中等\n题目描述 给你一个数组 orders ，表示客户在餐厅中完成的订单，确切地说， orders[i]=[customerNamei,tableNumberi,foodItemi] ，其中 customerNamei 是客户的姓名，tableNumberi 是客户所在餐桌的桌号，而 foodItemi 是客户点的餐品名称。\n请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。\n注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。\n示例 1：  输入： orders = [[\u0026ldquo;David\u0026rdquo;,\u0026ldquo;3\u0026rdquo;,\u0026ldquo;Ceviche\u0026rdquo;],[\u0026ldquo;Corina\u0026rdquo;,\u0026ldquo;10\u0026rdquo;,\u0026ldquo;Beef Burrito\u0026rdquo;],[\u0026ldquo;David\u0026rdquo;,\u0026ldquo;3\u0026rdquo;,\u0026ldquo;Fried Chicken\u0026rdquo;],[\u0026ldquo;Carla\u0026rdquo;,\u0026ldquo;5\u0026rdquo;,\u0026ldquo;Water\u0026rdquo;],[\u0026ldquo;Carla\u0026rdquo;,\u0026ldquo;5\u0026rdquo;,\u0026ldquo;Ceviche\u0026rdquo;],[\u0026ldquo;Rous\u0026rdquo;,\u0026ldquo;3\u0026rdquo;,\u0026ldquo;Ceviche\u0026rdquo;]]\n输出： [[\u0026ldquo;Table\u0026rdquo;,\u0026ldquo;Beef Burrito\u0026rdquo;,\u0026ldquo;Ceviche\u0026rdquo;,\u0026ldquo;Fried Chicken\u0026rdquo;,\u0026ldquo;Water\u0026rdquo;],[\u0026ldquo;3\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;],[\u0026ldquo;5\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;1\u0026rdquo;],[\u0026ldquo;10\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;]]\n解释：\n点菜展示表如下所示：\nTable,Beef Burrito,Ceviche,Fried Chicken,Water\n3 ,0 ,2 ,1 ,0\n5 ,0 ,1 ,0 ,1\n10 ,1 ,0 ,0 ,0\n对于餐桌 3：David 点了 \u0026ldquo;Ceviche\u0026rdquo; 和 \u0026ldquo;Fried Chicken\u0026rdquo;，而 Rous 点了 \u0026ldquo;Ceviche\u0026rdquo;\n而餐桌 5：Carla 点了 \u0026ldquo;Water\u0026rdquo; 和 \u0026ldquo;Ceviche\u0026rdquo;\n餐桌 10：Corina 点了 \u0026ldquo;Beef Burrito\u0026rdquo;\n 示例 2:  输入： orders = [[\u0026ldquo;James\u0026rdquo;,\u0026ldquo;12\u0026rdquo;,\u0026ldquo;Fried Chicken\u0026rdquo;],[\u0026ldquo;Ratesh\u0026rdquo;,\u0026ldquo;12\u0026rdquo;,\u0026ldquo;Fried Chicken\u0026rdquo;],[\u0026ldquo;Amadeus\u0026rdquo;,\u0026ldquo;12\u0026rdquo;,\u0026ldquo;Fried Chicken\u0026rdquo;],[\u0026ldquo;Adam\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;Canadian Waffles\u0026rdquo;],[\u0026ldquo;Brianna\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;Canadian Waffles\u0026rdquo;]]\n输出： [[\u0026ldquo;Table\u0026rdquo;,\u0026ldquo;Canadian Waffles\u0026rdquo;,\u0026ldquo;Fried Chicken\u0026rdquo;],[\u0026ldquo;1\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;0\u0026rdquo;],[\u0026ldquo;12\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;3\u0026rdquo;]]\n解释：\n对于餐桌 1：Adam 和 Brianna 都点了 \u0026ldquo;Canadian Waffles\u0026rdquo;\n而餐桌 12：James, Ratesh 和 Amadeus 都点了 \u0026ldquo;Fried Chicken\u0026rdquo;\n 示例 3:  输入： orders = [[\u0026ldquo;Laura\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;Bean Burrito\u0026rdquo;],[\u0026ldquo;Jhon\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;Beef Burrito\u0026rdquo;],[\u0026ldquo;Melissa\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;Soda\u0026rdquo;]]\n输出： [[\u0026ldquo;Table\u0026rdquo;,\u0026ldquo;Bean Burrito\u0026rdquo;,\u0026ldquo;Beef Burrito\u0026rdquo;,\u0026ldquo;Soda\u0026rdquo;],[\u0026ldquo;2\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;]]\n 提示：  1 \u0026lt;= orders.length \u0026lt;= 5 * 104 orders[i].length == 3 1 \u0026lt;= customerNamei.length, foodItemi.length \u0026lt;= 20 customerNamei 和 foodItemi 由大小写英文字母及空格字符 ' ' 组成。 tableNumberi 是 1 到 500 范围内的整数。  解题思路 哈希计数 遍历所有每个订单，记录同一桌号每种菜品的数量，然后根据桌号顺序，和菜品顺序生成结果。\nfunc displayTable(orders [][]string) [][]string { tableFoodsCnt := make(map[int]map[string]int) foods := make([]string, 0, len(orders)) // 菜品名单 \tisAddToFoods := make(map[string]bool) // 去重 \tfor _, order := range orders { // 加入菜品名单 \tif !isAddToFoods[order[2]] { foods = append(foods, order[2]) isAddToFoods[order[2]] = true } // 统计数量 \ttable, _ := strconv.Atoi(order[1]) if tableFoodsCnt[table] == nil { tableFoodsCnt[table] = make(map[string]int) } tableFoodsCnt[table][order[2]]++ } // 菜品排序 \tsort.Strings(foods) // 桌号排序 \ttables := make([]int, 0, len(tableFoodsCnt)) for table := range tableFoodsCnt { tables = append(tables, table) } sort.Ints(tables) // 生成结果 \tres := make([][]string, len(tables)+1) res[0] = make([]string, 0, len(foods)+1) // 表头 \tres[0] = append(res[0], \u0026#34;Table\u0026#34;) for _, food := range foods { res[0] = append(res[0], food) } // 填表 \ti := 1 for _, table := range tables { res[i] = make([]string, 0, len(foods)+1) res[i] = append(res[i], strconv.FormatInt(int64(table), 10)) // 桌号 \t// 菜品数 \tfor _, food := range foods { res[i] = append(res[i], strconv.FormatInt(int64(tableFoodsCnt[table][food]), 10)) } i++ } return res } 复杂度  时间复杂度：$ O(NlogN), N=len(orders) $ 空间复杂度：O(N)  ","date":"2021-07-06T09:20:22+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1418.-%E7%82%B9%E8%8F%9C%E5%B1%95%E7%A4%BA%E8%A1%A8/","title":"Leetcode 1418. 点菜展示表"},{"content":"链接： https://leetcode-cn.com/problems/number-of-atoms/\n难度： 困难\n题目描述 给定一个化学式 formula （作为字符串），返回每种原子的数量。\n原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。\n如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。\n两个化学式连在一起是新的化学式。例如 H2O2He3Mg4 也是化学式。\n一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。\n给定一个化学式 formula ，返回所有原子的数量。格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。\n示例1：  输入： formula = \u0026ldquo;H2O\u0026rdquo;\n输出： \u0026ldquo;H2O\u0026rdquo;\n解释：\n原子的数量是 {\u0026lsquo;H\u0026rsquo;: 2, \u0026lsquo;O\u0026rsquo;: 1}。\n 示例2：  输入： formula = \u0026ldquo;Mg(OH)2\u0026rdquo;\n输出： \u0026ldquo;H2MgO2\u0026rdquo;\n解释：\n原子的数量是 {\u0026lsquo;H\u0026rsquo;: 2, \u0026lsquo;Mg\u0026rsquo;: 1, \u0026lsquo;O\u0026rsquo;: 2}。\n 示例3：  输入： formula = \u0026ldquo;K4(ON(SO3)2)2\u0026rdquo;\n输出： \u0026ldquo;K4N2O14S4\u0026rdquo;\n解释：\n原子的数量是 {\u0026lsquo;K\u0026rsquo;: 4, \u0026lsquo;N\u0026rsquo;: 2, \u0026lsquo;O\u0026rsquo;: 14, \u0026lsquo;S\u0026rsquo;: 4}。\n 示例4：  输入： formula = \u0026ldquo;Be32\u0026rdquo;\n输出： \u0026ldquo;Be32\u0026rdquo;\n 提示：  1 \u0026lt;= formula.length \u0026lt;= 1000 formula 由小写英文字母、数字 '(' 和 ')' 组成。 formula 是有效的化学式。  解题思路 栈 依次记录每个元素的数量，当遇到 '(' 时，入栈，直至遇到 ')'：\n 读取其后的数字 cnt ，没有则记为 1 从栈中依次弹出元素，直到遇到 '(' 为止 将这些元素的数量 乘以 cnt ，然后重新放回栈中  重复以上步骤直到遍历完化学式，从栈中取出所有元素，排序，生成结果并返回。\n为避免重复记录过多的元素，通过 map 进行计数，作为栈的元素单位。\nfunc countOfAtoms(formula string) string { // 获取下一个数字 \tgetNum := func(idx *int) int { num := 0 for ; *idx \u0026lt; len(formula); *idx++ { if formula[*idx] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; formula[*idx] \u0026lt;= \u0026#39;9\u0026#39; { num = num*10 + int(formula[*idx]-\u0026#39;0\u0026#39;) } else { break } } if num == 0 { num = 1 } return num } // 获取下一个元素 \tgetAtom := func(idx *int) string { atom := make([]byte, 0, 2) atom = append(atom, formula[*idx]) for *idx++; *idx \u0026lt; len(formula); *idx++ { if formula[*idx] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; formula[*idx] \u0026lt;= \u0026#39;z\u0026#39; { atom = append(atom, formula[*idx]) } else { break } } return string(atom) } // 栈 \tstack := make([]map[string]int, 0, len(formula)) // 入栈 \tmerge := func(tmp *map[string]int) { if len(*tmp) == 0 { return } if len(stack) \u0026gt; 0 \u0026amp;\u0026amp; len(stack[len(stack)-1]) \u0026gt; 0 { for k, v := range *tmp { stack[len(stack)-1][k] += v } } else { stack = append(stack, *tmp) } *tmp = make(map[string]int) } // 计数map \ttmp := make(map[string]int) for i := 0; i \u0026lt; len(formula); { switch formula[i] { // 左括号所有元素入栈 \tcase \u0026#39;(\u0026#39;: merge(\u0026amp;tmp) stack = append(stack, nil) i++ // 右括号，最近左括号范围的元素数量 乘以 括号后的数 \tcase \u0026#39;)\u0026#39;: i++ merge(\u0026amp;tmp) cnt := getNum(\u0026amp;i) for len(stack) \u0026gt; 0 { pairs := stack[len(stack)-1] stack = stack[:len(stack)-1] if pairs == nil { break } for k, v := range pairs { tmp[k] += v * cnt } } merge(\u0026amp;tmp) default: tmp[getAtom(\u0026amp;i)] += getNum(\u0026amp;i) } } // 合并为一个map \tmerge(\u0026amp;tmp) tmp = make(map[string]int) for _, s := range stack { for atom, cnt := range s { tmp[atom] += cnt } } // 字典序排序 \tatoms := make([]string, 0, len(tmp)) for atom := range tmp { atoms = append(atoms, atom) } sort.Strings(atoms) // 生成结果字符串 \tres := make([]byte, 0, len(formula)\u0026lt;\u0026lt;1) for _, atom := range atoms { res = append(res, []byte(atom)...) if tmp[atom] \u0026gt; 1 { res = append(res, []byte(strconv.FormatInt(int64(tmp[atom]), 10))...) } } return string(res) } 复杂度  时间复杂度：O(N2)，其中 N = len(formula) 空间复杂度：O(N)  ","date":"2021-07-05T20:30:53+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-726.-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F/","title":"Leetcode 726. 原子的数量"},{"content":"链接： https://leetcode-cn.com/problems/set-mismatch/\n难度： 简单\n题目描述 集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。\n给定一个数组 nums 代表了集合 S 发生错误后的结果。\n请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。\n示例 1：  输入： nums = [1,2,2,4]\n输出： [2,3]\n 示例 2：  输入： nums = [1,1]\n输出： [1,2]\n 提示：  2 \u0026lt;= nums.length \u0026lt;= 104 1 \u0026lt;= nums[i] \u0026lt;= 104  解题思路 哈希 利用哈希表记录每个数字是否出现，可以找到重复出现过的数字；遍历哈希表可以找到丢失的数字。\nfunc findErrorNums(nums []int) []int { res := []int{0, 0} exist := make([]bool, len(nums)) for _, num := range nums { if exist[num-1] { res[0] = num } exist[num-1] = true } for num, ok := range exist { if !ok { res[1] = num + 1 } } return res } 复杂度  时间复杂度：O(N), N = len(nums) 空间复杂度：O(N)  ","date":"2021-07-04T10:12:40+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-645.-%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88/","title":"Leetcode 645. 错误的集合"},{"content":"链接： https://leetcode-cn.com/problems/sort-characters-by-frequency/\n难度： 中等\n题目描述 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。\n示例1：  输入:\n\u0026ldquo;tree\u0026rdquo;\n输出:\n\u0026ldquo;eert\u0026rdquo;\n解释:\n\u0026lsquo;e\u0026rsquo;出现两次，\u0026lsquo;r\u0026rsquo;和\u0026rsquo;t\u0026rsquo;都只出现一次。\n因此\u0026rsquo;e\u0026rsquo;必须出现在\u0026rsquo;r\u0026rsquo;和\u0026rsquo;t\u0026rsquo;之前。此外，\u0026ldquo;eetr\u0026quot;也是一个有效的答案。\n 示例2：  输入:\n\u0026ldquo;cccaaa\u0026rdquo;\n输出:\n\u0026ldquo;cccaaa\u0026rdquo;\n解释:\n\u0026lsquo;c\u0026rsquo;和\u0026rsquo;a\u0026rsquo;都出现三次。此外，\u0026ldquo;aaaccc\u0026quot;也是有效的答案。\n注意\u0026quot;cacaca\u0026quot;是不正确的，因为相同的字母必须放在一起。\n 示例3：  输入:\n\u0026ldquo;Aabb\u0026rdquo;\n输出:\n\u0026ldquo;bbAa\u0026rdquo;\n解释:\n此外，\u0026ldquo;bbaA\u0026quot;也是一个有效的答案，但\u0026quot;Aabb\u0026quot;是不正确的。\n注意\u0026rsquo;A\u0026rsquo;和\u0026rsquo;a\u0026rsquo;被认为是两种不同的字符。\n 解题思路 计数+排序 统计每个字符出现的次数，按照统计的次数对字符进行排序，然后按照字符顺序和数量展开。\nfunc frequencySort(s string) string { cnt := make(map[byte]int) for i := 0; i \u0026lt; len(s); i++ { cnt[s[i]]++ } chars := make([]byte, 0, len(s)) for char := range cnt { chars = append(chars, char) } sort.Slice(chars, func(i, j int) bool { return cnt[chars[i]] \u0026gt; cnt[chars[j]] }) res := make([]byte, 0, len(s)) for _, char := range chars { res = append(res, bytes.Repeat([]byte{char}, cnt[char])...) } return string(res) } 复杂度  时间复杂度：O(NlogN), N = len(s) 空间复杂度：O(N)  ","date":"2021-07-03T09:35:21+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-451.-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/","title":"Leetcode 451. 根据字符出现频率排序"},{"content":"链接： https://leetcode-cn.com/problems/maximum-ice-cream-bars/\n难度： 中等\n题目描述 夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。\n商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。\n给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。\n**注意：**Tony 可以按任意顺序购买雪糕。\n示例 1：  输入： costs = [1,3,2,4,1], coins = 7\n输出： 4\n解释： Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7\n 示例 2：  输入： costs = [10,6,8,7,7,8], coins = 5\n输出： 0\n解释： Tony 没有足够的钱买任何一支雪糕。\n 示例 3：  输入： costs = [1,6,3,1,2,5], coins = 20\n输出： 6\n解释： Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 = 18 。\n 提示：  costs.length == n 1 \u0026lt;= n \u0026lt;= 105 1 \u0026lt;= costs[i] \u0026lt;= 105 1 \u0026lt;= coins \u0026lt;= 108  解题思路 贪心 为了获得 最大数量，优先购买价格最低的雪糕即可，按照雪糕价格进行一次排序，依次选择到买不起为止。\nfunc maxIceCream(costs []int, coins int) int { sort.Ints(costs) for i, cost := range costs { coins -= cost if coins \u0026lt; 0 { return i } } return len(costs) } 复杂度  时间复杂度：O(NlogN) 空间复杂度：O(1)  ","date":"2021-07-02T10:28:04+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1833.-%E9%9B%AA%E7%B3%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/","title":"Leetcode 1833. 雪糕的最大数量"},{"content":"链接： https://leetcode-cn.com/problems/chuan-di-xin-xi/\n难度： 简单\n题目描述 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：\n 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人  给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。\n示例1：  输入： n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3\n输出： 3\n解释： 信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-\u0026gt;2-\u0026gt;0-\u0026gt;4， 0-\u0026gt;2-\u0026gt;1-\u0026gt;4， 0-\u0026gt;2-\u0026gt;3-\u0026gt;4。\n 示例2：  输入： n = 3, relation = [[0,2],[2,1]], k = 2\n输出： 0\n解释： 信息不能从小 A 处经过 2 轮传递到编号 2\n 限制：  2 \u0026lt;= n \u0026lt;= 10 1 \u0026lt;= k \u0026lt;= 5 1 \u0026lt;= relation.length \u0026lt;= 90, 且 relation[i].length == 2 0 \u0026lt;= relation[i][0],relation[i][1] \u0026lt; n 且 relation[i][0] != relation[i][1]  解题思路 深度优先搜索 从 0 开始进行深度优先搜索，结点可以重复到达，深度限制为 k，最后的结点为 n-1 时，计数+1。\n为快速找到某个玩家可达的下一个玩家，用 map 记录。\nfunc numWays(n int, relation [][]int, k int) int { deliver := make(map[int][]int, len(relation)) for _, pair := range relation { deliver[pair[0]] = append(deliver[pair[0]], pair[1]) } var dfs func(player int, depth int) int dfs = func(player int, depth int) int { if depth == k { if player == n-1 { return 1 } return 0 } res := 0 for _, nextPlayer := range deliver[player] { res += dfs(nextPlayer, depth+1) } return res } return dfs(0, 0) } 复杂度  时间复杂度：O(nk) 空间复杂度：O(n+k+len(relation))  动态规划 dp[i][j] 表示第 i 轮传递后，信息传递到第 j 个玩家的方案数量，很容易得到状态转移方程：\n dp[0][k] = 1 dp[i][k] = dp[i-1][j] + 1, (j, k) ∈ relation  注意到每次遍历下一行仅依赖上一行，可以对空间做进一步优化，将矩阵压缩到两个数组。\nfunc numWays(n int, relation [][]int, k int) int { dp := make([]int, n) dp[0] = 1 for i := 0; i \u0026lt; k; i++ { next := make([]int, n) for _, r := range relation { next[r[1]] += dp[r[0]] } dp = next } return dp[n-1] } 复杂度  时间复杂度：O(n*len(relation)) 空间复杂度：O(n)  ","date":"2021-07-01T11:14:31+08:00","permalink":"https://xianlianghe0123.github.io/p/lcp-07.-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/","title":"LCP 07. 传递信息"},{"content":"链接： https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/\n难度： 困难\n题目描述 请实现两个函数，分别用来序列化和反序列化二叉树。\n你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n**提示：**输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n示例1：  输入： root = [1,2,3,null,null,4,5]\n输出： [1,2,3,null,null,4,5]\n 解题思路 先序遍历 序列化时，先序遍历整个二叉树，将遍历到的每个结点按顺序加入列表中。需要将遍历到的空结点也加入到列表中，作为分割。\n反序列化时，按照列表顺序构建二叉树，遇到空结点表示该分支已结束，回到另一个分支处，继续构造结点。\nclass Codec: def serialize(self, root): \u0026#34;\u0026#34;\u0026#34;Encodes a tree to a single string. :type root: TreeNode :rtype: str \u0026#34;\u0026#34;\u0026#34; list = [] def dfs(node): if node == None: list.append(\u0026#34;None\u0026#34;) else: list.append(str(node.val)) dfs(node.left) dfs(node.right) dfs(root) return \u0026#34;,\u0026#34;.join(list) def deserialize(self, data): \u0026#34;\u0026#34;\u0026#34;Decodes your encoded data to tree. :type data: str :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; list = data.split(\u0026#34;,\u0026#34;) i = 0 def dfs(): nonlocal i if list[i] == \u0026#34;None\u0026#34;: i += 1 return None node = TreeNode(int(list[i])) i += 1 node.left = dfs() node.right = dfs() return node return dfs() 复杂度  时间复杂度：O(N) 空间复杂度：O(N)  ","date":"2021-06-30T15:51:24+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-37.-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"剑指 Offer 37. 序列化二叉树"},{"content":"链接： https://leetcode-cn.com/problems/excel-sheet-column-title/\n难度： 简单\n题目描述 给定一个正整数，返回它在 Excel 表中相对应的列名称。\n例如，\n 1 -\u0026gt; A\n2 -\u0026gt; B\n3 -\u0026gt; C\n\u0026hellip;\n26 -\u0026gt; Z\n27 -\u0026gt; AA\n28 -\u0026gt; AB\n\u0026hellip;\n 示例1：  输入: 1\n输出: \u0026ldquo;A\u0026rdquo;\n 示例2：  输入: 28\n输出: \u0026ldquo;AB\u0026rdquo;\n 示例3：  输入: 701\n输出: \u0026ldquo;ZY\u0026rdquo;\n 解题思路 数学 通过分析题意可以得知，该题是一个进制转换，将一个10进制的数转换为26进制。\n通过数学方法，逐次模26取余数，即可求得倒序的26进制每一位，反转该序列即可求得转换后的数。\n**注意：**该26进制从1开始计数，每次取模前应减1。\nfunc convertToTitle(columnNumber int) string { res := make([]byte, 0, 10) for ; columnNumber \u0026gt; 0; columnNumber /= 26 { columnNumber = columnNumber - 1 res = append(res, \u0026#39;A\u0026#39;+byte((columnNumber)%26)) } for i := 0; i \u0026lt; len(res)/2; i++ { res[i], res[len(res)-1-i] = res[len(res)-1-i], res[i] } return string(res) } 复杂度  时间复杂度：O(log26columnNumber) 空间复杂度：O(log26columnNumber)  ","date":"2021-06-29T10:26:51+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-168.-excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/","title":"Leetcode 168. Excel表列名称"},{"content":"链接： https://leetcode-cn.com/problems/bus-routes/\n难度： 困难\n题目描述 给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。\n 例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -\u0026gt; 5 -\u0026gt; 7 -\u0026gt; 1 -\u0026gt; 5 -\u0026gt; 7 -\u0026gt; 1 -\u0026gt; ... 这样的车站路线行驶。  现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。\n求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。\n示例 1：  输入： routes = [[1,2,7],[3,6,7]], source = 1, target = 6\n输出： 2\n解释： 最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。\n 示例 2：  输入： routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\n输出： -1\n 提示：  1 \u0026lt;= routes.length \u0026lt;= 500. 1 \u0026lt;= routes[i].length \u0026lt;= 105 routes[i] 中的所有值 互不相同 sum(routes[i].length) \u0026lt;= 105 0 \u0026lt;= routes[i][j] \u0026lt; 106 0 \u0026lt;= source, target \u0026lt; 106  解题思路 广度优先搜索 由于借助公交车进行移动，可以以公交车作为基本单位实行广度优先搜索，在每个站点搜索所有可乘坐公交车，直到某一条可以到达终点，或者乘坐过可乘坐的所有公交车均不能到达终点为止。\n需要对起点和终点相同的情况进行特判。\nfunc numBusesToDestination(routes [][]int, source int, target int) int { if source == target { return 0 } type Pair struct { Bus int Step int } buses := make(map[int][]int) for i, route := range routes { for _, station := range route { buses[station] = append(buses[station], i) } } isVisit := make([]bool, len(routes)) queue := make([]*Pair, 0, len(isVisit)) for _, bus := range buses[source] { queue = append(queue, \u0026amp;Pair{ Bus: bus, Step: 1, }) isVisit[bus] = true } for len(queue) \u0026gt; 0 { bus := queue[0].Bus step := queue[0].Step queue = queue[1:] for _, b := range buses[target] { if b == bus { return step } } for _, station := range routes[bus] { for _, b := range buses[station] { if !isVisit[b] { queue = append(queue, \u0026amp;Pair{ Bus: b, Step: step + 1, }) isVisit[b] = true } } } } return -1 } 复杂度  时间复杂度：O(N*M) 空间复杂度：O(N*M)  ","date":"2021-06-28T10:54:56+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-815.-%E5%85%AC%E4%BA%A4%E8%B7%AF%E7%BA%BF/","title":"Leetcode 815. 公交路线"},{"content":"链接： https://leetcode-cn.com/problems/snakes-and-ladders/\n难度： 中等\n题目描述 N x N 的棋盘 board 上，按从 1 到 N*N 的数字给方格编号，编号 从左下角开始，每一行交替方向。\n例如，一块 6 x 6 大小的棋盘，编号如下：\nr 行 c 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 board[r][c] != -1，那个蛇或梯子的目的地将会是 board[r][c]。\n玩家从棋盘上的方格 1 （总是在最后一行、第一列）开始出发。\n每一回合，玩家需要从当前方格 x 开始出发，按下述要求前进：\n 选定目标方格：选择从编号 x+1，x+2，x+3，x+4，x+5，或者 x+6 的方格中选出一个目标方格 s ，目标方格的编号 \u0026lt;= N*N。  该选择模拟了掷骰子的情景，无论棋盘大小如何，你的目的地范围也只能处于区间 [x+1, x+6] 之间。   传送玩家：如果目标方格 S 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 S。 注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。  返回达到方格 N*N 所需的最少移动次数，如果不可能，则返回 -1。\n示例：  输入： [\n[-1,-1,-1,-1,-1,-1],\n[-1,-1,-1,-1,-1,-1],\n[-1,-1,-1,-1,-1,-1],\n[-1,35,-1,-1,13,-1],\n[-1,-1,-1,-1,-1,-1],\n[-1,15,-1,-1,-1,-1]]\n输出： 4\n解释：\n首先，从方格 1 [第 5 行，第 0 列] 开始。\n你决定移动到方格 2，并必须爬过梯子移动到到方格 15。\n然后你决定移动到方格 17 [第 3 行，第 5 列]，必须爬过蛇到方格 13。\n然后你决定移动到方格 14，且必须通过梯子移动到方格 35。\n然后你决定移动到方格 36, 游戏结束。\n可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。\n 提示：  2 \u0026lt;= board.length = board[0].length \u0026lt;= 20 board[i][j] 介于 1 和 N*N 之间或者等于 -1。 编号为 1 的方格上没有蛇或梯子。 编号为 N*N 的方格上没有蛇或梯子。  解题思路 广度优先搜索 每次搜索下 6 个格子，当碰到蛇或者梯子时，将跳转位置入队，否则将当前位置入队，步数加一，标记已访问，避免重复搜索。直到到达 N*N返回步数；或队列为空，返回 -1。\nfunc snakesAndLadders(board [][]int) int { type Pair struct { Pos int Step int } isVisit := make([]bool, len(board)*len(board[0])) queue := make([]*Pair, 0, len(isVisit)) queue = append(queue, \u0026amp;Pair{ Pos: 0, Step: 0, }) isVisit[0] = true for len(queue) \u0026gt; 0 { pos := queue[0].Pos step := queue[0].Step queue = queue[1:] if pos == len(isVisit)-1 { return step } for i := 1; i \u0026lt;= 6; i++ { if pos+i \u0026gt;= len(isVisit) { break } row := len(board) - 1 - (pos+i)/len(board[0]) col := (pos + i) % len(board[0]) if (len(board)-1-row)\u0026amp;1 == 1 { col = len(board[0]) - 1 - col } cell := board[row][col] - 1 if cell \u0026lt; 0 { if isVisit[pos+i] { continue } queue = append(queue, \u0026amp;Pair{ Pos: pos + i, Step: step + 1, }) isVisit[pos+i] = true } else if !isVisit[cell] { queue = append(queue, \u0026amp;Pair{ Pos: cell, Step: step + 1, }) isVisit[cell] = true } } } return -1 } 复杂度  时间复杂度：O(N2) 空间复杂度：O(N2)  ","date":"2021-06-27T19:07:10+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-909.-%E8%9B%87%E6%A2%AF%E6%A3%8B/","title":"Leetcode 909. 蛇梯棋"},{"content":"链接： https://leetcode-cn.com/problems/open-the-lock/\n难度： 中等\n题目描述 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为 '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。\n锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。\n列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。\n字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。\n示例1：  输入： deadends = [\u0026ldquo;0201\u0026rdquo;,\u0026ldquo;0101\u0026rdquo;,\u0026ldquo;0102\u0026rdquo;,\u0026ldquo;1212\u0026rdquo;,\u0026ldquo;2002\u0026rdquo;], target = \u0026ldquo;0202\u0026rdquo;\n输出： 6\n解释：\n可能的移动序列为 \u0026ldquo;0000\u0026rdquo; -\u0026gt; \u0026ldquo;1000\u0026rdquo; -\u0026gt; \u0026ldquo;1100\u0026rdquo; -\u0026gt; \u0026ldquo;1200\u0026rdquo; -\u0026gt; \u0026ldquo;1201\u0026rdquo; -\u0026gt; \u0026ldquo;1202\u0026rdquo; -\u0026gt; \u0026ldquo;0202\u0026rdquo;。\n注意 \u0026ldquo;0000\u0026rdquo; -\u0026gt; \u0026ldquo;0001\u0026rdquo; -\u0026gt; \u0026ldquo;0002\u0026rdquo; -\u0026gt; \u0026ldquo;0102\u0026rdquo; -\u0026gt; \u0026ldquo;0202\u0026rdquo; 这样的序列是不能解锁的，\n因为当拨动到 \u0026ldquo;0102\u0026rdquo; 时这个锁就会被锁定。\n 示例2：  输入: deadends = [\u0026ldquo;8888\u0026rdquo;], target = \u0026ldquo;0009\u0026rdquo;\n输出： 1\n解释：\n把最后一位反向旋转一次即可 \u0026ldquo;0000\u0026rdquo; -\u0026gt; \u0026ldquo;0009\u0026rdquo;\n 示例3：  输入: deadends = [\u0026ldquo;8887\u0026rdquo;,\u0026ldquo;8889\u0026rdquo;,\u0026ldquo;8878\u0026rdquo;,\u0026ldquo;8898\u0026rdquo;,\u0026ldquo;8788\u0026rdquo;,\u0026ldquo;8988\u0026rdquo;,\u0026ldquo;7888\u0026rdquo;,\u0026ldquo;9888\u0026rdquo;], target = \u0026ldquo;8888\u0026rdquo;\n输出： -1\n解释：\n无法旋转到目标数字且不被锁定。\n 示例4：  输入: deadends = [\u0026ldquo;0000\u0026rdquo;], target = \u0026ldquo;8888\u0026rdquo;\n输出： -1\n 提示：  1 \u0026lt;= deadends.length \u0026lt;= 500 deadends[i].length == 4 target.length == 4 target 不在 deadends 之中 target 和 deadends[i] 仅由若干位数字组成  解题思路 广度优先搜索 每次转动一个拨轮，记录转动后的锁状态，以及到目前为止转动的次数，如果未访问过，加入队列，直到首次与target匹配则返回。\n每次入队后将当前锁状态加入到 deadends 中，防止重复搜索。\n需要对一开始即被锁的情况进行特判。\nfunc openLock(deadends []string, target string) int { type Pair struct { Cur string Cnt int } deadendsMap := make(map[string]bool) for _, s := range deadends { deadendsMap[s] = true } if deadendsMap[\u0026#34;0000\u0026#34;] { return -1 } // 广度优先搜索 \tmin := -1 queue := make([]*Pair, 0, 10000) queue = append(queue, \u0026amp;Pair{ Cur: \u0026#34;0000\u0026#34;, Cnt: 0, }) deadendsMap[\u0026#34;0000\u0026#34;] = true for len(queue) \u0026gt; 0 { cur := queue[0].Cur cnt := queue[0].Cnt queue = queue[1:] if cur == target { if min == -1 { min = cnt break } } for i := 0; i \u0026lt; 4; i++ { // 向后旋转 \tt := []byte(cur) t[i] = \u0026#39;0\u0026#39; + ((t[i]-\u0026#39;0\u0026#39;)+1)%10 if !deadendsMap[string(t)] { queue = append(queue, \u0026amp;Pair{ Cur: string(t), Cnt: cnt + 1, }) deadendsMap[string(t)] = true } // 向前旋转 \tt = []byte(cur) t[i] = \u0026#39;0\u0026#39; + ((t[i]-\u0026#39;0\u0026#39;)-1+10)%10 if !deadendsMap[string(t)] { queue = append(queue, \u0026amp;Pair{ Cur: string(t), Cnt: cnt + 1, }) deadendsMap[string(t)] = true } } } return min } 复杂度  时间复杂度：O(bd*d)，其中 b 是数字的进制，d 是转盘数字的位数， 空间复杂度：O(bd*d)  ","date":"2021-06-25T17:34:59+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-752.-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/","title":"Leetcode 752. 打开转盘锁"},{"content":"链接： https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/\n难度： 简单\n题目描述 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。\n示例1：  输入： 00000000000000000000000000001011\n输出： 3\n解释： 输入的二进制串 00000000000000000000000000001011 中，共有三位为 \u0026lsquo;1\u0026rsquo;。\n 示例 2：  输入： 00000000000000000000000010000000\n输出： 1\n解释： 输入的二进制串 00000000000000000000000010000000 中，共有一位为 \u0026lsquo;1\u0026rsquo;。\n 示例 3：  输入： 11111111111111111111111111111101\n输出： 31\n解释： 输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 \u0026lsquo;1\u0026rsquo;。\n 提示：  输入必须是长度为 32 的 二进制串 。  解题思路 计数 每次统计最右边的一位，并向右移动一位。\nfunc hammingWeight(num uint32) int { cnt := 0 for ; num != 0; num \u0026gt;\u0026gt;= 1 { cnt += int(num \u0026amp; 1) } return cnt } 复杂度  时间复杂度：$ O(\\log{N}) $ 空间复杂度：$ O(1) $  消除 使用lowbit算法，每次消除最右边的 1，直到该数为 0，消除次数即为1的个数 每次统计最右边的一位，并向右移动一位。\nfunc hammingWeight(num uint32) int { cnt := 0 for ; num != 0; cnt++ { num \u0026amp;= num - 1 } return cnt } 复杂度  时间复杂度：$ O(\\log{N}) $ 空间复杂度：$ O(1) $  ","date":"2021-06-23T21:39:35+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/","title":"剑指 Offer 15. 二进制中1的个数"},{"content":"链接： https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/\n难度： 中等\n题目描述 输入一个字符串，打印出该字符串中字符的所有排列。\n你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。\n示例1：  输入： s = \u0026ldquo;abc\u0026rdquo;\n输出： [\u0026ldquo;abc\u0026rdquo;,\u0026ldquo;acb\u0026rdquo;,\u0026ldquo;bac\u0026rdquo;,\u0026ldquo;bca\u0026rdquo;,\u0026ldquo;cab\u0026rdquo;,\u0026ldquo;cba\u0026rdquo;]\n 提示：  1 \u0026lt;= s 的长度 \u0026lt;= 8  解题思路 回溯 遍历未入栈字符列表，每次选取一个字符入栈，并标记此字符已经入栈，递归的寻找下一个字符，直到所有字符全部入栈，将结果加入集合中。\nfunc permutation(s string) []string { only := make(map[string]bool) choice := make([]bool, len(s)) prefix := make([]byte, 0, len(s)) var backtrack func() backtrack = func() { if len(prefix) == len(s) { only[string(prefix)] = true return } for i := range choice { if choice[i] { continue } prefix = append(prefix, s[i]) choice[i] = true backtrack() choice[i] = false prefix = prefix[:len(prefix)-1] } } backtrack() res := make([]string, 0, 1\u0026lt;\u0026lt;(len(s)-1)) for k := range only { res = append(res, k) } return res } 复杂度  时间复杂度：O(N*N!) 空间复杂度：O(N*N!)  ","date":"2021-06-22T21:43:40+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-38.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/","title":"剑指 Offer 38. 字符串的排列"},{"content":"链接： https://leetcode-cn.com/problems/binary-watch/\n难度： 简单\n题目描述 二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。\n 例如，下面的二进制手表读取 \u0026quot;3:25\u0026quot; 。  给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。\n小时不会以零开头：\n 例如，\u0026quot;01:00\u0026quot; 是无效的时间，正确的写法应该是 \u0026quot;1:00\u0026quot; 。  分钟必须由两位数组成，可能会以零开头：\n 例如，\u0026quot;10:2\u0026quot; 是无效的时间，正确的写法应该是 \u0026quot;10:02\u0026quot; 。  示例 1：  输入： turnedOn = 1\n输出： [\u0026ldquo;0:01\u0026rdquo;,\u0026ldquo;0:02\u0026rdquo;,\u0026ldquo;0:04\u0026rdquo;,\u0026ldquo;0:08\u0026rdquo;,\u0026ldquo;0:16\u0026rdquo;,\u0026ldquo;0:32\u0026rdquo;,\u0026ldquo;1:00\u0026rdquo;,\u0026ldquo;2:00\u0026rdquo;,\u0026ldquo;4:00\u0026rdquo;,\u0026ldquo;8:00\u0026rdquo;]\n 示例 2：  输入： turnedOn = 9\n输出： []\n 提示：  0 \u0026lt;= turnedOn \u0026lt;= 10  解题思路 穷举 枚举出所有小时和分钟的合法数，将符合条件的加入到结果列表中\nfunc readBinaryWatch(turnedOn int) []string { res := make([]string, 0, 720) for h := 0; h \u0026lt; 12; h++ { for m := 0; m \u0026lt; 60; m++ { if bits.OnesCount8(uint8(h))+bits.OnesCount8(uint8(m)) == turnedOn { res = append(res, fmt.Sprintf(\u0026#34;%d:%02d\u0026#34;, h, m)) } } } return res } 复杂度  时间复杂度：O(1) 空间复杂度：O(1)  ","date":"2021-06-21T21:27:36+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-401.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/","title":"Leetcode 401. 二进制手表"},{"content":"链接： https://leetcode-cn.com/problems/throne-inheritance/\n难度： 中等\n题目描述 一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。\n这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。\n Successor(x, curOrder):\n如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：\n如果 x 是国王，那么返回 null\n否则，返回 Successor(x 的父亲, curOrder)\n否则，返回 x 不在 curOrder 中最年长的孩子\n 比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。\n 一开始， curOrder 为 [\u0026ldquo;king\u0026rdquo;]. 调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 [\u0026quot;king\u0026quot;, \u0026quot;Alice\u0026quot;] 。 调用 Successor(Alice, curOrder) ，返回 Jack ，所以我们将 Jack 放入 curOrder 中，得到 [\u0026quot;king\u0026quot;, \u0026quot;Alice\u0026quot;, \u0026quot;Jack\u0026quot;] 。 调用 Successor(Jack, curOrder) ，返回 Bob ，所以我们将 Bob 放入 curOrder 中，得到 [\u0026quot;king\u0026quot;, \u0026quot;Alice\u0026quot;, \u0026quot;Jack\u0026quot;, \u0026quot;Bob\u0026quot;] 。 调用 Successor(Bob, curOrder) ，返回 null 。最终得到继承顺序为 [\u0026quot;king\u0026quot;, \u0026quot;Alice\u0026quot;, \u0026quot;Jack\u0026quot;, \u0026quot;Bob\u0026quot;] 。  通过以上的函数，我们总是能得到一个唯一的继承顺序。\n请你实现 ThroneInheritance 类：\n ThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。 void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。 void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。 string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。  示例：  输入： [\u0026ldquo;ThroneInheritance\u0026rdquo;, \u0026ldquo;birth\u0026rdquo;, \u0026ldquo;birth\u0026rdquo;, \u0026ldquo;birth\u0026rdquo;, \u0026ldquo;birth\u0026rdquo;, \u0026ldquo;birth\u0026rdquo;, \u0026ldquo;birth\u0026rdquo;, \u0026ldquo;getInheritanceOrder\u0026rdquo;, \u0026ldquo;death\u0026rdquo;, \u0026ldquo;getInheritanceOrder\u0026rdquo;]\n[[\u0026ldquo;king\u0026rdquo;], [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;andy\u0026rdquo;], [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;bob\u0026rdquo;], [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;catherine\u0026rdquo;], [\u0026ldquo;andy\u0026rdquo;, \u0026ldquo;matthew\u0026rdquo;], [\u0026ldquo;bob\u0026rdquo;, \u0026ldquo;alex\u0026rdquo;], [\u0026ldquo;bob\u0026rdquo;, \u0026ldquo;asha\u0026rdquo;], [null], [\u0026ldquo;bob\u0026rdquo;], [null]]\n输出： [null, null, null, null, null, null, null, [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;andy\u0026rdquo;, \u0026ldquo;matthew\u0026rdquo;, \u0026ldquo;bob\u0026rdquo;, \u0026ldquo;alex\u0026rdquo;, \u0026ldquo;asha\u0026rdquo;, \u0026ldquo;catherine\u0026rdquo;], null, [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;andy\u0026rdquo;, \u0026ldquo;matthew\u0026rdquo;, \u0026ldquo;alex\u0026rdquo;, \u0026ldquo;asha\u0026rdquo;, \u0026ldquo;catherine\u0026rdquo;]]\n解释： ThroneInheritance t= new ThroneInheritance(\u0026ldquo;king\u0026rdquo;); // 继承顺序：king\nt.birth(\u0026ldquo;king\u0026rdquo;, \u0026ldquo;andy\u0026rdquo;); // 继承顺序：king \u0026gt; andy\nt.birth(\u0026ldquo;king\u0026rdquo;, \u0026ldquo;bob\u0026rdquo;); // 继承顺序：king \u0026gt; andy \u0026gt; bob\nt.birth(\u0026ldquo;king\u0026rdquo;, \u0026ldquo;catherine\u0026rdquo;); // 继承顺序：king \u0026gt; andy \u0026gt; bob \u0026gt; catherine\nt.birth(\u0026ldquo;andy\u0026rdquo;, \u0026ldquo;matthew\u0026rdquo;); // 继承顺序：king \u0026gt; andy \u0026gt; matthew \u0026gt; bob \u0026gt; catherine\nt.birth(\u0026ldquo;bob\u0026rdquo;, \u0026ldquo;alex\u0026rdquo;); // 继承顺序：king \u0026gt; andy \u0026gt; matthew \u0026gt; bob \u0026gt; alex \u0026gt; catherine\nt.birth(\u0026ldquo;bob\u0026rdquo;, \u0026ldquo;asha\u0026rdquo;); // 继承顺序：king \u0026gt; andy \u0026gt; matthew \u0026gt; bob \u0026gt; alex \u0026gt; asha \u0026gt; catherine\nt.getInheritanceOrder(); // 返回 [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;andy\u0026rdquo;, \u0026ldquo;matthew\u0026rdquo;, \u0026ldquo;bob\u0026rdquo;, \u0026ldquo;alex\u0026rdquo;, \u0026ldquo;asha\u0026rdquo;, \u0026ldquo;catherine\u0026rdquo;]\nt.death(\u0026ldquo;bob\u0026rdquo;); // 继承顺序：king \u0026gt; andy \u0026gt; matthew \u0026gt; bob（已经去世）\u0026gt; alex \u0026gt; asha \u0026gt; catherine\nt.getInheritanceOrder(); // 返回 [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;andy\u0026rdquo;, \u0026ldquo;matthew\u0026rdquo;, \u0026ldquo;alex\u0026rdquo;, \u0026ldquo;asha\u0026rdquo;, \u0026ldquo;catherine\u0026rdquo;]\n 提示：  1 \u0026lt;= kingName.length, parentName.length, childName.length, name.length \u0026lt;= 15 kingName，parentName， childName 和 name 仅包含小写英文字母。 所有的参数 childName 和 kingName 互不相同。 所有 death 函数中的死亡名字 name 要么是国王，要么是已经出生了的人员名字。 每次调用 birth(parentName, childName) 时，测试用例都保证 parentName 对应的人员是活着的。 最多调用 105 次birth 和 death 。 最多调用 10 次 getInheritanceOrder 。  解题思路 树 整个家庭成员的关系显然是一个树状结构，用树来保存家庭成员关系信息，而继承的顺序则是数的前序遍历。\n另外，为快速定位到某个成员，使用一个 map 记录代表每个成员的结点。\ntype Person struct { name string isLive bool children []*Person } type ThroneInheritance struct { root *Person pos map[string]*Person } func Constructor(kingName string) ThroneInheritance { king := \u0026amp;Person{ name: kingName, isLive: true, } return ThroneInheritance{ root: king, pos: map[string]*Person{ kingName: king, }, } } func (this *ThroneInheritance) Birth(parentName string, childName string) { this.pos[childName] = \u0026amp;Person{ name: childName, isLive: true, } this.pos[parentName].children = append(this.pos[parentName].children, this.pos[childName]) } func (this *ThroneInheritance) Death(name string) { this.pos[name].isLive = false } func (this *ThroneInheritance) GetInheritanceOrder() []string { res := make([]string, 0, len(this.pos)) var dfs func(p *Person) dfs = func(p *Person) { if p.isLive { res = append(res, p.name) } for _, child := range p.children { dfs(child) } } dfs(this.root) return res } 复杂度  时间复杂度：  Constructor: O(1) Birth: O(1) Death: O(1) GetInheritanceOrder: O(N)   空间复杂度：O(N)  ","date":"2021-06-20T09:58:32+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1600.-%E7%9A%87%E4%BD%8D%E7%BB%A7%E6%89%BF%E9%A1%BA%E5%BA%8F/","title":"Leetcode 1600. 皇位继承顺序"},{"content":"链接： https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/\n难度： 简单\n题目描述 符合下列属性的数组 arr 称为 山脉数组 ：\n arr.length \u0026gt;= 3 存在 i（0 \u0026lt; i \u0026lt; arr.length - 1）使得：  arr[0] \u0026lt; arr[1] \u0026lt; \u0026hellip; arr[i-1] \u0026lt; arr[i] arr[i] \u0026gt; arr[i+1] \u0026gt; \u0026hellip; \u0026gt; arr[arr.length - 1]    给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] \u0026lt; arr[1] \u0026lt; ... arr[i - 1] \u0026lt; arr[i] \u0026gt; arr[i + 1] \u0026gt; ... \u0026gt; arr[arr.length - 1] 的下标 i 。\n示例 1：  输入： arr = [0,1,0]\n输出： 1\n 示例 2：  输入： arr = [0,2,1,0]\n输出： 1\n 示例 3：  输入： arr = [0,10,5,2]\n输出： 1\n 示例 4：  输入： arr = [3,4,5,1]\n输出： 2\n 示例 5：  输入： arr = [24,69,100,99,79,78,67,36,26,19]\n输出： 2  提示：  3 \u0026lt;= arr.length \u0026lt;= 104 0 \u0026lt;= arr[i] \u0026lt;= 106 题目数据保证 arr 是一个山脉数组  解题思路 暴力求解 遍历数组，找出最大值，返回其下标。\nfunc peakIndexInMountainArray(arr []int) int { max := 0 idx := 0 for i, num := range arr { if max \u0026lt; num { max = num idx = i } } return idx } 复杂度  时间复杂度：O(N) 空间复杂度：O(1)  二分查找 每次获取数组中间的数，并与相邻的两个数做比较：\n 均大于这两个数，说明该数为山顶，返回 大于前一个数，说明左侧均小于该书数，右侧查找 同理，大于后一个数，左侧查找  func peakIndexInMountainArray(arr []int) int { mid := 0 for l, r := 0, len(arr)-1; ; { mid = (l + r) / 2 if arr[mid] \u0026gt; arr[mid-1] { if arr[mid] \u0026gt; arr[mid+1] { break } l = mid } else { r = mid } } return mid } 复杂度  时间复杂度：O(logN) 空间复杂度：O(1)  ","date":"2021-06-15T20:49:55+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-852.-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/","title":"Leetcode 852. 山脉数组的峰顶索引"},{"content":"链接： https://leetcode-cn.com/problems/guess-number-higher-or-lower/\n难度： 简单\n题目描述 猜数字游戏的规则如下：\n 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。  你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：\n -1：我选出的数字比你猜的数字小 pick \u0026lt; num 1：我选出的数字比你猜的数字大 pick \u0026gt; num 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num  返回我选出的数字。\n示例 1：  输入： n = 10, pick = 6\n输出： 6\n 示例 2：  输入： n = 1, pick = 1\n输出： 1\n 示例 3：  输入： n = 2, pick = 1\n输出： 1\n 示例 4：  输入： n = 2, pick = 2\n输出： 2  提示：  1 \u0026lt;= n \u0026lt;= 231 - 1 1 \u0026lt;= pick \u0026lt;= n  解题思路 二分查找 每次选取中间的数字获取比较结果，等于返回，大于去左半边找，小于去右半边找。\nfunc guessNumber(n int) int { var binSearch func(l, r int) int binSearch = func(l, r int) int { mid := (l + r) / 2 switch guess(mid) { case 0: return mid case -1: return binSearch(l, mid-1) case 1: return binSearch(mid+1, r) } return 0 } return binSearch(1, n) } 复杂度  时间复杂度：O(logN) 空间复杂度：O(1)  ","date":"2021-06-14T10:50:24+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-374.-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/","title":"Leetcode 374. 猜数字大小"},{"content":"链接： https://leetcode-cn.com/problems/first-bad-version/\n难度： 简单\n题目描述 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。\n你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\n示例 1：  给定 n = 5，并且 version = 4 是第一个错误的版本。\n调用 isBadVersion(3) -\u0026gt; false\n调用 isBadVersion(5) -\u0026gt; true\n调用 isBadVersion(4) -\u0026gt; true\n所以，4 是第一个错误的版本。  解题思路 二分查找 对于连续的版本号 [i, j] 每次判断版本号 (i+j)/2 是否出错，未出错查找范围缩小到 [(i+j)/2+1, j]，出错缩小到 [i, (i+j)/2]，直到 i = j 即得到首个出错的版本号 i\nfunc firstBadVersion(n int) int { var binSearch func(i, j int) int binSearch = func(i, j int) int { if i == j { return i } mid := (i + j) / 2 if isBadVersion(mid) { return binSearch(i, mid) } else { return binSearch(mid+1, j) } } return binSearch(1, n) } 复杂度  时间复杂度：O(logN) 空间复杂度：O(1)  ","date":"2021-06-13T10:25:24+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-278.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/","title":"Leetcode 278. 第一个错误的版本"},{"content":"链接： https://leetcode-cn.com/problems/perfect-squares/\n难度： 中等\n题目描述 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n示例 1：  输入： n = 12\n输出： 3\n解释： 12 = 4 + 4 + 4\n 示例 2：  输入： n = 13\n输出： 2\n解释： 13 = 4 + 9\n 注意： 你可以假设：\n 1 \u0026lt;= n \u0026lt;= 104  解题思路 动态规划 dp[i] 表示组成数字 i 的最少完全平方数，易得到状态转移方程：\n dp[0] = 0 dp[i] = min(dp[i-j]+1), j \u0026lt; i 且 j是完全平方数  func change(amount int, coins []int) int { dp = make([]int, amount+1) dp[0] = 1 for i := range coins { for j := 0; j \u0026lt;= amount; j++ { for k := 0; k*coins[i] \u0026lt;= j; k++ { dp[j] += dp[j-k*coins[i]] } } } return dp[amount] } 复杂度  时间复杂度：O(N*√N) 空间复杂度：O(N)  ","date":"2021-06-11T19:33:36+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-279.-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/","title":"Leetcode 279. 完全平方数"},{"content":"链接： https://leetcode-cn.com/problems/coin-change-2/\n难度： 中等\n题目描述 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。\n示例 1：  输入: amount = 5, coins = [1, 2, 5]\n输出: 4\n解释: 有四种方式可以凑成总金额:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n 示例 2：  输入: amount = 3, coins = [2]\n输出: 0\n解释: 只用面额2的硬币不能凑成总金额3。\n 示例 3：  输入: amount = 10, coins = [10]\n输出: 1\n 注意： 你可以假设：\n 0 \u0026lt;= amount (总金额) \u0026lt;= 5000 1 \u0026lt;= coin (硬币面额) \u0026lt;= 5000 硬币种类不超过 500 种 结果符合 32 位符号整数  解题思路 动态规划 dp[i][j] 表示前 i 种面额的硬币，组成总金额 j 的方案数，则可以得到状态转移方程：\n dp[0][0] = 1 dp[i][j] = ∑dp[i-1][j-k*coins[i]], k∈N 且 k*coins[i] \u0026lt;= j  func change(amount int, coins []int) int { dp = make([]int, amount+1) dp[0] = 1 for i := range coins { for j := 0; j \u0026lt;= amount; j++ { for k := 0; k*coins[i] \u0026lt;= j; k++ { dp[j] += dp[j-k*coins[i]] } } } return dp[amount] } 复杂度  时间复杂度：O(N*amount) 空间复杂度：O(N*amount)  优化 用 dp[i] 记录组成总金额 i 的方案数，则对于每个面额 coin 的金币，都可以将其加进去，使得 dp[i+coin] 的方案数增加 dp[i] 。由此得到状态转移方程：\n dp[0] = 1 dp[i] = ∑dp[i-coin], coin∈coins  func change(amount int, coins []int) int { dp := make([]int, amount+1) dp[0] = 1 for _, coin := range coins { for i := coin; i \u0026lt;= amount; i++ { dp[i] += dp[i-coin] } fmt.Println(dp) } return dp[amount] } 复杂度  时间复杂度：O(N*amount) 空间复杂度：O(amount)  ","date":"2021-06-10T10:35:20+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-518.-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii/","title":"Leetcode 518. 零钱兑换 II"},{"content":"链接： https://leetcode-cn.com/problems/last-stone-weight-ii/\n难度： 中等\n题目描述 有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。\n每一回合，从中选出 任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x \u0026lt;= y。那么粉碎的可能结果如下：\n 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。  最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。\n示例 1：  输入： stones = [2,7,4,1,8,1]\n输出： 1\n解释：\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。\n 示例 2：  输入： stones = [31,26,33,21,40]\n输出： 5\n 示例 3：  输入： stones = [1,2]\n输出： 1\n 提示：  1 \u0026lt;= stones.length \u0026lt;= 30 1 \u0026lt;= stones[i] \u0026lt;= 100  解题思路 动态规划 每次从石头堆中拿出两块石头 a 和 b，不妨假设 a \u0026lt; b，则放回石头堆的石头为 b - a。所以最后的结果是 ∑ki*stonesi, ki=-1或1。\n为使得结果最小，要求系数为 -1 和 1 的两堆石头的重量和要最接近，所以原问题转化 01背包问题，背包容量为石头重量总和 sum 的一半，要求从石头堆选取石头装到背包的最大值。\nfunc lastStoneWeightII(stones []int) int { sum := 0 for _, stone := range stones { sum += stone } dp := make([]int, sum/2+1) for _, stones := range stones { for j := len(dp) - 1; j \u0026gt;= 0; j-- { if j \u0026gt;= stones \u0026amp;\u0026amp; dp[j] \u0026lt; dp[j-stones]+stones { dp[j] = dp[j-stones] + stones } } } if (dp[len(dp)-1] \u0026lt;\u0026lt; 1) \u0026gt; sum { return (dp[len(dp)-1] \u0026lt;\u0026lt; 1) - sum } else { return sum - (dp[len(dp)-1] \u0026lt;\u0026lt; 1) } } 复杂度  时间复杂度：O(N*sum(stones)) 空间复杂度：O(sum(stones))  ","date":"2021-06-08T11:35:42+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1049.-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-ii/","title":"Leetcode 1049. 最后一块石头的重量 II"},{"content":"链接： https://leetcode-cn.com/problems/target-sum/\n难度： 中等\n题目描述 给你一个整数数组 nums 和一个整数 target 。\n向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：\n 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 \u0026quot;+2-1\u0026quot; 。  返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。\n示例 1：  输入： nums = [1,1,1,1,1], target = 3\n输出： 5\n解释： 一共有 5 种方法让最终目标和为 3 。\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n 示例 2：  输入： nums = [1], target = 1\n输出： 1\n 注意：  1 \u0026lt;= nums.length \u0026lt;= 20 0 \u0026lt;= nums[i] \u0026lt;= 1000 0 \u0026lt;= sum(nums[i]) \u0026lt;= 1000 -1000 \u0026lt;= target \u0026lt;= 100  解题思路 暴力求解 对于每个数字，可以有 + 和 - 两种符号，枚举出所有的情况，统计符合题意的数量。\nfunc findTargetSumWays(nums []int, target int) int { if len(nums) == 0 { if target == 0 { return 1 } else { return 0 } } return findTargetSumWays(nums[1:], target-nums[0]) + findTargetSumWays(nums[1:], target+nums[0]) } 复杂度  时间复杂度：O(2N) 空间复杂度：O(N)  动态规划 用 dp[i][j] 记录以 i 为结尾的前缀数组，计算结果为 j 的方案数量，很容易得到状态转移方程：\n dp[i][j] = dp[i-1][j-num[i]] + dp[i-1][j+num[i]]  由于计算结果可以为负值，故对其添加一个偏移量，使之全部为非负数\nfunc findTargetSumWays(nums []int, target int) int { dp := [20][2002]int{} dp[0][1000+nums[0]] += 1 dp[0][1000-nums[0]] += 1 for i := 1; i \u0026lt; len(nums); i++ { for j, cnt := range dp[i-1] { if cnt == 0 { continue } dp[i][j+nums[i]] += dp[i-1][j] dp[i][j-nums[i]] += dp[i-1][j] } } return dp[len(nums)-1][target+1000] } 复杂度  时间复杂度：O(N*scope) 空间复杂度：O(N*scope)  ","date":"2021-06-07T20:34:13+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-494.-%E7%9B%AE%E6%A0%87%E5%92%8C/","title":"Leetcode 494. 目标和"},{"content":"链接： https://leetcode-cn.com/problems/ones-and-zeroes/\n难度： 中等\n题目描述 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。\n请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。\n如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。\n示例 1：  输入： strs = [\u0026ldquo;10\u0026rdquo;, \u0026ldquo;0001\u0026rdquo;, \u0026ldquo;111001\u0026rdquo;, \u0026ldquo;1\u0026rdquo;, \u0026ldquo;0\u0026rdquo;], m = 5, n = 3\n输出： 4\n解释： 最多有 5 个 0 和 3 个 1 的最大子集是 {\u0026ldquo;10\u0026rdquo;,\u0026ldquo;0001\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;} ，因此答案是 4 。\n其他满足题意但较小的子集包括 {\u0026ldquo;0001\u0026rdquo;,\u0026ldquo;1\u0026rdquo;} 和 {\u0026ldquo;10\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;} 。{\u0026ldquo;111001\u0026rdquo;} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。\n 示例 2：  输入： strs = [\u0026ldquo;10\u0026rdquo;, \u0026ldquo;0\u0026rdquo;, \u0026ldquo;1\u0026rdquo;], m = 1, n = 1\n输出： 2\n解释： 最大的子集是 {\u0026ldquo;0\u0026rdquo;, \u0026ldquo;1\u0026rdquo;} ，所以答案是 2 。\n 注意：  1 \u0026lt;= strs.length \u0026lt;= 600 1 \u0026lt;= strs[i].length \u0026lt;= 100 strs[i] 仅由 '0' 和 '1' 组成 1 \u0026lt;= m, n \u0026lt;= 100  解题思路 动态规划 对于数组中的每个元素，都有两种选择，要么其位于最大集合中，要么其不在最大子集中。所以该题为背包问题的一个变种，参考背包问题的求解思路，用动态规划求解。\n用 dp[i][j][k] 表示当选择第 i 个元素时，0 的数量为 j，而 1 的数量为 k，此时最大子集的大小。状态转移方程如下：\n 当前元素不可被选择时，即j \u0026lt; zeros 或 k \u0026lt; ones，dp[i][j][k] = dp[i-1][j][k]； 当当前元素可以被选择时，即j \u0026gt;= zeros 且 k \u0026gt;= ones，dp[i][j][k] = max(dp[i-1][j-zeros][k-ones] + 1, dp[i-1][j][k])。  注意到每次转移仅依赖与上一个元素选择的结果，可以缩减一维空间，降低空间复杂度，而依赖前值的问题可以通过倒序计算解决:\nfunc findMaxForm(strs []string, m int, n int) int { dp := [101][101]int{} for _, str := range strs { zeros := 0 ones := 0 for i := 0; i \u0026lt; len(str); i++ { if str[i] == \u0026#39;0\u0026#39; { zeros++ } else { ones++ } } for j := m; j \u0026gt;= 0; j-- { for k := n; k \u0026gt;= 0; k-- { if j \u0026gt;= zeros \u0026amp;\u0026amp; k \u0026gt;= ones \u0026amp;\u0026amp; dp[j-zeros][k-ones] \u0026gt;= dp[j][k] { dp[j][k] = dp[j-zeros][k-ones] + 1 } } } } return dp[m][n] } 复杂度  时间复杂度：O(N*m*n) 空间复杂度：O(m*n)  ","date":"2021-06-06T10:08:43+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-474.-%E4%B8%80%E5%92%8C%E9%9B%B6/","title":"Leetcode 474. 一和零"},{"content":"链接： https://leetcode-cn.com/problems/remove-linked-list-elements/\n难度： 简单\n题目描述 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\n示例 1： \u0026lt;img src=\u0026ldquo;https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg\", width=\u0026ldquo;500px\u0026rdquo;\u0026gt;\n 输入： head = [1,2,6,3,4,5,6], val = 6\n输出： [1,2,3,4,5]\n 示例 2：  输入： head = [], val = 1\n输出： []\n 示例 3：  输入： head = [7,7,7,7], val = 7\n输出： []\n 提示：  列表中的节点在范围 [0, 10] 内 1 \u0026lt;= Node.val \u0026lt;= 50 0 \u0026lt;= k \u0026lt;= 50  解题思路 模拟 遍历整个链表，遇到值为 val 的结点，将其从链表中删除。\nfunc removeElements(head *ListNode, val int) *ListNode { head = \u0026amp;ListNode{ Val: 0, Next: head, } for node := head; node.Next != nil; { if node.Next.Val == val { node.Next = node.Next.Next } else { node = node.Next } } head = head.Next return head } 复杂度  时间复杂度：O(N) 空间复杂度：O(1)  ","date":"2021-06-05T22:26:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-203.-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/","title":"Leetcode 203. 移除链表元素"},{"content":"链接： https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n难度： 简单\n题目描述 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n图示两个链表在节点 c1 开始相交：\n题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构。\n示例1：  输入： intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出： Intersected at \u0026lsquo;8\u0026rsquo;\n解释： 相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n 示例2： \u0026lt;img src=\u0026ldquo;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png\", width=\u0026ldquo;350px\u0026rdquo;\u0026gt;\n 输入： intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出： Intersected at \u0026lsquo;2\u0026rsquo;\n解释： 相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n 示例3： \u0026lt;img src=\u0026ldquo;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\", width=\u0026ldquo;200px\u0026rdquo;\u0026gt;\n 输入： intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出： null\n解释： 从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n 提示：  listA 中节点数目为 m listB 中节点数目为 n 0 \u0026lt;= m, n \u0026lt;= 3 * 104 1 \u0026lt;= Node.val \u0026lt;= 105 0 \u0026lt;= skipA \u0026lt;= m 0 \u0026lt;= skipB \u0026lt;= n 如果 listA 和 listB 没有交点，intersectVal 为 0 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]  **进阶：**你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？\n解题思路 哈希 使用哈希表记录其中的一个链表结点，遍历另一个结点，在哈希表中查找该结点是否出现。\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode { hash := make(map[*ListNode]bool) for node := headA; node != nil; node = node.Next { hash[node] = true } for node := headB; node != nil; node = node.Next { if hash[node] { return node } } return nil } 复杂度  时间复杂度：O(N+M) 空间复杂度：O(N)  截断 两个链表相交，即尾部对齐，可以将较长的链表截断，使得两个链表的长度相同，就可以逐结点比较。\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode { // 记长 \tlenA := 0 for node := headA; node != nil; node = node.Next { lenA++ } lenB := 0 for node := headB; node != nil; node = node.Next { lenB++ } nodeA := headA nodeB := headB // 对齐 \tif lenA \u0026gt; lenB { for i := 0; i \u0026lt; lenA-lenB; i++ { nodeA = nodeA.Next } } else { for i := 0; i \u0026lt; lenB-lenA; i++ { nodeB = nodeB.Next } } // 比较 \tfor ; nodeA != nil; nodeA, nodeB = nodeA.Next, nodeB.Next { if nodeA == nodeB { return nodeA } } return nil } 复杂度  时间复杂度：O(N+M) 空间复杂度：O(1)  ","date":"2021-06-04T17:53:32+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-160.-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","title":"Leetcode 160. 相交链表"},{"content":"链接： https://leetcode-cn.com/problems/contiguous-array/\n难度： 中等\n题目描述 给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。\n示例1：  输入: nums = [0,1]\n输出: 2\n说明: [0, 1] 是具有相同数量0和1的最长连续子数组。\n 示例2：  输入: nums = [0,1,0]\n输出: 2\n说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。\n 示例3：  输入： nums = [23,2,6,4,7], k = 13\n输出： false\n 提示：  1 \u0026lt;= nums.length \u0026lt;= 105 nums[i] 不是 0 就是 1  解题思路 前缀和+哈希 在一段区间内，对该段区间求和即可得出 1 的数量，用区间长度减去 1 的数量，就可以得到 0 的数量，可以用前缀和降低时间复杂度。\n又结果要求对 0 和 1 的数量相等，所以前缀和可以只记录0 和 1 的数量差，当两个前缀数组的和相同时，表示该段数组中0 和 1 的数量相等。原问题转化为在一个数组中找到两个相同的数，且距离相差最大。\n可以利用哈希表保存每个数最早出现的位置，直到找到相同的数，其距离必然为最大，判断是否满足条件即可。\n注意，对 0 需要特殊判断，可以预先在哈希表中存入其位置为 -1。\nfunc findMaxLength(nums []int) int { pos := map[int]int{ 0: -1, } sum := 0 max := 0 for i, num := range nums { if num == 0 { sum-- } else { sum++ } if p, ok := pos[sum]; ok { if max \u0026lt; (i - p) { max = i - p } } else { pos[sum] = i } } return max } 复杂度  时间复杂度：O(N) 空间复杂度：O(N)  ","date":"2021-06-03T22:32:03+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-525.-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84/","title":"Leetcode 525. 连续数组"},{"content":"链接： https://leetcode-cn.com/problems/continuous-subarray-sum/\n难度： 中等\n题目描述 给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：\n子数组大小 至少为 2 ，且 子数组元素总和为 k 的倍数。 如果存在，返回 true ；否则，返回 false 。\n如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。\n示例1：  输入： nums = [23,2,4,6,7], k = 6\n输出： true\n解释： [2,4] 是一个大小为 2 的子数组，并且和为 6 。\n 示例2：  输入： nums = [23,2,6,4,7], k = 6\n输出： true\n解释： [23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。\n42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。\n 示例3：  输入： nums = [23,2,6,4,7], k = 13\n输出： false\n 提示：  1 \u0026lt;= nums.length \u0026lt;= 105 0 \u0026lt;= nums[i] \u0026lt;= 109 0 \u0026lt;= sum(nums[i]) \u0026lt;= 231 - 1 1 \u0026lt;= k \u0026lt;= 231 - 1  解题思路 前缀和+哈希 要求解连续子区间的和，首先考虑利用前缀和来降低区间运算的复杂度，两个前缀数组和的差值是 k 的倍数即可。\n又结果要求对 k 取模为 0，所以前缀和可以只需保留对 k 取模的值，此时两个前缀数组的差值就变为了 0 ，原问题转化为在一个数组中找到两个相同的数，要求其距离大于 1。\n可以利用哈希表保存每个数最早出现的位置，直到找到相同的数，其距离必然为最大，判断是否满足条件即可。\n注意，对 0 需要特殊判断，可以预先在哈希表中存入其位置为 -1。\nfunc checkSubarraySum(nums []int, k int) bool { pos := map[int]int{ 0: -1, } sum := 0 for i := 0; i \u0026lt; len(nums); i++ { sum = (sum + nums[i]) % k if p, ok := pos[sum]; ok { if i-p \u0026gt; 1 { return true } } else { pos[sum] = i } } return false } 复杂度  时间复杂度：O(N) 空间复杂度：O(min(N,k))  ","date":"2021-06-02T22:51:40+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-523.-%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/","title":"Leetcode 523. 连续的子数组和"},{"content":"链接： https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/\n难度： 中等\n题目描述 给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。\n你按照如下规则进行一场游戏：\n 你从第 0 天开始吃糖果。 你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。  请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。\n请你返回得到的数组 answer 。\n示例1：  输入： candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]\n输出： [true,false,true]\n提示：\n1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。\n2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。\n3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。\n 示例2：  输入： candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]\n输出： [false,true,true,false,false]\n 提示：  1 \u0026lt;= candiesCount.length \u0026lt;= 105 1 \u0026lt;= candiesCount[i] \u0026lt;= 105 1 \u0026lt;= queries.length \u0026lt;= 105 queries[i].length == 3 0 \u0026lt;= favoriteTypei \u0026lt; candiesCount.length 0 \u0026lt;= favoriteDayi \u0026lt;= 109 1 \u0026lt;= dailyCapi \u0026lt;= 109  解题思路 前缀和 据题意可知，每天可以吃的糖果数量在 1 ~ dailyCapi 之间，若想在第 favoriteDayi 天可以吃到第 favoriteTypei 类糖果，则必须将之前的类型全部吃完。\n从每天的可以吃的量可以推断出一个在第 favoriteDayi 天吃到糖果数量的一个范围，当该范围与小于等于第 favoriteTypei 类糖果的总量的范围有交集时，则可以吃到；否则不能。\n因每次获取的是当前种类之前的糖果总量，采用前缀和降低时间复杂度。\nfunc canEat(candiesCount []int, queries [][]int) []bool { sum := make([]int, len(candiesCount)) sum[0] = candiesCount[0] for i := 1; i \u0026lt; len(sum); i++ { sum[i] = sum[i-1] + candiesCount[i] } canEat := make([]bool, 0, len(queries)) for _, query := range queries { EatMin := query[1] + 1 EatMax := (query[1] + 1) * query[2] // 小于大的，大与小的有交集 \tif sum[query[0]] \u0026gt;= EatMin \u0026amp;\u0026amp; ((query[0] \u0026gt; 0 \u0026amp;\u0026amp; sum[query[0]-1] \u0026lt; EatMax) || query[0] == 0) { canEat = append(canEat, true) } else { canEat = append(canEat, false) } } return canEat } 复杂度  时间复杂度：O(N+Q) 空间复杂度：O(N)  ","date":"2021-06-01T22:35:59+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1744.-%E4%BD%A0%E8%83%BD%E5%9C%A8%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E9%82%A3%E5%A4%A9%E5%90%83%E5%88%B0%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E7%B3%96%E6%9E%9C%E5%90%97/","title":"Leetcode 1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？"},{"content":"链接： https://leetcode-cn.com/problems/power-of-four/\n难度： 简单\n题目描述 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。\n整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x\n示例 1：  输入： n = 16\n输出： true\n 示例 2：  输入： n = 5\n输出： false\n 示例 3：  输入： n = 1\n输出： true\n 提示：  -231 \u0026lt;= n \u0026lt;= 231 - 1\u0026gt;  解题思路 二进制 2 的幂其二进制表示为最高位为 1，后跟偶数个 0 的数，每次向右移位两位，最终结果为 1，即说明是 4 的幂。\n另，4 的幂为非负数。\nfunc isPowerOfFour(n int) bool { for ; n \u0026gt; 0; n \u0026gt;\u0026gt;= 2 { if n == 1 { return true } else if n\u0026amp;3 != 0 { return false } } return false } 复杂度  时间复杂度：O(logB) 空间复杂度：O(1)  ","date":"2021-05-31T22:42:12+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-342.-4%E7%9A%84%E5%B9%82/","title":"Leetcode 342. 4的幂"},{"content":"链接： https://leetcode-cn.com/problems/power-of-two/\n难度： 简单\n题目描述 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。\n如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。\n示例 1：  输入： n = 1\n输出： true\n解释： 20 = 1\n 示例 2：  输入： n = 16\n输出： true\n解释： 24 = 16\n 示例 3：  输入： n = 3\n输出： false\n 示例 4：  输入： n = 4\n输出： true\n 示例 5：  输入： n = 5\n输出： false\n 提示：  -231 \u0026lt;= n \u0026lt;= 231 - 1\u0026gt;  解题思路 二进制 2 的幂其二进制表示为最高位为 1，其余位为 0 的数，只有二进制位中 1 的数量是 1的数才满足条件。\n另，2 的幂为非负数。\nfunc isPowerOfTwo(n int) bool { cnt := 0 for ; n \u0026gt; 0; n \u0026gt;\u0026gt;= 1 { cnt += n \u0026amp; 1 } if cnt == 1 { return true } return false } 复杂度  时间复杂度：O(logB) 空间复杂度：O(1)  优化 利用lowbit算法，消除最小为的 1 ，所得结果为 0 即满足条件。\nfunc isPowerOfTwo(n int) bool { if n \u0026gt; 0 \u0026amp;\u0026amp; n\u0026amp;(n-1) == 0 { return true } return false } 复杂度  时间复杂度：O(1) 空间复杂度：O(1)  ","date":"2021-05-30T11:06:34+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-231.-2-%E7%9A%84%E5%B9%82/","title":"Leetcode 231. 2 的幂"},{"content":"链接： https://leetcode-cn.com/problems/total-hamming-distance/\n难度： 中等\n题目描述 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。\n计算一个数组中，任意两个数之间汉明距离的总和。\n示例：  输入: x = 1, y = 4\n输出: 2\n解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）\n所以答案为：\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n 注意：  数组中元素的范围为从 0 到 109。 数组的长度不超过 104。  解题思路 按位计数 当一对数字某一位上的两个数字不同时，汉明距离的总和才会加一。故可以统计数组中相同位的 0 和 1 的数量，相乘可统计当前位的汉明距离和。\nfunc totalHammingDistance(nums []int) int { totalDistance := 0 for i := 1 \u0026lt;\u0026lt; 30; i \u0026gt; 0; i \u0026gt;\u0026gt;= 1 { ones := 0 zeros := 0 for _, num := range nums { if num\u0026amp;i == 0 { zeros++ } else { ones++ } } totalDistance += ones * zeros } return totalDistance } 复杂度  时间复杂度：O(N*B) 空间复杂度：O(1)  ","date":"2021-05-28T17:37:15+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-477.-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/","title":"Leetcode 477. 汉明距离总和"},{"content":"链接： https://leetcode-cn.com/problems/hamming-distance/\n难度： 简单\n题目描述 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。\n给出两个整数 x 和 y，计算它们之间的汉明距离。\n注意：  0 ≤ x, y \u0026lt; 231  示例：  输入: x = 1, y = 4\n输出: 2\n解释:\n1 (0 0 0 1)\n4 (0 1 0 0)\n↑ ↑\n上面的箭头指出了对应二进制位不同的位置。\n 解题思路 异或 异或操作可以得出标记出两个数二进制位不同的位置，然后统计数量即可。\nfunc hammingDistance(x int, y int) int { distance := 0 for xor := x ^ y; xor != 0; xor \u0026gt;\u0026gt;= 1 { distance += xor \u0026amp; 1 } return distance } 复杂度  时间复杂度：O(logB) 空间复杂度：O(1)  ","date":"2021-05-27T23:17:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-461.-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/","title":"Leetcode 461. 汉明距离"},{"content":"链接： https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/\n难度： 中等\n题目描述 给出一个字符串 s（仅含有小写英文字母和括号）。\n请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。\n注意，您的结果中 不应 包含任何括号。\n示例1：  输入： s = \u0026ldquo;(abcd)\u0026rdquo;\n输出： \u0026ldquo;dcba\u0026rdquo;\n 示例 2：  输入： s = \u0026ldquo;(u(love)i)\u0026rdquo;\n输出： \u0026ldquo;iloveu\u0026rdquo;\n 示例 3：  输入： s = \u0026ldquo;(ed(et(oc))el)\u0026rdquo;\n输出： \u0026ldquo;leetcode\u0026rdquo;\n 示例 4：  输入： s = \u0026ldquo;a(bcdefghijkl(mno)p)q\u0026rdquo;\n输出： \u0026ldquo;apmnolkjihgfedcbq\u0026rdquo;\n 提示：  0 \u0026lt;= s.length \u0026lt;= 2000 s 中只有小写英文字母和括号 我们确保所有括号都是成对出现的  解题思路 栈 利用栈来进行每一次的反转：\n 当遇到非 ) 时，入栈； 当遇到 ) 时，依次从栈中取出元素加入一个队列，直到取出 ( 时为止，再将队列中的元素全部入栈，即先完成了内层括号的反转。  依次执行上述逻辑，直到遍历到字符串结尾，栈中元素即为反转后的结果。\nfunc reverseParentheses(s string) string { stack := make([]byte, 0, len(s)) queue := make([]byte, 0, len(s)) for i := range s { if s[i] != \u0026#39;)\u0026#39; { stack = append(stack, s[i]) continue } queue = queue[:0] for j := len(stack) - 1; stack[j] != \u0026#39;(\u0026#39;; j-- { queue = append(queue, stack[j]) stack = stack[:len(stack)-1] } stack = stack[:len(stack)-1] stack = append(stack, queue...) } return string(stack) } 复杂度  时间复杂度：O(N) 空间复杂度：O(N2)  跳跃 通过模拟可以发现，每次奇数层的括号内元素需要反转，而偶数内不需要。\n当遇到一个括号时，可以跳转到其对应的另一个括号处，并改变遍历方向，即完成了反转。最终遍历的结果即是答案。\nfunc reverseParentheses(s string) string { stack := make([]int, 0, len(s)) pair := make(map[int]int) for i := range s { switch s[i] { case \u0026#39;(\u0026#39;: stack = append(stack, i) case \u0026#39;)\u0026#39;: pair[i] = stack[len(stack)-1] pair[stack[len(stack)-1]] = i stack = stack[:len(stack)-1] } } res := make([]byte, 0, len(s)) step := 1 for i := 0; i \u0026lt; len(s); i += step { if s[i] == \u0026#39;(\u0026#39; || s[i] == \u0026#39;)\u0026#39; { step = -step i = pair[i] } else { res = append(res, s[i]) } } return string(res) } 复杂度  时间复杂度：O(N) 空间复杂度：O(N)  ","date":"2021-05-26T23:59:13+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1190.-%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%90%E4%B8%B2/","title":"Leetcode 1190. 反转每对括号间的子串"},{"content":"链接： https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/\n难度： 困难\n题目描述 给你一个由非负整数组成的数组 nums 。另有一个查询数组 queries ，其中 queries[i] = [xi, mi] 。\n第 i 个查询的答案是 xi 和任何 nums 数组中不超过 mi 的元素按位异或（XOR）得到的最大值。换句话说，答案是 max(nums[j] XOR xi) ，其中所有 j 均满足 nums[j] \u0026lt;= mi 。如果 nums 中的所有元素都大于 mi，最终答案就是 -1 。\n返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。\n示例1：  输入： nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]\n输出： [3,3,7]\n解释：\n 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。 1 XOR 2 = 3. 5 XOR 2 = 7.   示例2：  输入： nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]\n输出： [15,-1,5]\n 提示：  1 \u0026lt;= nums.length, queries.length \u0026lt;= 105 queries[i].length == 2 0 \u0026lt;= nums[j], xi, mi \u0026lt;= 109  解题思路 Trie树 同421题的思路，采用二进制形的形式，生成一个包含数组中所有数字的Trie树，通过贪心策略求解满足条件的那个最大值。\n因为对元素的取值范围有限制，所以每次需要判断代表 1 的路径能否可达，可以在每个节点记录通过当前路径的最小值，其与 mi 比较即可得到路径是否可达。\nfunc maximizeXor(nums []int, queries [][]int) []int { type Node struct { Left, Right *Node Min int } // 生成Trie数 \troot := new(Node) for _, num := range nums { node := root for bit := 1 \u0026lt;\u0026lt; 30; bit \u0026gt; 0; bit \u0026gt;\u0026gt;= 1 { if num\u0026amp;bit == 0 { if node.Left == nil { node.Left = \u0026amp;Node{ Left: nil, Right: nil, Min: num, } } node = node.Left if node.Min \u0026gt; num { node.Min = num } } else { if node.Right == nil { node.Right = \u0026amp;Node{ Left: nil, Right: nil, Min: num, } } node = node.Right if node.Min \u0026gt; num { node.Min = num } } } } res := make([]int, 0, len(queries)) // 求最大值 \tfor _, query := range queries { node := root val := 0 for bit := 1 \u0026lt;\u0026lt; 30; bit \u0026gt; 0; bit \u0026gt;\u0026gt;= 1 { if query[0]\u0026amp;bit == 0 { // 优先取1 \tif node.Right != nil \u0026amp;\u0026amp; node.Right.Min \u0026lt;= query[1] { node = node.Right val += bit } else if node.Left != nil { node = node.Left } else { val = -1 break } } else { // 优先取0 \tif node.Left != nil { node = node.Left } else if node.Right != nil \u0026amp;\u0026amp; node.Right.Min \u0026lt;= query[1] { node = node.Right val += bit } else { val = -1 break } } } if val == -1 { res = append(res, -1) } else { res = append(res, query[0]^val) } } return res } 复杂度  时间复杂度：O(N*logB) 空间复杂度：O(N*logB)  ","date":"2021-05-23T09:17:20+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1707.-%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/","title":"Leetcode 1707. 与数组中元素的最大异或值"},{"content":"链接： https://leetcode-cn.com/problems/uncrossed-lines/\n难度： 中等\n题目描述 在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。\n现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：\n nums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。\n以这种方法绘制线条，并返回可以绘制的最大连线数。\n示例1：  输入： nums1 = [1,4,2], nums2 = [1,2,4]\n输出： 2\n解释： 可以画出两条不交叉的线，如上图所示。\n但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。\n 示例2：  输入： nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]\n输出： 3\n 示例3:  输入： nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]\n输出： 2\n 提示：  1 \u0026lt;= nums1.length \u0026lt;= 500 1 \u0026lt;= nums2.length \u0026lt;= 500 1 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 2000  解题思路 动态规划 最长公共子序列的变种题目，其思路也相同，用动态规划解决。用 dp[i][j] 表示 nums1[0:i] 和 nums2[0:j] 两个子数组的最大连接数，状态转移方程如下：\n 当 nums1[i] = nums2[j] 时，dp[i][j] = dp[i-1][j-1] + 1 当 nums1[i] != nums2[j] 时， dp[i][j] = max(dp[i-1][j], dp[i][j-1])  func maxUncrossedLines(nums1 []int, nums2 []int) int { dp := make([][]int, 0, len(nums1)+1) dp = append(dp, make([]int, len(nums2)+1)) for i := range nums1 { dp = append(dp, make([]int, len(nums2)+1)) for j := range nums2 { if nums1[i] == nums2[j] { dp[i+1][j+1] = dp[i][j] + 1 } else { if dp[i][j+1] \u0026gt; dp[i+1][j] { dp[i+1][j+1] = dp[i][j+1] } else { dp[i+1][j+1] = dp[i+1][j] } } } } return dp[len(nums1)][len(nums2)] } 复杂度  时间复杂度：O(NM) 空间复杂度：O(NM)  ","date":"2021-05-21T23:42:03+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1035.-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF/","title":"Leetcode 1035. 不相交的线"},{"content":"链接： https://leetcode-cn.com/problems/top-k-frequent-words/\n难度： 中等\n题目描述 给一非空的单词列表，返回前 k 个出现次数最多的单词。\n返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。\n示例1：  输入: [\u0026ldquo;i\u0026rdquo;, \u0026ldquo;love\u0026rdquo;, \u0026ldquo;leetcode\u0026rdquo;, \u0026ldquo;i\u0026rdquo;, \u0026ldquo;love\u0026rdquo;, \u0026ldquo;coding\u0026rdquo;], k = 2\n输出: [\u0026ldquo;i\u0026rdquo;, \u0026ldquo;love\u0026rdquo;]\n解析: \u0026ldquo;i\u0026rdquo; 和 \u0026ldquo;love\u0026rdquo; 为出现次数最多的两个单词，均为2次。\n注意，按字母顺序 \u0026ldquo;i\u0026rdquo; 在 \u0026ldquo;love\u0026rdquo; 之前。\n 示例2：  输入: [\u0026ldquo;the\u0026rdquo;, \u0026ldquo;day\u0026rdquo;, \u0026ldquo;is\u0026rdquo;, \u0026ldquo;sunny\u0026rdquo;, \u0026ldquo;the\u0026rdquo;, \u0026ldquo;the\u0026rdquo;, \u0026ldquo;the\u0026rdquo;, \u0026ldquo;sunny\u0026rdquo;, \u0026ldquo;is\u0026rdquo;, \u0026ldquo;is\u0026rdquo;], k = 4\n输出: [\u0026ldquo;the\u0026rdquo;, \u0026ldquo;is\u0026rdquo;, \u0026ldquo;sunny\u0026rdquo;, \u0026ldquo;day\u0026rdquo;]\n解析: \u0026ldquo;the\u0026rdquo;, \u0026ldquo;is\u0026rdquo;, \u0026ldquo;sunny\u0026rdquo; 和 \u0026ldquo;day\u0026rdquo; 是出现次数最多的四个单词，\n出现次数依次为 4, 3, 2 和 1 次。\n 注意：  假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。 输入的单词均由小写字母组成。  扩展联系：  尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。  解题思路 哈希 遍历单词列表，记录每个单词的频率，然后经一次排序即可找出结果。\nfunc topKFrequent(words []string, k int) []string { wordsCnt := make(map[string]int) for _, word := range words { wordsCnt[word]++ } uniqWords := make([]string, 0, len(wordsCnt)) for k := range wordsCnt { uniqWords = append(uniqWords, k) } sort.Slice(uniqWords, func(i, j int) bool { if wordsCnt[uniqWords[i]] \u0026gt; wordsCnt[uniqWords[j]] { return true } else if wordsCnt[uniqWords[i]] \u0026lt; wordsCnt[uniqWords[j]] { return false } else { return uniqWords[i] \u0026lt; uniqWords[j] } }) return uniqWords[:k] } 复杂度  时间复杂度：O(NlogN) 空间复杂度：O(N)  ","date":"2021-05-20T21:45:44+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-692.-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/","title":"Leetcode 692. 前K个高频单词"},{"content":"链接： https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/\n难度： 中等\n题目描述 给你一个二维矩阵 matrix 和一个整数 k ，矩阵大小为 m x n 由非负整数组成。\n矩阵中坐标 (a, b) 的 值 可由对所有满足 0 \u0026lt;= i \u0026lt;= a \u0026lt; m 且 0 \u0026lt;= j \u0026lt;= b \u0026lt; n 的元素 matrix[i][j]（下标从 0 开始计数）执行异或运算得到。\n请你找出 matrix 的所有坐标中第 k 大的值（k 的值从 1 开始计数）。\n示例1：  输入： matrix = [[5,2],[1,6]], k = 1\n输出： 7\n解释： 坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。\n 示例2：  输入： matrix = [[5,2],[1,6]], k = 2\n输出： 5\n解释： 坐标 (0,0) 的值是 5 = 5 ，为第 2 大的值。\n 示例3：  输入： matrix = [[5,2],[1,6]], k = 3\n输出： 4\n解释： 坐标 (1,0) 的值是 5 XOR 1 = 4 ，为第 3 大的值。\n 示例4：  输入： matrix = [[5,2],[1,6]], k = 4\n输出： 0\n解释： 坐标 (1,1) 的值是 5 XOR 2 XOR 1 XOR 6 = 0 ，为第 4 大的值。\n 提示：  m == matrix.length n == matrix[i].length 1 \u0026lt;= m, n \u0026lt;= 1000 0 \u0026lt;= matrix[i][j] \u0026lt;= 106 1 \u0026lt;= k \u0026lt;= m * n  解题思路 前缀 枚举所有的 a 和 b，求得子矩阵异或值记录下来，经排序即可找到第 k 大的那一个。\n进行计算时，可以利用之前计算的子矩阵，即每次使用上一行的计算结果计算下一行，以进一步降低时间复杂度。\nfunc kthLargestValue(matrix [][]int, k int) int { vals := make([]int, 0, len(matrix)*len(matrix[0])) line := make([]int, len(matrix[0])) for a := 0; a \u0026lt; len(matrix); a++ { xor := 0 for b := 0; b \u0026lt; len(matrix[0]); b++ { xor ^= matrix[a][b] line[b] ^= xor vals = append(vals, line[b]) } } sort.Ints(vals) return vals[len(vals)-k] } 复杂度  时间复杂度：O(NMlog(NM)) 空间复杂度：O(NM)  ","date":"2021-05-19T22:46:08+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1738.-%E6%89%BE%E5%87%BA%E7%AC%AC-k-%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96%E5%9D%90%E6%A0%87%E5%80%BC/","title":"Leetcode 1738. 找出第 K 大的异或坐标值"},{"content":"链接： https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/\n难度： 中等\n题目描述 给你一个整数数组 arr 。\n现需要从数组中取三个下标 i、j 和 k ，其中 (0 \u0026lt;= i \u0026lt; j \u0026lt;= k \u0026lt; arr.length) 。\na 和 b 定义如下：\n a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1] b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k] 注意：^ 表示 按位异或 操作。  请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。\n示例1：  输入： arr = [2,3,1,6,7]\n输出： 4\n解释： 满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)\n 示例 2：  输入： arr = [1,1,1,1,1]\n输出： 10\n 示例 3：  输入： arr = [2,3]\n输出： 0\n 示例 4：  输入： arr = [1,3,5,7,9]\n输出： 3\n 示例 5：  输入： arr = [7,11,12,9,5,2,7,17,22]\n输出： 8\n 提示：  1 \u0026lt;= arr.length \u0026lt;= 300 1 \u0026lt;= arr[i] \u0026lt;= 108  解题思路 暴力求解 枚举所有可能的 i、j 和 k ，求解所有符合条件的三元组数量。\nfunc countTriplets(arr []int) int { cnt := 0 for i := 0; i \u0026lt; len(arr); i++ { a := 0 for j := i + 1; j \u0026lt; len(arr); j++ { a ^= arr[j-1] b := 0 for k := j; k \u0026lt; len(arr); k++ { b ^= arr[k] if a == b { cnt++ } } } } return cnt } 复杂度  时间复杂度：O(N3) 空间复杂度：O(1)  异或性质 两个数异或为 0 ，则这两个数一定相等，反之亦然。\n可以利用此条性质，寻找一段异或为 0 的子数组，则以其中任意一点分割得到的两个子数组，其异或结果必然相等。\nfunc countTriplets(arr []int) int { cnt := 0 for i := 0; i \u0026lt; len(arr); i++ { a := arr[i] for j := i + 1; j \u0026lt; len(arr); j++ { a ^= arr[j] if a == 0 { cnt += j - i } } } return cnt } 复杂度  时间复杂度：O(N2) 空间复杂度：O(1)  ​\n","date":"2021-05-18T22:40:57+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1442.-%E5%BD%A2%E6%88%90%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%88%96%E7%9B%B8%E7%AD%89%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE/","title":"Leetcode 1442. 形成两个异或相等数组的三元组数目"},{"content":"链接： https://leetcode-cn.com/problems/cousins-in-binary-tree/\n难度： 简单\n题目描述 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。\n如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。\n我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。\n只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。\n示例1： \u0026lt;img src=\u0026ldquo;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png\", width=\u0026ldquo;180px\u0026rdquo;\u0026gt;\n 输入： root = [1,2,3,4], x = 4, y = 3\n输出： false\n 示例2： \u0026lt;img src=\u0026ldquo;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png\", width=\u0026ldquo;201px\u0026rdquo;\u0026gt;\n 输入： root = [1,2,3,null,4,null,5], x = 5, y = 4\n输出： true\n 示例3： \u0026lt;img src=\u0026ldquo;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png\", width=\u0026ldquo;156px\u0026rdquo;\u0026gt;\n 输入： root = [1,2,3,null,4], x = 2, y = 3\n输出： false\n 提示：  二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。  解题思路 搜索 记录两个结点的父节点和高度，然后比较即可。\nfunc isCousins(root *TreeNode, x int, y int) bool { parents := make([]int, 0, 2) heights := make([]int, 0, 2) var dfs func(*TreeNode, int, int) dfs = func(node *TreeNode, parent, height int) { if node == nil { return } if node.Val == x || node.Val == y { heights = append(heights, height) parents = append(parents, parent) } dfs(node.Left, node.Val, height+1) dfs(node.Right, node.Val, height+1) } dfs(root, 0, 1) if parents[0] != parents[1] \u0026amp;\u0026amp; heights[0] == heights[1] { return true } return false } 复杂度  时间复杂度：O(N) 空间复杂度：O(N)  ","date":"2021-05-17T09:29:10+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-993.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/","title":"Leetcode 993. 二叉树的堂兄弟节点"},{"content":"链接： https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/\n难度： 中等\n题目描述 给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j \u0026lt; n 。\n**进阶：**你可以在 O(n) 的时间解决这个问题吗？\n示例1：  输入： nums = [3,10,5,25,2,8]\n输出： 28\n解释： 最大运算结果是 5 XOR 25 = 28.\n 示例2：  输入： nums = [0]\n输出： 0\n 示例3：  输入： nums = [2,4]\n输出： 6\n 示例4：  输入： nums = [8,10,2]\n输出： 10\n 示例5：  输入： nums = [14,70,53,83,49,91,36,80,92,51,66,70]\n输出： 127\n 提示：  1 \u0026lt;= nums.length \u0026lt;= 2 * 104 0 \u0026lt;= nums[i] \u0026lt;= 232 - 1  解题思路 暴力求解 枚举所有的 i 和 j，求解比较得出最大值。\nfunc findMaximumXOR(nums []int) int { max := 0 for i := range nums { for j := i + 1; j \u0026lt; len(nums); j++ { t := nums[i] ^ nums[j] if max \u0026lt; t { max = t } } } return max } 复杂度  时间复杂度：O(N2) 空间复杂度：O(1)  Trie树 采用二进制形的形式，生成一个包含数组中所有数字的Trie树，通过贪心策略可以得到与某个数异或最大值。依次枚举每一个数，即可得到全局最大值。\nfunc findMaximumXOR(nums []int) int { type Node struct { Left, Right *Node } // 生成Trie数 \troot := new(Node) for _, num := range nums { node := root for bit := 1 \u0026lt;\u0026lt; 30; bit \u0026gt; 0; bit \u0026gt;\u0026gt;= 1 { if num\u0026amp;bit == 0 { if node.Left == nil { node.Left = new(Node) } node = node.Left } else { if node.Right == nil { node.Right = new(Node) } node = node.Right } } } // 求最大值 \tmax := 0 for _, num := range nums { node := root localMax := 0 for bit := 1 \u0026lt;\u0026lt; 30; bit \u0026gt; 0; bit \u0026gt;\u0026gt;= 1 { if num\u0026amp;bit == 0 { if node.Right != nil { node = node.Right localMax += bit } else { node = node.Left } } else { if node.Left != nil { node = node.Left localMax += bit } else { node = node.Right } } } if max \u0026lt; localMax { max = localMax } } return max } 复杂度  时间复杂度：O(N*logB) 空间复杂度：O(N*logB)  ","date":"2021-05-16T22:31:57+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-421.-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/","title":"Leetcode 421. 数组中两个数的最大异或值"},{"content":"链接： https://leetcode-cn.com/problems/integer-to-roman/\n难度： 中等\n题目描述 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。  C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。  给你一个整数，将其转为罗马数字。\n示例1：  输入: num = 3\n输出: \u0026ldquo;III\u0026rdquo;\n 示例2：  输入: num = 4\n输出: \u0026ldquo;IV\u0026rdquo;\n 示例3：  输入: num = 9\n输出: \u0026ldquo;IX\u0026rdquo;\n 示例4:  输入: num = 58\n输出: \u0026ldquo;LVIII\u0026rdquo;\n解释: L = 50, V = 5, III = 3.\n 示例5:  输入: num = 1994\n输出: \u0026ldquo;MCMXCIV\u0026rdquo;\n解释: M = 1000, CM = 900, XC = 90, IV = 4.\n 提示：  1 \u0026lt;= num \u0026lt;= 3999  解题思路 模拟 使用数组 dp 保存解码的总数， dp[i] 表示截止到长度为 i 的字串可以解码的总数，转移时有两种情况需要考虑：\n 第一种情况，对 s[i] 进行解码，要求 s[i] != 0 第二种情况，对 s[i-1]s[i] 解码, 要求 \u0026quot;00\u0026quot; \u0026lt; s[i-1]s[i] \u0026lt;= \u0026quot;26  然后就可以推导出状态转移方程：\n 初始时，dp[0] = 0, 表示空字符串有一种解法 - 空串 仅满足情况一， dp[i+1] = dp[i] 经满足情况二， dp[i+1] = dp[i-1] 同时满足情况一和二， dp[i+1] = dp[i] + dp[i-1] 情况一和二均不满足，说明该字符串不能解码  求解到 s 尾，即可求解得所有解码总数 dp[len(s)]。\nfunc numDecodings(s string) int { dp := make([]int, len(s)+1) dp[0] = 1 for i := 0; i \u0026lt; len(s); i++ { exist := false // 标记是否可以解码 \t// 情况一 \tif s[i] \u0026gt; \u0026#39;0\u0026#39; { dp[i+1] += dp[i] exist = true } // 情况二 \tif i \u0026gt; 0 \u0026amp;\u0026amp; s[i-1] != \u0026#39;0\u0026#39; { num := 10*int(s[i-1]-\u0026#39;0\u0026#39;) + int(s[i]-\u0026#39;0\u0026#39;) if num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt;= 26 { dp[i+1] += dp[i-1] exist = true } } if !exist { break } } return dp[len(s)] } 优化 每次迭代只涉及到三个变量，故可以用三个变量代替数组，进一步降低空间复杂度\nfunc numDecodings(s string) int { dp := []int{0, 1, 0} for i := 0; i \u0026lt; len(s); i++ { exist := false // 标记是否可以解码 \tdp[2] = 0 // 情况一 \tif s[i] \u0026gt; \u0026#39;0\u0026#39; { dp[2] += dp[1] exist = true } // 情况二 \tif i \u0026gt; 0 \u0026amp;\u0026amp; s[i-1] != \u0026#39;0\u0026#39; { num := 10*int(s[i-1]-\u0026#39;0\u0026#39;) + int(s[i]-\u0026#39;0\u0026#39;) if num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt;= 26 { dp[2] += dp[0] exist = true } } if !exist { break } dp[0], dp[1] = dp[1], dp[2] } return dp[2] } 复杂度  时间复杂度：O(N) 空间复杂度：优化前：O(N)，优化后O(1)  ","date":"2021-05-14T17:30:13+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-12.-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/","title":"Leetcode 12. 整数转罗马数字"},{"content":"链接： https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/\n难度： 困难\n题目描述 有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。\n每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。\n给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。\n由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。\n示例1：  输入： steps = 3, arrLen = 2\n输出： 4\n解释： 3 步后，总共有 4 种不同的方法可以停在索引 0 处。\n向右，向左，不动\n不动，向右，向左\n向右，不动，向左\n不动，不动，不动\n 示例2：  输入： steps = 2, arrLen = 4\n输出： 2\n解释： 2 步后，总共有 2 种不同的方法可以停在索引 0 处。\n向右，向左\n不动，不动\n 示例2：  输入： steps = 4, arrLen = 2\n输出： 8\n 提示：  1 \u0026lt;= steps \u0026lt;= 500 1 \u0026lt;= arrLen \u0026lt;= 10^6  解题思路 动态规划 由于方案数量很多，记录中间结果并重复使用将有效的降低时间复杂度，考虑用动态规划求解。\n用 dp[i][j] 表示指针移动 i 次到达下标 j 的方案数量，其来源分为三部分：\n 上一步到达下标 j-1 处，此时移动了 i-1 次， 上一步已经到达 j 处，移动了 i-1 次 上一步到达 j+1 处，移动了 i-1 次  根据以上情况得到状态转移方程： dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1]，随即可得出结果。\nfunc numWays(steps int, arrLen int) int { const MOD = 1_000_000_007 far := steps + 1 if far \u0026gt; arrLen { far = arrLen } dp := make([][]int, steps) // 计算到i-1步为止 \tdp[0] = make([]int, far) // 移动0次 \tdp[0][0] = 1 // 初始在0 \tfor i := 1; i \u0026lt; cap(dp); i++ { dp[i] = make([]int, 0, far) for j := 0; j \u0026lt; far; j++ { t := dp[i-1][j] if j == 0 { // 左边越界 \tt = (t + dp[i-1][j+1]) % MOD } else if j == far-1 { // 右边越界 \tt = (t + dp[i-1][j-1]) % MOD } else { t = ((t+dp[i-1][j-1])%MOD + dp[i-1][j+1]) % MOD } dp[i] = append(dp[i], t) } } res := dp[steps-1][0] if arrLen \u0026gt; 1 { res = (res + dp[steps-1][1]) % MOD } return res } 复杂度  时间复杂度：O(steps*min(steps, arrLen)) 空间复杂度：O(steps*min(steps, arrLen))  优化 由于下一行的状态转移计算仅依赖于上一行，所以可以仅用一个数组，降低空间复杂度\nfunc numWays(steps int, arrLen int) int { const MOD = 1_000_000_007 far := steps + 1 if far \u0026gt; arrLen { far = arrLen } dp := make([]int, far) // 移动0次 \tdp[0] = 1 // 初始在0 \tfor i := 1; i \u0026lt; steps; i++ { last := dp[0] for j := 0; j \u0026lt; far; j++ { t := dp[j] if j == 0 { // 左边越界 \tt = (t + dp[j+1]) % MOD } else if j == far-1 { // 右边越界 \tt = (t + last) % MOD } else { t = ((t+last)%MOD + dp[j+1]) % MOD } last = dp[j] dp[j] = t } } res := dp[0] if arrLen \u0026gt; 1 { res = (res + dp[1]) % MOD } return res } 复杂度  时间复杂度：O(steps*min(steps, arrLen)) 空间复杂度：O(min(steps, arrLen))  ","date":"2021-05-13T23:12:12+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1269.-%E5%81%9C%E5%9C%A8%E5%8E%9F%E5%9C%B0%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/","title":"Leetcode 1269. 停在原地的方案数"},{"content":"链接： https://leetcode-cn.com/problems/xor-queries-of-a-subarray/\n难度： 中等\n题目描述 有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。\n对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。\n并返回一个包含给定查询 queries 所有结果的数组。\n示例1：  输入： arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]\n输出： [2,7,14,8]\n解释：\n数组中元素的二进制表示形式是：\n1 = 0001\n3 = 0011\n4 = 0100\n8 = 1000\n查询的 XOR 值为：\n[0,1] = 1 xor 3 = 2\n[1,2] = 3 xor 4 = 7\n[0,3] = 1 xor 3 xor 4 xor 8 = 14\n[3,3] = 8\n 示例2：  输入： arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]\n输出： [8,0,4,4]\n 提示：  1 \u0026lt;= arr.length \u0026lt;= 3 * 104 1 \u0026lt;= arr[i] \u0026lt;= 109 1 \u0026lt;= queries.length \u0026lt;= 3 * 104 queries[i].length == 2 0 \u0026lt;= queries[i][0] \u0026lt;= queries[i][1] \u0026lt; arr.length  解题思路 暴力 依照题意，直接对查询下标范围内的所有数进行异或运算。\nfunc xorQueries(arr []int, queries [][]int) []int { res := make([]int, 0, len(queries)) for _, query := range queries { t := 0 for i := query[0]; i \u0026lt;= query[1]; i++ { t ^= arr[i] } res = append(res, t) } return res } 复杂度  时间复杂度：O(N*M) 空间复杂度：O(1)  消除 利用异或运算的 自反性，记录前缀数组的异或值，然后通过异或操作对前缀数组的值进行消除，即可以 O(1) 的时间求得结果。\nfunc xorQueries(arr []int, queries [][]int) []int { xor := make([]int, 0, len(arr)+1) xor = append(xor, 0) for i := 0; i \u0026lt; len(arr); i++ { xor = append(xor, xor[i]^arr[i]) } res := make([]int, 0, len(queries)) for _, query := range queries { res = append(res, xor[query[0]]^xor[query[1]+1]) } return res } 复杂度  时间复杂度：O(N+M) 空间复杂度：O(N)  ","date":"2021-05-12T23:14:18+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1310.-%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2/","title":"Leetcode 1310. 子数组异或查询"},{"content":"链接： https://leetcode-cn.com/problems/decode-xored-permutation/\n难度： 中等\n题目描述 给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。\n它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。\n给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。\n示例1：  输入： encoded = [3,1]\n输出： [1,2,3]\n解释： 如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]\n 示例2：  输入： encoded = [6,5,4,6]\n输出： [2,4,1,5,3]\n 提示：  3 \u0026lt;= n \u0026lt; 105 n 是奇数。 encoded.length == n - 1  解题思路 消除 有题意可知，只要知道原数组 perm 的一个元素，就可以推导得出整个数组，而原数组的所有元素均已知，所以可以求得所有元素的异或值 1⊕2⊕…⊕n。\n由 encoded[i] = perm[i]⊕[i+1] 且 n为奇数，可以进一步得到 perm[1]⊕perm[2]⊕…⊕perm[n-1] = encoded[1]⊕encoded[3]⊕...⊕encoded[n-2]。\n将上述两个结果异或即可消除除 perm[0] 外的所有值，然后就可以推导 perm 了\nfunc decode(encoded []int) []int { perm := make([]int, 0, len(encoded)+1) tmp := 0 for i := 1; i \u0026lt;= cap(perm); i++ { tmp ^= i } for i := 1; i \u0026lt; len(encoded); i += 2 { tmp ^= encoded[i] } perm = append(perm, tmp) for i := range encoded { perm = append(perm, perm[i]^encoded[i]) } return perm } 复杂度  时间复杂度：O(N) 空间复杂度：O(1)  ","date":"2021-05-11T19:55:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1734.-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97/","title":"Leetcode 1734. 解码异或后的排列"},{"content":"链接： https://leetcode-cn.com/problems/leaf-similar-trees/\n难度： 简单\n题目描述 请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。\n举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。\n如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。\n如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。\n示例1：  输入： root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n输出： true\n 示例2：  输入： root1 = [1], root2 = [1]\n输出： true\n 示例3：  输入： root1 = [1], root2 = [2]\n输出： false\n 示例4：  输入： root1 = [1,2], root2 = [2,2]\n输出： true\n 示例5： \u0026lt;img src=\u0026ldquo;https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg\", width=\u0026ldquo;450px\u0026rdquo;\u0026gt;\n 输入： root1 = [1,2,3], root2 = [1,3,2]\n输出： false\n 提示：  给定的两棵树可能会有 1 到 200 个结点。 给定的两棵树上的值介于 0 到 200 之间。  解题思路 直接求解 分别求出两棵树的叶值序列，然后逐一进行比较即可。\nfunc leafSimilar(root1 *TreeNode, root2 *TreeNode) bool { var dfs func(node *TreeNode, leafs *[]int) dfs = func(node *TreeNode, leafs *[]int) { fmt.Println(node.Val) if node.Left == nil \u0026amp;\u0026amp; node.Right == nil { *leafs = append(*leafs, node.Val) } else { if node.Left != nil { dfs(node.Left, leafs) } if node.Right != nil { dfs(node.Right, leafs) } } } leafs1 := make([]int, 0, 100) dfs(root1, \u0026amp;leafs1) leafs2 := make([]int, 0, 100) dfs(root2, \u0026amp;leafs2) if len(leafs1) != len(leafs2) { return false } for i := range leafs1 { if leafs1[i] != leafs2[i] { return false } } return true } 复杂度  时间复杂度：O(N1+N2) 空间复杂度：O(N1+N2)  ","date":"2021-05-10T23:30:50+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-872.-%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91/","title":"Leetcode 872. 叶子相似的树"},{"content":"链接： https://leetcode-cn.com/problems/xor-operation-in-an-array/\n难度： 简单\n题目描述 给你两个整数，n 和 start 。\n数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。\n请返回 nums 中所有元素按位异或（XOR）后得到的结果。\n示例1：  输入： n = 5, start = 0\n输出： 8\n解释： 数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。\n\u0026ldquo;^\u0026rdquo; 为按位异或 XOR 运算符。\n 示例2：  输入： n = 4, start = 3\n输出： 8\n解释： 数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.\n 示例3：  输入： n = 1, start = 7\n输出： 7\n 示例4：  输入： n = 10, start = 5\n输出： 2\n 提示：  1 \u0026lt;= n \u0026lt;= 1000 0 \u0026lt;= start \u0026lt;= 1000 n == nums.length  解题思路 模拟 按照数组生成方式生成数组，然后依次异或求解，由于每个元素只用依次，所以可以省略掉数组空间\nfunc xorOperation(n int, start int) int { res := 0 for i := 0; i \u0026lt; n; i++ { res ^= start + i\u0026lt;\u0026lt;1 } return res } 复杂度  时间复杂度：O(N) 空间复杂度：O(1)  ","date":"2021-05-07T17:05:42+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1486.-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/","title":"Leetcode 1486. 数组异或操作"},{"content":"链接： https://leetcode-cn.com/problems/decode-xored-array/\n难度： 中等\n题目描述 未知 整数数组 arr 由 n 个非负整数组成。\n经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。\n给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。\n请解码返回原数组 arr 。可以证明答案存在并且是唯一的。\n示例1：  输入： encoded = [1,2,3], first = 1\n输出： [1,0,2,1]\n解释： 若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]\n 示例2：  输入： encoded = [6,2,7,3], first = 4\n输出： [4,2,0,7,4]\n 提示：  2 \u0026lt;= n \u0026lt;= 104 encoded.length == n - 1 0 \u0026lt;= encoded[i] \u0026lt;= 105 0 \u0026lt;= first \u0026lt;= 105  解题思路 数学    a b a⊕b     0 0 0   0 1 1   1 0 1   1 1 0   通过上表可以推出: a = b ⊕ a⊕b，从而得到推导方程：arr[i+1] = arr[i] ⊕ encoded[i]      func decode(encoded []int, first int) []int { res := make([]int, 0, len(encoded)+1) res = append(res, first) for i, e := range encoded { res = append(res, res[i] ^ e) } return res } 复杂度  时间复杂度：O(N) 空间复杂度：O(1)  ","date":"2021-05-06T23:09:07+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1720.-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84/","title":"Leetcode 1720. 解码异或后的数组"},{"content":"链接： https://leetcode-cn.com/problems/delete-and-earn/\n难度： 中等\n题目描述 给你一个整数数组 nums ，你可以对它进行一些操作。\n每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。\n开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。\n示例1：  输入： nums = [3,4,2]\n输出： 6\n解释： 删除 4 获得 4 个点数，因此 3 也被删除。\n之后，删除 2 获得 2 个点数。总共获得 6 个点数。\n 示例2：  输入： nums = [2,2,3,3,3,4]\n输出： 9\n解释： 删除 3 获得 3 个点数，接着要删除两个 2 和 4 。\n之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。\n总共获得 9 个点数。\n 提示：  1 \u0026lt;= nums.length \u0026lt;= 2 * 104 1 \u0026lt;= nums[i] \u0026lt;= 104  解题思路 动态规划 典型的求最优解的问题，考虑用动态规划求解。\n当要删除一个数字 i 时，需将删除所有的 i 全部从数组中删除，记其数量为 cnt, 同时可以获得点数 i * cnt，将删除每个数获得的点数用 map 记录下来。\n用 dp[i] 表示在数组中，当前满足所有的数字均小于时的最大点数，则容易得到转移方程：\n dp[0] = 0, dp[1] = map[i] dp[i] = max(dp[i-1], dp[i-2]+map[i])  执行到整个数组的最大值时为止，得到最大点数。\nfunc deleteAndEarn(nums []int) int { maxNum := 0 cnt := make(map[int]int) for _, num := range nums { cnt[num]++ if maxNum \u0026lt; num { maxNum = num } } dp := make([]int, maxNum+1) dp[1] = cnt[1] for i := 2; i \u0026lt;= maxNum; i++ { dp[i] = dp[i-2] + cnt[i]*i if dp[i] \u0026lt; dp[i-1] { dp[i] = dp[i-1] } } return dp[maxNum] } 复杂度  时间复杂度：O(max(num[i])) 空间复杂度：O(N)  ","date":"2021-05-05T23:47:15+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-740.-%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/","title":"Leetcode 740. 删除并获得点数"},{"content":"链接： https://leetcode-cn.com/problems/reverse-integer/\n难度： 简单\n题目描述 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。\n假设环境不允许存储 64 位整数（有符号或无符号）。\n示例1：  输入： x = 123\n输出： 321\n 示例2：  输入： x = -123\n输出： -321\n 示例3：  输入： x = 120\n输出： 21\n 示例4：  输入： x = 0\n输出： 0\n 提示：  -231 \u0026lt;= x \u0026lt;= 231 - 14  解题思路 双指针 直接数字逐位反转，当数字为十位数时，32位整数无法存储，需要做一次溢位判断：\n可以将数字分为前9位数与第10位数进行比较，不再临界值的范围内，说明溢出。\nfunc reverse(x int) int { res := 0 for i := 0; x != 0 \u0026amp;\u0026amp; i \u0026lt; 9; i++ { res = res*10 + x%10 x /= 10 } if x != 0 { if (x \u0026gt; 0 \u0026amp;\u0026amp; (res \u0026gt; math.MaxInt32/10 || (res == math.MaxInt32/10 \u0026amp;\u0026amp; x \u0026gt; math.MaxInt32%10))) || (x \u0026lt; 0 \u0026amp;\u0026amp; (res \u0026lt; math.MinInt32/10 || (res == math.MinInt32/10 \u0026amp;\u0026amp; x \u0026lt; math.MinInt32%10))) { res = 0 } else { res = res*10 + x } } return res } 复杂度  时间复杂度：O(logB) 空间复杂度：O(1)  ","date":"2021-05-03T11:57:39+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-7.-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","title":"Leetcode 7. 整数反转"},{"content":"链接： https://leetcode-cn.com/problems/brick-wall/\n难度： 中等\n题目描述 你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。\n你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。\n给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。\n示例1： \u0026lt;img src=\u0026ldquo;https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg\", width=\u0026ldquo;493px\u0026rdquo;\u0026gt;\n 输入： wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\n输出： 2\n 示例2：  输入： wall = [[1],[1],[1]]\n输出： 3\n 提示：  n == wall.length 1 \u0026lt;= n \u0026lt;= 104 1 \u0026lt;= wall[i].length \u0026lt;= 104 1 \u0026lt;= sum(wall[i].length) \u0026lt;= 2 * 104 对于每一行 i ，sum(wall[i]) 应当是相同的 1 \u0026lt;= wall[i][j] \u0026lt;= 231 - 1  解题思路 计数 以每一行起点为 0 坐标，可以使得同一列的缝隙唯一标识，从而标记出所有缝隙的列坐标。\n统计每一列的缝隙出现次数，找出出现最多的缝隙，即可求得最小穿过砖块数量。\nfunc leastBricks(wall [][]int) int { gapCnt := make(map[int]int) for _, bricks := range wall { gap := 0 l := len(bricks) - 1 for i := 0; i \u0026lt; l; i++ { gap += bricks[i] gapCnt[gap]++ } } maxGaps := 0 for _, v := range gapCnt { if maxGaps \u0026lt; v { maxGaps = v } } return len(wall) - maxGaps } 复杂度  时间复杂度：O(M*N) 空间复杂度：O(M*N)  ","date":"2021-05-02T10:03:17+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-554.-%E7%A0%96%E5%A2%99/","title":"Leetcode 554. 砖墙"},{"content":"链接： https://leetcode-cn.com/problems/employee-importance/\n难度： 简单\n题目描述 给定一个保存员工信息的数据结构，它包含了员工 唯一的 id ，重要度 和 直系下属的 id 。\n比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在员工 1 的数据结构中。\n现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。\n示例：  输入： [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1\n输出： 11\n解释： 员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。\n 提示：  一个员工最多有一个 直系 领导，但是可以有多个 直系 下属 员工数量不超过 2000  解题思路 深度优先搜素 很容易可以看出整个的员工体系是一个树状结构，故可以采用深度优先搜索的策略，对某一员工及其下属逐一求和。\n为能快速定位到某一个员工，另使用一个 map 维护员工id到员工信息的映射。\nfunc getImportance(employees []*Employee, id int) int { m := make(map[int]*Employee) for _, e := range employees { m[e.Id] = e } var dfs func(id int) int dfs = func(id int) int { e, ok := m[id] if !ok { return 0 } sum := e.Importance for _, s := range e.Subordinates { sum += dfs(s) } return sum } return dfs(id) } 复杂度  时间复杂度：O(N) 空间复杂度：O(N)  ","date":"2021-05-01T21:20:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-690.-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/","title":"Leetcode 690. 员工的重要性"},{"content":"链接： https://leetcode-cn.com/problems/single-number-ii/\n难度： 中等\n题目描述 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。\n示例1：  输入： nums = [2,2,3,2] 输出： 3\n 示例2：  输入： nums = [0,1,0,1,0,1,99] 输出： 99\n 提示：  1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次  **进阶：**你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n解题思路 哈希 统计每个数出现的次数，然后找出其中只出现一次的数\nfunc singleNumber(nums []int) int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ } for k, v := range cnt { if v == 1 { return k } } return 0 } 复杂度  时间复杂度：O(N) 空间复杂度：O(N)  排序 将整个数组排序，没三个一组进行首尾比较，相同继续，不同返回。\nfunc singleNumber(nums []int) int { sort.Ints(nums) res := nums[0] for i := 2; i \u0026lt; len(nums); i += 3 { if res == nums[i] { res = nums[i+1] continue } else { break } } return res } 复杂度  时间复杂度：O(NlogN) 空间复杂度：O(1)  位运算 统计每一位的数字总和，其必然是 0 或者 3n+1，在统计过程中就可以逢3清零，依次求解下去即可。 考虑用两个位 a, b 记录求和数据，表如下所示:\n   cur num next     00 0 00   00 1 01   01 0 01   01 1 10   10 0 10   10 1 00   根据上表可推导出 a 和 b 的变换表：         a b x new_a     0 0 0 0   0 0 1 0   0 1 0 0   0 1 1 1   1 0 0 1   1 0 1 0   得到a的转移方程：      new_a = a'bx + ab'x'          b a x new_b     0 0 0 0   0 0 1 1   0 1 0 0   0 1 1 0   1 0 0 1   1 0 1 0   得到b的转移方程：      new_b = a'b'x + a'bx' = a'(b'x+bx') = a'(b⊕x)       func singleNumber(nums []int) int { a, b := 0, 0 for _, x := range nums { t := ^a\u0026amp;b\u0026amp;x | a\u0026amp;^b\u0026amp;^x b = ^a \u0026amp; (b ^ x) a = t } return b } ","date":"2021-04-30T18:18:49+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-137.-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-ii/","title":"Leetcode 137. 只出现一次的数字 II"},{"content":"链接： https://leetcode-cn.com/problems/frog-jump/\n难度： 困难\n题目描述 一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。\n给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。\n开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。\n如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。\n示例1：  输入： stones = [0,1,3,5,6,8,12,17]\n输出： true\n解释： 青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。\n 示例2：  输入： stones = [0,1,2,3,4,8,9,11]\n输出： false\n解释： 这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。\n 提示：  2 \u0026lt;= stones.length \u0026lt;= 2000 0 \u0026lt;= stones[i] \u0026lt;= 231-1 stones[0] == 0  解题思路 动态规划 从题意可以看出，青蛙每次从某块石头开始起跳，可以降落到一个范围 [k-1 k+1], k 表示上一次的跳跃步长。由于每次跳跃都依赖于前一次跳跃的步长，考虑用动态规划实现。 dp[i] 记录所有可以跳跃到第 i 个石头上面的步长集合，之后就可以根据该集合，向后推导下一跳：\n针对 dp[i] 的每一个步长 step，当 step-1 \u0026lt;= stones[j]-stones[i] \u0026lt;= step+1, (j \u0026gt; i, k∈dp[i]) 时，将步长 stones[j]-stones[i] 添加进 dp[j]\ndp[len-1] 不是空集合，说明能找到，返回 true；否则找不到返回 false\nfunc canCross(stones []int) bool { dp := make([]map[int]bool, len(stones)) dp[0] = map[int]bool{0: true} for i := 0; i \u0026lt; len(stones); i++ { for step := range dp[i] { for j := i + 1; j \u0026lt; len(stones) \u0026amp;\u0026amp; stones[j]-stones[i] \u0026lt;= step+1; j++ { if stones[j]-stones[i] \u0026gt;= step-1 { if dp[j] == nil { dp[j] = make(map[int]bool) } dp[j][stones[j]-stones[i]] = true } } } } if len(dp[len(stones)-1]) != 0 { return true } return false } 复杂度  时间复杂度：O(N2) 空间复杂度：O(N2)  ","date":"2021-04-29T14:21:06+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-403.-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/","title":"Leetcode 403. 青蛙过河"},{"content":"链接： https://leetcode-cn.com/problems/sum-of-square-numbers/\n难度： 中等\n题目描述 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。\n示例1：  输入： c = 5\n输出： true\n解释： 1 * 1 + 2 * 2 = 5\n 示例2：  输入： c = 3\n输出： false\n 示例3：  输入： c = 4\n输出： true\n 示例4：  输入： c = 2\n输出： true\n 示例5：  输入： c = 1 输出： true\n 提示：  0 \u0026lt;= c \u0026lt;= 231 - 1  解题思路 打表 维护一个保存所有平方数的 map，然后从0开始枚举所有可能是 a 的情况，寻找 b = c-a2 是否存在于 map 中\nvar exist = make(map[int]bool) func init() { for i := 0; i*i \u0026lt; math.MaxInt32; i++ { exist[i*i] = true } } func judgeSquareSum(c int) bool { for i := 0; i*i \u0026lt;= c; i++ { if exist[c-i*i] { return true } } return false } 复杂度  时间复杂度：O(√c) 空间复杂度：O(√N)  开方 枚举所有可能是 a 的情况，然后对 b = c-a2 开放，判断开方后的结果是否为整数即可\nfunc judgeSquareSum(c int) bool { for i := 0; i*i \u0026lt;= c; i++ { t := math.Sqrt(float64(c - i*i)) if i*i+int(t)*int(t) == c { return true } } return false } 复杂度  时间复杂度：O(√c) 空间复杂度：O(1)  双指针 用 i, j(i \u0026lt; j) 表示两个指针，向中间遍历，初始 i = 0, j = √c\n 当 i*i + j*j == c 时，返回 true; 当 i*i + j*j \u0026lt; c 时， i++; 当 i*i + j*j \u0026gt; c 时， j--;  直到 i \u0026gt; j 时，依然未能找到 a, b，返回 false\nfunc judgeSquareSum(c int) bool { for i := 0, j := int(); i*i \u0026lt;= c; i++ { t := math.Sqrt(float64(c - i*i)) if i*i+int(t)*int(t) == c { return true } } return false } 复杂度  时间复杂度：O(√c) 空间复杂度：O(1)  ","date":"2021-04-28T22:46:56+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-633.-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/","title":"Leetcode 633. 平方数之和"},{"content":"链接： https://leetcode-cn.com/problems/range-sum-of-bst/\n难度： 简单\n题目描述 给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。\n示例1：  输入： root = [10,5,15,3,7,null,18], low = 7, high = 15\n输出： 32\n 示例2：  输入： root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\n输出： 23\n 提示：  树中节点数目在范围 [1, 2 * 104] 内 1 \u0026lt;= Node.val \u0026lt;= 105 1 \u0026lt;= low \u0026lt;= high \u0026lt;= 105 所有 Node.val 互不相同  解题思路 深度优先搜索 不同于一般搜索树的搜索，该搜索需要遍历整颗树，以累计求和，必要部分需要剪枝加快遍历速度。\n搜索时需要区分三种情况：\n 当前结点值 val \u0026lt; low 时，左子树均不满足条件，继续搜索右子树； 当前结点值 val \u0026gt; high 时，右子树均不满足条件，继续搜索左子树； 其余情况，累加当前结点值，无法剪枝，左右子树都需要继续搜索。  func rangeSumBST(root *TreeNode, low int, high int) int { sum := 0 var search func(node *TreeNode) search = func(node *TreeNode) { if node == nil { return } if node.Val \u0026lt; low { search(node.Right) } else if node.Val \u0026gt; high { search(node.Left) } else { sum += node.Val search(node.Left) search(node.Right) } } search(root) return sum } 复杂度  时间复杂度：O(N) 空间复杂度：O(1)  ","date":"2021-04-27T10:31:11+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-938.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/","title":"Leetcode 938. 二叉搜索树的范围和"},{"content":"链接： https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/\n难度： 中等\n题目描述 传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。\n传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。\n返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。\n示例1：  输入： weights = [1,2,3,4,5,6,7,8,9,10], D = 5\n输出： 15\n解释：\n船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：\n第 1 天：1, 2, 3, 4, 5\n第 2 天：6, 7\n第 3 天：8\n第 4 天：9\n第 5 天：10\n请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。\n 示例2：  输入： weights = [3,2,2,4,1,4], D = 3\n输出： 6\n解释：\n船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：\n第 1 天：3, 2\n第 2 天：2, 4\n第 3 天：1, 4\n 示例3：  输入： weights = [1,2,3,1,1], D = 4\n输出： 3\n解释：\n第 1 天：1\n第 2 天：2\n第 3 天：3\n第 4 天：1, 1\n 提示：  1 \u0026lt;= D \u0026lt;= weights.length \u0026lt;= 50000 1 \u0026lt;= weights[i] \u0026lt;= 500  解题思路 暴力求解 将货物总重量的 平均数 和 最重货物 较大的一个重量作为初始的载重量，逐一向上累加，求得首次符合条件的结果。\nfunc shipWithinDays(weights []int, D int) int { sum := 0 max := 0 for _, weight := range weights { sum += weight if max \u0026lt; weight { max = weight } } minCap := sum / len(weights) if sum%len(weights) != 0 { minCap++ } if minCap \u0026lt; max { minCap = max } for { curCap := minCap // 当前容量 \tcnt := 1 // 第几天 \ti := 0 // 装到第几箱货物 \tfor i \u0026lt; len(weights) \u0026amp;\u0026amp; cnt \u0026lt;= D { // 能装入，继续 \tif curCap \u0026gt;= weights[i] { curCap -= weights[i] i++ continue } // 不能装入，等第二天 \tcnt++ curCap = minCap } // 装完 \tif i == len(weights) { return minCap } minCap++ } } 复杂度  时间复杂度：O(N*∑weight) 空间复杂度：O(1)  二分查找 将 最重货物重量 l 和 货物的总重量 r 作为二分查找的两端起始点，进行二分查找，每次求得完成送达的天数 d。\n 当 d \u0026lt;= D 时，载重量偏大，需要从左半部分 [l,mid] 查找 当 d \u0026gt; D 时，载重量偏小，需要从右半部分 (mid, r] 查找  func shipWithinDays(weights []int, D int) int { r := 0 l := 0 for _, weight := range weights { r += weight if l \u0026lt; weight { l = weight } } var binarySearch func(l, r int) int binarySearch = func(l, r int) int { if l == r { return l } mid := (l + r) / 2 cnt := 1 curCap := mid for i := 0; i \u0026lt; len(weights); { // 能装入，继续 \tif curCap \u0026gt;= weights[i] { curCap -= weights[i] i++ continue } // 不能装入，等第二天 \tcnt++ curCap = mid } if cnt \u0026lt;= D { return binarySearch(l, mid) } else { return binarySearch(mid+1, r) } } return binarySearch(l, r) } 复杂度  时间复杂度：O(N*log(∑weight)) 空间复杂度：O(1)  ","date":"2021-04-26T11:10:26+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1011.-%E5%9C%A8-d-%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/","title":"Leetcode 1011. 在 D 天内送达包裹的能力"},{"content":"链接： https://leetcode-cn.com/problems/increasing-order-search-tree/\n难度： 简单\n题目描述 给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。\n示例1：  输入： root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\n输出： [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n 示例2：  输入： root = [5,1,7]\n输出： [1,null,5,null,7]\n 提示：  树中节点数的取值范围是 [1, 100] 0 \u0026lt;= Node.val \u0026lt;= 1000  解题思路 新建树 重新构造一棵树，中序遍历原树的每个结点，将其加入到新树的右结点中。\nfunc increasingBST(root *TreeNode) *TreeNode { newRoot := new(TreeNode) newNode := newRoot var InorderTraversal func(node *TreeNode) InorderTraversal = func(node *TreeNode) { if node == nil { return } InorderTraversal(node.Left) newNode.Right = \u0026amp;TreeNode{ Val: node.Val, Left: nil, Right: nil, } newNode = newNode.Right InorderTraversal(node.Right) } InorderTraversal(root) newRoot = newRoot.Right return newRoot } 复杂度  时间复杂度：O(N) 空间复杂度：O(N)  就地改指针 维护一个叶结点指针，中序遍历整棵树，每当遇到一个新结点时，该结点 left 置为空，叶结点 right 修改为该结点，叶结点修正为该结点。\nfunc increasingBST(root *TreeNode) *TreeNode { newRoot := new(TreeNode) newLeaf := newRoot var LDR func(node *TreeNode) LDR = func(node *TreeNode) { if node == nil { return } LDR(node.Left) newLeaf.Right = node newLeaf = newLeaf.Right node.Left = nil LDR(node.Right) } LDR(root) newRoot = newRoot.Right return newRoot } 复杂度  时间复杂度：O(N) 空间复杂度：O(1)  ","date":"2021-04-25T11:41:33+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-897.-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E6%A0%91/","title":"Leetcode 897. 递增顺序搜索树"},{"content":"链接： https://leetcode-cn.com/problems/combination-sum-iv/ 难度： 中等\n题目描述 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。\n题目数据保证答案符合 32 位整数范围。\n示例1：  输入： nums = [1,2,3], target = 4\n输出： 7\n解释：\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n请注意，顺序不同的序列被视作不同的组合。\n 示例2：  输入： nums = [9], target = 3\n输出： 0\n 提示：  1 \u0026lt;= nums.length \u0026lt;= 200 1 \u0026lt;= nums[i] \u0026lt;= 1000 nums 中的所有元素 互不相同 1 \u0026lt;= target \u0026lt;= 1000  解题思路 动态规划 用 dp[i] 表示当 i 作为 target 时，排列方案的数量。当 dp[i] 不为 0 时，不妨假设排列的做后一位数字为 num，则 i-num 的排列数为 dp[i-num] ，容易得知状态转移方程：\n 当 i = 0 时，dp[i] = 1，表示没有元素被选中； 当 0 \u0026lt; i \u0026lt;= target 时，dp[i] = ∑dp[i-num],(num \u0026lt;= i)。  func combinationSum4(nums []int, target int) int { dp := make([]int, target+1) dp[0] = 1 for i := 1; i \u0026lt;= target; i++ { for _, num := range nums { if num \u0026lt;= i { dp[i] += dp[i-num] } } } return dp[target] } 复杂度  时间复杂度：O(N*T) 空间复杂度：O(1)  ","date":"2021-04-24T21:50:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-377.-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/","title":"Leetcode 377. 组合总和 Ⅳ"},{"content":"链接： https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/\n难度： 困难\n题目描述 给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。\n题目数据保证总会存在一个数值和不超过 k 的矩形区域。\n示例1：  输入： matrix = [[1,0,1],[0,-2,3]], k = 2\n输出： 2\n解释： 蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。\n 示例2：  输入： matrix = [[2,2,-1]], k = 3\n输出： 3\n 提示：  m == matrix.length n == matrix[i].length -100 \u0026lt;= matrix[i][j] \u0026lt;= 100 -105 \u0026lt;= k \u0026lt;= 105  解题思路 暴力求解 以每个元素为起点，求解\nfunc compareVersion(version1 string, version2 string) int { num1 := strings.Split(version1, \u0026#34;.\u0026#34;) num2 := strings.Split(version2, \u0026#34;.\u0026#34;) for i := 0; i \u0026lt; len(num1) || i \u0026lt; len(num2); i++ { var p, q int64 if i \u0026lt; len(num1) { p, _ = strconv.ParseInt(num1[i], 10, 64) } if i \u0026lt; len(num2) { q, _ = strconv.ParseInt(num2[i], 10, 64) } if p \u0026gt; q { return 1 } else if p \u0026lt; q { return -1 } } return 0 } 复杂度  时间复杂度：O(N+N+max(N, M)) 空间复杂度：O(N+M)  双指针 指针 i , j 分别指向 version1 和 version2 , 每次分别从两个版本号中获取一个有效数字进行比较：\n i 指向的数字大，返回 1； j 指向的数字大，返回 -1； 两个数字相同，继续向后遍历。  遍历结束，仍未比较得出大小，说明两个版本号相同，返回 0\nfunc compareVersion(version1 string, version2 string) int { num1, num2 := 0, 0 for i, j := 0, 0; i \u0026lt; len(version1) || j \u0026lt; len(version2); { for ; i \u0026lt; len(version1) \u0026amp;\u0026amp; version1[i] != \u0026#39;.\u0026#39;; i++ { num1 = num1*10 + int(version1[i]-\u0026#39;0\u0026#39;) } for ; j \u0026lt; len(version2) \u0026amp;\u0026amp; version2[j] != \u0026#39;.\u0026#39;; j++ { num2 = num2*10 + int(version2[j]-\u0026#39;0\u0026#39;) } fmt.Println(num1, num2, i, j) if num1 \u0026gt; num2 { return 1 } else if num1 \u0026lt; num2 { return -1 } else { i++ j++ num1, num2 = 0, 0 } } return 0 } 复杂度  时间复杂度：O(N+M) 空间复杂度：O(1)  ","date":"2021-04-22T10:41:53+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-363.-%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87-k-%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC%E5%92%8C/","title":"Leetcode 363. 矩形区域不超过 K 的最大数值和"},{"content":"链接： https://leetcode-cn.com/problems/decode-ways/\n难度： 中等\n题目描述 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：\n'A' -\u0026gt; 1 'B' -\u0026gt; 2 ... 'Z' -\u0026gt; 26 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，\u0026quot;11106\u0026quot; 可以映射为：\n \u0026quot;AAJF\u0026quot; ，将消息分组为 (1 1 10 6) \u0026quot;KJF\u0026quot; ，将消息分组为 (11 10 6)  注意，消息不能分组为 (1 11 06) ，因为 \u0026quot;06\u0026quot; 不能映射为 \u0026quot;F\u0026quot; ，这是由于 \u0026quot;6\u0026quot; 和 \u0026quot;06\u0026quot; 在映射中并不等价。\n给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。\n题目数据保证答案肯定是一个 32 位 的整数。\n示例1：  输入： s = \u0026ldquo;12\u0026rdquo;\n输出： 2\n解释： 它可以解码为 \u0026ldquo;AB\u0026rdquo;（1 2）或者 \u0026ldquo;L\u0026rdquo;（12）。\n 示例2：  输入： s = \u0026ldquo;226\u0026rdquo;\n输出： 3\n解释： 它可以解码为 \u0026ldquo;BZ\u0026rdquo; (2 26), \u0026ldquo;VF\u0026rdquo; (22 6), 或者 \u0026ldquo;BBF\u0026rdquo; (2 2 6) 。\n 示例3：  输入： s = \u0026ldquo;0\u0026rdquo;\n输出： 0\n解释： 没有字符映射到以 0 开头的数字。\n含有 0 的有效映射是 \u0026lsquo;J\u0026rsquo; -\u0026gt; \u0026ldquo;10\u0026rdquo; 和 \u0026lsquo;T\u0026rsquo;-\u0026gt; \u0026ldquo;20\u0026rdquo; 。\n由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。\n 示例4:  输入： s = \u0026ldquo;06\u0026rdquo;\n输出： 0\n解释： \u0026ldquo;06\u0026rdquo; 不能映射到 \u0026ldquo;F\u0026rdquo; ，因为字符串含有前导 0（\u0026ldquo;6\u0026rdquo; 和 \u0026ldquo;06\u0026rdquo; 在映射中并不等价）。\n 提示：  1 \u0026lt;= s.length \u0026lt;= 100 s 只包含数字，并且可能包含前导零。  解题思路 动态规划 使用数组 dp 保存解码的总数， dp[i] 表示截止到长度为 i 的字串可以解码的总数，转移时有两种情况需要考虑：\n 第一种情况，对 s[i] 进行解码，要求 s[i] != 0 第二种情况，对 s[i-1]s[i] 解码, 要求 \u0026quot;00\u0026quot; \u0026lt; s[i-1]s[i] \u0026lt;= \u0026quot;26  然后就可以推导出状态转移方程：\n 初始时，dp[0] = 0, 表示空字符串有一种解法 - 空串 仅满足情况一， dp[i+1] = dp[i] 经满足情况二， dp[i+1] = dp[i-1] 同时满足情况一和二， dp[i+1] = dp[i] + dp[i-1] 情况一和二均不满足，说明该字符串不能解码  求解到 s 尾，即可求解得所有解码总数 dp[len(s)]。\nfunc numDecodings(s string) int { dp := make([]int, len(s)+1) dp[0] = 1 for i := 0; i \u0026lt; len(s); i++ { exist := false // 标记是否可以解码 \t// 情况一 \tif s[i] \u0026gt; \u0026#39;0\u0026#39; { dp[i+1] += dp[i] exist = true } // 情况二 \tif i \u0026gt; 0 \u0026amp;\u0026amp; s[i-1] != \u0026#39;0\u0026#39; { num := 10*int(s[i-1]-\u0026#39;0\u0026#39;) + int(s[i]-\u0026#39;0\u0026#39;) if num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt;= 26 { dp[i+1] += dp[i-1] exist = true } } if !exist { break } } return dp[len(s)] } 优化 每次迭代只涉及到三个变量，故可以用三个变量代替数组，进一步降低空间复杂度\nfunc numDecodings(s string) int { dp := []int{0, 1, 0} for i := 0; i \u0026lt; len(s); i++ { exist := false // 标记是否可以解码 \tdp[2] = 0 // 情况一 \tif s[i] \u0026gt; \u0026#39;0\u0026#39; { dp[2] += dp[1] exist = true } // 情况二 \tif i \u0026gt; 0 \u0026amp;\u0026amp; s[i-1] != \u0026#39;0\u0026#39; { num := 10*int(s[i-1]-\u0026#39;0\u0026#39;) + int(s[i]-\u0026#39;0\u0026#39;) if num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt;= 26 { dp[2] += dp[0] exist = true } } if !exist { break } dp[0], dp[1] = dp[1], dp[2] } return dp[2] } 复杂度  时间复杂度：O(N) 空间复杂度：优化前：O(N)，优化后O(1)  ","date":"2021-04-21T10:35:45+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-91.-%E8%A7%A3%E7%A0%81%E6%96%B9%E5%BC%8F/","title":"Leetcode 91. 解码方式"},{"content":"链接： https://leetcode-cn.com/problems/compare-version-numbers/\n难度： 中等\n题目描述 给你两个版本号 version1 和 version2 ，请你比较它们。\n版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。\n比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 \u0026lt; 1 。\n返回规则如下：\n 如果 version1 \u0026gt; version2 返回 1， 如果 version1 \u0026lt; version2 返回 -1， 除此之外返回 0。  示例1：  输入： version1 = \u0026ldquo;1.01\u0026rdquo;, version2 = \u0026ldquo;1.001\u0026rdquo;\n输出： 0\n解释： 忽略前导零，\u0026ldquo;01\u0026rdquo; 和 \u0026ldquo;001\u0026rdquo; 都表示相同的整数 \u0026ldquo;1\u0026rdquo;\n 示例2：  输入： version1 = \u0026ldquo;1.0\u0026rdquo;, version2 = \u0026ldquo;1.0.0\u0026rdquo;\n输出： 0\n解释： version1 没有指定下标为 2 的修订号，即视为 \u0026ldquo;0\u0026rdquo;\n 示例3：  输入： version1 = \u0026ldquo;0.1\u0026rdquo;, version2 = \u0026ldquo;1.1\u0026rdquo;\n输出： -1\n解释： version1 中下标为 0 的修订号是 \u0026ldquo;0\u0026rdquo;，version2 中下标为 0 的修订号是 \u0026ldquo;1\u0026rdquo; 。0 \u0026lt; 1，所以 version1 \u0026lt; version2\n 示例4：  输入： version1 = \u0026ldquo;1.0.1\u0026rdquo;, version2 = \u0026ldquo;1\u0026rdquo;\n输出： 1\n 示例5：  输入： version1 = \u0026ldquo;7.5.2.4\u0026rdquo;, version2 = \u0026ldquo;7.5.3\u0026rdquo;\n输出： -1\n 提示：  1 \u0026lt;= version1.length, version2.length \u0026lt;= 500 version1 和 version2 仅包含数字和 '.' version1 和 version2 都是 有效版本号 version1 和 version2 的所有修订号都可以存储在 32 位整数 中  解题思路 分割 将两个版本号以 '.' 为分割符进行分割，之后注意比较各个部分，较短的版本号，后续缺失的部分用 0 进行代替。\nfunc compareVersion(version1 string, version2 string) int { num1 := strings.Split(version1, \u0026#34;.\u0026#34;) num2 := strings.Split(version2, \u0026#34;.\u0026#34;) for i := 0; i \u0026lt; len(num1) || i \u0026lt; len(num2); i++ { var p, q int64 if i \u0026lt; len(num1) { p, _ = strconv.ParseInt(num1[i], 10, 64) } if i \u0026lt; len(num2) { q, _ = strconv.ParseInt(num2[i], 10, 64) } if p \u0026gt; q { return 1 } else if p \u0026lt; q { return -1 } } return 0 } 复杂度  时间复杂度：$ O(N+M), N = len(version1), M = len(version2) $ 空间复杂度：$ O(N+M) $  双指针 指针 i , j 分别指向 version1 和 version2 , 每次分别从两个版本号中获取一个有效数字进行比较：\n i 指向的数字大，返回 1； j 指向的数字大，返回 -1； 两个数字相同，继续向后遍历。  遍历结束，仍未比较得出大小，说明两个版本号相同，返回 0\nfunc compareVersion(version1 string, version2 string) int { num1, num2 := 0, 0 for i, j := 0, 0; i \u0026lt; len(version1) || j \u0026lt; len(version2); { for ; i \u0026lt; len(version1) \u0026amp;\u0026amp; version1[i] != \u0026#39;.\u0026#39;; i++ { num1 = num1*10 + int(version1[i]-\u0026#39;0\u0026#39;) } for ; j \u0026lt; len(version2) \u0026amp;\u0026amp; version2[j] != \u0026#39;.\u0026#39;; j++ { num2 = num2*10 + int(version2[j]-\u0026#39;0\u0026#39;) } if num1 \u0026gt; num2 { return 1 } else if num1 \u0026lt; num2 { return -1 } else { i++ j++ num1, num2 = 0, 0 } } return 0 } 复杂度  时间复杂度：$ O(N+M), N = len(version1), M = len(version2) $ 空间复杂度：$ O(1) $  ","date":"2021-04-20T20:33:19+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-165.-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/","title":"Leetcode 165. 比较版本号"},{"content":"链接： https://leetcode-cn.com/problems/implement-strstr/\n难度： 简单\n题目描述 实现 strStr() 函数。\n给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。\n说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。\n示例1：  输入： haystack = \u0026ldquo;hello\u0026rdquo;, needle = \u0026ldquo;ll\u0026rdquo;\n输出： 2\n 示例2：  输入： haystack = \u0026ldquo;aaaaa\u0026rdquo;, needle = \u0026ldquo;bba\u0026rdquo;\n输出： -1\n 示例3：  输入： haystack = \u0026ldquo;\u0026rdquo;, needle = \u0026quot;\u0026quot;\n输出： 0\n 提示：  0 \u0026lt;= haystack.length, needle.length \u0026lt;= 5 * 104 haystack 和 needle 仅由小写英文字符组成  解题思路 暴力匹配 从 haystack 的每个字符开始，依次向后和 needle 中的字符逐个匹配：\n 匹配成功，继续向后匹配； 匹配失败，从 haystack 的下个字符重新进行匹配； 匹配到 needle 结束，说明完成了查找，返回 haystack 初始匹配的下标。  遍历结束，都未完成匹配，表示无法找到，返回 -1\nfunc strStr(haystack string, needle string) int { maxIdx := len(haystack) - len(needle) + 1 for i := 0; i \u0026lt; maxIdx; i++ { j := 0 for ; j \u0026lt; len(needle); j++ { if haystack[i+j] != needle[j] { break } } if j == len(needle) { return i } } return -1 } 复杂度  时间复杂度：O(N*M) 空间复杂度：O(1)  KMP算法 func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } // 求解next数组 \tnext := make([]int, len(needle)) next[0] = -1 i, j := -1, 0 for j+1 \u0026lt; len(needle) { if i == -1 || needle[i] == needle[j] { i++ j++ if needle[i] == needle[j] { next[j] = next[i] } else { next[j] = i } } else { i = next[i] } } // 匹配 \ti, j = 0, 0 for i \u0026lt; len(haystack) \u0026amp;\u0026amp; j \u0026lt; len(needle) { if j == -1 || haystack[i] == needle[j] { i++ j++ } else { j = next[j] } } if j == len(needle) { return i - j } return -1 } 复杂度  时间复杂度：O(N+M) 空间复杂度：O(1)  ","date":"2021-04-20T17:21:05+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-28.-%E5%AE%9E%E7%8E%B0-strstr/","title":"Leetcode 28. 实现 strStr()"},{"content":"链接： https://leetcode-cn.com/problems/remove-element/\n难度： 简单\n题目描述 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n说明： 为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 示例1：  输入： nums = [3,2,2,3], val = 3\n输出： 2, nums = [2,2]\n解释： 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n 示例2：  输入： nums = [0,1,2,2,3,0,4,2], val = 2\n输出： 5, nums = [0,1,4,0,3]\n解释： 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n 提示：  0 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 100  解题思路 双指针 用两个指针分别指向 待返回的结果数组 和 待遍历的原数组 第一个指针 i 表示当前已删除 val 的结果数组的下一个可赋值的位置，也即结果数组的长度；第二个指针 j 表示当前遍历到的元素下标。\n 当 nums[i] == val 时，继续向后遍历； 当 nums[j] != val 时，表示该数毋需删除，将其加入到结果数组，遍历下一个元素。  遍历结束，返回数组长度 i\nfunc removeElement(nums []int, val int) int { i := 0 for j := 0; j \u0026lt; len(nums); j++ { if nums[j] != val { nums[i] = nums[j] i++ } } return i } 复杂度  时间复杂度：O(N) 空间复杂度：O(1)  ","date":"2021-04-19T10:34:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-27.-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/","title":"Leetcode 27. 移除元素"},{"content":"链接： https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\n难度： 简单\n题目描述 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n说明： 为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 示例1：  输入： nums = [1,1,2]\n输出： 2, nums = [1,2]\n解释： 函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n 示例2：  输入： nums = [0,0,1,1,1,2,2,3,3,4]\n输出： 5, nums = [0,1,2,3,4]\n解释： 函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n 提示：  0 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 已按升序排列  解题思路 双指针 由于整个数组已经过排序，排在某个数之前的数不会在其后重复出现，所以可以简单的用双指针实现。\n第一个指针 i 表示当前不重复的数组最后一个数的下标，第二个指针 j 表示当前遍历到的元素下标。\n 当 nums[i] == nums[j] 时，表示该数已加入结果中，继续向后遍历； 当 nums[i] != nums[j] 时，表示该数是一个新的不重复数，将其填入 nums[i+1] 中，i指针向后移动一位。  遍历结束，返回数组长度 i+1\nfunc removeDuplicates(nums []int) int { i := 0 for j := 1; j \u0026lt; len(nums); j++ { if nums[i] != nums[j] { i++ nums[i] = nums[j] } } return i + 1 } 复杂度  时间复杂度：O(N) 空间复杂度：O(1)  ","date":"2021-04-18T10:52:18+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-26.-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","title":"Leetcode 26. 删除有序数组中的重复项"},{"content":"链接： https://leetcode-cn.com/problems/contains-duplicate-iii/\n难度： 中等\n题目描述 给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) \u0026lt;= t ，同时又满足 abs(i - j) \u0026lt;= k 。\n如果存在则返回 true，不存在返回 false。\n示例：  输入： nums = [1,2,3,1], k = 3, t = 0\n输出： true\n 示例：  输入： nums = [1,0,1,1], k = 1, t = 2\n输出： true\n 示例：  输入： nums = [1,5,9,1,5,9], k = 2, t = 3\n输出： false\n 提示：  0 \u0026lt;= nums.length \u0026lt;= 2 * 104 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 0 \u0026lt;= k \u0026lt;= 104 0 \u0026lt;= t \u0026lt;= 231 - 1  解题思路 暴力求解 枚举所有差不大于 k 的下标 i 和 j，逐一判断是否符合条件\nfunc abs(x int) int { if x \u0026lt; 0 { return -x } return x } func containsNearbyAlmostDuplicate(nums []int, k int, t int) bool { for i := range nums { for j := i + 1; j \u0026lt;= i+k \u0026amp;\u0026amp; j \u0026lt; len(nums); j++ { if j \u0026gt;= len(nums) { break } if abs(nums[j]-nums[i]) \u0026lt;= t { return true } } } return false } 复杂度  时间复杂度：O(N*k) 空间复杂度：O(1)  滑动窗口 在解法暴力求解的基础上，对于相邻的两个下标，符合要求的下标范围中有 k-1 个是重复出现的，可以利用这些已知信息，构造一个滑动窗口，来进一步降低时间复杂度。\n对于下标 i，其前面的符合条件的下标为 i-t、\u0026hellip;、i-1(i-t \u0026gt;= 0)，每次只需要判断其中的最大值是否满足条件，当不满足条件时，将 nums[i] 加入，排除掉下标 nums[i-t-1]的值。\n要满足上述条件，就要求添加、查找和删除一个元素的时间复杂度均 \u0026lt; O(k)，满足该条件的数据结构是平衡树。\n时间复杂度：O(N*logk) 空间复杂度：O(k) func containsNearbyAlmostDuplicate(nums []int, k int, t int) bool { sort.I for i := range nums { for j := i + 1; j \u0026lt; len(nums); j++ { if j-i \u0026lt;= k \u0026amp;\u0026amp; abs(nums[j]-nums[i]) \u0026lt;= t { return true } } } return false } ","date":"2021-04-17T20:58:46+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-220.-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-iii/","title":"Leetcode 220. 存在重复元素 III"}]