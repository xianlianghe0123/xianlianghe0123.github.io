[{"content":"链接： https://leetcode.cn/problems/merge-strings-alternately/\n难度： 简单\n题目描述 给你两个字符串 word1 和 word2 。请你从 word1 开始，通过交替添加字母来合并字符串。如果一个字符串比另一个字符串长，就将多出来的字母追加到合并后字符串的末尾。\n返回 合并后的字符串 。\n示例 1： 输入： word1 = \u0026ldquo;abc\u0026rdquo;, word2 = \u0026ldquo;pqr\u0026rdquo;\n输出： \u0026ldquo;apbqcr\u0026rdquo;\n解释： 字符串合并情况如下所示：\nword1： a b c\nword2： p q r\n合并后： a p b q c r\n示例 2： 输入： word1 = \u0026ldquo;ab\u0026rdquo;, word2 = \u0026ldquo;pqrs\u0026rdquo;\n输出： \u0026ldquo;apbqrs\u0026rdquo;\n解释： 注意，word2 比 word1 长，\u0026ldquo;rs\u0026rdquo; 需要追加到合并后字符串的末尾。\nword1： a b\nword2： p q r s\n合并后： a p b q r s\n示例 3： 输入： word1 = \u0026ldquo;abcd\u0026rdquo;, word2 = \u0026ldquo;pq\u0026rdquo;\n输出： \u0026ldquo;apbqcd\u0026rdquo;\n解释： 注意，word1 比 word2 长，\u0026ldquo;cd\u0026rdquo; 需要追加到合并后字符串的末尾。\nword1： a b c d word2： p q 合并后： a p b q c d\n提示： 1 \u0026lt;= word1.length, word2.length \u0026lt;= 100 word1 和 word2 由小写英文字母组成 解题思路 模拟 依次从 word1，word2 中交替取出字符，直到任意一个字符串中的字符全部取出为止。\n之后将剩余字符添加到尾部。\nfunc mergeAlternately(word1 string, word2 string) string { minLength := len(word1) if minLength \u0026gt; len(word2) { minLength = len(word2) } ans := make([]byte, 0, len(word1)+len(word2)) for i := 0; i \u0026lt; minLength; i++ { ans = append(ans, word1[i], word2[i]) } ans = append(ans, word1[minLength:]...) ans = append(ans, word2[minLength:]...) return string(ans) } 复杂度 时间复杂度：$ O(M+N), M = len(word1), N = len(word2) $ 空间复杂度：$ O(1) ","date":"2022-10-23T11:34:46+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1768.-%E4%BA%A4%E6%9B%BF%E5%90%88%E5%B9%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 1768. 交替合并字符串"},{"content":"链接： https://leetcode.cn/problems/maximum-profit-in-job-scheduling/\n难度： 困难\n题目描述 你打算利用空闲时间来做兼职工作赚些零花钱。\n这里有 n 份兼职工作，每份工作预计从 startTime[i] 开始到 endTime[i] 结束，报酬为 profit[i]。\n给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。\n注意，时间上出现重叠的 2 份工作不能同时进行。\n如果你选择的工作在时间 X 结束，那么你可以立刻进行在时间 X 开始的下一份工作。\n示例 1： 输入： startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]\n输出： 120\n解释：\n我们选出第 1 份和第 4 份工作，\n时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。\n示例 2： 输入： startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]\n输出： 150\n解释：\n我们选择第 1，4，5 份工作。\n共获得报酬 150 = 20 + 70 + 60。\n示例 3： 输入： startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]\n输出： 6\n提示： 1 \u0026lt;= startTime.length == endTime.length == profit.length \u0026lt;= 5 * 104 1 \u0026lt;= startTime[i] \u0026lt; endTime[i] \u0026lt;= 109 1 \u0026lt;= profit[i] \u0026lt;= 104 解题思路 动态规划 + 二分查找 对于其中的某项工作 i，若能得知在其开始时间 startTime[i] 之前的最大利润，则可以得到选择这份工作之后的最大利润。可以利用动态规划求解。\n首先将所用工作按照结束时间排序，这样可以保证在求解过程中，先结束的工作会优先被计算。\n使用 dp[i+1] 表示到达第 i 份工作截止时间后可以获得的最大利润，其有做与不做两种情况，在下述两种情况最大值：\n当选择做该工作时，需要找到 ≤ startTime[i]（不妨设为k，二分查找）的最大利润 dp[k]，加上当前 profit[i]； 当不做该工作时，即寻找到 endTime[i] 之前的最大利润，由于已经排序，则为 dp[i]。 根据上述分析，得到状态转移转移方程：\n初始化，dp[0] = 0； dp[i+1] = max(dp[i], dp[k] + profit[i])。 最终的最大利润为 dp[n+1]。\nfunc jobScheduling(startTime []int, endTime []int, profit []int) int { jobs := make([][]int, 0, len(startTime)) for i := range startTime { jobs = append(jobs, []int{startTime[i], endTime[i], profit[i]}) } sort.Slice(jobs, func(i, j int) bool { return jobs[i][1] \u0026lt; jobs[j][1] }) dp := make([]int, len(startTime)+1) for i := range jobs { // 二分查找，当前工作开始时间之前最晚结束的工作 k := sort.Search(i, func(j int) bool { return jobs[j][1] \u0026gt; jobs[i][0] }) dp[i+1] = dp[i] if t := dp[k] + jobs[i][2]; dp[i+1] \u0026lt; t { dp[i+1] = t } } return dp[len(startTime)] } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(startTime) = len(endTime) = len(profit) $ 空间复杂度：$ O(N) $ ","date":"2022-10-22T11:44:50+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1235.-%E8%A7%84%E5%88%92%E5%85%BC%E8%81%8C%E5%B7%A5%E4%BD%9C/","title":"Leetcode 1235. 规划兼职工作"},{"content":"链接： https://leetcode.cn/problems/online-stock-span/\n难度： 中等\n题目描述 编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。\n今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。\n例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。\n示例： 输入： [\u0026ldquo;StockSpanner\u0026rdquo;,\u0026ldquo;next\u0026rdquo;,\u0026ldquo;next\u0026rdquo;,\u0026ldquo;next\u0026rdquo;,\u0026ldquo;next\u0026rdquo;,\u0026ldquo;next\u0026rdquo;,\u0026ldquo;next\u0026rdquo;,\u0026ldquo;next\u0026rdquo;], [[],[100],[80],[60],[70],[60],[75],[85]]\n输出： [null,1,1,1,2,1,4,6]\n解释：\n首先，初始化 S = StockSpanner()，然后：\nS.next(100) 被调用并返回 1，\nS.next(80) 被调用并返回 1，\nS.next(60) 被调用并返回 1，\nS.next(70) 被调用并返回 2，\nS.next(60) 被调用并返回 1，\nS.next(75) 被调用并返回 4，\nS.next(85) 被调用并返回 6。\n注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格\n(包括今天的价格 75) 小于或等于今天的价格。\n提示： 调用 StockSpanner.next(int price) 时，将有 1 \u0026lt;= price \u0026lt;= 105。 每个测试用例最多可以调用 10000 次 StockSpanner.next。 在所有测试用例中，最多调用 150000 次 StockSpanner.next。 此问题的总时间限制减少了 50%。 解题思路 单调栈 从某一天开始，股票的 跨度 唯一受限于 在其之前最近的大于该价格的那一天，在其后的所有天数，都在跨度内。\n所以，当出现新的 极大值 时，在此之前小于该极值的波谷处，不会对后续跨度造成影响，采用单调栈求解。\n单调栈维护价格的递减序列，同时保存对应哪一天。当计算每一个跨度时，如下：\n对比栈顶股票价格与当天价格 price ，若 ≤ price 则不断弹出，直到栈空或栈顶股票价格 \u0026gt; price； 栈空，则从第一开始即在跨度内 栈不空，则从下一天开始在跨度内 求得跨度，并将当天股票价格入栈； type StockSpanner struct { stack [][]int counter int } func Constructor() StockSpanner { return StockSpanner{ stack: make([][]int, 0), counter: 0, } } func (this *StockSpanner) Next(price int) int { idx := -1 for len(this.stack) != 0 { top := this.stack[len(this.stack)-1] if top[1] \u0026gt; price { idx = top[0] break } this.stack = this.stack[:len(this.stack)-1] } this.stack = append(this.stack, []int{this.counter, price}) this.counter++ return this.counter - 1 - idx } 复杂度 时间复杂度： Constructor: $ O(1) $ Next: $ O(1) $ 空间复杂度：$ O(N) $ ","date":"2022-10-21T10:14:05+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-901.-%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6/","title":"Leetcode 901. 股票价格跨度"},{"content":"链接： https://leetcode.cn/problems/k-th-symbol-in-grammar/\n难度： 中等\n题目描述 我们构建了一个包含 n 行( 索引从 1 开始 )的表。首先在第一行我们写上一个 0。接下来的每一行，将前一行中的 0 替换为 01，1 替换为 10。\n例如，对于 n = 3 ，第 1 行是 0 ，第 2 行是 01 ，第3行是 0110 。 给定行数 n 和序数 k，返回第 n 行中第 k 个字符。（ k 从索引 1 开始）\n示例 1： 输入: n = 1, k = 1\n输出: 0\n解释: 第一行：0\n输入： n = 2, k = 1\n输出： 0\n解释：\n第一行: 0\n第二行: 01\n示例 3： 输入： n = 2, k = 2\n输出： 1\n解释：\n第一行: 0\n第二行: 01\n提示： 1 \u0026lt;= n \u0026lt;= 30 1 \u0026lt;= k \u0026lt;= 2n - 1 解题思路 递归 每次进行替换后，长度变为上一行的两倍，对应的当前行下标位置为 i 的元素，来源于上一行下标位置 (i+1)/2。\n若得到上一行对应来源处的元素值，则可根据 i 的奇偶性求解。\n递归求解上一行，初始时，即 n = 1 时，元素为 0。\nfunc kthGrammar(n int, k int) int { if n == 1 { return 0 } src := kthGrammar(n-1, (k+1)/2) if k\u0026amp;1 == 1 { return src } return src ^ 1 } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(n) $ ","date":"2022-10-20T10:20:32+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-779.-%E7%AC%ACk%E4%B8%AA%E8%AF%AD%E6%B3%95%E7%AC%A6%E5%8F%B7/","title":"Leetcode 779. 第K个语法符号"},{"content":"链接： https://leetcode.cn/problems/reformat-phone-number/\n难度： 简单\n题目描述 学校的自助午餐提供圆形和方形的三明治，分别用数字 0 和 1 表示。所有学生站在一个队列里，每个学生要么喜欢圆形的要么喜欢方形的。 餐厅里三明治的数量与学生的数量相同。所有三明治都放在一个 栈 里，每一轮：\n如果队列最前面的学生 喜欢 栈顶的三明治，那么会 拿走它 并离开队列。 否则，这名学生会 放弃这个三明治 并回到队列的尾部。 这个过程会一直持续到队列里所有学生都不喜欢栈顶的三明治为止。\n给你两个整数数组 students 和 sandwiches ，其中 sandwiches[i] 是栈里面第 i​​​​​​ 个三明治的类型（i = 0 是栈的顶部）， students[j] 是初始队列里第 j​​​​​​ 名学生对三明治的喜好（j = 0 是队列的最开始位置）。请你返回无法吃午餐的学生数量。\n示例 1： 输入： students = [1,1,0,0], sandwiches = [0,1,0,1]\n输出： 0\n解释：\n最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,0,0,1]。 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,0,1,1]。 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [0,1,1]，三明治栈为 sandwiches = [1,0,1]。 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [1,1,0]。 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1,0]，三明治栈为 sandwiches = [0,1]。 最前面的学生放弃最顶上的三明治，并回到队列的末尾，学生队列变为 students = [0,1]。 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = [1]，三明治栈为 sandwiches = [1]。 最前面的学生拿走最顶上的三明治，剩余学生队列为 students = []，三明治栈为 sandwiches = []。\n所以所有学生都有三明治吃。 示例 2： 输入： students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1]\n输出： 3\n提示： 1 \u0026lt;= students.length, sandwiches.length \u0026lt;= 100 students.length == sandwiches.length sandwiches[i] 要么是 0 ，要么是 1 。 students[i] 要么是 0 ，要么是 1 。 解题思路 模拟 模拟用餐过程，直到所有学生全部取完三明治或者剩余学生全部不能取。\n故只需要统计喜欢每种三明治学生的数量，然后依次递减即可。\nfunc countStudents(students []int, sandwiches []int) int { square := 0 for _, s := range students { square += s } circle := len(students) - square for _, sandwich := range sandwiches { if sandwich == 0 \u0026amp;\u0026amp; circle \u0026gt; 0 { circle-- continue } if sandwich == 1 \u0026amp;\u0026amp; square \u0026gt; 0 { square-- continue } break } return square + circle } 复杂度 时间复杂度：$ O(N), N = len(students) = len(sandwiches) $ 空间复杂度：$ O(1) $ ","date":"2022-10-19T10:11:22+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1700.-%E6%97%A0%E6%B3%95%E5%90%83%E5%8D%88%E9%A4%90%E7%9A%84%E5%AD%A6%E7%94%9F%E6%95%B0%E9%87%8F/","title":"Leetcode 1700. 无法吃午餐的学生数量"},{"content":"链接： https://leetcode.cn/problems/fruit-into-baskets/\n难度： 中等\n题目描述 你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。\n你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\n你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。 你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。 给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。\n示例 1： 输入： fruits = [1,2,1]\n输出： 3\n解释： 可以采摘全部 3 棵树。\n示例 2： 输入： fruits = [0,1,2,2]\n输出： 3\n解释： 可以采摘 [1,2,2] 这三棵树。\n如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。\n示例 3： 输入： fruits = [1,2,3,2,2]\n输出： 4\n解释： 可以采摘 [2,3,2,2] 这四棵树。\n如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。\n示例 4： 输入： fruits = [3,3,3,1,2,1,1,2,3,3,4]\n输出： 5\n解释： 可以采摘 [1,2,1,1,2] 这五棵树。\n提示： 1 \u0026lt;= fruits.length \u0026lt;= 105 0 \u0026lt;= fruits[i] \u0026lt; fruits.length 解题思路 滑动窗口 根据题意，需要找出仅包含两种水果的最长子数组。\n使用滑动窗口记录当前遍历到的符合条件的，当出现第三种水果时，更新最大值，收缩知道窗口内仅剩一种水果。\nfunc totalFruit(fruits []int) int { cnt := make(map[int]int) ans := 0 for l, r := 0, 0; r \u0026lt; len(fruits); r++ { cnt[fruits[r]]++ // 收缩左端点 for ; len(cnt) \u0026gt; 2; l++ { cnt[fruits[l]]-- if cnt[fruits[l]] == 0 { delete(cnt, fruits[l]) } } if ans \u0026lt; r-l+1 { ans = r - l + 1 } } return ans } 复杂度 时间复杂度：$ O(N), N = len(fruits) $ 空间复杂度：$ O(1) $ ","date":"2022-10-17T10:14:22+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-904.-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/","title":"Leetcode 904. 水果成篮"},{"content":"链接： https://leetcode.cn/problems/build-an-array-with-stack-operations/\n难度： 中等\n题目描述 给你一个数组 target 和一个整数 n。每次迭代，需要从 list = { 1 , 2 , 3 ..., n } 中依次读取一个数字。\n请使用下述操作来构建目标数组 target ：\n\u0026quot;Push\u0026quot;：从 list 中读取一个新元素， 并将其推入数组中。 \u0026quot;Pop\u0026quot;：删除数组中的最后一个元素。 如果目标数组构建完成，就停止读取更多元素。 题目数据保证目标数组严格递增，并且只包含 1 到 n 之间的数字。\n请返回构建目标数组所用的操作序列。如果存在多个可行方案，返回任一即可。\n示例 1： 输入： target = [1,3], n = 3\n输出： [\u0026ldquo;Push\u0026rdquo;,\u0026ldquo;Push\u0026rdquo;,\u0026ldquo;Pop\u0026rdquo;,\u0026ldquo;Push\u0026rdquo;]\n解释：\n读取 1 并自动推入数组 -\u0026gt; [1]\n读取 2 并自动推入数组，然后删除它 -\u0026gt; [1]\n读取 3 并自动推入数组 -\u0026gt; [1,3]\n示例 2: 输入： target = [1,2,3], n = 3\n输出： [\u0026ldquo;Push\u0026rdquo;,\u0026ldquo;Push\u0026rdquo;,\u0026ldquo;Push\u0026rdquo;]\n示例 3: 输入： target = [1,2], n = 4\n输出： [\u0026ldquo;Push\u0026rdquo;,\u0026ldquo;Push\u0026rdquo;]\n解释： 只需要读取前 2 个数字就可以停止。\n提示： 1 \u0026lt;= target.length \u0026lt;= 100 1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= target[i] \u0026lt;= n target 严格递增 解题思路 模拟 模拟整个操作，对每个执行入栈以后进行判断：\n当栈顶元素和 target 中对应元素不同时，执行出栈操作； 否则，继续处理下一个元素； 在以上过程中，若已和 target 保持一致，则提前结束。\nfunc buildArray(target []int, n int) []string { ans := make([]string, 0, n\u0026lt;\u0026lt;1) for i := 1; i \u0026lt;= n; i++ { ans = append(ans, \u0026#34;Push\u0026#34;) if target[0] != i { ans = append(ans, \u0026#34;Pop\u0026#34;) continue } target = target[1:] if len(target) == 0 { break } } return ans } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2022-10-15T11:29:48+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1441.-%E7%94%A8%E6%A0%88%E6%93%8D%E4%BD%9C%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84/","title":"Leetcode 1441. 用栈操作构建数组"},{"content":"链接： https://leetcode.cn/problems/max-chunks-to-make-sorted/\n难度： 中等\n题目描述 给定一个长度为 n 的整数数组 arr ，它表示在 [0, n - 1] 范围内的整数的排列。\n我们将 arr 分割成若干 块 (即分区)，并对每个块单独排序。将它们连接起来后，使得连接的结果和按升序排序后的原数组相同。\n返回数组能分成的最多块数量。\n示例 1： 输入： arr = [4,3,2,1,0]\n输出： 1\n解释：\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。\n示例 2： 输入： arr = [1,0,2,3,4]\n输出： 4\n解释：\n我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。\n然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。\n提示： n == arr.length 1 \u0026lt;= n \u0026lt;= 10 0 \u0026lt;= arr[i] \u0026lt; n arr 中每个元素都 不同 解题思路 贪心 根据题目给定的数据范围，当排序完成后，其元素值和下标是相同的。\n所以对于下标不同的元素 arr[i]，其直到排序后的下标的位置 arr[i] 为止，必须在位于一个块中。\nfunc maxChunksToSorted(arr []int) int { blocks := 0 blockEnd := 0 // 块终止 for i, num := range arr { // 更新块终止 if blockEnd \u0026lt; num { blockEnd = num } // 当所有块中所有元素均在该块中时 if i == blockEnd { blocks++ } } return blocks } 复杂度 时间复杂度：$ O(N), N = len(arr) $ 空间复杂度：$ O(1) $ ","date":"2022-10-13T10:19:00+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-769.-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97/","title":"Leetcode 769. 最多能完成排序的块"},{"content":"链接： https://leetcode.cn/problems/linked-list-components/\n难度： 中等\n题目描述 给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。同时给定列表 nums，该列表是上述链表中整型值的一个子集。\n返回列表 nums 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 nums 中）构成的集合。\n示例 1： 输入： head = [0,1,2,3], nums = [0,1,3]\n输出： 2\n解释： 链表中,0 和 1 是相连接的，且 nums 中不包含 2，所以 [0, 1] 是 nums 的一个组件，同理 [3] 也是一个组件，故返回 2。\n示例 2： 输入： head = [0,1,2,3,4], nums = [0,3,1,4]\n输出： 2\n解释： 链表中，0 和 1 是相连接的，3 和 4 是相连接的，所以 [0, 1] 和 [3, 4] 是两个组件，故返回 2。\n提示： 链表中节点数为 n 1 \u0026lt;= n \u0026lt;= 104 0 \u0026lt;= Node.val \u0026lt; n Node.val 中所有值 不同 1 \u0026lt;= nums.length \u0026lt;= n 0 \u0026lt;= nums[i] \u0026lt; n nums 中所有值 不同 解题思路 哈希 使用哈希表记录 nums 中存在的元素。\n依次遍历整个链表，当节点值存在于链表中时，标记，并继续遍历直到遇到不存在的值为止。\n清除标记，组件值 +1。\nfunc numComponents(head *ListNode, nums []int) int { exist := make(map[int]struct{}) for _, num := range nums { exist[num] = struct{}{} } ans := 0 cur := false for n := head; n != nil; n = n.Next { if _, ok := exist[n.Val]; ok { cur = true continue } if cur { ans++ } cur = false } if cur { ans++ } return ans } 复杂度 时间复杂度：$ O(N), N = len(head) $ 空间复杂度：$ O(M), M = len(nums) $ ","date":"2022-10-12T10:26:31+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-817.-%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6/","title":"Leetcode 817. 链表组件"},{"content":"链接： https://leetcode.cn/problems/check-if-one-string-swap-can-make-strings-equal/\n难度： 简单\n题目描述 给你长度相等的两个字符串 s1 和 s2 。一次 字符串交换 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。\n如果对 其中一个字符串 执行 最多一次字符串交换 就可以使两个字符串相等，返回 true ；否则，返回 false 。\n示例 1： 输入： s1 = \u0026ldquo;bank\u0026rdquo;, s2 = \u0026ldquo;kanb\u0026rdquo;\n输出： true\n解释： 例如，交换 s2 中的第一个和最后一个字符可以得到 \u0026ldquo;bank\u0026rdquo;\n示例 2： 输入： s1 = \u0026ldquo;attack\u0026rdquo;, s2 = \u0026ldquo;defend\u0026rdquo;\n输出： false\n解释： 一次字符串交换无法使两个字符串相等\n示例 3： 输入： s1 = \u0026ldquo;kelb\u0026rdquo;, s2 = \u0026ldquo;kelb\u0026rdquo;\n输出： true\n解释： 两个字符串已经相等，所以不需要进行字符串交换\n示例 4： 输入： s1 = \u0026ldquo;abcd\u0026rdquo;, s2 = \u0026ldquo;dcba\u0026rdquo;\n输出： false\n提示： 1 \u0026lt;= s1.length, s2.length \u0026lt;= 100 s1.length == s2.length s1 和 s2 仅由小写英文字母组成 解题思路 模拟 依次比较两个字符串对应下标的字符，若不相同的地方超过 2 处或者仅有 1 处，则返回 false。\n若完全相同，则两个字符串同一下标处的两个字符交换，不会改变字符串的值，返回 true。\n若仅有两处不同，判断交换以后是否相同。\nfunc areAlmostEqual(s1 string, s2 string) bool { diff := make([]int, 0, 2) for i := range s1 { if s1[i] == s2[i] { continue } // 超过两处不同 if len(diff) == 2 { return false } diff = append(diff, i) } if len(diff) == 0 { return true } if len(diff) == 1 { return false } if s1[diff[0]] == s2[diff[1]] \u0026amp;\u0026amp; s1[diff[1]] == s2[diff[0]] { return true } return false } 复杂度 时间复杂度：$ O(N), M = len(s1) = len(s2) $ 空间复杂度：$ O(1) $ ","date":"2022-10-12T10:09:29+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1790.-%E4%BB%85%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BA%A4%E6%8D%A2%E8%83%BD%E5%90%A6%E4%BD%BF%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E7%AD%89/","title":"Leetcode 1790. 仅执行一次字符串交换能否使两个字符串相等"},{"content":"链接： https://leetcode.cn/problems/score-of-parentheses/\n难度： 中等/font\u0026gt;\n题目描述 给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：\n() 得 1 分。 AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。 (A) 得 2 * A 分，其中 A 是平衡括号字符串。 示例 1： 输入： \u0026ldquo;()\u0026rdquo;\n输出： 1\n示例 2： 输入： \u0026ldquo;(())\u0026rdquo;\n输出： 2\n示例 3： 输入： \u0026ldquo;()()\u0026rdquo;\n输出： 2\n示例 4： 输入： \u0026ldquo;(()(()))\u0026rdquo;\n输出： 6\n提示： S 是平衡括号字符串，且只含有 ( 和 ) 。 2 \u0026lt;= S.length \u0026lt;= 50 解题思路 数学 通过分析不难发现，括号的嵌套深度决定了其分数，并且初始的分数产生于 \u0026quot;()\u0026quot;，深度每加1，则分数翻倍。\n由于给定的字符串括号是匹配的，遍历并维护深度，当识别到 \u0026quot;()\u0026quot; 时，求得对应的分值并累加。\nfunc scoreOfParentheses(s string) int { score := 0 depth := 0 for i := range s { if s[i] == \u0026#39;(\u0026#39; { depth++ continue } depth-- if s[i-1] == \u0026#39;(\u0026#39; { score += 1 \u0026lt;\u0026lt; depth } } return score } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2022-10-09T10:29:34+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-856.-%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%88%86%E6%95%B0/","title":"Leetcode 856. 括号的分数"},{"content":"链接： https://leetcode.cn/problems/advantage-shuffle/\n难度： 中等\n题目描述 给定两个大小相等的数组 nums1 和 nums2，nums1 相对于 nums2 的优势可以用满足 nums1[i] \u0026gt; nums2[i] 的索引 i 的数目来描述。\n返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。\n示例 1： 输入： nums1 = [2,7,11,15], nums2 = [1,10,4,11]\n输出： [2,11,7,15]\n示例 2： 输入： nums1 = [12,24,8,32], nums2 = [13,25,32,11]\n输出： [24,32,8,12]\n提示： 1 \u0026lt;= nums1.length \u0026lt;= 105 nums2.length == nums1.length 0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 109 解题思路 贪心 为使得优势最大，需尝试从 nums1 中找出比 nums2 中较小的那部分数字更大，可以采用田忌赛马策略。\n首先将两个数组排序，分别从头开始遍历（不妨设下标指针分别 i 和 j）：\n当 nums1[i] \u0026gt; nums2[j]，即找到了一个对应的优势点； 否则，nums[i] 不会比剩余的 nums2 中的数字大了，可将其依次倒序放置到 nums2 的后半部分。 由于最后的结果要和 nums2 的初始排序对应，故可以按照 nums2 中的排序下标，通过下标找到对应元素。\nfunc advantageCount(nums1 []int, nums2 []int) []int { n := len(nums1) idx2 := make([]int, 0, n) for i := 0; i \u0026lt; n; i++ { idx2 = append(idx2, i) } sort.Ints(nums1) sort.Slice(idx2, func(i, j int) bool { return nums2[idx2[i]] \u0026lt; nums2[idx2[j]] }) ans := make([]int, n) j, k := 0, n-1 for _, num1 := range nums1 { if num1 \u0026lt;= nums2[idx2[j]] { ans[idx2[k]] = num1 k-- continue } ans[idx2[j]] = num1 j++ } return ans } 复杂度 时间复杂度：$ O(N), N = len(nums1) = len(nums2) $ 空间复杂度：$ O(N) $ ","date":"2022-10-09T10:10:49+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-870.-%E4%BC%98%E5%8A%BF%E6%B4%97%E7%89%8C/","title":"Leetcode 870. 优势洗牌"},{"content":"链接： https://leetcode.cn/problems/maximum-ascending-subarray-sum/\n难度： 简单\n题目描述 给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。\n子数组是数组中的一个连续数字序列。\n已知子数组 [numsl, numsl+1, \u0026hellip;, numsr-1, numsr] ，若对所有 i（l \u0026lt;= i \u0026lt; r），numsi \u0026lt; numsi+1 都成立，则称这一子数组为 升序 子数组。注意，大小为 1 的子数组也视作 升序 子数组。\n示例 1： 输入： nums = [10,20,30,5,10,50]\n输出： 65\n解释： [5,10,50] 是元素和最大的升序子数组，最大元素和为 65 。\n示例 2： 输入： nums = [10,20,30,40,50]\n输出： 150\n解释： [10,20,30,40,50] 是元素和最大的升序子数组，最大元素和为 150 。\n示例 3： 输入： nums = [12,17,15,13,10,11,12]\n输出： 33\n解释： [10,11,12] 是元素和最大的升序子数组，最大元素和为 33 。\n示例 4： 输入： nums = [100,10,1]\n输出： 100\n提示： 1 \u0026lt;= nums.length \u0026lt;= 100 1 \u0026lt;= nums[i] \u0026lt;= 100 解题思路 模拟 由于题设表明子数组是连续的，并且所有的数字都是正数，故字数组应尽量长。\n从首个数字开始向后遍历求得当前段最长的升序子数组的和。之后从下一个元素开始，继续重复以上操作，则得到每一段升序字数组的和；从而得到最大值。\nfunc maxAscendingSum(nums []int) int { ans := 0 sum := nums[0] for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt; nums[i-1] { sum += nums[i] continue } if ans \u0026lt; sum { ans = sum } sum = nums[i] } if ans \u0026lt; sum { ans = sum } return ans } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2022-10-07T16:54:41+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1800.-%E6%9C%80%E5%A4%A7%E5%8D%87%E5%BA%8F%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/","title":"Leetcode 1800. 最大升序子数组和"},{"content":"链接： https://leetcode.cn/problems/subdomain-visit-count/\n难度： 中等\n题目描述 网站域名 \u0026quot;discuss.leetcode.com\u0026quot; 由多个子域名组成。顶级域名为 \u0026quot;com\u0026quot; ，二级域名为 \u0026quot;leetcode.com\u0026quot; ，最低一级为 \u0026quot;discuss.leetcode.com\u0026quot; 。当访问域名 \u0026quot;discuss.leetcode.com\u0026quot; 时，同时也会隐式访问其父域名 \u0026quot;leetcode.com\u0026quot; 以及 \u0026quot;com\u0026quot; 。\n计数配对域名 是遵循 \u0026quot;rep d1.d2.d3\u0026quot; 或 \u0026quot;rep d1.d2\u0026quot; 格式的一个域名表示，其中 rep 表示访问域名的次数，d1.d2.d3 为域名本身。\n例如，\u0026quot;9001 discuss.leetcode.com\u0026quot; 就是一个 计数配对域名 ，表示 discuss.leetcode.com 被访问了 9001 次。 给你一个 计数配对域名 组成的数组 cpdomains ，解析得到输入中每个子域名对应的 计数配对域名 ，并以数组形式返回。可以按 任意顺序 返回答案。\n示例 1： 输入： cpdomains = [\u0026ldquo;9001 discuss.leetcode.com\u0026rdquo;]\n输出： [\u0026ldquo;9001 leetcode.com\u0026rdquo;,\u0026ldquo;9001 discuss.leetcode.com\u0026rdquo;,\u0026ldquo;9001 com\u0026rdquo;]\n解释： 例子中仅包含一个网站域名：\u0026ldquo;discuss.leetcode.com\u0026rdquo;。\n按照前文描述，子域名 \u0026ldquo;leetcode.com\u0026rdquo; 和 \u0026ldquo;com\u0026rdquo; 都会被访问，所以它们都被访问了 9001 次。\n示例 2： 输入： cpdomains = [\u0026ldquo;900 google.mail.com\u0026rdquo;, \u0026ldquo;50 yahoo.com\u0026rdquo;, \u0026ldquo;1 intel.mail.com\u0026rdquo;, \u0026ldquo;5 wiki.org\u0026rdquo;]\n输出： [\u0026ldquo;901 mail.com\u0026rdquo;,\u0026ldquo;50 yahoo.com\u0026rdquo;,\u0026ldquo;900 google.mail.com\u0026rdquo;,\u0026ldquo;5 wiki.org\u0026rdquo;,\u0026ldquo;5 org\u0026rdquo;,\u0026ldquo;1 intel.mail.com\u0026rdquo;,\u0026ldquo;951 com\u0026rdquo;]\n解释： 按照前文描述，会访问 \u0026ldquo;google.mail.com\u0026rdquo; 900 次，\u0026ldquo;yahoo.com\u0026rdquo; 50 次，\u0026ldquo;intel.mail.com\u0026rdquo; 1 次，\u0026ldquo;wiki.org\u0026rdquo; 5 次。\n而对于父域名，会访问 \u0026ldquo;mail.com\u0026rdquo; 900 + 1 = 901 次，\u0026ldquo;com\u0026rdquo; 900 + 50 + 1 = 951 次，和 \u0026ldquo;org\u0026rdquo; 5 次。\n提示： 1 \u0026lt;= cpdomain.length \u0026lt;= 100 1 \u0026lt;= cpdomain[i].length \u0026lt;= 100 cpdomain[i] 会遵循 \u0026ldquo;repi d1i.d2i.d3i\u0026quot; 或 \u0026ldquo;repi d1i.d2i\u0026quot; 格式 repi 是范围 [1, 104] 内的一个整数 d1i、d2i 和 d3i 由小写英文字母组成 解题思路 哈希 对于每个计数配对域名，解析得到该域名的父域名，使用哈希表维护每个域名的访问次数。\nfunc subdomainVisits(cpdomains []string) []string { cnt := make(map[string]int) for _, cp := range cpdomains { // 解析访问次数 i := strings.IndexByte(cp, \u0026#39; \u0026#39;) rep, _ := strconv.Atoi(cp[:i]) cp = cp[i+1:] // 更新所有域名的访问次数 cnt[cp] += rep for i := range cp { if cp[i] == \u0026#39;.\u0026#39; { cnt[cp[i+1:]] += rep } } } ans := make([]string, 0, len(cnt)) for k, v := range cnt { ans = append(ans, fmt.Sprintf(\u0026#34;%d %s\u0026#34;, v, k)) } return ans } 复杂度 时间复杂度：$ O(N), N = \\sum{len(cpdomains[i])} $ 空间复杂度：$ O(N) $ ","date":"2022-10-05T10:37:13+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-811.-%E5%AD%90%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E8%AE%A1%E6%95%B0/","title":"Leetcode 811. 子域名访问计数"},{"content":"链接： https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/\n难度： 中等\n题目描述 只有满足下面几点之一，括号字符串才是有效的：\n它是一个空字符串，或者 它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者 它可以被写作 (A)，其中 A 是有效字符串。 给定一个括号字符串 s ，移动 N 次，你就可以在字符串的任何位置插入一个括号。\n例如，如果 s = \u0026quot;()))\u0026quot; ，你可以插入一个开始括号为 \u0026quot;(()))\u0026quot; 或结束括号为 \u0026quot;())))\u0026quot; 。 返回 为使结果字符串 s 有效而必须添加的最少括号数。\n示例 1： 输入： s = \u0026ldquo;())\u0026rdquo;\n输出： 1\n示例 2： 输入： s = \u0026ldquo;(((\u0026rdquo;\n输出： 3\n提示： 1 \u0026lt;= s.length \u0026lt;= 1000 s 只包含 '(' 和 ')' 字符。 解题思路 贪心 当每个 '(' 右侧存在 ')' 时，其必然是可以完成匹配的。所以有两种情况需要补足：\n'(' 右侧没有 ')'； ')' 左侧没有 '('。 使用一个变量记录遍历到的 '(' 的数量，每当遇到 ')' 时，若此时有 '(' ，即完成一次匹配，否则需要添加一个 '('。\n最后当'(' 的数量不为 0 时，需要在最后添加同等数量的 ')'\nfunc minAddToMakeValid(s string) int { ans := 0 left := 0 for i := range s { if s[i] == \u0026#39;(\u0026#39; { left++ continue } if left == 0 { ans++ } else { left-- } } ans += left return ans } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2022-10-04T10:52:07+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-921.-%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%91%E6%B7%BB%E5%8A%A0/","title":"Leetcode 921. 使括号有效的最少添加"},{"content":"链接： https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones/\n难度： 简单\n题目描述 给你一个二进制字符串 s ，该字符串 不含前导零 。\n如果 s 包含 零个或一个由连续的 '1' 组成的字段 ，返回 true​​​ 。否则，返回 false 。\n如果 s 中 由连续若干个 '1' 组成的字段 数量不超过 1，返回 true​​​ 。否则，返回 false 。\n示例 1： 输入： s = \u0026ldquo;1001\u0026rdquo;\n输出： false\n解释： 由连续若干个 \u0026lsquo;1\u0026rsquo; 组成的字段数量为 2，返回 false\n示例 2： 输入： s = \u0026ldquo;110\u0026rdquo;\n输出： true\n提示： 1 \u0026lt;= s.length \u0026lt;= 100 s[i]​​​​ 为 '0' 或 '1' s[0] 为 '1' 解题思路 遍历 由于首个字符必然是 1，则其后若有 0 出现，此后不能再出现 1。\nfunc checkOnesSegment(s string) bool { i := 0 for ; i \u0026lt; len(s) \u0026amp;\u0026amp; s[i] == \u0026#39;1\u0026#39;; i++ { } return !strings.ContainsRune(s[i:], \u0026#39;1\u0026#39;) } 复杂度 时间复杂度：$ O(N), M = len(s) $ 空间复杂度：$ O(1) $ ","date":"2022-10-03T10:27:16+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1784.-%E6%A3%80%E6%9F%A5%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E6%AE%B5/","title":"Leetcode 1784. 检查二进制字符串字段"},{"content":"链接： https://leetcode.cn/problems/reformat-phone-number/\n难度： 简单\n题目描述 给你一个字符串形式的电话号码 number 。number 由数字、空格 ' '、和破折号 '-' 组成。\n请你按下述方式重新格式化电话号码。\n首先，删除 所有的空格和破折号。 其次，将数组从左到右 每 3 个一组 分块，直到 剩下 4 个或更少数字。剩下的数字将按下述规定再分块： 2 个数字：单个含 2 个数字的块。 3 个数字：单个含 3 个数字的块。 4 个数字：两个分别含 2 个数字的块。 最后用破折号将这些块连接起来。注意，重新格式化过程中 不应该 生成仅含 1 个数字的块，并且 最多 生成两个含 2 个数字的块。\n返回格式化后的电话号码。\n示例 1： 输入： number = \u0026ldquo;1-23-45 6\u0026rdquo;\n输出： \u0026ldquo;123-456\u0026rdquo;\n解释： 数字是 \u0026ldquo;123456\u0026rdquo;\n步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 \u0026ldquo;123\u0026rdquo; 。\n步骤 2：剩下 3 个数字，将它们放入单个含 3 个数字的块。第 2 个块是 \u0026ldquo;456\u0026rdquo; 。\n连接这些块后得到 \u0026ldquo;123-456\u0026rdquo; 。\n示例 2： 输入： number = \u0026ldquo;123 4-567\u0026rdquo;\n输出： \u0026ldquo;123-45-67\u0026rdquo;\n解释： 数字是 \u0026ldquo;1234567\u0026rdquo;.\n步骤 1：共有超过 4 个数字，所以先取 3 个数字分为一组。第 1 个块是 \u0026ldquo;123\u0026rdquo; 。\n步骤 2：剩下 4 个数字，所以将它们分成两个含 2 个数字的块。这 2 块分别是 \u0026ldquo;45\u0026rdquo; 和 \u0026ldquo;67\u0026rdquo; 。\n连接这些块后得到 \u0026ldquo;123-45-67\u0026rdquo; 。\n示例 3： 输入： number = \u0026ldquo;123 4-5678\u0026rdquo;\n输出： \u0026ldquo;123-456-78\u0026rdquo;\n解释： 数字是 \u0026ldquo;12345678\u0026rdquo; 。\n步骤 1：第 1 个块 \u0026ldquo;123\u0026rdquo; 。\n步骤 2：第 2 个块 \u0026ldquo;456\u0026rdquo; 。\n步骤 3：剩下 2 个数字，将它们放入单个含 2 个数字的块。第 3 个块是 \u0026ldquo;78\u0026rdquo; 。\n连接这些块后得到 \u0026ldquo;123-456-78\u0026rdquo; 。\n示例 4： 输入： number = \u0026ldquo;12\u0026rdquo;\n输出： \u0026ldquo;12\u0026rdquo;\n示例 5： 输入： number = \u0026ldquo;\u0026ndash;17-5 229 35-39475 \u0026quot;\n输出： \u0026ldquo;175-229-353-94-75\u0026rdquo;\n提示： 2 \u0026lt;= number.length \u0026lt;= 100 number 由数字和字符 '-' 及 ' ' 组成。 number 中至少含 2 个数字。 解题思路 模拟 遍历 number ，仅识别出数字，每三个进行分组，用 '-' 连接，直至处理完毕。\n最后一组的数量可能是 0、1、2，分别进行处理：\n当为 0 时，消除最后的 '-'； 当为 1 时，将最后的 '-' 与其前面的数字交换，构成末尾 2 + 2 的 块； 当为 2 时候，不做处理； 返回最后结果。\nfunc reformatNumber(number string) string { ans := make([]byte, 0, len(number)) cnt := 0 for i := range number { if number[i] \u0026lt; \u0026#39;0\u0026#39; || number[i] \u0026gt; \u0026#39;9\u0026#39; { continue } ans = append(ans, number[i]) cnt = (cnt + 1) % 3 // 每三个末尾加一个 - if cnt == 0 { ans = append(ans, \u0026#39;-\u0026#39;) } } switch cnt { case 0: ans = ans[:len(ans)-1] case 1: ans[len(ans)-3], ans[len(ans)-2] = ans[len(ans)-2], ans[len(ans)-3] } return string(ans) } 复杂度 时间复杂度：$ O(N), N = len(number) $ 空间复杂度：$ O(1) $ ","date":"2022-10-01T11:22:02+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1694.-%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81/","title":"Leetcode 1694. 重新格式化电话号码"},{"content":"链接： https://leetcode.cn/problems/zero-matrix-lcci/\n难度： 中等\n题目描述 编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。\n示例 1： 输入： [ [1,1,1], [1,0,1], [1,1,1] ] 输出： [ [1,0,1], [0,0,0], [1,0,1] ]\n示例 2： 输入： [ [0,1,2,0], [3,4,5,2], [1,3,1,5] ] 输出： [ [0,0,0,0], [0,4,5,0], [0,3,1,0] ]\n解题思路 哈希 遍历整个矩阵，使用哈希表记录每个元素为 0 的行和列，最后将记录的所有行列中的元素置为 0。\nfunc setZeroes(matrix [][]int) { rows := make(map[int]struct{}) cols := make(map[int]struct{}) for i, line := range matrix { for j, cell := range line { if cell == 0 { rows[i] = struct{}{} cols[j] = struct{}{} } } } for r := range rows { for j := 0; j \u0026lt; len(matrix[0]); j++ { matrix[r][j] = 0 } } for c := range cols { for i := 0; i \u0026lt; len(matrix); i++ { matrix[i][c] = 0 } } } 复杂度 时间复杂度：$ O(MN) $ 空间复杂度：$ O(M+N) $ ","date":"2022-09-30T10:01:23+08:00","permalink":"https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-01.08.-%E9%9B%B6%E7%9F%A9%E9%98%B5/","title":"面试题 01.08. 零矩阵"},{"content":"链接： https://leetcode.cn/problems/check-permutation-lcci/\n难度： 简单\n题目描述 字符串轮转。给定两个字符串 s1 和 s2，请编写代码检查 s2 是否为 s1 旋转而成（比如，waterbottle 是 erbottlewat 旋转后的字符串）。\n示例 1： 输入： s1 = \u0026ldquo;waterbottle\u0026rdquo;, s2 = \u0026ldquo;erbottlewat\u0026rdquo;\n输出： True\n示例 2： 输入： s1 = \u0026ldquo;aa\u0026rdquo;, s2 = \u0026ldquo;aba\u0026rdquo;\n输出： False\n提示 字符串长度在 [0, 100000] 范围内。 说明 你能只调用一次检查子串的方法吗？ 解题思路 枚举 s1 能旋转为 s2 一个充分条件为字符串长度一致，首先针对长度初步判断。\n当长度一致时，需找到一个分隔点，前后两个字串分别是 s2 的后缀和前缀，方可以通过旋转得到。\n遍历整个 s1 ，通过枚举寻找。\nfunc isFlipedString(s1 string, s2 string) bool { if len(s1) != len(s2) { return false } for i := 0; i \u0026lt;= len(s1); i++ { if strings.HasPrefix(s2, s1[i:]) \u0026amp;\u0026amp; strings.HasSuffix(s2, s1[:i]) { return true } } return false } 复杂度 时间复杂度：$ O(N^2), N = len(s1) $ 空间复杂度：$ O(1) $ 枚举 首先依然判断长度，长度不一致，直接返回 false。\ns1 的旋转流程是将最开始一个字符移动到字符串尾，不断重复该过程。通过将两个 s1 直接拼接得到的新串包含 s1 选装的所有情况，判断 s2 是否为新串的字串。\nfunc isFlipedString(s1 string, s2 string) bool { if len(s1) != len(s2) { return false } return strings.Contains(s1+s1, s2) } 复杂度 时间复杂度：$ O(N), N = len(s1) $ 空间复杂度：$ O(N) $ ","date":"2022-09-29T10:11:03+08:00","permalink":"https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-01.09.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AE%E8%BD%AC/","title":"面试题 01.09. 字符串轮转"},{"content":"链接： https://leetcode.cn/problems/get-kth-magic-number-lcci/\n难度： 中等\n题目描述 有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。\n示例： 输入： k = 5\n输出： 9\n解题思路 哈希 \u0026amp; 堆 使用小顶堆，维护最小元素，初始堆中元素只有 1。\n每次弹出最小元素，依次和因子 3、5、7 想乘，利用哈希表去重，添加到堆中。不断重复该操作，第 k 次弹出的堆顶元素即为有序排列的第 k 个数。\ntype minHeap struct { sort.IntSlice } func (m *minHeap) Push(x interface{}) { m.IntSlice = append(m.IntSlice, x.(int)) } func (m *minHeap) Pop() interface{} { x := m.IntSlice[len(m.IntSlice)-1] m.IntSlice = m.IntSlice[:len(m.IntSlice)-1] return x } func getKthMagicNumber(k int) int { minHeap := \u0026amp;minHeap{ IntSlice: []int{1}, } exist := map[int]struct{}{ 1: {}, } for i := 1; i \u0026lt; k; i++ { cur := heap.Pop(minHeap).(int) for _, factor := range []int{3, 5, 7} { num := cur * factor if _, ok := exist[num]; ok { continue } heap.Push(minHeap, num) exist[num] = struct{}{} } } return heap.Pop(minHeap).(int) } 复杂度 时间复杂度：$ O(k\\log{k}) $ 空间复杂度：$ O(k) $ 哈希 \u0026amp; 排序 不同变位词中字母相同，所以将字符串按照字母排序后，其值也一定相同。故可以将其排序后的值作为哈希表的 key，并将其添加进 value 数组中。\nfunc groupAnagrams(strs []string) [][]string { hash := make(map[string][]string) for _, str := range strs { t := []byte(str) sort.Slice(t, func(i, j int) bool { return t[i] \u0026lt; t[j] }) hash[string(t)] = append(hash[string(t)], str) } res := make([][]string, 0, len(hash)) for _, v := range hash { res = append(res, v) } return res } 复杂度 时间复杂度：$ O(NLlogL), N = len(strs), L = max(len(str)) $ 空间复杂度：$ O(NL) $ ","date":"2022-09-28T10:15:43+08:00","permalink":"https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.09.-%E7%AC%AC-k-%E4%B8%AA%E6%95%B0/","title":"面试题 17.09. 第 k 个数"},{"content":"链接： https://leetcode.cn/problems/check-permutation-lcci/\n难度： 简单\n题目描述 给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。\n示例 1： 输入： s1 = \u0026ldquo;abc\u0026rdquo;, s2 = \u0026ldquo;bca\u0026rdquo;\n输出： true\n示例 2： 输入： s1 = \u0026ldquo;abc\u0026rdquo;, s2 = \u0026ldquo;bad\u0026rdquo;\n输出： false\n说明 0 \u0026lt;= len(s1) \u0026lt;= 100 0 \u0026lt;= len(s2) \u0026lt;= 100 解题思路 哈希 两个字符串互为重排，要求两个字符串的每种字符的数量完全一致。\n首先用长度做初步判断，不同则直接返回 false\n然后使用哈希表统计其中一个字符串每种字母的数量，然后遍历另一个字符串，将对应的字符从哈希表中删除。最后哈希表为空则为 true，否则 false。\nfunc CheckPermutation(s1 string, s2 string) bool { if len(s1) != len(s2) { return false } cnt := make(map[byte]int) for i := range s1 { cnt[s1[i]]++ } for i := range s2 { cnt[s2[i]]-- if cnt[s2[i]] \u0026lt; 0 { return false } if cnt[s2[i]] == 0 { delete(cnt, s2[i]) } } return len(cnt) == 0 } 复杂度 时间复杂度：$ O(N), N = len(s1) $ 空间复杂度：$ O(N) $ ","date":"2022-09-27T10:11:44+08:00","permalink":"https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-01.02.-%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/","title":"面试题 01.02. 判定是否互为字符重排"},{"content":"链接： https://leetcode.cn/problems/rotated-digits/\n难度： 中等\n题目描述 我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。\n如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 互为镜像）；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。\n现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？\n示例： 输入： 10\n输出： 4\n解释：\n在[1, 10]中有四个好数： 2, 5, 6, 9。\n注意 1 和 10 不是好数, 因为他们在旋转之后不变。\n提示： N 的取值范围是 [1, 10000]。 解题思路 枚举 好数的条件是仅包含 {0,1,2,5,6,8,9} 这7个数，且至少包含 {2,5,6,9} 中的一个。\n依次枚举进行判断\nfunc valid(n int) bool { same := true for ; n \u0026gt; 0; n /= 10 { switch n % 10 { case 3, 4, 7: return false case 2, 5, 6, 9: same = false } } return !same } func rotatedDigits(n int) int { ans := 0 for i := 1; i \u0026lt;= n; i++ { if valid(i) { ans++ } } return ans } 复杂度 时间复杂度：$ O(n\\log{n}) $ 空间复杂度：$ O(1) $ ","date":"2022-09-25T10:05:11+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-788.-%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%97/","title":"Leetcode 788. 旋转数字"},{"content":"链接： https://leetcode.cn/problems/defuse-the-bomb/\n难度： 简单\n题目描述 你有一个炸弹需要拆除，时间紧迫！你的情报员会给你一个长度为 n 的 循环 数组 code 以及一个密钥 k 。\n为了获得正确的密码，你需要替换掉每一个数字。所有数字会 同时 被替换。\n如果 k \u0026gt; 0 ，将第 i 个数字用 接下来 k 个数字之和替换。 如果 k \u0026lt; 0 ，将第 i 个数字用 之前 k 个数字之和替换。 如果 k == 0 ，将第 i 个数字用 0 替换。 由于 code 是循环的， code[n-1] 下一个元素是 code[0] ，且 code[0] 前一个元素是 code[n-1] 。\n给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！\n示例 1： 输入： code = [5,7,1,4], k = 3\n输出： [12,10,16,13]\n解释： 每个数字都被接下来 3 个数字之和替换。解密后的密码为 [7+1+4, 1+4+5, 4+5+7, 5+7+1]。注意到数组是循环连接的。\n示例 2： 输入： code = [1,2,3,4], k = 0\n输出： [0,0,0,0]\n解释： 当 k 为 0 时，所有数字都被 0 替换。\n示例 3： 输入： code = [2,4,9,3], k = -2\n输出： [12,5,6,13]\n解释： 解密后的密码为 [3+9, 2+3, 4+2, 9+4] 。注意到数组是循环连接的。如果 k 是负数，那么和为 之前 的数字。\n提示： n == code.length 1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= code[i] \u0026lt;= 100 -(n - 1) \u0026lt;= k \u0026lt;= n - 1 解题思路 滑动窗口 若 k 为 0，则直接返回长度 n , 元素均为 0 的数组；\n否则，维护一个长度为 |k| 的滑动窗口 [i,|k|-i] 的和：\n当 k \u0026gt; 0，对应下标 (i-1+n)%n 为滑动窗口的和； 当 k \u0026lt; 0，对应下标 (i-k)%n 为滑动窗口的和。 func decrypt(code []int, k int) []int { n := len(code) if k == 0 { return make([]int, n) } idx := n-1 if k \u0026lt; 0 { idx = -k k = -k } sum := 0 for i := 0; i \u0026lt; k; i++ { sum += code[i] } ans := make([]int, n) for i := range code { ans[idx] = sum sum = sum - code[i] + code[(i+k)%n] idx = (idx + 1) % n } return ans } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(n) $ ","date":"2022-09-24T06:58:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1652.-%E6%8B%86%E7%82%B8%E5%BC%B9/","title":"Leetcode 1652. 拆炸弹"},{"content":"链接： https://leetcode.cn/problems/design-linked-list/\n难度： 中等\n题目描述 设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。\n在链表类中实现这些功能：\nget(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果 index 小于 0，则在头部插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 示例： MyLinkedList linkedList = new MyLinkedList(); linkedList.addAtHead(1); linkedList.addAtTail(3); linkedList.addAtIndex(1,2); //链表变为1-\u0026gt; 2-\u0026gt; 3 linkedList.get(1); //返回2 linkedList.deleteAtIndex(1); //现在链表是1-\u0026gt; 3 linkedList.get(1); //返回3 提示： 所有 val 值都在 [1, 1000] 之内。 操作次数将在 [1, 1000] 之内。 请不要使用内置的 LinkedList 库。 解题思路 单向链表 type node struct { val int next *node } type MyLinkedList struct { head *node length int } func Constructor() MyLinkedList { return MyLinkedList{ head: new(node), length: 0, } } func (this *MyLinkedList) Get(index int) int { if index \u0026lt; -1 || index \u0026gt;= this.length { return -1 } n := this.head for ; index \u0026gt;= 0; index-- { n = n.next } return n.val } func (this *MyLinkedList) AddAtHead(val int) { this.head.next = \u0026amp;node{ val: val, next: this.head.next, } this.length++ } func (this *MyLinkedList) AddAtTail(val int) { n := this.head for ; n.next != nil; n = n.next { } n.next = \u0026amp;node{ val: val, next: n.next, } this.length++ } func (this *MyLinkedList) getPre(index int) *node { // 寻找上一个节点 n := this.head for ; index \u0026gt; 0; index-- { n = n.next } return n } func (this *MyLinkedList) AddAtIndex(index int, val int) { if index \u0026lt; 0 { this.AddAtHead(val) return } if index \u0026gt; this.length { return } n := this.getPre(index) n.next = \u0026amp;node{ val: val, next: n.next, } this.length++ } func (this *MyLinkedList) DeleteAtIndex(index int) { if index \u0026lt; 0 || index \u0026gt;= this.length { return } n := this.getPre(index) n.next = n.next.next this.length-- } 复杂度 时间复杂度： Constructor：$ O(1) $ Get：$ O(N) $ AddAtHead：$ O(1) $ AddAtTail：$ O(N) $ AddAtIndex：$ O(N) $ DeleteAtIndex：$ O(N) $ 空间复杂度：$ O(N) $ ","date":"2022-09-23T10:14:17+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-707.-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/","title":"Leetcode 707. 设计链表"},{"content":"链接： https://leetcode.cn/problems/check-array-formation-through-concatenation/submissions/\n难度： 简单\n题目描述 给你一个整数数组 arr ，数组中的每个整数 互不相同 。另有一个由整数数组构成的数组 pieces，其中的整数也 互不相同 。请你以 任意顺序 连接 pieces 中的数组以形成 arr 。但是，不允许 对每个数组 pieces[i] 中的整数重新排序。\n如果可以连接 pieces 中的数组形成 arr ，返回 true ；否则，返回 false 。\n示例 1： 输入： arr = [15,88], pieces = [[88],[15]]\n输出： true\n解释： 依次连接 [15] 和 [88]\n示例 2： 输入： arr = [49,18,16], pieces = [[16,18,49]]\n输出： false\n解释： 即便数字相符，也不能重新排列 pieces[0]\n示例 3： 输入： arr = [91,4,64,78], pieces = [[78],[4,64],[91]]\n输出： true\n解释： 依次连接 [91]、[4,64] 和 [78]\n提示： 1 \u0026lt;= pieces.length \u0026lt;= arr.length \u0026lt;= 100 sum(pieces[i].length) == arr.length 1 \u0026lt;= pieces[i].length \u0026lt;= arr.length 1 \u0026lt;= arr[i], pieces[i][j] \u0026lt;= 100 arr 中的整数 互不相同 pieces 中的整数 互不相同（也就是说，如果将 pieces 扁平化成一维数组，数组中的所有整数互不相同） 解题思路 哈希 由于整个 arr 和 pieces 中的元素各不相同，所以只要找到 arr 中对应 pieces[i][0] 相同，继续向后遍历到 pieces[i] 到结束，必须和 arr 一致。\n重复上述步骤，直到找到不匹配的情况或匹配结束。\n使用哈希记录每个 pieces[i][0] 到 pieces[i] 的映射，降低时间复杂度。\nfunc canFormArray(arr []int, pieces [][]int) bool { first2Piece := make(map[int][]int) for _, p := range pieces { first2Piece[p[0]] = p } for i := 0; i \u0026lt; len(arr); { if first2Piece[arr[i]] == nil { return false } for _, p := range first2Piece[arr[i]] { if arr[i] != p { return false } i++ } } return true } 复杂度 时间复杂度：$ O(N), N = len(arr) $ 空间复杂度：$ O(N) $ ","date":"2022-09-22T20:18:59+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1640.-%E8%83%BD%E5%90%A6%E8%BF%9E%E6%8E%A5%E5%BD%A2%E6%88%90%E6%95%B0%E7%BB%84/","title":"Leetcode 1640. 能否连接形成数组"},{"content":"链接： https://leetcode.cn/problems/sort-array-by-increasing-frequency/\n难度： 简单\n题目描述 给你一个整数数组 nums ，请你将数组按照每个值的频率 升序 排序。如果有多个值的频率相同，请你按照数值本身将它们 降序 排序。\n请你返回排序后的数组。\n示例 1： 输入： nums = [1,1,2,2,2,3]\n输出： [3,1,1,2,2,2]\n解释： \u0026lsquo;3\u0026rsquo; 频率为 1，\u0026lsquo;1\u0026rsquo; 频率为 2，\u0026lsquo;2\u0026rsquo; 频率为 3 。\n示例 2： 输入： nums = [2,3,1,3,2]\n输出： [1,3,3,2,2]\n解释： \u0026lsquo;2\u0026rsquo; 和 \u0026lsquo;3\u0026rsquo; 频率都为 2 ，所以它们之间按照数值本身降序排序。\n示例 3： 输入： nums = [-1,1,-6,4,5,-6,1,4,1]\n输出： [5,-1,4,4,-6,-6,1,1,1]\n提示： 1 \u0026lt;= nums.length \u0026lt;= 100 -100 \u0026lt;= nums[i] \u0026lt;= 100 解题思路 哈希 + 自定义排序 首先使用哈希表统计每个数出现的频数，然后自定义 compare 函数实现排序。\nfunc frequencySort(nums []int) []int { freq := make(map[int]int) for _, num := range nums { freq[num]++ } sort.Slice(nums, func(i, j int) bool { if freq[nums[i]] \u0026lt; freq[nums[j]] { return true } if freq[nums[i]] \u0026gt; freq[nums[j]] { return false } return nums[i] \u0026gt; nums[j] }) return nums } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2022-09-19T10:04:58+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1636.-%E6%8C%89%E7%85%A7%E9%A2%91%E7%8E%87%E5%B0%86%E6%95%B0%E7%BB%84%E5%8D%87%E5%BA%8F%E6%8E%92%E5%BA%8F/","title":"Leetcode 1636. 按照频率将数组升序排序"},{"content":"链接： https://leetcode.cn/problems/making-a-large-island/\n难度： 困难\n题目描述 给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。\n返回执行此操作后，grid 中最大的岛屿面积是多少？\n岛屿 由一组上、下、左、右四个方向相连的 1 形成。\n示例 1： 输入： grid = [[1, 0], [0, 1]]\n输出： 3\n解释： 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。\n示例 2： 输入： grid = [[1, 1], [1, 0]]\n输出： 4\n解释： 将一格0变成1，岛屿的面积扩大为 4。\n示例 3： 输入： grid = [[1, 1], [1, 1]]\n输出： 4\n解释： 没有0可以让我们变成1，面积依然为 4。\n提示： n == grid.length n == grid[i].length 1 \u0026lt;= n \u0026lt;= 500 grid[i][j] 为 0 或 1 解题思路 深度优先搜索 + 枚举 进行变化后，可能将多个岛屿连通，通过给每个岛屿编号的方式，可以快速求解整个新岛屿的大小。\n首先通过深度优先搜索，求得各岛屿（连通集）的大小，并进行编号。\n然后通过枚举，依次将所有为 0 的变为 1，将四周不同编号的岛屿面积求并 +1，更新最大岛屿面积。\nvar dirs = [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} func largestIsland(grid [][]int) int { n := len(grid) outOfRange := func(row, col int) bool { if row \u0026lt; 0 || row \u0026gt;= n || col \u0026lt; 0 || col \u0026gt;= n { return true } return false } // 求得单一岛屿面积 var dfs func(row int, col int, no int) int dfs = func(row int, col int, no int) int { if outOfRange(row, col) { return 0 } if grid[row][col] != 1 { return 0 } grid[row][col] = no area := 1 for _, dir := range dirs { area += dfs(row+dir[0], col+dir[1], no) } return area } maxArea := 1 // 求得所有岛屿的面积并编号 no2Area := make(map[int]int) no := 2 for i := range grid { for j := range grid[i] { if grid[i][j] == 1 { area := dfs(i, j, no) no2Area[no] = area if maxArea \u0026lt; area { maxArea = area } no++ } } } // 枚举 for i := range grid { for j := range grid[i] { if grid[i][j] != 0 { continue } area := 1 // 将周围新连通的所有岛屿面积求和 island := make(map[int]struct{}) for _, dir := range dirs { r, c := i+dir[0], j+dir[1] if outOfRange(r, c) { continue } no := grid[r][c] if _, ok := island[no]; !ok { area += no2Area[no] island[no] = struct{}{} } } if maxArea \u0026lt; area { maxArea = area } } } return maxArea } 复杂度 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(n^2) $ ","date":"2022-09-18T11:04:03+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-827.-%E6%9C%80%E5%A4%A7%E4%BA%BA%E5%B7%A5%E5%B2%9B/","title":"Leetcode 827. 最大人工岛"},{"content":"链接： https://leetcode.cn/problems/largest-substring-between-two-equal-characters/\n难度： 简单\n题目描述 给你一个字符串 s，请你返回 两个相同字符之间的最长子字符串的长度 ，计算长度时不含这两个字符。如果不存在这样的子字符串，返回 -1 。\n子字符串 是字符串中的一个连续字符序列。\n示例 1： 输入： s = \u0026ldquo;aa\u0026rdquo;\n输出： 0\n解释： 最优的子字符串是两个 \u0026lsquo;a\u0026rsquo; 之间的空子字符串。\n示例 2： 输入： s = \u0026ldquo;abca\u0026rdquo;\n输出： 2\n解释： 最优的子字符串是 \u0026ldquo;bc\u0026rdquo; 。\n示例 3： 输入： s = \u0026ldquo;cbzxy\u0026rdquo;\n输出： -1\n解释： s 中不存在出现出现两次的字符，所以返回 -1 。\n示例 4： 输入： s = \u0026ldquo;cabbac\u0026rdquo;\n输出： 4\n解释： 最优的子字符串是 \u0026ldquo;abba\u0026rdquo; ，其他的非最优解包括 \u0026ldquo;bb\u0026rdquo; 和 \u0026quot;\u0026quot; 。\n提示： 1 \u0026lt;= s.length \u0026lt;= 300 s 只含小写英文字母 解题思路 哈希 遍历字符串，记录每个字符出现的最左位置，后续再次遍历到相同字符时即求得与最左侧字符之间的长度。\nfunc maxLengthBetweenEqualCharacters(s string) int { max := -1 idx := make(map[byte]int) for i := range s { left, ok := idx[s[i]] if !ok { idx[s[i]] = i continue } if max \u0026lt; i-left-1 { max = i - left - 1 } } return max } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(\\Sigma), \\Sigma表示字符集，本体中为 26 $ ","date":"2022-09-17T11:21:59+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1624.-%E4%B8%A4%E4%B8%AA%E7%9B%B8%E5%90%8C%E5%AD%97%E7%AC%A6%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 1624. 两个相同字符之间的最长子字符串"},{"content":"链接： https://leetcode.cn/problems/mean-of-array-after-removing-some-elements/\n难度： 简单\n题目描述 给你一个整数数组 arr ，请你删除最小 5% 的数字和最大 5% 的数字后，剩余数字的平均值。\n与 标准答案 误差在 10-5 的结果都被视为正确结果。\n示例 1： 输入： arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n输出： 2.00000\n解释： 删除数组中最大和最小的元素后，所有元素都等于 2，所以平均值为 2 。\n示例 2： 输入： arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n输出： 4.00000\n示例 3： 输入： arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n输出： 4.77778\n示例 4： 输入： arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n输出： 5.27778\n示例 5： 输入： arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n输出： 5.29167\n提示： 20 \u0026lt;= arr.length \u0026lt;= 1000 arr.length 是 20 的 倍数 0 \u0026lt;= arr[i] \u0026lt;= 105 解题思路 排序 将整个数组从小到大排序，去掉两侧各 arr.length/20 的元素，剩余元素去平均值。\nfunc trimMean(arr []int) float64 { sort.Ints(arr) sum := 0 for _, num := range arr[len(arr)/20 : len(arr)-len(arr)/20] { sum += num } return float64(sum) / float64(len(arr) - len(arr)/10) } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(arr) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-09-14T20:20:30+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1619.-%E5%88%A0%E9%99%A4%E6%9F%90%E4%BA%9B%E5%85%83%E7%B4%A0%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84%E5%9D%87%E5%80%BC/","title":"Leetcode 1619. 删除某些元素后的数组均值"},{"content":"链接： https://leetcode.cn/problems/maximum-swap/\n难度： 中等\n题目描述 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。\n示例 1： 输入： 2736\n输出： 7236\n解释： 交换数字2和数字7。\n示例 2： 输入： 9973\n输出： 9973\n解释： 不需要交换。\n注意： 给定数字的范围是 [0, 108] 解题思路 单调栈 为使得交换后的数字最大，需要将尽量靠右的较大数位与左侧较小的数位交换。\n识别出该数字的每一位，使用哈希表记录每个数最靠右出现的位置。\n顺序遍历该数字，当哈希表中存在的在该数右侧的最大数字比该数大时，进行交换。\nfunc maximumSwap(num int) int { digits := []byte(strconv.Itoa(num)) swapIdxes := make([]int, 0) maxIdx := len(digits) - 1 // 倒序遍历 for i := len(digits) - 1; i \u0026gt;= 0; i-- { // 当前数最大 if digits[maxIdx] \u0026lt; digits[i] { maxIdx = i continue } // 右侧存在更大的数，可以交换 if digits[maxIdx] \u0026gt; digits[i] { swapIdxes = []int{maxIdx, i} } } if len(swapIdxes) \u0026gt; 0 { digits[swapIdxes[0]], digits[swapIdxes[1]] = digits[swapIdxes[1]], digits[swapIdxes[0]] num, _ = strconv.Atoi(string(digits)) } return num } 复杂度 时间复杂度：$ O(\\log{num}) $ 空间复杂度：$ O(1) $ ","date":"2022-09-13T10:16:14+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-670.-%E6%9C%80%E5%A4%A7%E4%BA%A4%E6%8D%A2/","title":"Leetcode 670. 最大交换"},{"content":"链接： https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x/\n难度： 简单\n题目描述 给你一个非负整数数组 nums 。如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。\n注意： x 不必 是 nums 的中的元素。\n如果数组 nums 是一个 特殊数组 ，请返回它的特征值 x 。否则，返回 -1 。可以证明的是，如果 nums 是特殊数组，那么其特征值 x 是 唯一的 。\n示例 1： 输入： nums = [3,5]\n输出： 2\n解释： 有 2 个元素（3 和 5）大于或等于 2 。\n示例 2： 输入： nums = [0,0]\n输出： -1\n解释： 没有满足题目要求的特殊数组，故而也不存在特征值 x 。\n如果 x = 0，应该有 0 个元素 \u0026gt;= x，但实际有 2 个。\n如果 x = 1，应该有 1 个元素 \u0026gt;= x，但实际有 0 个。\n如果 x = 2，应该有 2 个元素 \u0026gt;= x，但实际有 0 个。\nx 不能取更大的值，因为 nums 中只有两个元素。\n示例 3： 输入： nums = [0,4,3,0,4]\n输出： 3\n解释： 有 3 个元素大于或等于 3 。\n示例 4： 输入： nums = [3,6,7,7,0]\n输出： -1\n提示： 1 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 1000 解题思路 排序 按从大到小的顺序排序。\n要使得 nums 中恰好有 x 个元素 大于或者等于 x，则对于排序后的元素，nums[x-1] 应大于等于 x，并且 nums[x] 严格小于 x。\n遍历该数组，依次进行判断是否存在。\nfunc specialArray(nums []int) int { sort.Sort(sort.Reverse(sort.IntSlice(nums))) for i := range nums { if nums[i] \u0026gt;= i+1 \u0026amp;\u0026amp; (i+1 == len(nums) || nums[i+1] \u0026lt;= i) { return i + 1 } } return -1 } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(nums) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-09-12T10:00:06+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1608.-%E7%89%B9%E6%AE%8A%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E5%BE%81%E5%80%BC/","title":"Leetcode 1608. 特殊数组的特征值"},{"content":"链接： https://leetcode.cn/problems/trim-a-binary-search-tree/\n难度： 中等\n题目描述 给你二叉搜索树的根节点 root ，同时给定最小边界 low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在 [low, high] 中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。\n所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。\n示例 1： 输入： root = [1,0,2], low = 1, high = 2\n输出： [1,null,2]\n示例 2： 输入： root = [3,0,4,null,2,null,null,1], low = 1, high = 3\n输出： [3,2,null,1]\n提示： 树中节点数在范围 [1, 104] 内 0 \u0026lt;= Node.val \u0026lt;= 104 树中每个节点的值都是 唯一 的 题目数据保证输入是一棵有效的二叉搜索树 0 \u0026lt;= low \u0026lt;= high \u0026lt;= 104 解题思路 递归 对于树的每个节点而言，有三种情况：\n当值在区间 [low, high] 中时，返回该节点，继续修建左右子树，并更新。 当值 \u0026lt; low 时，该节点与其左子树也都 \u0026lt; low ，修剪右子树代替该节点。 当值 \u0026gt; low 时，该节点与其右子树也都 \u0026gt; low ，修剪左子树代替该节点。 func trimBST(root *TreeNode, low int, high int) *TreeNode { if root == nil { return nil } if root.Val \u0026lt; low { return trimBST(root.Right, low, high) } if root.Val \u0026gt; high { return trimBST(root.Left, low, high) } root.Left = trimBST(root.Left, low, high) root.Right = trimBST(root.Right, low, high) return root } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(N) $ ","date":"2022-09-10T08:36:43+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-669.-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","title":"Leetcode 669. 修剪二叉搜索树"},{"content":"链接： https://leetcode.cn/problems/crawler-log-folder/\n难度： 简单\n题目描述 每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。\n下面给出对变更操作的说明：\n\u0026quot;../\u0026quot; ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 继续停留在当前文件夹 。 \u0026quot;./\u0026quot; ：继续停留在当前文件夹。 \u0026quot;x/\u0026quot; ：移动到名为 x 的子文件夹中。题目数据 保证总是存在文件夹 x 。 给你一个字符串列表 logs ，其中 logs[i] 是用户在 ith 步执行的操作。\n文件系统启动时位于主文件夹，然后执行 logs 中的操作。\n执行完所有变更文件夹操作后，请你找出 返回主文件夹所需的最小步数 。\n示例 1： 输入： logs = [\u0026ldquo;d1/\u0026rdquo;,\u0026ldquo;d2/\u0026rdquo;,\u0026quot;../\u0026quot;,\u0026ldquo;d21/\u0026rdquo;,\u0026quot;./\u0026quot;]\n输出： 2\n解释： 执行 \u0026ldquo;../\u0026rdquo; 操作变更文件夹 2 次，即可回到主文件夹\n示例 2： 输入： logs = [\u0026ldquo;d1/\u0026rdquo;,\u0026ldquo;d2/\u0026rdquo;,\u0026quot;./\u0026quot;,\u0026ldquo;d3/\u0026rdquo;,\u0026quot;../\u0026quot;,\u0026ldquo;d31/\u0026rdquo;]\n输出： 3\n示例 3： 输入： logs = [\u0026ldquo;d1/\u0026rdquo;,\u0026quot;../\u0026quot;,\u0026quot;../\u0026quot;,\u0026quot;../\u0026quot;]\n输出： 0\n提示： 1 \u0026lt;= logs.length \u0026lt;= 103 2 \u0026lt;= logs[i].length \u0026lt;= 10 logs[i] 包含小写英文字母，数字，'.' 和 '/' logs[i] 符合语句中描述的格式 文件夹名称由小写英文字母和数字组成 解题思路 模拟 维护一个从主文件夹开始的嵌套文件夹的深度，对于每一个 logs[i]，判断：\n当等于 \u0026quot;../\u0026quot; 时，若当前深度为 0 ，则忽略，否则深度 -1; 当等于 \u0026quot;./\u0026quot; 时，深度不变； 当等于 \u0026quot;x/\u0026quot; 时，深度 +1。 最后得到的深度信息就是返回到主文件夹的 最小步数 。\nfunc minOperations(logs []string) int { depth := 0 for _, log := range logs { switch log { case \u0026#34;../\u0026#34;: if depth != 0 { depth-- } case \u0026#34;./\u0026#34;: break default: depth++ } } return depth } 复杂度 时间复杂度：$ O(N), N = len(logs) $ 空间复杂度：$ O(1) $ ","date":"2022-09-09T19:53:06+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1598.-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E6%90%9C%E9%9B%86%E5%99%A8/","title":"Leetcode 1598. 文件夹操作日志搜集器"},{"content":"链接： https://leetcode.cn/problems/beautiful-arrangement-ii/\n难度： 中等\n题目描述 给你两个整数 n 和 k ，请你构造一个答案列表 answer ，该列表应当包含从 1 到 n 的 n 个不同正整数，并同时满足下述条件：\n假设该列表是 answer = [a1, a2, a3, \u0026hellip; , an] ，那么列表 [|a1 - a2|, |a2 - a3|, |a3 - a4|, \u0026hellip; , |an-1 - an|] 中应该有且仅有 k 个不同整数。 返回列表 answer 。如果存在多种答案，只需返回其中 任意一种 。\n示例 1： 输入： n = 3, k = 1\n输出： [1, 2, 3]\n解释： [1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1\n示例 2： 输入： n = 3, k = 2\n输出： [1, 3, 2]\n解释： [1, 3, 2] 包含 3 个范围在 1-3 的不同整数，并且 [2, 1] 中有且仅有 2 个不同整数：1 和 2\n提示： 1 \u0026lt;= k \u0026lt; n \u0026lt;= 104 解题思路 模拟 对于连续的自然数队列，按照顺序分别从头尾依次取出数字构成新的排列，其相邻元素差值列表不同整数的数量即为 元素数量 - 1 个。\n根据题意，需保留 k 不同的值，则需要 k + 1 个元素排列，剩余的最开始的 n - k - 1 个数按照升序顺序排列即可。\nfunc constructArray(n int, k int) []int { answer := make([]int, 0, n) i := 1 for ; i \u0026lt; n-k; i++ { answer = append(answer, i) } for j := n; i \u0026lt;= j; i, j = i+1, j-1 { answer = append(answer, i) if i == j { break } answer = append(answer, j) } return answer } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2022-09-08T10:23:01+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-667.-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97-ii/","title":"Leetcode 667. 优美的排列 II"},{"content":"链接： https://leetcode.cn/problems/rearrange-spaces-between-words/\n难度： 简单\n题目描述 给你一个字符串 text ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 text 至少包含一个单词 。\n请你重新排列空格，使每对相邻单词之间的空格数目都 相等 ，并尽可能 最大化 该数目。如果不能重新平均分配所有空格，请 将多余的空格放置在字符串末尾 ，这也意味着返回的字符串应当与原 text 字符串的长度相等。\n返回 重新排列空格后的字符串 。\n示例 1： 输入： text = \u0026quot; this is a sentence \u0026quot;\n输出： \u0026ldquo;this is a sentence\u0026rdquo;\n解释： 总共有 9 个空格和 4 个单词。可以将 9 个空格平均分配到相邻单词之间，相邻单词间空格数为：9 / (4-1) = 3 个。\n示例 2： 输入： text = \u0026quot; practice makes perfect\u0026quot;\n输出： \u0026ldquo;practice makes perfect \u0026quot;\n解释： 总共有 7 个空格和 3 个单词。7 / (3-1) = 3 个空格加上 1 个多余的空格。多余的空格需要放在字符串的末尾。\n示例 3： 输入： text = \u0026ldquo;hello world\u0026rdquo;\n输出： \u0026ldquo;hello world\u0026rdquo;\n示例 4： 输入： text = \u0026quot; walks udp package into bar a\u0026rdquo;\n输出： \u0026ldquo;walks udp package into bar a \u0026quot;\n示例 5： 输入： text = \u0026ldquo;a\u0026rdquo; 输出： \u0026ldquo;a\u0026rdquo;\n提示： 1 \u0026lt;= text.length \u0026lt;= 100 text 由小写英文字母和 ' ' 组成 text 中至少包含一个单词 解题思路 模拟 求得所有空格和单词的数量：\n当仅有一个单词时，将空格全部放到该单词之后； 当单词数量大于 1 时，相邻单词之间的数量由 空格数量 / (单词数量 - 1) 向下取整，多余空格添加到末尾。 func reorderSpaces(text string) string { spaces := 0 words := 0 for i := range text { // 空格数量 if text[i] == \u0026#39; \u0026#39; { spaces++ continue } // 单词数量，或者开头，或者和上一个单词用空格隔开 if i == 0 || text[i-1] == \u0026#39; \u0026#39; { words++ } } // 间隔 interval := spaces if words \u0026gt; 1 { interval = spaces / (words - 1) } ans := make([]byte, 0, len(text)) for text != \u0026#34;\u0026#34; { text = strings.TrimLeft(text, \u0026#34; \u0026#34;) // 添加单词 for ; len(text) \u0026gt; 0 \u0026amp;\u0026amp; text[0] != \u0026#39; \u0026#39;; text = text[1:] { ans = append(ans, text[0]) } // 补充空格 for j := 0; len(ans) \u0026lt; cap(ans) \u0026amp;\u0026amp; j \u0026lt; interval; j++ { ans = append(ans, \u0026#39; \u0026#39;) } } // 有多余空格，添加到末尾 for len(ans) \u0026lt; cap(ans) { ans = append(ans, \u0026#39; \u0026#39;) } return string(ans) } 复杂度 时间复杂度：$ O(N), N = len(text) $ 空间复杂度：$ O(1) $ ","date":"2022-09-07T19:44:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1592.-%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%8D%95%E8%AF%8D%E9%97%B4%E7%9A%84%E7%A9%BA%E6%A0%BC/","title":"Leetcode 1592. 重新排列单词间的空格"},{"content":"链接： https://leetcode.cn/problems/find-duplicate-subtrees/\n难度： 中等\n题目描述 给定一棵二叉树 root，返回所有重复的子树。\n对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。\n如果两棵树具有相同的结构和相同的结点值，则它们是重复的。\n示例 1： 输入： root = [1,2,3,4,null,2,4,null,null,4]\n输出： [[2,4],[4]]\n示例 2： 输入： root = [2,1,1]\n输出： [[1]]\n示例 3： 输入： root = [2,2,2,3,null,3,null] 输出： [[2,3],[3]]\n提示： 树中的结点数在 [1,104]范围内。 -200 \u0026lt;= Node.val \u0026lt;= 200 解题思路 先序遍历 + 哈希 使用 ()x() 的字符串唯一的标识一颗子树，并通过哈希表记录相同子树的出现次数。\n每当出现两次时，将当前子树根节点加入到结果队列中。\nfunc findDuplicateSubtrees(root *TreeNode) []*TreeNode { ans := make([]*TreeNode, 0, 1) exist := make(map[string]int) var dfs func(node *TreeNode) string dfs = func(node *TreeNode) string { if node == nil { return \u0026#34;\u0026#34; } s := fmt.Sprintf(\u0026#34;(%s)%d(%s)\u0026#34;, dfs(node.Left), node.Val, dfs(node.Right)) exist[s]++ if exist[s] == 2 { ans = append(ans, node) } return s } dfs(root) return ans } 复杂度 时间复杂度：$ O(N) $ 空间复杂度：$ O(N) $ ","date":"2022-09-05T10:09:31+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-652.-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/","title":"Leetcode 652. 寻找重复的子树"},{"content":"链接： https://leetcode.cn/problems/special-positions-in-a-binary-matrix/\n难度： 简单\n题目描述 给你一个大小为 rows x cols 的矩阵 mat，其中 mat[i][j] 是 0 或 1，请返回 矩阵 mat 中特殊位置的数目 。\n特殊位置 定义：如果 mat[i][j] == 1 并且第 i 行和第 j 列中的所有其他元素均为 0（行和列的下标均 从 0 开始 ），则位置 (i, j) 被称为特殊位置。\n示例 1： 输入： mat = [[1,0,0],\n[0,0,1],\n[1,0,0]]\n输出： 1\n解释： (1,2) 是一个特殊位置，因为 mat[1][2] == 1 且所处的行和列上所有其他元素都是 0\n示例 2： 输入： mat = [[1,0,0],\n[0,1,0],\n[0,0,1]]\n输出： 3\n解释： (0,0), (1,1) 和 (2,2) 都是特殊位置\n示例 3： 输入： mat = [[0,0,0,1],\n[1,0,0,0],\n[0,1,1,0],\n[0,0,0,0]]\n输出： 2\n示例 4： 输入： mat = [[0,0,0,0,0],\n[1,0,0,0,0],\n[0,1,0,0,0],\n[0,0,1,0,0],\n[0,0,0,1,1]]\n输出： 3\n提示： rows == mat.length cols == mat[i].length 1 \u0026lt;= rows, cols \u0026lt;= 100 mat[i][j] 是 0 或 1 解题思路 遍历 首先按行遍历矩阵，找出每一行中仅出现一次 1 的坐标，然后判断找出的这些坐标是否也是列中唯一的 1。\nfunc modifyString(s string) string { t := []byte(s) for i := 0; i \u0026lt; len(t); i++ { if t[i] != \u0026#39;?\u0026#39; { continue } // 前一个字符 prev := byte(\u0026#39;$\u0026#39;) if i \u0026gt; 0 { prev = t[i-1] } // 后一个字符 post := byte(\u0026#39;$\u0026#39;) if i \u0026lt; len(t)-1 \u0026amp;\u0026amp; t[i+1] != \u0026#39;?\u0026#39; { post = t[i+1] } // 寻找可以替换的字符 for char := byte(\u0026#39;a\u0026#39;); char \u0026lt; \u0026#39;z\u0026#39;; char++ { if char != prev \u0026amp;\u0026amp; char != post { t[i] = char break } } } return string(t) } 复杂度 时间复杂度：$ O(MN), M = len(mat), N = len(mat[i]) $ 空间复杂度：$ O(1) $ ","date":"2022-09-04T09:43:16+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1582.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%8D%E7%BD%AE/","title":"Leetcode 1582. 二进制矩阵中的特殊位置"},{"content":"链接： https://leetcode.cn/problems/maximum-length-of-pair-chain/\n难度： 中等\n题目描述 给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。\n现在，我们定义一种跟随关系，当且仅当 b \u0026lt; c 时，数对 (c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。\n给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。\n示例： 输入： [[1,2], [2,3], [3,4]]\n输出： 2\n解释： 最长的数对链是 [1,2] -\u0026gt; [3,4]\n提示： 给出数对的个数在 [1, 1000] 范围内。 解题思路 排序 + 贪心 为使得链长度更大，应选择第二个数字尽量小的数对。\n以数对第二个数字的大小关系进行排序。遍历整个数组，当数对第一个数字比当前链表尾部数对的第二个数字更大时，添加到链表末尾，继续处理直到遍历到数组尾。\nfunc findLongestChain(pairs [][]int) int { sort.Slice(pairs, func(i, j int) bool { return pairs[i][1] \u0026lt; pairs[j][1] }) ans := 0 i := math.MinInt for _, p := range pairs { if i \u0026lt; p[0] { i = p[1] ans++ } } return ans } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(pairs) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-09-03T09:17:54+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-646.-%E6%9C%80%E9%95%BF%E6%95%B0%E5%AF%B9%E9%93%BE/","title":"Leetcode 646. 最长数对链"},{"content":"链接： https://leetcode.cn/problems/longest-univalue-path/\n难度： 中等\n题目描述 给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。\n两个节点之间的路径长度 由它们之间的边数表示。\n示例 1： 输入： root = [5,4,5,1,1,5]\n输出： 2\n示例 2： 输入： root = [1,4,5,4,4,5]\n输出： 2\n提示： 树的节点数的范围是 [0, 104] -1000 \u0026lt;= Node.val \u0026lt;= 1000 树的深度将不超过 1000 解题思路 深度优先搜索 对于一棵树的根节点而言，搜索以根节点为起始的的 左侧 最长路径和 右侧 最长路径，求和即可得到关联到 当前根节点 的最长路径。\n对于树中每个节点执行上述搜索，最终得到 全局 最长路径。\nfunc longestUnivaluePath(root *TreeNode) int { // 判空 if root == nil { return 0 } max := 0 // 最大路径 var dfs func(node *TreeNode, val int) int dfs = func(node *TreeNode, val int) int { // 遍历结束 if node == nil { return 0 } // 当前节点和父节点不同，父节点相关路径搜索结束，搜索该子树的路径 if node.Val != val { dfs(node, node.Val) return 0 } // 左右两侧路径最大值 l := dfs(node.Left, val) r := dfs(node.Right, val) // 更新最大值 if max \u0026lt; l+r { max = l + r } // 返回较大的路径 if l \u0026lt; r { return r + 1 } return l + 1 } dfs(root, root.Val) return max } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(N) $ ","date":"2022-09-02T19:49:50+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-687.-%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/","title":"Leetcode 687. 最长同值路径"},{"content":"链接： https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/\n难度： 简单\n题目描述 给你一个数组 prices ，其中 prices[i] 是商店里第 i 件商品的价格。\n商店里正在进行促销活动，如果你要买第 i 件商品，那么你可以得到与 prices[j] 相等的折扣，其中 j 是满足 j \u0026gt; i 且 prices[j] \u0026lt;= prices[i] 的 最小下标 ，如果没有满足条件的 j ，你将没有任何折扣。\n请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。\n示例 1： 输入： prices = [8,4,6,2,3]\n输出： [4,2,4,2,3]\n解释：\n商品 0 的价格为 price[0]=8 ，你将得到 prices[1]=4 的折扣，所以最终价格为 8 - 4 = 4 。\n商品 1 的价格为 price[1]=4 ，你将得到 prices[3]=2 的折扣，所以最终价格为 4 - 2 = 2 。\n商品 2 的价格为 price[2]=6 ，你将得到 prices[3]=2 的折扣，所以最终价格为 6 - 2 = 4 。\n商品 3 和 4 都没有折扣。\n示例 2： 输入： prices = [1,2,3,4,5]\n输出： [1,2,3,4,5]\n解释： 在这个例子中，所有商品都没有折扣。\n示例 3： 输入： prices = [10,1,1,6]\n输出： [9,0,1,6]\n提示： 1 \u0026lt;= prices.length \u0026lt;= 500 1 \u0026lt;= prices[i] \u0026lt;= 103 解题思路 模拟 遍历整个数组，对于每个元素，向前查找其折扣。\nfunc finalPrices(prices []int) []int { ans := make([]int, len(prices)) for i := range prices { discount := 0 for j := i + 1; j \u0026lt; len(prices); j++ { if prices[j] \u0026lt;= prices[i] { discount = prices[j] break } } ans[i] = prices[i] - discount } return ans } 复杂度 时间复杂度：$ O(N^2), N = len(prices) $ 空间复杂度：$ O(1) $ 模拟 遍历整个数组，对于每个元素，向前查找其折扣。\nfunc finalPrices(prices []int) []int { ans := make([]int, len(prices)) for i := range prices { discount := 0 for j := i + 1; j \u0026lt; len(prices); j++ { if prices[j] \u0026lt;= prices[i] { discount = prices[j] break } } ans[i] = prices[i] - discount } return ans } 复杂度 时间复杂度：$ O(N^2), N = len(prices) $ 空间复杂度：$ O(1) $ ","date":"2022-09-01T10:08:48+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1475.-%E5%95%86%E5%93%81%E6%8A%98%E6%89%A3%E5%90%8E%E7%9A%84%E6%9C%80%E7%BB%88%E4%BB%B7%E6%A0%BC/","title":"Leetcode 1475. 商品折扣后的最终价格"},{"content":"链接： https://leetcode.cn/problems/validate-stack-sequences/\n难度： 中等\n题目描述 给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。\n示例 1： 输入： pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n输出： true\n解释： 我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -\u0026gt; 4,\npush(5), pop() -\u0026gt; 5, pop() -\u0026gt; 3, pop() -\u0026gt; 2, pop() -\u0026gt; 1\n示例 2： 输入： pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n输出： false\n解释： 1 不能在 2 之前弹出。\n提示： 1 \u0026lt;= pushed.length \u0026lt;= 1000 0 \u0026lt;= pushed[i] \u0026lt;= 1000 pushed 的所有元素 互不相同 popped.length == pushed.length popped 是 pushed 的一个排列 解题思路 栈 由于所有元素均不相同，使用一个栈进行模拟。\n遍历出栈序列，对于每个元素依次执行一下判定：\n首先尝从栈顶寻找该元素，若找到执行出栈操作； 若未找到，后续入展序列依次入栈，在此过程找到时停止；若找不到说明不满足，返回 false。 所有出栈元素能依次全部找到，返回 true。\nfunc validateStackSequences(pushed []int, popped []int) bool { stack := make([]int, 0, len(pushed)) for i, j := 0, 0; j \u0026lt; len(popped); j++ { // 当前栈顶元素即为 pop 元素，弹出，并处理下一个 if len(stack) \u0026gt; 0 \u0026amp;\u0026amp; popped[j] == stack[len(stack)-1] { stack = stack[:len(stack)-1] continue } // 尝试进行push 操作，向后寻找 for ; i \u0026lt; len(pushed) \u0026amp;\u0026amp; pushed[i] != popped[j]; i++ { stack = append(stack, pushed[i]) } // 没找到，不满足条件 if i == len(pushed) { return false } else { i++ // 找到跳过 } } return true } 复杂度 时间复杂度：$ O(N), N = len(pushed) $ 空间复杂度：$ O(N) $ ","date":"2022-08-31T11:52:09+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-946.-%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/","title":"Leetcode 946. 验证栈序列"},{"content":"链接： https://leetcode.cn/problems/maximum-binary-tree-ii/\n难度： 中等\n题目描述 最大树 定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。\n给你最大树的根节点 root 和一个整数 val 。\n就像 之前的问题 那样，给定的树是利用 Construct(a) 例程从列表 a（root = Construct(a)） 递归地构建的：\n如果 a 为空，返回 null 。 否则，令 a[i] 作为 a 的最大元素。创建一个值为 a[i] 的根节点 root 。 root 的左子树将被构建为 Construct([a[0], a[1], ..., a[i - 1]]) 。 root 的右子树将被构建为 Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]]) 。 返回 root 。 请注意，题目没有直接给出 a ，只是给出一个根节点 root = Construct(a) 。\n假设 b 是 a 的副本，并在末尾附加值 val。题目数据保证 b 中的值互不相同。\n返回 Construct(b) 。\n示例 1： 输入： root = [4,1,3,null,null,2], val = 5\n输出： [5,4,null,1,3,null,null,2]\n解释： a = [1,4,2,3], b = [1,4,2,3,5]\n示例 2： 输入： root = [5,2,4,null,1], val = 3\n输出： [5,2,4,null,1,null,3]\n解释： a = [2,1,5,4], b = [2,1,5,4,3]\n示例 3： 输入： root = [5,2,3,null,1], val = 4\n输出： [5,2,4,null,1,3]\n解释： a = [2,1,5,3], b = [2,1,5,3,4]\n提示： 树中节点数目在范围 [1, 100] 内 1 \u0026lt;= Node.val \u0026lt;= 100 树中的所有值 互不相同 1 \u0026lt;= val \u0026lt;= 100 解题思路 递归 根据题意，由于附加值 val 添加到末尾，所以影响的是右子树，忽略左子树部分。\n当附加值大于当前节点时，使用附加值节点作为子树的根，将原子树设置为该节点的左子树； 当附加值小于当前节点时，递归的搜索处理右子树； 当右子树为空时，添加该附加值节点。 func insertIntoMaxTree(root *TreeNode, val int) *TreeNode { if root == nil { return \u0026amp;TreeNode{ Val: val, } } if val \u0026gt; root.Val { return \u0026amp;TreeNode{ Val: val, Left: root, } } root.Right = insertIntoMaxTree(root.Right, val) return root } 复杂度 时间复杂度：$ O(N), N = size(root) $ 空间复杂度：$O(1) $ ","date":"2022-08-30T10:09:45+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-998.-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91-ii/","title":"Leetcode 998. 最大二叉树 II"},{"content":"链接： https://leetcode.cn/problems/shuffle-the-array/\n难度： 简单\n题目描述 给你一个数组 nums ，数组中有 2n 个元素，按 [x1,x2,...,xn,y1,y2,...,yn] 的格式排列。\n请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。\n示例 1： 输入： nums = [2,5,1,3,4,7], n = 3\n输出： [2,3,5,4,1,7]\n解释： 由于 x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 ，所以答案为 [2,3,5,4,1,7]\n示例 2： 输入： nums = [1,2,3,4,4,3,2,1], n = 4\n输出： [1,4,2,3,3,2,4,1]\n示例 3： 输入： nums = [1,1,2,2], n = 2\n输出： [1,2,1,2]\n提示： 1 \u0026lt;= n \u0026lt;= 500 nums.length == 2n 1 \u0026lt;= nums[i] \u0026lt;= 103 解题思路 模拟 按照顺序从前 n 个和后 n 个元素中交替去除元素，依次添加到结果队列中。\nfunc shuffle(nums []int, n int) []int { ans := make([]int, 0, len(nums)) for i := 0; i \u0026lt; n; i++ { ans = append(ans, nums[i], nums[i+n]) } return ans } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2022-08-29T10:08:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1470.-%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84/","title":"Leetcode 1470. 重新排列数组"},{"content":"链接： https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/\n难度： 困难\n题目描述 f(x) 是 x! 末尾是 0 的数量。回想一下 x! = 1 * 2 * 3 * ... * x，且 0! = 1 。\n例如， f(3) = 0 ，因为 3! = 6 的末尾没有 0 ；而 f(11) = 2 ，因为 11!= 39916800 末端有 2 个 0 。 给定 k，找出返回能满足 f(x) = k 的非负整数 x 的数量。\n示例 1： 输入： k = 0\n输出： 5\n解释： 0!, 1!, 2!, 3!, 和 4! 均符合 k = 0 的条件。\n示例 2： 输入： k = 5\n输出： 0\n解释： 没有匹配到这样的 x!，符合 k = 5 的条件。\n示例 3： 输入： k = 3\n输出： 5\n提示： 0 \u0026lt;= k \u0026lt;= 109 解题思路 二分查找 阶乘末尾零的数量与因子 2 和 5 的数量相关，而 2 的数量一定是大于 5 的，所以计算求得 5 的数量即可得到阶乘末尾 0 的数量。\n对于 [0, x] 的自然数，其含有因子 5 的数字有 $\\lfloor\\frac{x}{5}\\rfloor$ 个，部分阶乘数字（如25， 125等）含有多个因子 5，需要将这一部分计算在内，从而得到阶乘末尾 0 数量的计算公式：\n$$ zeroes(x) = \\sum\\limits_{i=1}^{\\lfloor\\frac{x}{5}\\rfloor}{\\lfloor\\frac{x}{5^i}\\rfloor} $$\n根据题意加以分析，发现当末尾有 k 个 0 的阶乘 x! 不存在时，结果为 0；否则，其距离下个因子 5 有 5 个数，结果为 5。\n使用二分查找寻找对应 x 的值。初始范围为 [0, 5k]。\nfunc zeros(n int) int { ans := 0 for i := 5; i \u0026lt;= n; i *= 5 { ans += n / i } return ans } func preimageSizeFZF(k int) int { var binarySearch func(l, r int) bool binarySearch = func(l, r int) bool { if l \u0026gt; r { return false } mid := (l + r) / 2 switch t := zeros(mid); { case t == k: fmt.Println(mid, t) return true case t \u0026gt; k: return binarySearch(l, mid-1) default: return binarySearch(mid+1, r) } } if binarySearch(0, 5*k) { return 5 } return 0 } 复杂度 时间复杂度：$ O(\\log^2{k}), N = len(arr) $ 空间复杂度：$ O(1) $ ","date":"2022-08-28T08:05:40+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-793.-%E9%98%B6%E4%B9%98%E5%87%BD%E6%95%B0%E5%90%8E-k-%E4%B8%AA%E9%9B%B6/","title":"Leetcode 793. 阶乘函数后 K 个零"},{"content":"链接： https://leetcode.cn/problems/maximum-width-of-binary-tree/\n难度： 中等\n题目描述 给你一棵二叉树的根节点 root ，返回树的 最大宽度 。\n树的 最大宽度 是所有层中最大的 宽度 。\n每一层的 宽度 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 null 节点，这些 null 节点也计入长度。\n题目数据保证答案将会在 32 位 带符号整数范围内。\n示例 1： 输入： root = [1,3,2,5,3,null,9]\n输出： 4\n解释： 最大宽度出现在树的第 3 层，宽度为 4 (5,3,null,9) 。\n示例 2： 输入： root = [1,3,2,5,null,null,9,6,null,7]\n输出： 7\n解释： 最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。\n示例 3： 输入： root = [1,3,2,5]\n输出： 2\n解释： 最大宽度出现在树的第 2 层，宽度为 2 (3,2) 。\n提示： 树中节点的数目范围是 [1, 3000] -100 \u0026lt;= Node.val \u0026lt;= 100 解题思路 层序遍历 层序遍历，求得每一个层宽度，进而得到最大宽度。\n由于会计算空节点，采用满二叉树编号的方式，初始根节点编号为 1。对于编号为 i 的节点，其左子节点编号为 2i，右子节点编号为 2i + 1。\n同层最大和最小编号之差再加一即为当前层宽度。\nfunc widthOfBinaryTree(root *TreeNode) int { q := list.New() q.PushBack(\u0026amp;TreeNode{ Val: 1, Left: root.Left, Right: root.Right, }) ans := 0 for q.Len() \u0026gt; 0 { min, max := math.MaxInt, math.MinInt for i := q.Len(); i \u0026gt; 0; i-- { n := q.Remove(q.Front()).(*TreeNode) if min \u0026gt; n.Val { min = n.Val } if max \u0026lt; n.Val { max = n.Val } if n.Left != nil { q.PushBack(\u0026amp;TreeNode{ Val: n.Val * 2, Left: n.Left.Left, Right: n.Left.Right, }) } if n.Right != nil { q.PushBack(\u0026amp;TreeNode{ Val: n.Val*2 + 1, Left: n.Right.Left, Right: n.Right.Right, }) } } if ans \u0026lt; max-min+1 { ans = max - min + 1 } } return ans } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(N) $ 先序遍历 采用上述编号的方法，先序遍历的时候进行传递，同时传递深度信息。\n先序遍历首次遍历到的一定是最左边的节点，进行记录，后续遍历到同层节点时求差即可。\nfunc widthOfBinaryTree(root *TreeNode) int { ans := 1 minNo := make(map[int]int) var dfs func(node *TreeNode, depth int, no int) dfs = func(node *TreeNode, depth int, no int) { if node == nil { return } if _, ok := minNo[depth]; !ok { minNo[depth] = no } else if ans \u0026lt; no-minNo[depth]+1 { ans = no - minNo[depth] + 1 } dfs(node.Left, depth+1, no*2) dfs(node.Right, depth+1, no*2+1) } dfs(root, 0, 1) return ans } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(N) $ ","date":"2022-08-27T10:57:48+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-662.-%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%A4%A7%E5%AE%BD%E5%BA%A6/","title":"Leetcode 662. 二叉树最大宽度"},{"content":"链接： https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/\n难度： 简单\n题目描述 给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。\n请你计算并返回该式的最大值。\n示例 1： 输入： nums = [3,4,5,2]\n输出： 12\n解释： 如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值，(nums[1]-1)(nums[2]-1) = (4-1)(5-1) = 3*4 = 12 。\n示例 2： 输入： nums = [1,5,4,5]\n输出： 16\n解释： 选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。\n示例 3： 输入： nums = [3,7]\n输出： 12\n提示： 2 \u0026lt;= nums.length \u0026lt;= 500 1 \u0026lt;= nums[i] \u0026lt;= 103 解题思路 枚举 枚举所有的二元组，求得积的最大值。\nfunc maxProduct(nums []int) int { ans := 0 for i := len(nums) - 2; i \u0026gt;= 0; i-- { for j := i + 1; j \u0026lt; len(nums); j++ { prod := (nums[i] - 1) * (nums[j] - 1) if ans \u0026lt; prod { ans = prod } } } return ans } 复杂度 时间复杂度：$ O(N^2), N = len(nums) $ 空间复杂度：$ O(1) $ 求解最大值和次大值 因为给定的数组元素的取值范围是大于 2 的，也就是说找出最大的两个元素，从而求得的乘积最大。\n遍历一次数组，维护最大值和此大值。\nfunc maxProduct(nums []int) int { max, secondary := 0, 0 for i := range nums { if max \u0026lt; nums[i] { max, secondary = nums[i], max continue } if secondary \u0026lt; nums[i] { secondary = nums[i] } } return (max - 1) * (secondary - 1) } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2022-08-26T10:01:30+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1464.-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/","title":"Leetcode 1464. 数组中两元素的最大乘积"},{"content":"链接： https://leetcode.cn/problems/find-k-closest-elements/\n难度： 中等\n题目描述 给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。\n整数 a 比整数 b 更接近 x 需要满足：\n|a - x| \u0026lt; |b - x| 或者 |a - x| == |b - x| 且 a \u0026lt; b 示例 1： 输入： arr = [1,2,3,4,5], k = 4, x = 3\n输出： [1,2,3,4]\n示例 2： 输入： arr = [1,2,3,4,5], k = 4, x = -1\n输出： [1,2,3,4]\n提示： 1 \u0026lt;= k \u0026lt;= arr.length 1 \u0026lt;= arr.length \u0026lt;= 104 arr 按 升序 排列 -104 \u0026lt;= arr[i], x \u0026lt;= 104 解题思路 二分查找 + 双指针 由于原数组是已排好序的，首先使用二分查找定位到距离 x 最近的位置。\n然后使用两个指针分别向前和后遍历元素，两两比较取最小的那一个，直到区间范围为 k 为止。\nfunc findClosestElements(arr []int, k int, x int) []int { if len(arr) == k { return arr } j := sort.SearchInts(arr, x) i := j - 1 for j-i \u0026lt;= k { if i == -1 { j++ continue } if j == len(arr) { i-- continue } t := arr[j] - x - (x - arr[i]) if t \u0026gt;= 0 { i-- continue } j++ } ans := make([]int, 0, k) for i++; i \u0026lt; j; i++ { ans = append(ans, arr[i]) } return ans } 复杂度 时间复杂度：$ O(\\log{N}+k), N = len(arr) $ 空间复杂度：$ O(1) $ ","date":"2022-08-25T10:08:54+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-658.-%E6%89%BE%E5%88%B0-k-%E4%B8%AA%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E5%85%83%E7%B4%A0/","title":"Leetcode 658. 找到 K 个最接近的元素"},{"content":"链接： https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-sub-arrays/\n难度： 简单\n题目描述 给你两个长度相同的整数数组 target 和 arr 。每一步中，你可以选择 arr 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。\n如果你能让 arr 变得与 target 相同，返回 True；否则，返回 False 。\n示例 1： 输入： target = [1,2,3,4], arr = [2,4,1,3]\n输出： true\n解释： 你可以按照如下步骤使 arr 变成 target：\n1- 翻转子数组 [2,4,1] ，arr 变成 [1,4,2,3]\n2- 翻转子数组 [4,2] ，arr 变成 [1,2,4,3]\n3- 翻转子数组 [4,3] ，arr 变成 [1,2,3,4]\n上述方法并不是唯一的，还存在多种将 arr 变成 target 的方法。\n示例 2： 输入： target = [7], arr = [7]\n输出： true\n解释： arr 不需要做任何翻转已经与 target 相等。\n示例 3： 输入： target = [3,7,9], arr = [3,7,11]\n输出： false\n解释： arr 没有数字 9 ，所以无论如何也无法变成 target 。\n提示： target.length == arr.length 1 \u0026lt;= target.length \u0026lt;= 1000 1 \u0026lt;= target[i] \u0026lt;= 1000 1 \u0026lt;= arr[i] \u0026lt;= 1000 解题思路 哈希 可以任意的翻转子数组，相当于可以任意的移动数组中的元素，只要判断两个数组中的元素值和数量是否相同即可。\n使用哈希表实现。\nfunc canBeEqual(target []int, arr []int) bool { cnt := make(map[int]int) for _, num := range target { cnt[num]++ } for _, num := range arr { cnt[num]-- if cnt[num] \u0026lt; 0 { return false } } return true } 复杂度 时间复杂度：$ O(N), N = len(target) $ 空间复杂度：$ O(N) $ ","date":"2022-08-24T10:00:21+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1460.-%E9%80%9A%E8%BF%87%E7%BF%BB%E8%BD%AC%E5%AD%90%E6%95%B0%E7%BB%84%E4%BD%BF%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9B%B8%E7%AD%89/","title":"Leetcode 1460. 通过翻转子数组使两个数组相等"},{"content":"链接： https://leetcode.cn/problems/print-binary-tree/\n难度： 中等\n题目描述 给你一棵二叉树的根节点 root ，请你构造一个下标从 0 开始、大小为 m x n 的字符串矩阵 res ，用以表示树的 格式化布局 。构造此格式化布局矩阵需要遵循以下规则：\n树的 高度 为 height ，矩阵的行数 m 应该等于 height + 1 。 矩阵的列数 n 应该等于 2height+1 - 1 。 根节点 需要放置在 顶行 的 正中间 ，对应位置为 res[0][(n-1)/2] 。 对于放置在矩阵中的每个节点，设对应位置为 res[r][c] ，将其左子节点放置在 res[r+1][c-2height-r-1] ，右子节点放置在 res[r+1][c+2height-r-1] 。 继续这一过程，直到树中的所有节点都妥善放置。 任意空单元格都应该包含空字符串 \u0026quot;\u0026quot; 。 返回构造得到的矩阵 res 。\n示例 1： 输入： root = [1,2]\n输出：\n[[\u0026quot;\u0026quot;,\u0026ldquo;1\u0026rdquo;,\u0026quot;\u0026quot;],\n[\u0026ldquo;2\u0026rdquo;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;]]\n示例 2： 输入： root = [1,2,3,null,4]\n输出：\n[[\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026ldquo;1\u0026rdquo;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;],\n[\u0026quot;\u0026quot;,\u0026ldquo;2\u0026rdquo;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026ldquo;3\u0026rdquo;,\u0026quot;\u0026quot;],\n[\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026ldquo;4\u0026rdquo;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;]]\n提示： 树中节点数在范围 [1, 210] 内 -99 \u0026lt;= Node.val \u0026lt;= 99 树的深度在范围 [1, 10] 内 解题思路 深度优先搜索 首先先序遍历整个二叉树，计算求得树高。\n然后再次进行先序遍历，构造矩阵。\nfunc printTree(root *TreeNode) [][]string { var height func(node *TreeNode) int height = func(node *TreeNode) int { if node == nil { return 0 } h := height(node.Left) rHight := height(node.Right) if h \u0026lt; rHight { h = rHight } return h + 1 } m := height(root) n := (1 \u0026lt;\u0026lt; m) - 1 ans := make([][]string, m) for i := 0; i \u0026lt; m; i++ { ans[i] = make([]string, n) } var build func(node *TreeNode, row, col1, col2 int) build = func(node *TreeNode, row, col1, col2 int) { if node == nil { return } mid := (col1 + col2) / 2 ans[row][mid] = strconv.Itoa(node.Val) build(node.Left, row+1, col1, mid-1) build(node.Right, row+1, mid+1, col2) } build(root, 0, 0, n) return ans } 复杂度 时间复杂度：$ O(N^2), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2022-08-22T10:08:19+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-655.-%E8%BE%93%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"Leetcode 655. 输出二叉树"},{"content":"链接： https://leetcode.cn/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/\n难度： 简单\n题目描述 给你一个字符串 sentence 作为句子并指定检索词为 searchWord ，其中句子由若干用 单个空格 分隔的单词组成。请你检查检索词 searchWord 是否为句子 sentence 中任意单词的前缀。\n如果 searchWord 是某一个单词的前缀，则返回句子 sentence 中该单词所对应的下标（下标从 1 开始）。如果 searchWord 是多个单词的前缀，则返回匹配的第一个单词的下标（最小下标）。如果 searchWord 不是任何单词的前缀，则返回 -1 。\n字符串 s 的 前缀 是 s 的任何前导连续子字符串。\n示例 1： 输入： sentence = \u0026ldquo;i love eating burger\u0026rdquo;, searchWord = \u0026ldquo;burg\u0026rdquo;\n输出： 4\n解释： \u0026ldquo;burg\u0026rdquo; 是 \u0026ldquo;burger\u0026rdquo; 的前缀，而 \u0026ldquo;burger\u0026rdquo; 是句子中第 4 个单词。\n示例 2： 输入： sentence = \u0026ldquo;this problem is an easy problem\u0026rdquo;, searchWord = \u0026ldquo;pro\u0026rdquo;\n输出： 2\n解释： \u0026ldquo;pro\u0026rdquo; 是 \u0026ldquo;problem\u0026rdquo; 的前缀，而 \u0026ldquo;problem\u0026rdquo; 是句子中第 2 个也是第 6 个单词，但是应该返回最小下标 2 。\n示例 3： 输入： sentence = \u0026ldquo;i am tired\u0026rdquo;, searchWord = \u0026ldquo;you\u0026rdquo;\n输出： -1\n解释： \u0026ldquo;you\u0026rdquo; 不是句子中任何单词的前缀。\n提示： 1 \u0026lt;= sentence.length \u0026lt;= 100 1 \u0026lt;= searchWord.length \u0026lt;= 10 sentence 由小写英文字母和空格组成。 searchWord 由小写英文字母组成。 解题思路 模拟 分割 sentence，然后依次判断 searchWord 是否为某个单词的前缀，是则返回下标，否则返回 -1。\nfunc isPrefixOfWord(sentence string, searchWord string) int { idx := 1 for start, end := 0, 0; end \u0026lt;= len(sentence); end++ { if end == len(sentence) || sentence[end] == \u0026#39; \u0026#39; { if strings.HasPrefix(sentence[start:end], searchWord) { return idx } idx++ start = end + 1 } } return -1 } 复杂度 时间复杂度：$ O(N), N = len(sentence) $ 空间复杂度：$ O(1) $ ","date":"2022-08-21T09:25:47+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1455.-%E6%A3%80%E6%9F%A5%E5%8D%95%E8%AF%8D%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A5%E4%B8%AD%E5%85%B6%E4%BB%96%E5%8D%95%E8%AF%8D%E7%9A%84%E5%89%8D%E7%BC%80/","title":"Leetcode 1455. 检查单词是否为句中其他单词的前缀"},{"content":"链接： https://leetcode-cn.com/problems/2-keys-keyboard/\n难度： 中等\n题目描述 给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:\n创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 最大二叉树 。\n示例 1： 输入： nums = [3,2,1,6,0,5]\n输出： [6,3,5,null,2,0,null,null,1]\n解释： 递归调用如下所示：\n[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 空数组，无子节点。 [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 空数组，无子节点。 只有一个元素，所以子节点是一个值为 1 的节点。 [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 只有一个元素，所以子节点是一个值为 0 的节点。 空数组，无子节点。 示例 2： 输入： nums = [3,2,1]\n输出： [3,null,2,null,1]\n提示： 1 \u0026lt;= nums.length \u0026lt;= 1000 0 \u0026lt;= nums[i] \u0026lt;= 1000 nums 中的所有整数 互不相同 解题思路 递归 便利数组，找到最大值的下标，构造根节点。然后分别在两侧的子数组上递归地执行该操作，构造左右子树。\nfunc constructMaximumBinaryTree(nums []int) *TreeNode { if len(nums) == 0 { return nil } maxIdx := 0 for i := range nums { if nums[maxIdx] \u0026lt; nums[i] { maxIdx = i } } return \u0026amp;TreeNode{ Val: nums[maxIdx], Left: constructMaximumBinaryTree(nums[:maxIdx]), Right: constructMaximumBinaryTree(nums[maxIdx+1:]), } } 复杂度 时间复杂度：$ O(N^2), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2022-08-20T08:56:50+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-654.-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"Leetcode 654. 最大二叉树"},{"content":"链接： https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/\n难度： 简单\n题目描述 给你两个整数数组 startTime（开始时间）和 endTime（结束时间），并指定一个整数 queryTime 作为查询时间。\n已知，第 i 名学生在 startTime[i] 时开始写作业并于 endTime[i] 时完成作业。\n请返回在查询时间 queryTime 时正在做作业的学生人数。形式上，返回能够使 queryTime 处于区间 [startTime[i], endTime[i]]（含）的学生人数。\n示例 1： 输入： startTime = [1,2,3], endTime = [3,2,7], queryTime = 4\n输出： 1\n解释： 一共有 3 名学生。\n第一名学生在时间 1 开始写作业，并于时间 3 完成作业，在时间 4 没有处于做作业的状态。\n第二名学生在时间 2 开始写作业，并于时间 2 完成作业，在时间 4 没有处于做作业的状态。\n第三名学生在时间 3 开始写作业，预计于时间 7 完成作业，这是是唯一一名在时间 4 时正在做作业的学生。\n示例 2： 输入： startTime = [4], endTime = [4], queryTime = 4\n输出： 1\n解释： 在查询时间只有一名学生在做作业。\n示例 3： 输入： startTime = [4], endTime = [4], queryTime = 5\n输出： 0\n示例 4： 输入： startTime = [1,1,1,1], endTime = [1,3,2,4], queryTime = 7\n输出： 0\n示例 5： 输入： startTime = [9,8,7,6,5,4,3,2,1], endTime = [10,10,10,10,10,10,10,10,10], queryTime = 5\n输出： 5\n提示： startTime.length == endTime.length 1 \u0026lt;= startTime.length \u0026lt;= 100 1 \u0026lt;= startTime[i] \u0026lt;= endTime[i] \u0026lt;= 1000 1 \u0026lt;= queryTime \u0026lt;= 1000 解题思路 模拟 遍历数组，判断每个学生 i 是否在 queryTime 正在完成作业。\nfunc busyStudent(startTime []int, endTime []int, queryTime int) int { ans := 0 for i := range startTime { if startTime[i] \u0026lt;= queryTime \u0026amp;\u0026amp; queryTime \u0026lt;= endTime[i] { ans++ } } return ans } 复杂度 时间复杂度：$ O(N), N = len(startTime) $ 空间复杂度：$ O(1) $ ","date":"2022-08-19T10:10:46+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1450.-%E5%9C%A8%E6%97%A2%E5%AE%9A%E6%97%B6%E9%97%B4%E5%81%9A%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%AD%A6%E7%94%9F%E4%BA%BA%E6%95%B0/","title":"Leetcode 1450. 在既定时间做作业的学生人数"},{"content":"链接： https://leetcode.cn/problems/deepest-leaves-sum/\n难度： 中等\n题目描述 给你一棵二叉树的根节点 root ，请你返回 层数最深的叶子节点的和 。\n示例 1： 输入： root = [1,2,3,4,5,null,6,7,null,null,null,null,8]\n输出： 15\n示例 2： 输入： root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\n输出： 19\n提示： 树中节点数目在范围 [1, 104] 之间。 1 \u0026lt;= Node.val \u0026lt;= 100 解题思路 深度优先搜索 先序遍历整个二叉树，将深度信息向下传递，同时记录最大深度。\n当遇到同一深度的节点时，累加和。当遇到更深的节点时，累加和清空，重新计算。\n以上累加时，由于深度最深的点一定是叶节点，故不用区分是否为叶节点。\nfunc deepestLeavesSum(root *TreeNode) int { maxDepth := 0 sum := 0 var dfs func(node *TreeNode, depth int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if maxDepth == depth { sum += node.Val } else if maxDepth \u0026lt; depth { maxDepth = depth sum = node.Val } dfs(node.Left, depth+1) dfs(node.Right, depth+1) } dfs(root, 0) return sum } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-08-17T10:17:33+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1302.-%E5%B1%82%E6%95%B0%E6%9C%80%E6%B7%B1%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E5%92%8C/","title":"Leetcode 1302. 层数最深叶子节点的和"},{"content":"链接： https://leetcode.cn/problems/design-an-ordered-stream/\n难度： 简单\n题目描述 有 n 个 (id, value) 对，其中 id 是 1 到 n 之间的一个整数，value 是一个字符串。不存在 id 相同的两个 (id, value) 对。\n设计一个流，以 任意 顺序获取 n 个 (id, value) 对，并在多次调用时 按 id 递增的顺序 返回一些值。\n实现 OrderedStream 类：\nOrderedStream(int n) 构造一个能接收 n 个值的流，并将当前指针 ptr 设为 1 。 String[] insert(int id, String value) 向流中存储新的 (id, value) 对。存储后： 如果流存储有 id = ptr 的 (id, value) 对，则找出从 id = ptr 开始的 最长 id 连续递增序列 ，并 按顺序 返回与这些 id 关联的值的列表。然后，将 ptr 更新为最后那个 id + 1 。 否则，返回一个空列表。 示例： 输入\n[\u0026ldquo;OrderedStream\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;]\n[[5], [3, \u0026ldquo;ccccc\u0026rdquo;], [1, \u0026ldquo;aaaaa\u0026rdquo;], [2, \u0026ldquo;bbbbb\u0026rdquo;], [5, \u0026ldquo;eeeee\u0026rdquo;], [4, \u0026ldquo;ddddd\u0026rdquo;]]\n输出\n[null, [], [\u0026ldquo;aaaaa\u0026rdquo;], [\u0026ldquo;bbbbb\u0026rdquo;, \u0026ldquo;ccccc\u0026rdquo;], [], [\u0026ldquo;ddddd\u0026rdquo;, \u0026ldquo;eeeee\u0026rdquo;]]\n解释\nOrderedStream os= new OrderedStream(5);\nos.insert(3, \u0026ldquo;ccccc\u0026rdquo;); // 插入 (3, \u0026ldquo;ccccc\u0026rdquo;)，返回 []\nos.insert(1, \u0026ldquo;aaaaa\u0026rdquo;); // 插入 (1, \u0026ldquo;aaaaa\u0026rdquo;)，返回 [\u0026ldquo;aaaaa\u0026rdquo;]\nos.insert(2, \u0026ldquo;bbbbb\u0026rdquo;); // 插入 (2, \u0026ldquo;bbbbb\u0026rdquo;)，返回 [\u0026ldquo;bbbbb\u0026rdquo;, \u0026ldquo;ccccc\u0026rdquo;]\nos.insert(5, \u0026ldquo;eeeee\u0026rdquo;); // 插入 (5, \u0026ldquo;eeeee\u0026rdquo;)，返回 []\nos.insert(4, \u0026ldquo;ddddd\u0026rdquo;); // 插入 (4, \u0026ldquo;ddddd\u0026rdquo;)，返回 [\u0026ldquo;ddddd\u0026rdquo;, \u0026ldquo;eeeee\u0026rdquo;]\n提示： 1 \u0026lt;= n \u0026lt;= 1000 1 \u0026lt;= id \u0026lt;= n value.length == 5 value 仅由小写字母组成 每次调用 insert 都会使用一个唯一的 id 恰好调用 n 次 insert 解题思路 哈希 使用数组模拟哈希表存储 (id, value) 对。\n初始时，开辟长度为 n 的数组，将对应的每个 id 的 value 插入到下标为 id-1 的数组下标处。\n返回递增序列时，依次向后遍历即可。\ntype OrderedStream struct { elems []string id int } func Constructor(n int) OrderedStream { return OrderedStream{ elems: make([]string, n), id: 0, } } func (this *OrderedStream) Insert(idKey int, value string) []string { this.elems[idKey-1] = value start := this.id for ; this.id \u0026lt; len(this.elems); this.id++ { if this.elems[this.id] == \u0026#34;\u0026#34; { break } } ans := make([]string, this.id-start) copy(ans, this.elems[start:this.id]) return ans } 复杂度 时间复杂度： OrderedStream：$ O(1) $ Insert：$ O(1) $ 空间复杂度：$ O(n) $ ","date":"2022-08-16T10:04:04+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1656.-%E8%AE%BE%E8%AE%A1%E6%9C%89%E5%BA%8F%E6%B5%81/","title":"Leetcode 1656. 设计有序流"},{"content":"链接： https://leetcode.cn/problems/design-circular-deque/\n难度： 中等\n题目描述 设计实现双端队列。\n实现 MyCircularDeque 类:\nMyCircularDeque(int k) ：构造函数,双端队列最大为 k 。 boolean insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true ，否则返回 false 。 boolean insertLast() ：将一个元素添加到双端队列尾部。如果操作成功返回 true ，否则返回 false 。 boolean deleteFront() ：从双端队列头部删除一个元素。 如果操作成功返回 true ，否则返回 false 。 boolean deleteLast() ：从双端队列尾部删除一个元素。如果操作成功返回 true ，否则返回 false 。 int getFront() ：从双端队列头部获得一个元素。如果双端队列为空，返回 -1 。 int getRear() ：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1 。 boolean isEmpty() ：若双端队列为空，则返回 true ，否则返回 false 。 boolean isFull() ：若双端队列满了，则返回 true ，否则返回 false 。 示例： 输入：\n[\u0026ldquo;MyCircularDeque\u0026rdquo;, \u0026ldquo;insertLast\u0026rdquo;, \u0026ldquo;insertLast\u0026rdquo;, \u0026ldquo;insertFront\u0026rdquo;, \u0026ldquo;insertFront\u0026rdquo;, \u0026ldquo;getRear\u0026rdquo;, \u0026ldquo;isFull\u0026rdquo;, \u0026ldquo;deleteLast\u0026rdquo;, \u0026ldquo;insertFront\u0026rdquo;, \u0026ldquo;getFront\u0026rdquo;]\n[[3], [1], [2], [3], [4], [], [], [], [4], []]\n输出：\n[null, true, true, true, false, 2, true, true, true, 4]\n解释：\nMyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3\ncircularDeque.insertLast(1);\t// 返回 true\ncircularDeque.insertLast(2);\t// 返回 true\ncircularDeque.insertFront(3);\t// 返回 true\ncircularDeque.insertFront(4);\t// 已经满了，返回 false\ncircularDeque.getRear(); // 返回 2\ncircularDeque.isFull();\t// 返回 true\ncircularDeque.deleteLast();\t// 返回 true\ncircularDeque.insertFront(4);\t// 返回 true\ncircularDeque.getFront();\t// 返回 4\n提示： 1 \u0026lt;= k \u0026lt;= 1000 0 \u0026lt;= value \u0026lt;= 1000 insertFront, insertLast, deleteFront, deleteLast, getFront, getRear, isEmpty, isFull 调用次数不大于 2000 次 解题思路 数组模拟 使用数组进行模拟，需要一个头指针和元素数量。\n元素数量判定循环队列的空和满，头指针和元素数量求和即可快速定位到环的头部和尾部。\ntype MyCircularDeque struct { elems []int head int length int capacity int } func Constructor(k int) MyCircularDeque { return MyCircularDeque{ elems: make([]int, k), head: 0, length: 0, capacity: k, } } func (this *MyCircularDeque) InsertFront(value int) bool { if this.IsFull() { return false } this.head = (this.head - 1 + this.capacity) % this.capacity this.elems[this.head] = value this.length++ return true } func (this *MyCircularDeque) InsertLast(value int) bool { if this.IsFull() { return false } tail := (this.head + this.length) % this.capacity this.elems[tail] = value this.length++ return true } func (this *MyCircularDeque) DeleteFront() bool { if this.IsEmpty() { return false } this.head = (this.head + 1) % this.capacity this.length-- return true } func (this *MyCircularDeque) DeleteLast() bool { if this.IsEmpty() { return false } this.length-- return true } func (this *MyCircularDeque) GetFront() int { if this.IsEmpty() { return -1 } return this.elems[this.head] } func (this *MyCircularDeque) GetRear() int { if this.IsEmpty() { return -1 } return this.elems[(this.head+this.length-1)%this.capacity] } func (this *MyCircularDeque) IsEmpty() bool { return this.length == 0 } func (this *MyCircularDeque) IsFull() bool { return this.length == this.capacity } 复杂度 时间复杂度： MyCircularDeque(int k) ：$ O(1) $ boolean insertFront()：$ O(1) $ boolean insertLast() ：$ O(1) $ boolean deleteFront() ：$ O(1) $ boolean deleteLast() ：$ O(1) $ int getFront() ：$ O(1) $ int getRear() ：$ O(1) $ boolean isEmpty() ：$ O(1) $ boolean isFull() ：$ O(1) $ 空间复杂度：$ O(k) $ ","date":"2022-08-15T10:03:04+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-641.-%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/","title":"Leetcode 641. 设计循环双端队列"},{"content":"链接： https://leetcode.cn/problems/maximum-score-after-splitting-a-string/\n难度： 简单\n题目描述 给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。\n「分割字符串的得分」为 左 子字符串中 0 的数量加上 右 子字符串中 1 的数量。\n示例 1： 输入： s = \u0026ldquo;011101\u0026rdquo;\n输出： 5\n解释：\n将字符串 s 划分为两个非空子字符串的可行方案有： 左子字符串 = \u0026ldquo;0\u0026rdquo; 且 右子字符串 = \u0026ldquo;11101\u0026rdquo;，得分 = 1 + 4 = 5\n左子字符串 = \u0026ldquo;01\u0026rdquo; 且 右子字符串 = \u0026ldquo;1101\u0026rdquo;，得分 = 1 + 3 = 4\n左子字符串 = \u0026ldquo;011\u0026rdquo; 且 右子字符串 = \u0026ldquo;101\u0026rdquo;，得分 = 1 + 2 = 3\n左子字符串 = \u0026ldquo;0111\u0026rdquo; 且 右子字符串 = \u0026ldquo;01\u0026rdquo;，得分 = 1 + 1 = 2\n左子字符串 = \u0026ldquo;01110\u0026rdquo; 且 右子字符串 = \u0026ldquo;1\u0026rdquo;，得分 = 2 + 1 = 3\n示例 2: 输入： s = \u0026ldquo;00111\u0026rdquo;\n输出： 5\n解释： 当 左子字符串 = \u0026ldquo;00\u0026rdquo; 且 右子字符串 = \u0026ldquo;111\u0026rdquo; 时，我们得到最大得分 = 2 + 3 = 5\n示例 3: 输入： s = \u0026ldquo;1111\u0026rdquo;\n输出： 3\n提示： 2 \u0026lt;= s.length \u0026lt;= 500 字符串 s 仅由字符 '0' 和 '1' 组成。 解题思路 枚举 使用前缀和统计所有时 枚举所有的分割点，计算相应的得分，找出最大值。\nfunc maxScore(s string) int { ans := 0 for i := 1; i \u0026lt; len(s); i++ { zeroes := 0 ones := 0 for j := range s { if j \u0026lt; i \u0026amp;\u0026amp; s[j] == \u0026#39;0\u0026#39; { zeroes++ continue } if j \u0026gt;= i \u0026amp;\u0026amp; s[j] == \u0026#39;1\u0026#39; { ones++ } } if ans \u0026lt; zeroes+ones { ans = zeroes + ones } } return ans } 复杂度 时间复杂度：$ O(N^2), N=len(s) $ 空间复杂度：$ O(1) $ 枚举 + 前缀和 使用前缀和记录前缀中字符 1 的数量，因为字符串中仅存在 0 和 1 ，故 0 的数量可以推导得出。\n枚举所有的分割点，利用前缀和 $ O(1) $ 计算相应的得分，找出最大值。\nfunc maxScore(s string) int { preSum := make([]int, len(s)) if s[0] == \u0026#39;1\u0026#39; { preSum[0] = 1 } for i := 1; i \u0026lt; len(s); i++ { preSum[i] = preSum[i-1] if s[i] == \u0026#39;1\u0026#39; { preSum[i]++ } } ans := 0 for i := 1; i \u0026lt; len(s); i++ { score := i - preSum[i-1] + preSum[len(s)-1] - preSum[i-1] if ans \u0026lt; score { ans = score } } return ans } 复杂度 时间复杂度：$ O(N), N=len(s) $ 空间复杂度：$ O(N) $ 枚举优化 在依次枚举分割点的思路中，可以发现当分割点从 i 移动到 i+1 时，s[i] 从 右 字串移动到 左 字串，对应左右字串的 0 和 1 数量仅针对该字符做相应变更即可快速求得得分。\nfunc maxScore(s string) int { zeroes := 0 ones := 0 for i := 0; i \u0026lt; len(s); i++ { if s[i] == \u0026#39;1\u0026#39; { ones++ } } ans := 0 for i := 1; i \u0026lt; len(s); i++ { if s[i-1] == \u0026#39;0\u0026#39; { zeroes++ } else { ones-- } if ans \u0026lt; zeroes+ones { ans = zeroes + ones } } return ans } 复杂度 时间复杂度：$ O(N), N=len(s) $ 空间复杂度：$ O(1) $ ","date":"2022-08-14T10:43:40+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1422.-%E5%88%86%E5%89%B2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/","title":"Leetcode 1422. 分割字符串的最大得分"},{"content":"链接： https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/\n难度： 困难\n题目描述 这个问题和 “最多能完成排序的块” 相似，但给定数组中的元素可以重复，输入数组最大长度为 2000，其中的元素最大为108。\narr 是一个可能包含 重复元素 的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n我们最多能将数组分成多少块？\n示例 1： 输入： arr = [5,4,3,2,1]\n输出： 1\n解释：\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。\n示例 2： 输入： arr = [2,1,3,4,4]\n输出： 4\n解释：\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。\n提示： arr 的长度在 [1, 2000] 之间。 arr[i] 的大小在 [0, 108]之间。 解题思路 排序 + 哈希 要使得分块后排序的结果和整体排序后的结果相同，则每一块内的元素必须和整体排序后对应的元素除顺序外保持相同。\n首先复制数组并排序，然后使用哈希表来确认相同区间内排序前后数组元素和数量是否一致，可以使用加减运算处理。\n由于需要求解最大的分块数，每当发现哈希表为空时，该部分区间即可分为一段。\nfunc maxChunksToSorted(arr []int) int { sorted := append([]int{}, arr...) sort.Ints(sorted) cnt := make(map[int]int) blocks := 0 for i := range arr { cnt[arr[i]]-- if cnt[arr[i]] == 0 { delete(cnt, arr[i]) } cnt[sorted[i]]++ if cnt[sorted[i]] == 0 { delete(cnt, sorted[i]) } if len(cnt) == 0 { blocks++ } } return blocks } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(arr) $ 空间复杂度：$ O(N) $ ","date":"2022-08-13T10:13:18+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-768.-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97-ii/","title":"Leetcode 768. 最多能完成排序的块 II"},{"content":"链接： https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/\n难度： 困难\n题目描述 有 n 个人被分成数量未知的组。每个人都被标记为一个从 0 到 n - 1 的 唯一ID 。\n给定一个整数数组 groupSizes ，其中 groupSizes[i] 是第 i 个人所在的组的大小。例如，如果 groupSizes[1] = 3 ，则第 1 个人必须位于大小为 3 的组中。\n返回一个组列表，使每个人 i 都在一个大小为 groupSizes[i] 的组中。\n每个人应该 恰好只 出现在 一个组 中，并且每个人必须在一个组中。如果有多个答案，返回其中 任何 一个。可以 保证 给定输入 至少有一个 有效的解。\n示例 1： 输入： groupSizes = [3,3,3,3,3,1,3]\n输出： [[5],[0,1,2],[3,4,6]]\n解释：\n第一组是 [5]，大小为 1，groupSizes[5] = 1。\n第二组是 [0,1,2]，大小为 3，groupSizes[0] = groupSizes[1] = groupSizes[2] = 3。\n第三组是 [3,4,6]，大小为 3，groupSizes[3] = groupSizes[4] = groupSizes[6] = 3。\n其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。\n示例 2： 输入： groupSizes = [2,1,3,3,3,2]\n输出： [[1],[0,5],[2,3,4]]\n提示： groupSizes.length == n 1 \u0026lt;= n \u0026lt;= 500 1 \u0026lt;= groupSizes[i] \u0026lt;= n 解题思路 动态规划 因为题目保证存在有效的解，所以使用哈希表记录不同大小的人员未满的组。\n遍历整个数组，将对应的人加入到对应的组中，当组满时，加入到结果列表中。\nfunc groupThePeople(groupSizes []int) [][]int { ans := make([][]int, 0, 1) groupSize2People := make(map[int][]int) for i, groupSize := range groupSizes { if cap(groupSize2People[groupSize]) == 0 { groupSize2People[groupSize] = make([]int, 0, groupSize) } groupSize2People[groupSize] = append(groupSize2People[groupSize], i) if len(groupSize2People[groupSize]) == groupSize { ans = append(ans, groupSize2People[groupSize]) groupSize2People[groupSize] = nil } } return ans } 复杂度 时间复杂度：$ O(N), N = len(groupSizes) $ 空间复杂度：$ O(N) $ ","date":"2022-08-12T09:57:09+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1282.-%E7%94%A8%E6%88%B7%E5%88%86%E7%BB%84/","title":"Leetcode 1282. 用户分组"},{"content":"链接： https://leetcode.cn/problems/reformat-the-string/\n难度： 简单\n题目描述 给你一个混合了数字和字母的字符串 s，其中的字母均为小写英文字母。\n请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。\n请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。\n示例 1： 输入： s = \u0026ldquo;a0b1c2\u0026rdquo;\n输出： \u0026ldquo;0a1b2c\u0026rdquo;\n解释： \u0026ldquo;0a1b2c\u0026rdquo; 中任意两个相邻字符的类型都不同。 \u0026ldquo;a0b1c2\u0026rdquo;, \u0026ldquo;0a1b2c\u0026rdquo;, \u0026ldquo;0c2a1b\u0026rdquo; 也是满足题目要求的答案。\n示例 2： 输入： s = \u0026ldquo;leetcode\u0026rdquo;\n输出： \u0026quot;\u0026quot;\n解释： \u0026ldquo;leetcode\u0026rdquo; 中只有字母，所以无法满足重新格式化的条件。\n示例 3： 输入： s = \u0026ldquo;1229857369\u0026rdquo;\n输出： \u0026quot;\u0026quot;\n解释： \u0026ldquo;1229857369\u0026rdquo; 中只有数字，所以无法满足重新格式化的条件。\n示例 4： 输入： s = \u0026ldquo;covid2019\u0026rdquo;\n输出： \u0026ldquo;c2o0v1i9d\u0026rdquo;\n示例 5： 输入： s = \u0026ldquo;ab123\u0026rdquo;\n输出： \u0026ldquo;1a2b3\u0026rdquo;\n提示： 1 \u0026lt;= s.length \u0026lt;= 500 s 仅由小写英文字母和/或数字组成。 解题思路 模拟 统计字母和数字的数量，当且仅当二者的差值小于1时，可以格式化。\n使用两个指针分别指向未使用过的字符，按照数字字母交替的顺序格式化。\nfunc reformat(s string) string { digits := make([]byte, 0, len(s)) letters := make([]byte, 0, len(s)) for i := range s { if s[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;9\u0026#39; { digits = append(digits, s[i]) } else { letters = append(letters, s[i]) } } curDigit := true switch len(digits) - len(letters) { case 0, 1: case -1: curDigit = false default: return \u0026#34;\u0026#34; } ans := make([]byte, 0, len(s)) for i, j := 0, 0; len(ans) != len(s); curDigit = !curDigit { if curDigit { ans = append(ans, digits[i]) i++ } else { ans = append(ans, letters[j]) j++ } } return string(ans) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(N) $ ","date":"2022-08-11T10:45:39+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1417.-%E9%87%8D%E6%96%B0%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 1417. 重新格式化字符串"},{"content":"链接： https://leetcode.cn/problems/solve-the-equation/\n难度： 中等\n题目描述 求解一个给定的方程，将 x 以字符串 \u0026quot;x=#value\u0026quot; 的形式返回。该方程仅包含 '+' ， '-' 操作，变量 x 和其对应系数。\n如果方程没有解，请返回 \u0026quot;No solution\u0026quot; 。如果方程有无限解，则返回 \u0026quot;Infinite solutions\u0026quot; 。\n题目保证，如果方程中只有一个解，则 'x' 的值是一个整数。\n示例 1： 输入： equation = \u0026ldquo;x+5-3+x=6+x-2\u0026rdquo;\n输出： \u0026ldquo;x=2\u0026rdquo;\n示例 2： 输入： equation = \u0026ldquo;x=x\u0026rdquo;\n输出： \u0026ldquo;Infinite solutions\u0026rdquo;\n示例 3： 输入： equation = \u0026ldquo;2x=x\u0026rdquo;\n输出： \u0026ldquo;x=0\u0026rdquo;\n提示： 3 \u0026lt;= equation.length \u0026lt;= 1000 equation 只有一个 '='. equation 方程由整数组成，其绝对值在 [0, 100] 范围内，不含前导零和变量 'x' 。 解题思路 模拟 解析字符串，并进行移项，得到形如 a*x + b = 0 的形式。\n若此时\na = 0 且 b = 0 则有无数解； a = 0 且 b ≠ 0 则无解； 否则唯一解为 -b / a 。 func solveEquation(equation string) string { coefficient := 0 // 系数 constant := 0 // 常数 equalLeft := true // 标记等式左右 for i := 0; i \u0026lt; len(equation); { switch equation[i] { case \u0026#39;=\u0026#39;: // 等式右侧 equalLeft = false i++ default: // 识别其中一项 j := i for ; j \u0026lt; len(equation) \u0026amp;\u0026amp; strings.ContainsRune(\u0026#34;+-01234567898\u0026#34;, rune(equation[j])); j++ { } num, err := strconv.Atoi(equation[i:j]) // 解析系数或常数 // 处理 x +x -x 的情况 if err != nil { num = 1 if equation[i] == \u0026#39;-\u0026#39; { num = -1 } } // 移项处理 if !equalLeft { num = -num } if j \u0026lt; len(equation) \u0026amp;\u0026amp; equation[j] == \u0026#39;x\u0026#39; { // 系数更新 coefficient += num j++ } else { // 常数更新 constant += num } i = j } } if coefficient == 0 { if constant == 0 { return \u0026#34;Infinite solutions\u0026#34; } return \u0026#34;No solution\u0026#34; } return fmt.Sprintf(\u0026#34;x=%d\u0026#34;, -constant/coefficient) } 复杂度 时间复杂度：$ O(N), N = len(equation) $ 空间复杂度：$ (1) $ ","date":"2022-08-10T09:57:21+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-640.-%E6%B1%82%E8%A7%A3%E6%96%B9%E7%A8%8B/","title":"Leetcode 640. 求解方程"},{"content":"链接： https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum/\n难度： 简单\n题目描述 给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。\n你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。\n请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。\n示例 1： 输入： nums = [-3,2,-3,4,2]\n输出： 5\n解释： 如果你选择 startValue = 4，在第三次累加时，和小于 1 。\n累加求和 startValue = 4 startValue = 5 nums (4 -3 ) = 1 (5 -3 ) = 2 -3 (1 +2 ) = 3 (2 +2 ) = 4 2 (3 -3 ) = 0 (4 -3 ) = 1 -3 (0 +4 ) = 4 (1 +4 ) = 5 4 (4 +2 ) = 6 (5 +2 ) = 7 2 示例 2： 输入： nums = [1,2]\n输出： 1\n解释： 最小的 startValue 需要是正数。\n示例 3： 输入： nums = [1,-2,-3]\n输出： 5\n提示： 1 \u0026lt;= nums.length \u0026lt;= 100 -100 \u0026lt;= nums[i] \u0026lt;= 100 解题思路 模拟 要保证所有的累加和 ≥ 1，则最小的累加和 ≥ 1 即可。\n从左往右遍历依次累加求和，找出在此过程中累加和的最小值。\n若为负数则 startValue 取其相反数加1，否则取 1。\nfunc minStartValue(nums []int) int { sum := 0 min := math.MaxInt for _, num := range nums { sum += num if min \u0026gt; sum { min = sum } } if min \u0026lt; 0 { return 1 - min } return 1 } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2022-08-09T09:49:56+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1413.-%E9%80%90%E6%AD%A5%E6%B1%82%E5%92%8C%E5%BE%97%E5%88%B0%E6%AD%A3%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","title":"Leetcode 1413. 逐步求和得到正数的最小值"},{"content":"链接： https://leetcode.cn/problems/exclusive-time-of-functions/\n难度： 中等\n题目描述 有一个 单线程 CPU 正在运行一个含有 n 道函数的程序。每道函数都有一个位于 0 和 n-1 之间的唯一标识符。\n函数调用 存储在一个 调用栈 上 ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 当前正在执行的函数 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。\n给你一个由日志组成的列表 logs ，其中 logs[i] 表示第 i 条日志消息，该消息是一个按 \u0026quot;{function_id}:{\u0026quot;start\u0026quot; | \u0026quot;end\u0026quot;}:{timestamp}\u0026quot; 进行格式化的字符串。例如，\u0026quot;0:start:3\u0026quot; 意味着标识符为 0 的函数调用在时间戳 3 的 起始开始执行 ；而 \u0026quot;1:end:2\u0026quot; 意味着标识符为 1 的函数调用在时间戳 2 的 末尾结束执行。注意，函数可以 调用多次，可能存在递归调用 。\n函数的 独占时间 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 2 单位时间，另一次调用执行 1 单位时间，那么该函数的 独占时间 为 2 + 1 = 3 。\n以数组形式返回每个函数的 独占时间 ，其中第 i 个下标对应的值表示标识符 i 的函数的独占时间。\n示例 1： 输入： n = 2, logs = [\u0026ldquo;0:start:0\u0026rdquo;,\u0026ldquo;1:start:2\u0026rdquo;,\u0026ldquo;1:end:5\u0026rdquo;,\u0026ldquo;0:end:6\u0026rdquo;]\n输出： [3,4]\n解释：\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。\n函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。\n函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。\n所以函数 0 总共执行 2 + 1 = 3 个单位时间，函数 1 总共执行 4 个单位时间。\n示例 2： 输入： n = 1, logs = [\u0026ldquo;0:start:0\u0026rdquo;,\u0026ldquo;0:start:2\u0026rdquo;,\u0026ldquo;0:end:5\u0026rdquo;,\u0026ldquo;0:start:6\u0026rdquo;,\u0026ldquo;0:end:6\u0026rdquo;,\u0026ldquo;0:end:7\u0026rdquo;]\n输出： [8]\n解释：\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。\n函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。\n函数 0（初始调用）恢复执行，并立刻再次调用它自身。\n函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。\n函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。\n所以函数 0 总共执行 2 + 4 + 1 + 1 = 8 个单位时间。\n示例 3： 输入： n = 2, logs = [\u0026ldquo;0:start:0\u0026rdquo;,\u0026ldquo;0:start:2\u0026rdquo;,\u0026ldquo;0:end:5\u0026rdquo;,\u0026ldquo;1:start:6\u0026rdquo;,\u0026ldquo;1:end:6\u0026rdquo;,\u0026ldquo;0:end:7\u0026rdquo;]\n输出： [7,1]\n解释：\n函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。\n函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。\n函数 0（初始调用）恢复执行，并立刻调用函数 1 。\n函数 1在时间戳 6 的起始开始执行，执行 1 个单位时间，于时间戳 6 的末尾结束执行。\n函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间，于时间戳 7 的末尾结束执行。\n所以函数 0 总共执行 2 + 4 + 1 = 7 个单位时间，函数 1 总共执行 1 个单位时间。\n示例 4： 输入： n = 2, logs = [\u0026ldquo;0:start:0\u0026rdquo;,\u0026ldquo;0:start:2\u0026rdquo;,\u0026ldquo;0:end:5\u0026rdquo;,\u0026ldquo;1:start:7\u0026rdquo;,\u0026ldquo;1:end:7\u0026rdquo;,\u0026ldquo;0:end:8\u0026rdquo;]\n输出： [8,1]\n示例 5： 输入： n = 1, logs = [\u0026ldquo;0:start:0\u0026rdquo;,\u0026ldquo;0:end:0\u0026rdquo;]\n输出： [1]\n提示： 1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= logs.length \u0026lt;= 500 0 \u0026lt;= function_id \u0026lt; n 0 \u0026lt;= timestamp \u0026lt;= 109 两个开始事件不会在同一时间戳发生 两个结束事件不会在同一时间戳发生 每道函数都有一个对应 \u0026quot;start\u0026quot; 日志的 \u0026quot;end\u0026quot; 日志\n解题思路 栈 模拟调用栈，所有的开始时间入栈，通过栈顶元素的开始和结束时间，统计每个函数的独占时间总和。\nfunc exclusiveTime(n int, logs []string) []int { ans := make([]int, n) stack := make([]int, 0, len(logs)/2) now := 0 // 当前时间，开始位置 for _, log := range logs { l := strings.Split(log, \u0026#34;:\u0026#34;) no, _ := strconv.Atoi(l[0]) time, _ := strconv.Atoi(l[2]) // 当前在执行的函数，执行时间累加 if len(stack) \u0026gt; 0 { cur := stack[len(stack)-1] ans[cur] += time - now if l[1] == \u0026#34;end\u0026#34; { ans[cur]++ } } if l[1] == \u0026#34;start\u0026#34; { // 新函数运行开始，入栈 stack = append(stack, no) now = time } else { // 栈顶函数运行结束，出栈 stack = stack[:len(stack)-1] now = time + 1 } } return ans } 复杂度 时间复杂度：$ O(N), N = len(logs) $ 空间复杂度：$ O(N) $ ","date":"2022-08-07T09:30:44+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-636.-%E5%87%BD%E6%95%B0%E7%9A%84%E7%8B%AC%E5%8D%A0%E6%97%B6%E9%97%B4/","title":"Leetcode 636. 函数的独占时间"},{"content":"链接： https://leetcode.cn/problems/string-matching-in-an-array/\n难度： 中等\n题目描述 给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。\n如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 word[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。\n示例 1： 输入： words = [\u0026ldquo;mass\u0026rdquo;,\u0026ldquo;as\u0026rdquo;,\u0026ldquo;hero\u0026rdquo;,\u0026ldquo;superhero\u0026rdquo;]\n输出： [\u0026ldquo;as\u0026rdquo;,\u0026ldquo;hero\u0026rdquo;]\n解释： \u0026ldquo;as\u0026rdquo; 是 \u0026ldquo;mass\u0026rdquo; 的子字符串，\u0026ldquo;hero\u0026rdquo; 是 \u0026ldquo;superhero\u0026rdquo; 的子字符串。\n[\u0026ldquo;hero\u0026rdquo;,\u0026ldquo;as\u0026rdquo;] 也是有效的答案。\n示例 2： 输入： words = [\u0026ldquo;leetcode\u0026rdquo;,\u0026ldquo;et\u0026rdquo;,\u0026ldquo;code\u0026rdquo;]\n输出： [\u0026ldquo;et\u0026rdquo;,\u0026ldquo;code\u0026rdquo;]\n解释： \u0026ldquo;et\u0026rdquo; 和 \u0026ldquo;code\u0026rdquo; 都是 \u0026ldquo;leetcode\u0026rdquo; 的子字符串。\n示例 3： 输入： words = [\u0026ldquo;blue\u0026rdquo;,\u0026ldquo;green\u0026rdquo;,\u0026ldquo;bu\u0026rdquo;]\n输出： []\n提示： 1 \u0026lt;= words.length \u0026lt;= 100 1 \u0026lt;= words[i].length \u0026lt;= 30 words[i] 仅包含小写英文字母。 题目数据 保证 每个 words[i] 都是独一无二的。 解题思路 枚举 枚举所有的字符串，以此判断是否为其他字符串的字串。\nfunc stringMatching(words []string) []string { ans := make([]string, 0, len(words)) for i := range words { for j := range words { if i == j { continue } if strings.Contains(words[j], words[i]) { ans = append(ans, words[i]) break } } } return ans } 复杂度 时间复杂度：$ O(N^2*L), N = len(words), L = avg(len(words[i])) $ 空间复杂度：$ O(1) $ ","date":"2022-08-06T18:19:05+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1408.-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/","title":"Leetcode 1408. 数组中的字符串匹配"},{"content":"链接： https://leetcode.cn/problems/add-one-row-to-tree/\n难度： 中等\n题目描述 给定一个二叉树的根 root 和两个整数 val 和 depth ，在给定的深度 depth 处添加一个值为 val 的节点行。\n注意，根节点 root 位于深度 1 。\n加法规则如下:\n给定整数 depth，对于深度为 depth - 1 的每个非空树节点 cur ，创建两个值为 val 的树节点作为 cur 的左子树根和右子树根。 cur 原来的左子树应该是新的左子树根的左子树。 cur 原来的右子树应该是新的右子树根的右子树。 如果 depth == 1 意味着 depth - 1 根本没有深度，那么创建一个树节点，值 val 作为整个原始树的新根，而原始树就是新根的左子树。 示例 1： 输入： root = [4,2,6,3,1,5], val = 1, depth = 2\n输出： [4,1,1,2,null,null,6,3,1,5]\n示例 2： 输入： root = [4,2,null,3,1], val = 1, depth = 3\n输出： [4,2,null,1,1,3,null,null,1]\n提示： 节点数在 [1, 104] 范围内 树的深度在 [1, 104] 范围内 -100 \u0026lt;= Node.val \u0026lt;= 100 -105 \u0026lt;= val \u0026lt;= 105 1 \u0026lt;= depth \u0026lt;= the depth of tree + 1 解题思路 深度优先搜索 采用深度优先搜索策略，同时将深度信息传递下去。\n当深度为 n-1 时，插入两个子节点。另可额外引入一个 TreeNode 处理根的问题。\nfunc addOneRow(root *TreeNode, val int, depth int) *TreeNode { var dfs func(parent *TreeNode, depth int) dfs = func(parent *TreeNode, depth int) { if parent == nil { return } // 插入 val 节点 if depth == 1 { parent.Left = \u0026amp;TreeNode{ Val: val, Left: parent.Left, Right: nil, } parent.Right = \u0026amp;TreeNode{ Val: val, Left: nil, Right: parent.Right, } return } dfs(parent.Left, depth-1) dfs(parent.Right, depth-1) } // 虚拟节点处理根节点问题 virtual := \u0026amp;TreeNode{ Val: 0, Left: root, Right: nil, } dfs(virtual, depth) return virtual.Left } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-08-05T09:55:14+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-623.-%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A2%9E%E5%8A%A0%E4%B8%80%E8%A1%8C/","title":"Leetcode 623. 在二叉树中增加一行"},{"content":"链接： https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/\n难度： 简单\n题目描述 给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。\n如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。\n与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。\n注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。\n示例 1： 输入： nums = [4,3,10,9,8]\n输出： [10,9]\n解释： 子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 示例 2： 输入： nums = [4,4,7,6,7]\n输出： [7,7,6]\n解释： 子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，元素按非递增顺序返回。\n示例 3： 输入： nums = [6]\n输出： [6]\n提示： 1 \u0026lt;= nums.length \u0026lt;= 500 1 \u0026lt;= nums[i] \u0026lt;= 100 解题思路 贪心（排序） 为使得子序列的长度最小，优先挑选值比较大的元素。\n将所有元素排序，首先求得所有元素之和。然后从最大元素开始，依次累加直到累加值大于总和的一半为止。\nfunc minSubsequence(nums []int) []int { halfOfSum := 0 for _, num := range nums { halfOfSum += num } halfOfSum /= 2 sort.Sort(sort.Reverse(sort.IntSlice(nums))) s := 0 i := 0 for i = range nums { s += nums[i] if s \u0026gt; halfOfSum { break } } return nums[:i+1] } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(nums) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-08-04T10:04:16+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1403.-%E9%9D%9E%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E5%BA%8F%E5%88%97/","title":"Leetcode 1403. 非递增顺序的最小子序列"},{"content":"链接： https://leetcode.cn/problems/orderly-queue/\n难度： 困难\n题目描述 给定一个字符串 s 和一个整数 k 。你可以从 s 的前 k 个字母中选择一个，并把它加到字符串的末尾。\n返回 在应用上述步骤的任意数量的移动后，字典上最小的字符串 。\n示例 1： 输入： s = \u0026ldquo;cba\u0026rdquo;, k = 1\n输出： \u0026ldquo;acb\u0026rdquo;\n解释：\n在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。\n在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。\n示例 2： 输入： s = \u0026ldquo;baaca\u0026rdquo;, k = 3\n输出： \u0026ldquo;aaabc\u0026rdquo;\n解释：\n在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。\n在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。\n提示： 1 \u0026lt;= k \u0026lt;= S.length \u0026lt;= 1000 s 只由小写字母组成。 解题思路 分类讨论 对于 k = 1 的情况，将字符串首尾连接组成环，每个字符的相对位置不会改变，所以需要找寻某个位置开始绕环一周的最小字符串。\n对于 k \u0026gt; 1 的情况，可以将某个字符移动到任意相对位置，故总可以将其变为升序，返回排序后的结果即可。\nfunc orderlyQueue(s string, k int) string { if k \u0026gt; 1 { bytes := []byte(s) sort.Slice(bytes, func(i, j int) bool { return bytes[i] \u0026lt; bytes[j] }) return string(bytes) } minIdx := 0 for i := 1; i \u0026lt; len(s); i++ { // 比较两个字符串 for j := 0; j \u0026lt; len(s); j++ { if s[(minIdx+j)%len(s)] \u0026lt; s[(i+j)%len(s)] { break } else if s[(minIdx+j)%len(s)] \u0026gt; s[(i+j)%len(s)] { minIdx = i break } } } return s[minIdx:] + s[:minIdx] } 复杂度 时间复杂度：$ O(N^2), N = len(s) $ 空间复杂度：$ O(N) $ ","date":"2022-08-04T09:52:15+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-899.-%E6%9C%89%E5%BA%8F%E9%98%9F%E5%88%97/","title":"Leetcode 899. 有序队列"},{"content":"链接： https://leetcode.cn/problems/design-circular-queue/\n难度： 中等\n题目描述 设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。\n循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。\n你的实现应该支持如下操作：\nMyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 示例： MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3 circularQueue.enQueue(1); // 返回 true circularQueue.enQueue(2); // 返回 true circularQueue.enQueue(3); // 返回 true circularQueue.enQueue(4); // 返回 false，队列已满 circularQueue.Rear(); // 返回 3 circularQueue.isFull(); // 返回 true circularQueue.deQueue(); // 返回 true circularQueue.enQueue(4); // 返回 true circularQueue.Rear(); // 返回 4\n提示： 所有的值都在 0 至 1000 的范围内； 操作数将在 1 至 1000 的范围内； 请不要使用内置的队列库。 解题思路 数组模拟 使用数组进行模拟，需要一个头指针和元素数量。\n元素数量判定循环队列的空和满，头指针和元素数量求和即可快速定位到环的尾部。\ntype MyCircularQueue struct { elems []int head int length int capacity int } func Constructor(k int) MyCircularQueue { return MyCircularQueue{ elems: make([]int, k), head: 0, length: 0, capacity: k, } } func (this *MyCircularQueue) EnQueue(value int) bool { // 已满 if this.IsFull() { return false } tail := (this.head + this.length) % this.capacity this.elems[tail] = value this.length++ return true } func (this *MyCircularQueue) DeQueue() bool { // 没有元素 if this.IsEmpty() { return false } this.head = (this.head + 1) % this.capacity this.length-- return true } func (this *MyCircularQueue) Front() int { if this.IsEmpty() { return -1 } return this.elems[this.head] } func (this *MyCircularQueue) Rear() int { if this.IsEmpty() { return -1 } return this.elems[(this.head+this.length-1)%this.capacity] } func (this *MyCircularQueue) IsEmpty() bool { return this.length == 0 } func (this *MyCircularQueue) IsFull() bool { return this.length == this.capacity } 复杂度 时间复杂度： Constructor：$ O(1)$ EnQueue：$ O(1)$ DeQueue：$ O(1)$ Front：$ O(1)$ Rear：$ O(1)$ IsEmpty：$ O(1)$ IsFull：$ O(1)$ 空间复杂度：$ O(k) $ ","date":"2022-08-02T09:54:57+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-622.-%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/","title":"Leetcode 622. 设计循环队列"},{"content":"链接： https://leetcode.cn/problems/generate-a-string-with-characters-that-have-odd-counts/\n难度： 简单\n题目描述 给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。\n返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。\n示例 1： 输入： n = 4\n输出： \u0026ldquo;pppz\u0026rdquo;\n解释： \u0026ldquo;pppz\u0026rdquo; 是一个满足题目要求的字符串，因为 \u0026lsquo;p\u0026rsquo; 出现 3 次，且 \u0026lsquo;z\u0026rsquo; 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：\u0026ldquo;ohhh\u0026rdquo; 和 \u0026ldquo;love\u0026rdquo;。\n示例 2： 输入： n = 2\n输出： \u0026ldquo;xy\u0026rdquo;\n解释： \u0026ldquo;xy\u0026rdquo; 是一个满足题目要求的字符串，因为 \u0026lsquo;x\u0026rsquo; 和 \u0026lsquo;y\u0026rsquo; 各出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：\u0026ldquo;ag\u0026rdquo; 和 \u0026ldquo;ur\u0026rdquo;。\n示例 3： 输入： n = 7\n输出： \u0026ldquo;holasss\u0026rdquo;\n提示： 1 \u0026lt;= n \u0026lt;= 500 解题思路 分类讨论 当 n 为奇数时，全部用同一个字母 a；若为偶数时，前 n - 1 个字母为 a ，最后跟一个 b。\nfunc generateTheString(n int) string { ans := bytes.Repeat([]byte{\u0026#39;a\u0026#39;}, n) if n\u0026amp;1 == 0 { ans[n-1] = \u0026#39;b\u0026#39; } return string(ans) } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2022-08-01T09:40:32+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1374.-%E7%94%9F%E6%88%90%E6%AF%8F%E7%A7%8D%E5%AD%97%E7%AC%A6%E9%83%BD%E6%98%AF%E5%A5%87%E6%95%B0%E4%B8%AA%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 1374. 生成每种字符都是奇数个的字符串"},{"content":"链接： https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/\n难度： 中等\n题目描述 给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。\n请返回层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。\n示例 1： 输入： root = [1,7,0,7,-8,null,null]\n输出： 2\n解释：\n第 1 层各元素之和为 1，\n第 2 层各元素之和为 7 + 0 = 7，\n第 3 层各元素之和为 7 + -8 = -1，\n所以我们返回第 2 层的层号，它的层内元素之和最大。\n示例 2： 输入： root = [989,null,10250,98693,-89388,null,null,null,-32127]\n输出： 2\n提示： 树中的节点数在 [1, 104] 范围内 -105 \u0026lt;= Node.val \u0026lt;= 105 解题思路 层序遍历 层序遍历，求得每层节点元素和，找出最大的那一层。\nfunc maxLevelSum(root *TreeNode) int { q := list.New() q.PushBack(root) max := math.MinInt32 minLayer := 0 for layer := 1; q.Len() \u0026gt; 0; layer++ { sum := 0 for i := q.Len(); i \u0026gt; 0; i-- { node := q.Remove(q.Front()).(*TreeNode) sum += node.Val if node.Left != nil { q.PushBack(node.Left) } if node.Right != nil { q.PushBack(node.Right) } } if max \u0026lt; sum { max = sum minLayer = layer } } return minLayer } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(N) $ ","date":"2022-07-31T09:39:44+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1161.-%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C/","title":"Leetcode 1161. 最大层内元素和"},{"content":"链接： https://leetcode.cn/problems/largest-component-size-by-common-factor/\n难度： 困难\n题目描述 给定一个由不同正整数的组成的非空数组 nums ，考虑下面的图：\n有 nums.length 个节点，按从 nums[0] 到 nums[nums.length - 1] 标记； 只有当 nums[i] 和 nums[j] 共用一个大于 1 的公因数时，nums[i] 和 nums[j] 之间才有一条边。 返回 图中最大连通组件的大小 。\n示例 1： 输入： nums = [4,6,15,35]\n输出： 4\n示例 2： 输入： nums = [20,50,9,63]\n输出： 2\n示例 3： 输入： nums = [2,3,6,7,4,12,21,39]\n输出： 8\n提示： 1 \u0026lt;= nums.length \u0026lt;= 2 * 104 1 \u0026lt;= nums[i] \u0026lt;= 105 nums 中所有值都 不同 解题思路 并查集 a 和 b 连通，则与 a 连通的所有元素和与 c 连通的所有元素均处于一个连通集中，典型的并查集题目。\n对于每个元素，其与所有的因数均位于一个连通集中，求解该元素所有的因数，用最小因数代表该连通集，并进行 merge 操作合并各因数代表的连通集。\n最后遍历所有的元素，统计每个连通集的元素数量，求得最大连通集。\nfunc getRoot(elem int, father map[int]int) int { if e, ok := father[elem]; !ok || e == elem { return elem } root := getRoot(father[elem], father) father[elem] = root return root } func merge(elem1, elem2 int, father map[int]int) { root1, root2 := getRoot(elem1, father), getRoot(elem2, father) if root1 \u0026lt; root2 { father[root2] = getRoot(root1, father) } father[root1] = getRoot(root2, father) } func largestComponentSize(nums []int) int { father := make(map[int]int) for _, num := range nums { for i := 2; i*i \u0026lt;= num; i++ { if num%i != 0 { continue } merge(num, i, father) merge(i, num/i, father) } } max := 0 // 统计位于相同连通集中的元素个数 cnt := make(map[int]int) for _, num := range nums { root := getRoot(num, father) cnt[root]++ if max \u0026lt; cnt[root] { max = cnt[root] } } return max } 复杂度 时间复杂度：$ O(N*\\sqrt{M}), N = len(nums), M = max(nums[i]) $ 空间复杂度：$ O(M) $ ","date":"2022-07-30T13:52:50+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-952.-%E6%8C%89%E5%85%AC%E5%9B%A0%E6%95%B0%E8%AE%A1%E7%AE%97%E6%9C%80%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%A4%A7%E5%B0%8F/","title":"Leetcode 952. 按公因数计算最大组件大小"},{"content":"链接： https://leetcode.cn/problems/valid-square/\n难度： 中等\n题目描述 给定2D空间中四个点的坐标 p1, p2, p3 和 p4，如果这四个点构成一个正方形，则返回 true 。\n点的坐标 pi 表示为 [xi, yi] 。输入 不是 按任何顺序给出的。\n一个 有效的正方形 有四条等边和四个等角(90度角)。\n示例 1： 输入： p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1]\n输出： True\n示例 2： 输入： p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12]\n输出： false\n示例 3： 输入： p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1]\n输出： true\n提示： p1.length == p2.length == p3.length == p4.length == 2 -104 \u0026lt;= xi, yi \u0026lt;= 104 解题思路 数学 四个点构成的闭合图形，有四条边和两条对角线，四条边相同并且对角线也相同即为正方形。\n计算所有点两两之间的距离，其中4个距离相同，另外2个距离也相同，可以构成正方形。\n注意： 当存在相同点坐标时，一定不会是正方形。\nfunc distance2(p1, p2 []int) int { diff1, diff2 := p1[0]-p2[0], p1[1]-p2[1] return diff1*diff1 + diff2*diff2 } func validSquare(p1 []int, p2 []int, p3 []int, p4 []int) bool { cnt := make(map[int]int) points := [][]int{p1, p2, p3, p4} for i := len(points) - 2; i \u0026gt;= 0; i-- { for j := i + 1; j \u0026lt; len(points); j++ { d := distance2(points[i], points[j]) // 两个点相同，一定不是正方形 if d == 0 { return false } cnt[d]++ } } has2, has4 := false, false for _, c := range cnt { switch c { case 2: has2 = true case 4: has4 = true } } return has2 \u0026amp;\u0026amp; has4 } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2022-07-29T10:02:59+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-593.-%E6%9C%89%E6%95%88%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2/","title":"Leetcode 593. 有效的正方形"},{"content":"链接： https://leetcode.cn/problems/rank-transform-of-an-array/\n难度： 简单\n题目描述 给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。\n序号代表了一个元素有多大。序号编号的规则如下：\n序号从 1 开始编号。 一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。 每个数字的序号都应该尽可能地小。 示例 1： 输入： arr = [40,10,20,30]\n输出： [4,1,2,3]\n解释： 40 是最大的元素。 10 是最小的元素。 20 是第二小的数字。 30 是第三小的数字。\n示例 2： 输入： arr = [100,100,100]\n输出： [1,1,1]\n解释： 所有元素有相同的序号。\n示例 3： 输入： arr = [37,12,28,9,100,56,80,5,12]\n输出： [5,3,4,2,8,6,7,1,3]\n提示： 0 \u0026lt;= arr.length \u0026lt;= 105 -109 \u0026lt;= arr[i] \u0026lt;= 109 解题思路 排序 \u0026amp; 哈希 按照元素大小进行一轮排序，然后使用哈希表去重并记录元素的序号。\n最后按照原来的元素顺序查表得到结果。\nfunc arrayRankTransform(arr []int) []int { ans := make([]int, len(arr)) copy(ans, arr) sort.Ints(ans) seq := make(map[int]int) i := 1 for _, num := range ans { if _, ok := seq[num]; ok { continue } seq[num] = i i++ } for i, num := range arr { ans[i] = seq[num] } return ans } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(arr) $ 空间复杂度：$ O(N) $ ","date":"2022-07-28T09:45:01+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1331.-%E6%95%B0%E7%BB%84%E5%BA%8F%E5%8F%B7%E8%BD%AC%E6%8D%A2/","title":"Leetcode 1331. 数组序号转换"},{"content":"链接： https://leetcode.cn/problems/fraction-addition-and-subtraction/\n难度： 中等\n题目描述 给定一个表示分数加减运算的字符串 expression ，你需要返回一个字符串形式的计算结果。 这个结果应该是不可约分的分数，即最简分数。 如果最终结果是一个整数，例如 2，你需要将它转换成分数形式，其分母为 1。所以在上述例子中, 2 应该被转换为 2/1。\n示例 1： 输入： expression = \u0026ldquo;-1/2+1/2\u0026rdquo;\n输出： \u0026ldquo;0/1\u0026rdquo;\n示例 2： 输入： expression = \u0026ldquo;-1/2+1/2+1/3\u0026rdquo;\n输出： \u0026ldquo;1/3\u0026rdquo;\n示例 3： 输入： expression = \u0026ldquo;1/3-1/2\u0026rdquo;\n输出： \u0026ldquo;-1/6\u0026rdquo;\n提示： 输入和输出字符串只包含 '0' 到 '9' 的数字，以及 '/', '+' 和 '-'。 输入和输出分数格式均为 ±分子/分母。如果输入的第一个分数或者输出的分数是正数，则 '+' 会被省略掉。 输入只包含合法的最简分数，每个分数的分子与分母的范围是 [1,10]。 如果分母是 1，意味着这个分数实际上是一个整数。 输入的分数个数范围是 [1,10]。 最终结果的分子与分母保证是 32 位整数范围内的有效整数。 解题思路 模拟 识别出每个分数的分子和分母，做累计求和运算，每次运算后进行约分。\nfunc fractionAddition(expression string) string { sum := \u0026amp;frac{ numerator: 0, denominator: 1, } for i := 0; i \u0026lt; len(expression); { newFrac := new(frac) // 识别分子 j := i for ; j \u0026lt; len(expression) \u0026amp;\u0026amp; (expression[j] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; expression[j] \u0026lt;= \u0026#39;9\u0026#39; || expression[j] == \u0026#39;+\u0026#39; || expression[j] == \u0026#39;-\u0026#39;); j++ { } newFrac.numerator, _ = strconv.Atoi(expression[i:j]) i = j + 1 // 跳过/ // 识别分母 j = i for ; j \u0026lt; len(expression) \u0026amp;\u0026amp; expression[j] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; expression[j] \u0026lt;= \u0026#39;9\u0026#39;; j++ { } newFrac.denominator, _ = strconv.Atoi(expression[i:j]) i = j // 求和 sum = add(sum, newFrac) } return fmt.Sprintf(\u0026#34;%d/%d\u0026#34;, sum.numerator, sum.denominator) } type frac struct { numerator int denominator int } func add(f1, f2 *frac) *frac { ans := \u0026amp;frac{ numerator: f1.numerator*f2.denominator + f2.numerator*f1.denominator, denominator: f1.denominator * f2.denominator, } _gcd := gcd(ans.numerator, ans.denominator) ans.numerator /= _gcd ans.denominator /= _gcd return ans } func gcd(a int, b int) int { for b != 0 { a, b = b, a%b } if a \u0026lt; 0 { return -a } return a } 复杂度 时间复杂度：$ O(N), N = len(expression) $ 空间复杂度：$ O(1) $ ","date":"2022-07-27T10:06:50+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-592.-%E5%88%86%E6%95%B0%E5%8A%A0%E5%87%8F%E8%BF%90%E7%AE%97/","title":"Leetcode 592. 分数加减运算"},{"content":"链接： https://leetcode.cn/problems/design-skiplist/\n难度： 困难\n题目描述 不使用任何库函数，设计一个 跳表 。\n跳表 是在 O(log(n)) 时间内完成增加、删除、搜索操作的数据结构。跳表相比于树堆与红黑树，其功能与性能相当，并且跳表的代码长度相较下更短，其设计思想与链表相似。\n例如，一个跳表包含 [30, 40, 50, 60, 70, 90] ，然后增加 80、45 到跳表中，以下图的方式操作：\nArtyom Kalinin [CC BY-SA 3.0], via Wikimedia Commons\n跳表中有很多层，每一层是一个短的链表。在第一层的作用下，增加、删除和搜索操作的时间复杂度不超过 O(n)。跳表的每一个操作的平均时间复杂度是 O(log(n))，空间复杂度是 O(n)。\n了解更多 : https://en.wikipedia.org/wiki/Skip_list\n在本题中，你的设计应该要包含这些函数：\nbool search(int target): 返回 target 是否存在于跳表中。 void add(int num): 插入一个元素到跳表。 bool erase(int num): 在跳表中删除一个值，如果 num 不存在，直接返回 false. 如果存在多个 num ，删除其中任意一个即可。 注意，跳表中可能存在多个相同的值，你的代码需要处理这种情况。\n示例： 输入\n[\u0026ldquo;Skiplist\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;search\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;search\u0026rdquo;, \u0026ldquo;erase\u0026rdquo;, \u0026ldquo;erase\u0026rdquo;, \u0026ldquo;search\u0026rdquo;]\n[[], [1], [2], [3], [0], [4], [1], [0], [1], [1]]\n输出\n[null, null, null, null, false, null, true, false, true, false]\n解释\nSkiplist skiplist = new Skiplist();\nskiplist.add(1);\nskiplist.add(2);\nskiplist.add(3);\nskiplist.search(0); // 返回 false\nskiplist.add(4);\nskiplist.search(1); // 返回 true\nskiplist.erase(0); // 返回 false，0 不在跳表中\nskiplist.erase(1); // 返回 true\nskiplist.search(1); // 返回 false，1 已被擦除\n提示： 0 \u0026lt;= num, target \u0026lt;= 2 * 104 调用 search, add, erase操作次数不大于 5 * 104 解题思路 排序 将原数组从小到大排序，则最小差值一定出现在两个相邻的元素之间，依次遍历判断寻找：\n当当前差值大于最小差值时，忽略； 当当前差值等于最小差值时，加入到结果数组中； 当当前差值小于最小差值时，之前保留的结果无效，进行清空，并将当前元素对加入到结果数组中； type node struct { val int next []*node } type Skiplist struct { head *node randomLevel func() int level int } func Constructor() Skiplist { const maxLevel = 16 return Skiplist{ head: \u0026amp;node{ val: -1, next: make([]*node, maxLevel), }, randomLevel: func() func() int { random := rand.New(rand.NewSource(time.Now().UnixNano())).Int31n return func() int { return maxLevel - int(math.Log2(float64(random(math.MaxInt16)))) } }(), level: maxLevel, } } func (this *Skiplist) Search(target int) bool { n := this.head for level := this.level - 1; level \u0026gt;= 0; level-- { // 当前 level 不大于 target for ; n.next[level] != nil \u0026amp;\u0026amp; n.next[level].val \u0026lt;= target; n = n.next[level] { } // 已找到 if n.val == target { return true } } return false } func (this *Skiplist) Add(num int) { preNodes := make([]*node, this.level) // 每层前置节点 for level, n := this.level-1, this.head; level \u0026gt;= 0; level-- { // 当前 level 不大于 num for ; n.next[level] != nil \u0026amp;\u0026amp; n.next[level].val \u0026lt;= num; n = n.next[level] { } preNodes[level] = n } level := this.randomLevel() // 随机当前节点的 newNode := \u0026amp;node{ val: num, next: make([]*node, level), } // 更新前置结点 for i := level - 1; i \u0026gt;= 0; i-- { preNodes[i].next[i], newNode.next[i] = newNode, preNodes[i].next[i] } } func (this *Skiplist) Erase(num int) bool { n := this.head preNodes := make([]*node, this.level) // 每层前置节点 for level := this.level - 1; level \u0026gt;= 0; level-- { // 当前 level 小于 num for ; n.next[level] != nil \u0026amp;\u0026amp; n.next[level].val \u0026lt; num; n = n.next[level] { } preNodes[level] = n } n = n.next[0] // 判定是否存在 if n == nil || n.val != num { return false } for level := len(n.next) - 1; level \u0026gt;= 0; level-- { preNodes[level].next[level] = n.next[level] } return true } 复杂度 时间复杂度： Constructor：$ O(1) $ Search：$ O(\\log{N}), N = len(skiplist) $ Add：$ O(\\log{N}) $ Erase：$ O(\\log{N}) $ 空间复杂度：$ O(N) $ ","date":"2022-07-26T20:06:39+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1206.-%E8%AE%BE%E8%AE%A1%E8%B7%B3%E8%A1%A8/","title":"Leetcode 1206. 设计跳表"},{"content":"链接： https://leetcode.cn/problems/complete-binary-tree-inserter/\n难度： 简单\n题目描述 完全二叉树 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。\n设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。\n实现 CBTInserter 类:\nCBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构； CBTInserter.insert(int v) 向树中插入一个值为 Node.val == val 的新节点 TreeNode。使树保持完全二叉树的状态，并返回插入节点 TreeNode 的父节点的值； CBTInserter.get_root() 将返回树的头节点。 示例： 输入：\n[\u0026ldquo;CBTInserter\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;get_root\u0026rdquo;]\n[[[1, 2]], [3], [4], []]\n输出：\n[null, 1, 2, [1, 2, 3, 4]]\n解释：\nCBTInserter cBTInserter = new CBTInserter([1, 2]);\ncBTInserter.insert(3); // 返回 1\ncBTInserter.insert(4); // 返回 2\ncBTInserter.get_root(); // 返回 [1, 2, 3, 4]\n提示： 树中节点数量范围为 [1, 1000] 0 \u0026lt;= Node.val \u0026lt;= 5000 root 是完全二叉树 0 \u0026lt;= val \u0026lt;= 5000 每个测试用例最多调用 insert 和 get_root 操作 104 次 解题思路 广度优先搜索 从根节点开始，自左向右进行广度优先搜索，找到首个存在空子节点的节点，即为插入节点的父节点。\n若左子节点为空，则插入到左子节点；否则插入到右子节点。\ntype CBTInserter struct { root *TreeNode } func Constructor(root *TreeNode) CBTInserter { return CBTInserter{ root: root, } } func (this *CBTInserter) Insert(val int) int { q := list.New() q.PushBack(this.root) for q.Len() \u0026gt; 0 { n := q.Remove(q.Front()).(*TreeNode) if n.Left == nil { n.Left = \u0026amp;TreeNode{ Val: val, } return n.Val } if n.Right == nil { n.Right = \u0026amp;TreeNode{ Val: val, } return n.Val } q.PushBack(n.Left) q.PushBack(n.Right) } return 0 } func (this *CBTInserter) Get_root() *TreeNode { return this.root } 复杂度 时间复杂度： Constructor：$ O(1) $ Insert：$ O(N), N = size(Tree) $ Get_root：$ O(1) $ 空间复杂度：$ O(N) $ 数组 使用数组记录完全二叉树，则每个子节点 i 对应的父节点下标为 (i-1)/2。\n每次插入时，添加到数组尾部，并可 $ O(1) $ 的找到父节点，修改对应指针。\ntype CBTInserter struct { nodes []*TreeNode } func Constructor(root *TreeNode) CBTInserter { nodes := make([]*TreeNode, 0, 1) q := list.New() q.PushBack(root) for q.Len() \u0026gt; 0 { n := q.Remove(q.Front()).(*TreeNode) nodes = append(nodes, n) if n.Left != nil { q.PushBack(n.Left) } if n.Right != nil { q.PushBack(n.Right) } } return CBTInserter{ nodes: nodes, } } func (this *CBTInserter) Insert(val int) int { n := \u0026amp;TreeNode{ Val: val, } this.nodes = append(this.nodes, n) parent := this.nodes[(len(this.nodes)-2)/2] if parent.Left == nil { parent.Left = n } else { parent.Right = n } return parent.Val } func (this *CBTInserter) Get_root() *TreeNode { return this.nodes[0] } 复杂度 时间复杂度： Constructor：$ O(N), N = size(Tree) $ Insert：$ O(1) $ Get_root：$ O(1) $ 空间复杂度：$ O(N) $ ","date":"2022-07-25T20:31:06+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-919.-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E6%8F%92%E5%85%A5%E5%99%A8/","title":"Leetcode 919. 完全二叉树插入器"},{"content":"链接： https://leetcode.cn/problems/distance-between-bus-stops/\n难度： 简单\n题目描述 环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。\n环线上的公交车都可以按顺时针和逆时针的方向行驶。\n返回乘客从出发点 start 到目的地 destination 之间的最短距离。\n示例 1： 输入： distance = [1,2,3,4], start = 0, destination = 1\n输出： 1\n解释： 公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。\n示例 2： 输入： distance = [1,2,3,4], start = 0, destination = 2\n输出： 3\n解释： 公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。\n示例 3： 输入： distance = [1,2,3,4], start = 0, destination = 3\n输出： 4\n解释： 公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。\n提示： 1 \u0026lt;= n \u0026lt;= 104 distance.length == n 0 \u0026lt;= start, destination \u0026lt; n 0 \u0026lt;= distance[i] \u0026lt;= 104 解题思路 模拟 分别按照顺时针和逆时针前进，累计经过距离，最后再到达终点后，返回较小的那一个。\nfunc distanceBetweenBusStops(distance []int, start int, destination int) int { d1 := 0 for i := start; i != destination; i = (i + 1) % len(distance) { d1 += distance[i] } d2 := 0 for i := start; i != destination; i = (i - 1 + len(distance)) % len(distance) { d2 += distance[(i-1+len(distance))%len(distance)] } if d1 \u0026lt; d2 { return d1 } return d2 } 复杂度 时间复杂度：$ O(N), N = len(distance) $ 空间复杂度：$ O(1) $ ","date":"2022-07-24T12:04:02+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1184.-%E5%85%AC%E4%BA%A4%E7%AB%99%E9%97%B4%E7%9A%84%E8%B7%9D%E7%A6%BB/","title":"Leetcode 1184. 公交站间的距离"},{"content":"链接： https://leetcode.cn/problems/ur2n8P/\n难度： 中等\n题目描述 给定一个长度为 n 的整数数组 nums ，其中 nums 是范围为 [1，n] 的整数的排列。还提供了一个 2D 整数数组 sequences ，其中 sequences[i] 是 nums 的子序列。\n检查 nums 是否是唯一的最短 超序列 。最短 超序列 是 长度最短 的序列，并且所有序列 sequences[i] 都是它的子序列。对于给定的数组 sequences ，可能存在多个有效的 超序列 。\n例如，对于 sequences = [[1,2],[1,3]] ，有两个最短的 超序列 ，[1,2,3] 和 [1,3,2] 。 而对于 sequences = [[1,2],[1,3],[1,2,3]] ，唯一可能的最短 超序列 是 [1,2,3] 。[1,2,3,4] 是可能的超序列，但不是最短的。 如果 nums 是序列的唯一最短 超序列 ，则返回 true ，否则返回 false 。\n子序列 是一个可以通过从另一个序列中删除一些元素或不删除任何元素，而不改变其余元素的顺序的序列。\n示例 1： 输入： nums = [1,2,3], sequences = [[1,2],[1,3]]\n输出： false\n解释： 有两种可能的超序列：[1,2,3]和[1,3,2]。\n序列 [1,2] 是[1,2,3]和[1,3,2]的子序列。\n序列 [1,3] 是[1,2,3]和[1,3,2]的子序列。\n因为 nums 不是唯一最短的超序列，所以返回false。\n示例 2： 输入： nums = [1,2,3], sequences = [[1,2]]\n输出： false\n解释： 最短可能的超序列为 [1,2]。\n序列 [1,2] 是它的子序列：[1,2]。\n因为 nums 不是最短的超序列，所以返回false。\n示例 3： 输入： nums = [1,2,3], sequences = [[1,2],[1,3],[2,3]]\n输出： true\n解释： 最短可能的超序列为[1,2,3]。\n序列 [1,2] 是它的一个子序列：[1,2,3]。\n序列 [1,3] 是它的一个子序列：[1,2,3]。\n序列 [2,3] 是它的一个子序列：[1,2,3]。\n因为 nums 是唯一最短的超序列，所以返回true。\n提示 n == nums.length 1 \u0026lt;= n \u0026lt;= 104 nums 是 [1, n] 范围内所有整数的排列 1 \u0026lt;= sequences.length \u0026lt;= 104 1 \u0026lt;= sequences[i].length \u0026lt;= 104 1 \u0026lt;= sum(sequences[i].length) \u0026lt;= 105 1 \u0026lt;= sequences[i][j] \u0026lt;= n sequences 的所有数组都是 唯一 的 sequences[i] 是 nums 的一个子序列 解题思路 拓扑排序 sequences 中的每一个序列都决定了一些元素的先后顺序，则对整个 sequences 进行拓扑排序，即得到所谓的 超序列。\n超序列的唯一，要求在拓扑排序的结果唯一，即在排序过程中，不能出现入度为 0 的候选节点的数量\u0026gt; 1。\n最后判定唯一的 超序列 和 nums 是否完全一致即可。\nfunc sequenceReconstruction(nums []int, sequences [][]int) bool { inDegree := make([]int, len(nums)+1) // 入度 next := make([][]int, len(nums)+1) // 邻接链表 for _, seq := range sequences { for i := 1; i \u0026lt; len(seq); i++ { next[seq[i-1]] = append(next[seq[i-1]], seq[i]) inDegree[seq[i]]++ } } zeroInDegreeNums := make([]int, 0, 1) for _, num := range nums { if inDegree[num] == 0 { zeroInDegreeNums = append(zeroInDegreeNums, num) } } for len(zeroInDegreeNums) \u0026gt; 0 { // 拓扑排序结果不唯一 if len(zeroInDegreeNums) != 1 { return false } n := zeroInDegreeNums[0] zeroInDegreeNums = zeroInDegreeNums[1:] // 所有后继节点对应入度去除， // 寻找入度为 0 的节点 for _, num := range next[n] { inDegree[num]-- if inDegree[num] == 0 { zeroInDegreeNums = append(zeroInDegreeNums, num) } } } return true } 复杂度 时间复杂度：$ O(N+M), N = len(nums), M = \\sum{len(sequences[i])} $ 空间复杂度：$ O(N+M) $ ","date":"2022-07-23T10:39:46+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-ii-115.-%E9%87%8D%E5%BB%BA%E5%BA%8F%E5%88%97/","title":"剑指 Offer II 115. 重建序列"},{"content":"链接： https://leetcode.cn/problems/binary-tree-pruning/\n难度： 中等\n题目描述 给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。\n返回移除了所有不包含 1 的子树的原二叉树。\n节点 node 的子树为 node 本身加上所有 node 的后代。\n示例 1： 输入： root = [1,null,0,0,1]\n输出： [1,null,0,null,1]\n解释：\n只有红色节点满足条件“所有不包含 1 的子树”。 右图为返回的答案。\n示例 2： 输入： root = [1,0,1,0,0,0,1]\n输出： [1,null,1,null,1]\n示例 3： 输入： root = [1,1,0,1,1,0,1,0]\n输出： [1,1,0,1,1,null,1]\n提示： 树中节点的数目在范围 [1, 200] 内 Node.val 为 0 或 1 解题思路 递归 不包含 1 的子树，换言之就是子树中所有节点的值全部为 0，则不断删除值为 0 的叶结点即可。\nfunc pruneTree(root *TreeNode) *TreeNode { if root == nil { return nil } root.Left = pruneTree(root.Left) root.Right = pruneTree(root.Right) if root.Left == nil \u0026amp;\u0026amp; root.Right == nil \u0026amp;\u0026amp; root.Val == 0 { return nil } return root } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-07-21T10:04:18+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-814.-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/","title":"Leetcode 814. 二叉树剪枝"},{"content":"链接： https://leetcode.cn/problems/shift-2d-grid/\n难度： 简单\n题目描述 给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。\n每次「迁移」操作将会引发下述活动：\n位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。 位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。 位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。 请你返回 k 次迁移操作后最终得到的 二维网格。\n示例 1： 输入： grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1\n输出： [[9,1,2],[3,4,5],[6,7,8]]\n示例 2： 输入： grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4\n输出： [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]\n示例 3： 输入： grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9\n输出： [[1,2,3],[4,5,6],[7,8,9]]\n提示： m == grid.length n == grid[i].length 1 \u0026lt;= m \u0026lt;= 50 1 \u0026lt;= n \u0026lt;= 50 -1000 \u0026lt;= grid[i][j] \u0026lt;= 1000 0 \u0026lt;= k \u0026lt;= 100 解题思路 模拟 根据题意，所有行内元素右移，然后首列元素循环下移，即完成一次迁移。\n将上述动作重复 k 次即可。\nfunc shiftGrid(grid [][]int, k int) [][]int { for ; k \u0026gt; 0; k-- { // 行内元素循环右移 for _, line := range grid { tail := line[len(line)-1] copy(line[1:], line) line[0] = tail } // 首列元素循环下移 last := grid[len(grid)-1][0] for i := 0; i \u0026lt; len(grid); i++ { grid[i][0], last = last, grid[i][0] } } return grid } 复杂度 时间复杂度：$ O(k*m*n) $ 空间复杂度：$ O(1) $ 优化 每次迁移，每个元素的列都会循环右移一次，则对于第 j 列的元素，迁移完成后的列坐标为 (j+k)%n。\n而对于行坐标，只有每次最后一列的元素迁移到首列时才会发生，则第 i 行的元素迁移后会成为首列的次数为 (j+k)/n，从而得到行坐标为 (i+(j+k)/n)%m\nfunc shiftGrid(grid [][]int, k int) [][]int { m, n := len(grid), len(grid[0]) ans := make([][]int, m) for i := range ans { ans[i] = make([]int, n) } for i, line := range grid { for j, cell := range line { ans[(i+(j+k)/n)%m][(j+k)%n] = cell } } return ans } 复杂度 时间复杂度：$ O(m*n) $ 空间复杂度：$ O(1) $ ","date":"2022-07-20T09:39:15+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1260.-%E4%BA%8C%E7%BB%B4%E7%BD%91%E6%A0%BC%E8%BF%81%E7%A7%BB/","title":"Leetcode 1260. 二维网格迁移"},{"content":"链接： https://leetcode.cn/problems/my-calendar-ii/\n难度： 中等\n题目描述 实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。\nMyCalendar 有一个 book(int start, int end) 方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为, start \u0026lt;= x \u0026lt; end 。\n当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。\n每次调用 MyCalendar.book 方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。\n请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)\n示例： MyCalendar();\nMyCalendar.book(10, 20); // returns true\nMyCalendar.book(50, 60); // returns true\nMyCalendar.book(10, 40); // returns true\nMyCalendar.book(5, 15); // returns false\nMyCalendar.book(5, 10); // returns true\nMyCalendar.book(25, 55); // returns true\n解释：\n前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。\n第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。\n第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间10。\n第六个日程安排（25,55）可以添加至日历中，因为时间 [25,40] 将和第三个日程安排双重预订；\n时间 [40,50] 将单独预订，时间 [50,55）将和第二个日程安排双重预订。\n提示： 每个测试用例，调用 MyCalendar.book 函数最多不超过 1000 次。 调用函数 MyCalendar.book(start, end) 时， start 和 end 的取值范围为 [0, 109]。 解题思路 暴力求解 存储所有不出现三次预订日程的同时，另使用一个数组存储存在双重预订的区间。\n当有新日程时，遍历双重预订的区间，查看是否再次出现重复：\n当出现的时候，返回 false; 否则，遍历日程列表，找到所有双重预订的区间；并最后将当前预订添加到日程列表中，。 type MyCalendarTwo struct { book [][2]int repeat [][2]int } func Constructor() MyCalendarTwo { return MyCalendarTwo{ book: make([][2]int, 0, 10), repeat: make([][2]int, 0), // 记录重复的区间 } } func (this *MyCalendarTwo) Book(start int, end int) bool { // 从重复的区间找到，即为三重预订，返回 false for _, r := range this.repeat { if start \u0026lt; r[1] \u0026amp;\u0026amp; end \u0026gt; r[0] { return false } } // 记录重复的区间 for _, b := range this.book { if start \u0026gt;= b[1] || end \u0026lt;= b[0] { continue } this.repeat = append(this.repeat, [2]int{ func() int { if start \u0026gt; b[0] { return start } return b[0] }(), func() int { if end \u0026lt; b[1] { return end } return b[1] }(), }) } this.book = append(this.book, [2]int{start, end}) // 记录预订 return true } 复杂度 时间复杂度： Constructor：$ O(1) $ Book：$ O(N^2), N表示Book的调用次数 $ 空间复杂度：$ O(N) $ ","date":"2022-07-19T09:20:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-731.-%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8-ii/","title":"Leetcode 731. 我的日程安排表 II"},{"content":"链接： https://leetcode.cn/problems/array-nesting/\n难度： 简单\n题目描述 索引从 0 开始长度为 N 的数组 A，包含 0 到 N - 1 的所有整数。找到最大的集合 S 并返回其大小，其中 S[i] = {A[i], A[A[i]], A[A[A[i]]], ... } 且遵守以下的规则。\n假设选择索引为 i 的元素 A[i] 为 S 的第一个元素，S 的下一个元素应该是 A[A[i]]，之后是 A[A[A[i]]]... 以此类推，不断添加直到 S 出现重复的元素。\n示例： 输入： A = [5,4,0,3,1,6,2]\n输出： 4\n解释：\nA[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.\n其中一种最长的 S[K]:\nS[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}\n提示： N 是 [1, 20,000] 之间的整数。 A 中不含有重复的元素。 A 中的元素大小在 [0, N-1] 之间。 解题思路 并查集 根据题意，由于数组中的元素不会重复，则整个数组中元素会构成一个或多个环。\n枚举所有的初始元素，不断寻找直到出现环为止。\n将已经查找过的元素做标记，降低时间复杂度。\nfunc arrayNesting(nums []int) int { maxCnt := 0 for i := range nums { cnt := 0 for j := i; nums[j] != -1; { nums[j], j = -1, nums[j] // 标记已查找，并继续查找 cnt++ } if maxCnt \u0026lt; cnt { maxCnt = cnt } } return maxCnt } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2022-07-17T09:17:02+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-565.-%E6%95%B0%E7%BB%84%E5%B5%8C%E5%A5%97/","title":"Leetcode 565. 数组嵌套"},{"content":"链接： https://leetcode.cn/problems/qIsx9U/\n难度： 简单\n题目描述 给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。\n实现 MovingAverage 类：\nMovingAverage(int size) 用窗口大小 size 初始化对象。 double next(int val) 成员函数 next 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 size 个值的移动平均值，即滑动窗口里所有数字的平均值。 示例： 输入：\ninputs = [\u0026ldquo;MovingAverage\u0026rdquo;, \u0026ldquo;next\u0026rdquo;, \u0026ldquo;next\u0026rdquo;, \u0026ldquo;next\u0026rdquo;, \u0026ldquo;next\u0026rdquo;]\ninputs = [[3], [1], [10], [3], [5]]\n输出：\n[null, 1.0, 5.5, 4.66667, 6.0]\n解释：\nMovingAverage movingAverage = new MovingAverage(3);\nmovingAverage.next(1); // 返回 1.0 = 1 / 1\nmovingAverage.next(10); // 返回 5.5 = (1 + 10) / 2\nmovingAverage.next(3); // 返回 4.66667 = (1 + 10 + 3) / 3\nmovingAverage.next(5); // 返回 6.0 = (10 + 3 + 5) / 3\n提示 1 \u0026lt;= size \u0026lt;= 1000 -105 \u0026lt;= val \u0026lt;= 105 最多调用 next 方法 104 次 解题思路 队列 使用队列模拟滑动窗口，每次将新值添加到队尾，当队列长度超过滑动窗口的大小时，队头元素出队。\n另可使用一个变量存储队列中元素的和，降低求平均值的复杂度。\ntype MovingAverage struct { q *list.List sum int size int } /** Initialize your data structure here. */ func Constructor(size int) MovingAverage { return MovingAverage{ q: list.New(), sum: 0, size: size, } } func (this *MovingAverage) Next(val int) float64 { this.q.PushBack(val) this.sum += val if this.q.Len() \u0026gt; this.size { this.sum -= this.q.Remove(this.q.Front()).(int) } return float64(this.sum) / float64(this.q.Len()) } 复杂度 时间复杂度： Constructor：$ O(1) $ Next：$ O(1) $ 空间复杂度：$ O(size) $ ","date":"2022-07-16T10:23:33+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-ii-041.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E5%B9%B3%E5%9D%87%E5%80%BC/","title":"剑指 Offer II 041. 滑动窗口的平均值"},{"content":"链接： https://leetcode.cn/problems/logical-or-of-two-binary-grids-represented-as-quad-trees/\n难度： 中等\n题目描述 二进制矩阵中的所有元素不是 0 就是 1 。\n给你两个四叉树，quadTree1 和 quadTree2。其中 quadTree1 表示一个 n * n 二进制矩阵，而 quadTree2 表示另一个 n * n 二进制矩阵。\n请你返回一个表示 n * n 二进制矩阵的四叉树，它是 quadTree1 和 quadTree2 所表示的两个二进制矩阵进行 按位逻辑或运算 的结果。\n注意，当 isLeaf 为 False 时，你可以把 True 或者 False 赋值给节点，两种值都会被判题机制 接受 。\n四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：\nval：储存叶子结点所代表的区域的值。1 对应 True，0 对应 False； isLeaf: 当这个节点是一个叶子结点时为 True，如果它有 4 个子节点则为 False 。 class Node { public boolean val; public boolean isLeaf; public Node topLeft; public Node topRight; public Node bottomLeft; public Node bottomRight; } 我们可以按以下步骤为二维区域构建四叉树：\n如果当前网格的值相同（即，全为 0 或者全为 1），将 isLeaf 设为 True ，将 val 设为网格相应的值，并将四个子节点都设为 Null 然后停止。 如果当前网格的值不同，将 isLeaf 设为 False， 将 val 设为任意值，然后如下图所示，将当前网格划分为四个子网格。 使用适当的子网格递归每个子节点。 如果你想了解更多关于四叉树的内容，可以参考 wiki 。\n四叉树格式：\n输出为使用层序遍历后四叉树的序列化形式，其中 null 表示路径终止符，其下面不存在节点。\n它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 [isLeaf, val] 。\n如果 isLeaf 或者 val 的值为 True ，则表示它在列表 [isLeaf, val] 中的值为 1 ；如果 isLeaf 或者 val 的值为 False ，则表示值为 0 。\n示例 1： 输入： quadTree1 = [[0,1],[1,1],[1,1],[1,0],[1,0]],\nquadTree2 = [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n输出： [[0,0],[1,1],[1,1],[1,1],[1,0]]\n解释： quadTree1 和 quadTree2 如上所示。由四叉树所表示的二进制矩阵也已经给出。\n如果我们对这两个矩阵进行按位逻辑或运算，则可以得到下面的二进制矩阵，由一个作为结果的四叉树表示。\n注意，我们展示的二进制矩阵仅仅是为了更好地说明题意，你无需构造二进制矩阵来获得结果四叉树。 示例 2： 输入： quadTree1 = [[1,0]],\nquadTree2 = [[1,0]]\n输出： [[1,0]]\n解释： 两个数所表示的矩阵大小都为 11，值全为 0\n结果矩阵大小为 11，值全为 0 。\n示例 3： 输入： quadTree1 = [[0,0],[1,0],[1,0],[1,1],[1,1]],\nquadTree2 = [[0,0],[1,1],[1,1],[1,0],[1,1]]\n输出： [[1,1]]\n示例 4： 输入：quadTree1 = [[0,0],[1,1],[1,0],[1,1],[1,1]],\nquadTree2 = [[0,0],[1,1],[0,1],[1,1],[1,1],null,null,null,null,[1,1],[1,0],[1,0],[1,1]]\n输出：[[0,0],[1,1],[0,1],[1,1],[1,1],null,null,null,null,[1,1],[1,0],[1,0],[1,1]]\n示例 5： 输入：quadTree1 = [[0,1],[1,0],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]],\nquadTree2 = [[0,1],[0,1],[1,0],[1,1],[1,0],[1,0],[1,0],[1,1],[1,1]]\n输出：[[0,0],[0,1],[0,1],[1,1],[1,0],[1,0],[1,0],[1,1],[1,1],[1,0],[1,0],[1,1],[1,1]]\n说明： quadTree1 和 quadTree2 都是符合题目要求的四叉树，每个都代表一个 n * n 的矩阵。 n == 2x ，其中 0 \u0026lt;= x \u0026lt;= 9. 解题思路 分治 根据题意，需要将对应的结点进行或运算，必要时进行合并。\n递归从顶部向下查找叶节点，并逐层向上处理：\n若两个都不是叶节点，继续查找； 若其中仅有一个叶节点，并且其值为 1，则与对应另一个运算结果必然为 1，直接返回；否则，对其进行拆分，继续查找； 若两个都是叶节点，返回或运算的值； 当处理完一个节点的四个子树后，可能出现合并的情况，若四个子节点都是叶节点，并且值相同，则进行聚合。\nfunc intersect(quadTree1 *Node, quadTree2 *Node) *Node { var dfs func(n1, n2 *Node, v1, v2 bool) *Node dfs = func(n1, n2 *Node, v1, v2 bool) *Node { // 空节点，继承父节点的值 if n1 == nil { n1 = \u0026amp;Node{ Val: v1, IsLeaf: true, } } if n2 == nil { n2 = \u0026amp;Node{ Val: v2, IsLeaf: true, } } // 当其中一个为叶节点，并且 val 为 true 时，按位或最终结果必然为 true if n1.IsLeaf \u0026amp;\u0026amp; n1.Val || n2.IsLeaf \u0026amp;\u0026amp; n2.Val { return \u0026amp;Node{ Val: true, IsLeaf: true, } } // 两个都是叶节点，或运算 if n1.IsLeaf \u0026amp;\u0026amp; n2.IsLeaf { return \u0026amp;Node{ IsLeaf: true, Val: n1.Val || n2.Val, } } // 递归构建 n := \u0026amp;Node{ Val: false, IsLeaf: false, TopLeft: dfs(n1.TopLeft, n2.TopLeft, n1.Val, n2.Val), TopRight: dfs(n1.TopRight, n2.TopRight, n1.Val, n2.Val), BottomLeft: dfs(n1.BottomLeft, n2.BottomLeft, n1.Val, n2.Val), BottomRight: dfs(n1.BottomRight, n2.BottomRight, n1.Val, n2.Val), } // 子节点全部相同，进行合并 if n.TopLeft.IsLeaf \u0026amp;\u0026amp; n.TopRight.IsLeaf \u0026amp;\u0026amp; n.BottomLeft.IsLeaf \u0026amp;\u0026amp; n.BottomRight.IsLeaf \u0026amp;\u0026amp; n.TopLeft.Val == n.TopRight.Val \u0026amp;\u0026amp; n.TopLeft.Val == n.BottomLeft.Val \u0026amp;\u0026amp; n.TopLeft.Val == n.BottomRight.Val { return \u0026amp;Node{ Val: n.TopLeft.Val, IsLeaf: true, } } return n } return dfs(quadTree1, quadTree2, quadTree1.Val, quadTree2.Val) } 复杂度 时间复杂度：$ O(N), N = max(size(quadTree1), size(quadTree2) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-07-15T10:17:00+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-558.-%E5%9B%9B%E5%8F%89%E6%A0%91%E4%BA%A4%E9%9B%86/","title":"Leetcode 558. 四叉树交集"},{"content":"链接： https://leetcode.cn/problems/prefix-and-suffix-search/\n难度： 困难\n题目描述 设计一个包含一些单词的特殊词典，并能够通过前缀和后缀来检索单词。\n实现 WordFilter 类： WordFilter(string[] words) 使用词典中的单词 words 初始化对象。 f(string pref, string suff) 返回词典中具有前缀 prefix 和后缀 suff 的单词的下标。如果存在不止一个满足要求的下标，返回其中 最大的下标 。如果不存在这样的单词，返回 -1 。 示例 1： 输入：\n[\u0026ldquo;WordFilter\u0026rdquo;, \u0026ldquo;f\u0026rdquo;]\n[[[\u0026ldquo;apple\u0026rdquo;]], [\u0026ldquo;a\u0026rdquo;, \u0026ldquo;e\u0026rdquo;]]\n输出：\n[null, 0]\n解释：\nWordFilter wordFilter = new WordFilter([\u0026ldquo;apple\u0026rdquo;]);\nwordFilter.f(\u0026ldquo;a\u0026rdquo;, \u0026ldquo;e\u0026rdquo;); // 返回 0 ，因为下标为 0 的单词：前缀 prefix = \u0026ldquo;a\u0026rdquo; 且 后缀 suff = \u0026ldquo;e\u0026rdquo; 。\n提示： 2 \u0026lt;= letters.length \u0026lt;= 104 letters[i] 是一个小写字母 letters 按非递减顺序排序 letters 最少包含两个不同的字母 target 是一个小写字母 解题思路 哈希 由于字符串的长度很小，可以解析出所有能与之匹配的前后缀模式串，并记录该模式串对应的下标最大值到哈希表中。\n每次直接从哈希表中查找指定的模式串。\ntype WordFilter struct { pattern map[string]int } func Constructor(words []string) WordFilter { pattern := make(map[string]int) for idx, word := range words { for i := range word { for j := 0; j \u0026lt; len(word); j++ { pattern[fmt.Sprintf(\u0026#34;%s*%s\u0026#34;, word[:i+1], word[j:])] = idx } } } return WordFilter{ pattern: pattern, } } func (this *WordFilter) F(pref string, suff string) int { if idx, ok := this.pattern[fmt.Sprintf(\u0026#34;%s*%s\u0026#34;, pref, suff)]; ok { return idx } return -1 } 复杂度 时间复杂度： Constructor：$ O(\\sum{len(words[i])^3}) $ F：$ O(pref + suff) $ 空间复杂度：$ O(\\sum{len(words[i])^3}) $ ","date":"2022-07-14T10:11:46+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-745.-%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E6%90%9C%E7%B4%A2/","title":"Leetcode 745. 前缀和后缀搜索"},{"content":"链接： https://leetcode.cn/problems/asteroid-collision/\n难度： 中等\n题目描述 给定一个整数数组 asteroids，表示在同一行的行星。\n对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。\n找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。\n示例 1： 输入： asteroids = [5,10,-5]\n输出： [5,10]\n解释： 10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。\n示例 2： 输入： asteroids = [8,-8]\n输出： []\n解释： 8 和 -8 碰撞后，两者都发生爆炸。\n示例 3： 输入： asteroids = [10,2,-5]\n输出： [10]\n解释： 2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。\n提示： 2 \u0026lt;= asteroids.length \u0026lt;= 104 -1000 \u0026lt;= asteroids[i] \u0026lt;= 1000 asteroids[i] != 0 解题思路 栈 对于向右移动的行星，只有在其右侧出现向左移动的行星是，会发生碰撞。\n从左向右依次遍历，使用栈记录当前存在的所有行星，当遇到向左移动的行星时，进行碰撞判断：\n当栈为空时 或者 栈顶行星是向左移动时，不会发生碰撞，该行星入栈，继续向后遍历； 当向右移动的栈顶行星比该行星大时，该行星爆炸，继续向后遍历； 当向右移动的栈顶行星与该行星一样大时，两个都爆炸，栈顶行星出栈，继续向后遍历； 当向右移动的栈顶行星比该行星小时，栈顶行星爆炸，继续进行碰撞判断； 最后栈中存在所有未发生碰撞的行星。\nfunc asteroidCollision(asteroids []int) []int { ans := make([]int, 0, len(asteroids)) for _, a := range asteroids { if a \u0026gt; 0 { ans = append(ans, a) continue } for { // 不发生碰撞， if len(ans) == 0 || ans[len(ans)-1] \u0026lt; 0 { ans = append(ans, a) break } sum := ans[len(ans)-1] + a if sum \u0026gt; 0 { break } if sum == 0 { // 两个都爆炸 ans = ans[:len(ans)-1] break } ans = ans[:len(ans)-1] } } return ans } 复杂度 时间复杂度：$ O(N), N = len(asteroids) $ 空间复杂度：$ O(1) $ ","date":"2022-07-13T21:10:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-735.-%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E/","title":"Leetcode 735. 行星碰撞"},{"content":"链接： https://leetcode.cn/problems/cells-with-odd-values-in-a-matrix/\n难度： 简单\n题目描述 给你一个 m x n 的矩阵，最开始的时候，每个单元格中的值都是 0。\n另有一个二维索引数组 indices，indices[i] = [ri, ci] 指向矩阵中的某个位置，其中 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。\n对 indices[i] 所指向的每个位置，应同时执行下述增量操作：\nri 行上的所有单元格，加 1 。 ci 列上的所有单元格，加 1 。 给你 m、n 和 indices 。请你在执行完所有 indices 指定的增量操作后，返回矩阵中 奇数值单元格 的数目。\n示例 1： 输入： m = 2, n = 3, indices = [[0,1],[1,1]]\n输出： 6\n解释： 最开始的矩阵是 [[0,0,0],[0,0,0]]。\n第一次增量操作后得到 [[1,2,1],[0,1,0]]。\n最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。\n示例 2： 输入： m = 2, n = 2, indices = [[1,1],[0,0]]\n输出： 0\n解释： 最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。\n提示： 1 \u0026lt;= m, n \u0026lt;= 50 1 \u0026lt;= indices.length \u0026lt;= 100 0 \u0026lt;= ri \u0026lt; m 0 \u0026lt;= ci \u0026lt; n 进阶： 你可以设计一个时间复杂度为 $ O(n + m + indices.length)$ 且仅用 $O(n + m)$ 额外空间的算法来解决此问题吗？\n解题思路 模拟 按照题设描述，初始化一个矩阵，然后在矩阵上进行增量操作，最后统计 奇数值单元格 的数目。\nfunc oddCells(m int, n int, indices [][]int) int { matrix := make([][]int, m) for i := 0; i \u0026lt; m; i++ { matrix[i] = make([]int, n) } for _, pair := range indices { for col := 0; col \u0026lt; n; col++ { matrix[pair[0]][col]++ } for row := 0; row \u0026lt; m; row++ { matrix[row][pair[1]]++ } } ans := 0 for _, line := range matrix { for _, cell := range line { if cell\u0026amp;1 == 1 { ans++ } } } return ans } 复杂度 时间复杂度：$ O((m+n)*len(indices) + m*n) $ 空间复杂度：$ O(m*n) $ 优化 记录每一行和列被改动的次数，将行和列加起来就是对应单元格的值，统计数量。\nfunc oddCells(m int, n int, indices [][]int) int { row := make([]int, m) col := make([]int, n) for _, pair := range indices { row[pair[0]]++ col[pair[1]]++ } ans := 0 for _, r := range row { for _, c := range col { if (r+c)\u0026amp;1 == 1 { ans++ } } } return ans } 复杂度 时间复杂度：$ O(len(indices) + m*n) $ 空间复杂度：$ O(m+n) $ 再优化 再上述题解2的基础上，由于最终只关心奇偶性，只需统计所有行列的奇偶性，只有奇数叠加偶数的情况才是奇数。\n所以最后的结果是： 奇数行数 * 偶数列数 + 偶数行数 * 奇数列数\nfunc oddCells(m int, n int, indices [][]int) int { row := make([]int, m) col := make([]int, n) for _, pair := range indices { row[pair[0]]++ col[pair[1]]++ } oddRow := 0 for _, r := range row { if r\u0026amp;1 == 1 { oddRow++ } } oddCol := 0 for _, c := range col { if c\u0026amp;1 == 1 { oddCol++ } } return oddRow*(n-oddCol) + (m-oddRow)*oddCol } 复杂度 时间复杂度：$ O(len(indices) + m + n) $ 空间复杂度：$ O(m+n) $ ","date":"2022-07-12T20:58:51+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1252.-%E5%A5%87%E6%95%B0%E5%80%BC%E5%8D%95%E5%85%83%E6%A0%BC%E7%9A%84%E6%95%B0%E7%9B%AE/","title":"Leetcode 1252. 奇数值单元格的数目"},{"content":"链接： https://leetcode.cn/problems/implement-magic-dictionary/\n难度： 中等\n题目描述 设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。\n实现 MagicDictionary 类：\nMagicDictionary() 初始化对象 void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同 bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。 示例： 输入：\n[\u0026ldquo;MagicDictionary\u0026rdquo;, \u0026ldquo;buildDict\u0026rdquo;, \u0026ldquo;search\u0026rdquo;, \u0026ldquo;search\u0026rdquo;, \u0026ldquo;search\u0026rdquo;, \u0026ldquo;search\u0026rdquo;]\n[[], [[\u0026ldquo;hello\u0026rdquo;, \u0026ldquo;leetcode\u0026rdquo;]], [\u0026ldquo;hello\u0026rdquo;], [\u0026ldquo;hhllo\u0026rdquo;], [\u0026ldquo;hell\u0026rdquo;], [\u0026ldquo;leetcoded\u0026rdquo;]]\n输出：\n[null, null, false, true, false, false]\n解释：\nMagicDictionary magicDictionary = new MagicDictionary();\nmagicDictionary.buildDict([\u0026ldquo;hello\u0026rdquo;, \u0026ldquo;leetcode\u0026rdquo;]);\nmagicDictionary.search(\u0026ldquo;hello\u0026rdquo;); // 返回 False\nmagicDictionary.search(\u0026ldquo;hhllo\u0026rdquo;); // 将第二个 \u0026lsquo;h\u0026rsquo; 替换为 \u0026rsquo;e\u0026rsquo; 可以匹配 \u0026ldquo;hello\u0026rdquo; ，所以返回 True\nmagicDictionary.search(\u0026ldquo;hell\u0026rdquo;); // 返回 False\nmagicDictionary.search(\u0026ldquo;leetcoded\u0026rdquo;); // 返回 False\n提示： 1 \u0026lt;= dictionary.length \u0026lt;= 100 1 \u0026lt;= dictionary[i].length \u0026lt;= 100 dictionary[i] 仅由小写英文字母组成 dictionary 中的所有字符串 互不相同 1 \u0026lt;= searchWord.length \u0026lt;= 100 searchWord 仅由小写英文字母组成 buildDict 仅在 search 之前调用一次 最多调用 100 次 search 解题思路 哈希 基于题设的数据量，可以遍历整个词典，进行对照查找。\n满足题设 Search ，要求两个字符串的长度相同，在 buildDict 通过哈希表按照长度分开存储，降低搜索空间。\ntype MagicDictionary struct { dict map[int][]string } func Constructor() MagicDictionary { return MagicDictionary{ dict: make(map[int][]string), } } func (this *MagicDictionary) BuildDict(dictionary []string) { for _, word := range dictionary { this.dict[len(word)] = append(this.dict[len(word)], word) } } func (this *MagicDictionary) Search(searchWord string) bool { for _, word := range this.dict[len(searchWord)] { diff := 0 for i := 0; i \u0026lt; len(word); i++ { if searchWord[i] != word[i] { diff++ } } if diff == 1 { return true } } return false } 复杂度 时间复杂度： BuildDict：$ O(N), N = \\sum{len(dictionary[i])} $ Search：$ O(N) $ 空间复杂度：$ O(N) $ Trie 树 使用 dictionary 构造 Trie 树。\n进行匹配查询时，最多允许一次不匹配的情况。\ntype node struct { end bool children map[byte]*node } type MagicDictionary struct { head *node } func Constructor() MagicDictionary { return MagicDictionary{ head: \u0026amp;node{ end: false, children: make(map[byte]*node), }, } } func (this *MagicDictionary) BuildDict(dictionary []string) { for _, word := range dictionary { n := this.head for i := range word { if n.children[word[i]] == nil { n.children[word[i]] = \u0026amp;node{ end: false, children: make(map[byte]*node), } } n = n.children[word[i]] } n.end = true } } func (this *MagicDictionary) Search(searchWord string) bool { var dfs func(n *node, i int, diff bool) bool dfs = func(n *node, i int, diff bool) bool { // 完成匹配 if i == len(searchWord) { if !n.end { return false } return diff } // 已经代换过字符，后面需要完全匹配 if diff { // 未匹配到， if n.children[searchWord[i]] == nil { return false } // 继续匹配 return dfs(n.children[searchWord[i]], i+1, true) } // 未代换过字符 for char := range n.children { // 精确匹配 if searchWord[i] == char { if dfs(n.children[char], i+1, false) { return true } continue } // 代换 if dfs(n.children[char], i+1, true) { return true } } return false } return dfs(this.head, 0, false) } 复杂度 时间复杂度： BuildDict：$ O(N), N = \\sum{len(dictionary[i])} $ Search：$ O(N) $ 空间复杂度：$ O(N) $ ","date":"2022-07-11T10:03:34+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-676.-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%AD%94%E6%B3%95%E5%AD%97%E5%85%B8/","title":"Leetcode 676. 实现一个魔法字典"},{"content":"链接： https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/\n难度： 中等\n题目描述 如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的：\nn \u0026gt;= 3 对于所有 i + 2 \u0026lt;= n，都有 X_i + X_{i+1} = X_{i+2} 给定一个 严格递增 的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。\n（回想一下，子序列是从原序列 arr 中派生出来的，它从 arr 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）\n示例 1： 输入： arr = [1,2,3,4,5,6,7,8]\n输出： 5\n解释： 最长的斐波那契式子序列为 [1,2,3,5,8] 。\n示例 2： 输入： arr = [1,3,7,11,12,14,18]\n输出： 3\n解释： 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。\n提示： 3 \u0026lt;= arr.length \u0026lt;= 1000 1 \u0026lt;= arr[i] \u0026lt; arr[i + 1] \u0026lt;= 109 解题思路 哈希 对于一个 斐波那契式 的数列，当最开始的两个元素确定时，后续的元素全部可以通过递推公式得出。\n使用哈希表记录出现过的所有元素，通过枚举初始元素，不断计算下一个值并从哈希表中查找，直到找不到为止，得到当前数列的长度。\n在此过程中，找出最大长度。\nfunc lenLongestFibSubseq(arr []int) int { exist := make(map[int]struct{}) for _, num := range arr { exist[num] = struct{}{} } ans := 0 for i := len(arr) - 3; i \u0026gt;= 0; i-- { for j := len(arr) - 2; j \u0026gt; i; j-- { a, b := arr[i], arr[j] length := 2 for { if _, ok := exist[a+b]; !ok { break } length++ a, b = b, a+b } if length \u0026gt;= 3 \u0026amp;\u0026amp; ans \u0026lt; length { ans = length } } } return ans } 复杂度 时间复杂度：$ O(N^2), N = len(arr) $ 空间复杂度：$ O(N) $ ","date":"2022-07-09T09:42:30+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-873.-%E6%9C%80%E9%95%BF%E7%9A%84%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E9%95%BF%E5%BA%A6/","title":"Leetcode 873. 最长的斐波那契子序列的长度"},{"content":"链接： https://leetcode.cn/problems/minimum-absolute-difference/\n难度： 简单\n题目描述 有 n 个筹码。第 i 个筹码的位置是 position[i] 。\n我们需要把所有筹码移到同一个位置。在一步中，我们可以将第 i 个筹码的位置从 position[i] 改变为:\nposition[i] + 2 或 position[i] - 2 ，此时 cost = 0 position[i] + 1 或 position[i] - 1 ，此时 cost = 1 返回将所有筹码移动到同一位置上所需要的 最小代价 。\n示例 1： 输入： position = [1,2,3]\n输出： 1\n解释： 第一步:将位置3的筹码移动到位置1，成本为0。\n第二步:将位置2的筹码移动到位置1，成本= 1。\n总成本是1。\n示例 2： 输入： position = [2,2,2,3,3]\n输出： 2\n解释： 我们可以把位置3的两个筹码移到位置2。每一步的成本为1。总成本= 2。\n示例 3： 输入： position = [1,1000000000]\n输出： 1\n提示： 1 \u0026lt;= chips.length \u0026lt;= 100 1 \u0026lt;= chips[i] \u0026lt;= 109 解题思路 模拟 由于移动两个位置的 代价 为 0，则所有的筹码均可以按照此规则 零代价 地移动：\n位置下标为偶数的所有筹码可以 零代价 移动到一起， 同理，位置下标为奇数的所有筹码可以 零代价 移动到一起 最终偶数下标的筹码与奇数下标的筹码距离为 1，移动较少的那一堆，即为 最小代价。\nfunc minCostToMoveChips(position []int) int { odd, even := 0, 0 for _, p := range position { if p\u0026amp;1 == 1 { odd++ } else { even++ } } if odd \u0026lt; even { return odd } return even } 复杂度 时间复杂度：$ O(N), N = len(position) $ 空间复杂度：$ O(1) $ ","date":"2022-07-08T10:33:33+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1217.-%E7%8E%A9%E7%AD%B9%E7%A0%81/","title":"Leetcode 1217. 玩筹码"},{"content":"链接： https://leetcode.cn/problems/replace-words/\n难度： 中等\n题目描述 在英语中，我们有一个叫做 词根(root) 的概念，可以词根后面添加其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根 an，跟随着单词 other (其他)，可以形成新的单词 another (另一个)。\n现在，给定一个由许多词根组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。\n你需要输出替换之后的句子。\n示例 1： 输入： dictionary = [\u0026ldquo;cat\u0026rdquo;,\u0026ldquo;bat\u0026rdquo;,\u0026ldquo;rat\u0026rdquo;], sentence = \u0026ldquo;the cattle was rattled by the battery\u0026rdquo;\n输出： \u0026ldquo;the cat was rat by the bat\u0026rdquo;\n示例 2： 输入： dictionary = [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;c\u0026rdquo;], sentence = \u0026ldquo;aadsfasf absbs bbab cadsfafs\u0026rdquo;\n输出： \u0026ldquo;a a b c\u0026rdquo;\n提示： 1 \u0026lt;= dictionary.length \u0026lt;= 1000 1 \u0026lt;= dictionary[i].length \u0026lt;= 100 dictionary[i] 仅由小写字母组成。 1 \u0026lt;= sentence.length \u0026lt;= 106 sentence 仅由小写字母和空格组成。 sentence 中单词的总量在范围 [1, 1000] 内。 sentence 中每个单词的长度在范围 [1, 1000] 内。 sentence 中单词之间由一个空格隔开。 sentence 没有前导或尾随空格。 解题思路 匹配 识别出 sentence 里的每个单词，然后遍历整个 dictionary，当存在 词根（即前缀）时，将当前单词替换为 词根，即可保证最终的词根最短。\nfunc replaceWords(dictionary []string, sentence string) string { words := strings.Split(sentence, \u0026#34; \u0026#34;) for i := range words { for _, root := range dictionary { if strings.HasPrefix(words[i], root) { words[i] = root } } } return strings.Join(words, \u0026#34; \u0026#34;) } 复杂度 时间复杂度：$ O(MN), M = \\sum{len(dictionary[i])}, N = len(words) $ 空间复杂度：$ O(N) $ Trie树 以 dictionary 中的所有元素构造一颗 Trie 树，对于识别出的每个单词，到 Trie 树中匹配前缀，当可以匹配到时，使用该前缀替换。\ntype node struct { end bool children map[byte]*node } func newNode() *node { return \u0026amp;node{ end: false, children: make(map[byte]*node), } } type trie struct { root *node } func NewTrie() *trie { return \u0026amp;trie{ root: newNode(), } } func (t *trie) Insert(s string) { cur := t.root for i := range s { if cur.children[s[i]] == nil { cur.children[s[i]] = newNode() } cur = cur.children[s[i]] } cur.end = true } func (t *trie) Match(s string) string { ans := make([]byte, 0, len(s)) cur := t.root for i := range s { if cur.children[s[i]] == nil { return \u0026#34;\u0026#34; } ans = append(ans, s[i]) cur = cur.children[s[i]] if cur.end { return string(ans) } } return \u0026#34;\u0026#34; } func replaceWords(dictionary []string, sentence string) string { trie := NewTrie() for _, root := range dictionary { trie.Insert(root) } words := strings.Split(sentence, \u0026#34; \u0026#34;) for i := range words { root := trie.Match(words[i]) if root == \u0026#34;\u0026#34; { continue } words[i] = root } return strings.Join(words, \u0026#34; \u0026#34;) } 复杂度 时间复杂度：$ O(M + L), M = \\sum{len(dictionary[i])}, L = len(sentence) $ 空间复杂度：$ O(M) $ ","date":"2022-07-07T10:14:37+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-648.-%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2/","title":"Leetcode 648. 单词替换"},{"content":"链接： https://leetcode.cn/problems/parse-lisp-expression/\n难度： 困难\n题目描述 给你一个类似 Lisp 语句的字符串表达式 expression，求出其计算结果。\n表达式语法如下所示:\n表达式可以为整数，let 表达式，add 表达式，mult 表达式，或赋值的变量。表达式的结果总是一个整数。 (整数可以是正整数、负整数、0) let 表达式采用 \u0026quot;(let v1 e1 v2 e2 ... vn en expr)\u0026quot; 的形式，其中 let 总是以字符串 \u0026quot;let\u0026quot; 来表示，接下来会跟随一对或多对交替的变量和表达式，也就是说，第一个变量 v1 被分配为表达式 e1 的值，第二个变量 v2 被分配为表达式 e2 的值，依次类推；最终 let 表达式的值为 expr 表达式的值。 add 表达式表示为 \u0026quot;(add e1 e2)\u0026quot; ，其中 add 总是以字符串 \u0026quot;add\u0026quot; 来表示，该表达式总是包含两个表达式 e1、e2 ，最终结果是 e1 表达式的值与 e2 表达式的值之 和 。 mult 表达式表示为 \u0026quot;(mult e1 e2)\u0026quot; ，其中 mult 总是以字符串 \u0026quot;mult\u0026quot; 表示，该表达式总是包含两个表达式 e1、e2，最终结果是 e1 表达式的值与 e2 表达式的值之 积 。 在该题目中，变量名以小写字符开始，之后跟随 0 个或多个小写字符或数字。为了方便，\u0026quot;add\u0026quot; ，\u0026quot;let\u0026quot; ，\u0026quot;mult\u0026quot; 会被定义为 \u0026ldquo;关键字\u0026rdquo; ，不会用作变量名。 最后，要说一下作用域的概念。计算变量名所对应的表达式时，在计算上下文中，首先检查最内层作用域（按括号计），然后按顺序依次检查外部作用域。测试用例中每一个表达式都是合法的。有关作用域的更多详细信息，请参阅示例。 示例 1： 输入： expression = \u0026ldquo;(let x 2 (mult x (let x 3 y 4 (add x y))))\u0026rdquo;\n输出： 14\n解释：\n计算表达式 (add x y), 在检查变量 x 值时，\n在变量的上下文中由最内层作用域依次向外检查。\n首先找到 x = 3, 所以此处的 x 值是 3 。\n示例 2： 输入： expression = \u0026ldquo;(let x 3 x 2 x)\u0026rdquo;\n输出： 2\n解释： let 语句中的赋值运算按顺序处理即可。\n示例 3： 输入： expression = \u0026ldquo;(let x 1 y 2 x (add x y) (add x y))\u0026rdquo;\n输出： 5\n解释：\n第一个 (add x y) 计算结果是 3，并且将此值赋给了 x 。\n第二个 (add x y) 计算结果是 3 + 2 = 5 。\n提示： 1 \u0026lt;= expression.length \u0026lt;= 2000 exprssion 中不含前导和尾随空格 expressoin 中的不同部分（token）之间用单个空格进行分隔 答案和所有中间计算结果都符合 32-bit 整数范围 测试用例中的表达式均为合法的且最终结果为整数 解题思路 递归下降分析 type solution struct { e string variables map[string][]int } // 解析变量名 func (s *solution) buildVariable() string { s.e = strings.TrimLeft(s.e, \u0026#34; \u0026#34;) i := 0 for ; s.e[i] != \u0026#39; \u0026#39; \u0026amp;\u0026amp; s.e[i] != \u0026#39;)\u0026#39;; i++ { } name := s.e[:i] s.e = s.e[i:] return name } // 解析数字 func (s *solution) buildNum() int { s.e = strings.TrimLeft(s.e, \u0026#34; \u0026#34;) i := 0 for ; unicode.IsDigit(rune(s.e[i])) || s.e[i] == \u0026#39;-\u0026#39;; i++ { } num, _ := strconv.Atoi(s.e[:i]) s.e = s.e[i:] return num } // 解析let字句 func (s *solution) buildLet() int { names := make([]string, 0, 1) ans := 0 for s.e[0] != \u0026#39;)\u0026#39; { s.e = strings.TrimLeft(s.e, \u0026#34; \u0026#34;) // expr 部分 if s.e[0] == \u0026#39;(\u0026#39; || !unicode.IsLower(rune(s.e[0])) { ans = s.build() break } name := s.buildVariable() s.e = strings.TrimLeft(s.e, \u0026#34; \u0026#34;) // let 字句结束，最后一个变量时 expr ，不是变量名 if s.e[0] == \u0026#39;)\u0026#39; { ans = s.variables[name][len(s.variables[name])-1] break } val := s.build() s.variables[name] = append(s.variables[name], val) names = append(names, name) } s.e = s.e[1:] // 当前作用域内定义的变量值消除 for _, name := range names { s.variables[name] = s.variables[name][:len(s.variables[name])-1] } return ans } // 解析add字句 func (s *solution) buildAdd() int { e1 := s.build() e2 := s.build() s.e = strings.TrimLeft(s.e, \u0026#34; \u0026#34;)[1:] return e1 + e2 } // 解析mult子句 func (s *solution) buildMult() int { e1 := s.build() e2 := s.build() s.e = strings.TrimLeft(s.e, \u0026#34; \u0026#34;)[1:] return e1 * e2 } // 主解析函数 func (s *solution) build() int { s.e = strings.TrimLeft(s.e, \u0026#34; \u0026#34;) if unicode.IsDigit(rune(s.e[0])) || s.e[0] == \u0026#39;-\u0026#39; { return s.buildNum() } if s.e[0] == \u0026#39;(\u0026#39; { s.e = strings.TrimLeft(s.e, \u0026#34;( \u0026#34;) switch s.e[0] { case \u0026#39;l\u0026#39;: // let s.e = s.e[3:] return s.buildLet() case \u0026#39;a\u0026#39;: // add s.e = s.e[3:] return s.buildAdd() case \u0026#39;m\u0026#39;: // mult s.e = s.e[4:] return s.buildMult() } } name := s.buildVariable() return s.variables[name][len(s.variables[name])-1] } func evaluate(expression string) int { return (\u0026amp;solution{ e: expression, variables: make(map[string][]int), }).build() } 复杂度 时间复杂度：$ O(N), N = len(expression) $ 空间复杂度：$ O(N) $ ","date":"2022-07-06T19:31:29+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-736.-lisp-%E8%AF%AD%E6%B3%95%E8%A7%A3%E6%9E%90/","title":"Leetcode 736. Lisp 语法解析"},{"content":"链接： https://leetcode.cn/problems/my-calendar-i/\n难度： 中等\n题目描述 实现一个 MyCalendar 类来存放你的日程安排。如果要添加的日程安排不会造成 重复预订 ，则可以存储这个新的日程安排。\n当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 重复预订 。\n日程可以用一对整数 start 和 end 表示，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start \u0026lt;= x \u0026lt; end 。\n实现 MyCalendar 类：\nMyCalendar() 初始化日历对象。 boolean book(int start, int end) 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true 。否则，返回 false 并且不要将该日程安排添加到日历中。 示例： 输入：\n[\u0026ldquo;MyCalendar\u0026rdquo;, \u0026ldquo;book\u0026rdquo;, \u0026ldquo;book\u0026rdquo;, \u0026ldquo;book\u0026rdquo;]\n[[], [10, 20], [15, 25], [20, 30]]\n输出：\n[null, true, false, true]\n解释：\nMyCalendar myCalendar = new MyCalendar();\nmyCalendar.book(10, 20); // return True\nmyCalendar.book(15, 25); // return False ，这个日程安排不能添加到日历中，因为时间 15 已经被另一个日程安排预订了。\nmyCalendar.book(20, 30); // return True ，这个日程安排可以添加到日历中，因为第一个日程安排预订的每个时间都小于 20 ，且不包含时间 20 。\n提示： 0 \u0026lt;= start \u0026lt; end \u0026lt;= 109 每个测试用例，调用 book 方法的次数最多不超过 1000 次。 解题思路 暴力求解 存储所有不冲突的日程。\n当有新日程时，遍历日程列表，寻找是否出现冲突：\n出现冲突的时候，返回 false; 否则，添加到日程列表中，并返回 true。 type MyCalendar struct { book [][2]int } func Constructor() MyCalendar { return MyCalendar{ book: make([][2]int, 0, 10), } } func (this *MyCalendar) Book(start int, end int) bool { for _, schedule := range this.book { if start \u0026lt; schedule[1] \u0026amp;\u0026amp; end \u0026gt; schedule[0] { return false } } this.book = append(this.book, [2]int{start, end}) return true } 复杂度 时间复杂度： Constructor: $ O(1) $ Book：$ O(N), N表示Book的调用次数 $ 空间复杂度：$ O(N) $ ","date":"2022-07-05T14:25:31+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-729.-%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8-i/","title":"Leetcode 729. 我的日程安排表 I"},{"content":"链接： https://leetcode.cn/problems/minimum-absolute-difference/\n难度： 简单\n题目描述 给你个整数数组 arr，其中每个元素都 不相同。\n请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。\n示例 1： 输入： arr = [4,2,1,3]\n输出： [[1,2],[2,3],[3,4]]\n示例 2： 输入： arr = [1,3,6,10,15]\n输出： [[1,3]]\n示例 3： 输入： arr = [3,8,-10,23,19,-4,-14,27]\n输出： [[-14,-10],[19,23],[23,27]]\n提示： 2 \u0026lt;= arr.length \u0026lt;= 105 -106 \u0026lt;= arr[i] \u0026lt;= 106 解题思路 排序 将原数组从小到大排序，则最小差值一定出现在两个相邻的元素之间，依次遍历判断寻找：\n当当前差值大于最小差值时，忽略； 当当前差值等于最小差值时，加入到结果数组中； 当当前差值小于最小差值时，之前保留的结果无效，进行清空，并将当前元素对加入到结果数组中； func minimumAbsDifference(arr []int) [][]int { sort.Ints(arr) ans := make([][]int, 0, len(arr)) minDiff := math.MaxInt for i := 1; i \u0026lt; len(arr); i++ { diff := arr[i] - arr[i-1] if minDiff \u0026lt; diff { continue } if minDiff \u0026gt; diff { minDiff = diff ans = ans[:0] } ans = append(ans, []int{arr[i-1], arr[i]}) } return ans } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(arr) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-07-04T10:17:30+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1200.-%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/","title":"Leetcode 1200. 最小绝对差"},{"content":"链接： https://leetcode.cn/problems/different-ways-to-add-parentheses/\n难度： 中等\n题目描述 给你一个由数字和运算符组成的字符串 expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。\n生成的测试用例满足其对应输出值符合 32 位整数范围，不同结果的数量不超过 104 。\n示例 1： 输入： expression = \u0026ldquo;2-1-1\u0026rdquo;\n输出： [0,2]\n解释：\n((2-1)-1) = 0\n(2-(1-1)) = 2\n示例 2： 输入： expression = \u0026ldquo;2*3-4*5\u0026rdquo;\n输出： [-34,-14,-10,-10,10]\n解释：\n(2*(3-(45))) = -34\n((23)-(45)) = -14\n((2(3-4))5) = -10\n(2((3-4)5)) = -10\n(((23)-4)*5) = 10\n提示： 1 \u0026lt;= expression.length \u0026lt;= 20 expression 由数字和算符 '+'、'-' 和 '*' 组成。 输入表达式中的所有整数值在范围 [0, 99] 解题思路 分治 两个表达式进行运算，若其计算结果分别有 x 和 y 种，则最终的计算结果将 x 和 y 中所有结果的两两组合进行运算即可。\n根据上述性质，对于一个表达式，枚举运算符作为分隔，得到两个子表达式，同理不断进行枚举分隔，直到表达式仅有一个数时为止，则其计算结果即为该数。\n对于每个运算符，求得两个子表达式的计算结果，进行上述运算。\nfunc diffWaysToCompute(expression string) []int { nums := make([]int, 0, len(expression)/2) // 所有的数 ops := make([]byte, 0, len(expression)/2) // 所有的运算符 // 识别 buf := make([]byte, 0, 2) for i := 0; i \u0026lt; len(expression); i++ { switch expression[i] { case \u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;*\u0026#39;: num, _ := strconv.Atoi(string(buf)) nums = append(nums, num) buf = buf[:0] ops = append(ops, expression[i]) default: buf = append(buf, expression[i]) } } num, _ := strconv.Atoi(string(buf)) nums = append(nums, num) // l， r 数的左右边界，闭区间 var divideAndConquer func(l, r int) []int divideAndConquer = func(l, r int) []int { // 仅有一个数，返回 if l == r { return []int{nums[l]} } ans := make([]int, 0, r-l) // 记录当前表达式的结果 // 枚举所有的运算符 for i := l; i \u0026lt; r; i++ { lAns := divideAndConquer(l, i) // 左子表达式的结果 rAns := divideAndConquer(i+1, r) // 右子表达式的结果 // 两两组合运算 for _, lA := range lAns { for _, rA := range rAns { switch ops[i] { case \u0026#39;+\u0026#39;: ans = append(ans, lA+rA) case \u0026#39;-\u0026#39;: ans = append(ans, lA-rA) case \u0026#39;*\u0026#39;: ans = append(ans, lA*rA) } } } } return ans } return divideAndConquer(0, len(nums)-1) } 复杂度 时间复杂度：$ O(N*2^N), N为运算符的数量 $ 空间复杂度：$ O(2^N) $ 动态规划 上述解法中，有很多子问题中是重复的，采用动态规划的方法，自底向上进行计算。\nfunc diffWaysToCompute(expression string) []int { nums := make([]int, 0, len(expression)/2) // 所有的数 ops := make([]byte, 0, len(expression)/2) // 所有的运算符 // 识别 buf := make([]byte, 0, 2) for i := 0; i \u0026lt; len(expression); i++ { switch expression[i] { case \u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;*\u0026#39;: num, _ := strconv.Atoi(string(buf)) nums = append(nums, num) buf = buf[:0] ops = append(ops, expression[i]) default: buf = append(buf, expression[i]) } } num, _ := strconv.Atoi(string(buf)) nums = append(nums, num) // 初始化 dp := make([][][]int, len(nums)) for i := range nums { dp[i] = make([][]int, len(nums)) dp[i][i] = []int{nums[i]} } // 区间长度 for length := 1; length \u0026lt; len(nums); length++ { // 区间开始 for i := len(nums) - 1 - length; i \u0026gt;= 0; i-- { // 枚举区间内的运算符 for j := i + length - 1; j \u0026gt;= i; j-- { // 两两组合运算 for _, lA := range dp[i][j] { for _, rA := range dp[j+1][i+length] { switch ops[j] { case \u0026#39;+\u0026#39;: dp[i][i+length] = append(dp[i][i+length], lA+rA) case \u0026#39;-\u0026#39;: dp[i][i+length] = append(dp[i][i+length], lA-rA) case \u0026#39;*\u0026#39;: dp[i][i+length] = append(dp[i][i+length], lA*rA) } } } } } } return dp[0][len(nums)-1] } 复杂度 时间复杂度：$ O(2^N), N为运算符的数量 $ 空间复杂度：$ O(2^N) $ ","date":"2022-07-01T10:16:30+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-241.-%E4%B8%BA%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7/","title":"Leetcode 241. 为运算表达式设计优先级"},{"content":"链接： https://leetcode.cn/problems/prime-arrangements/\n难度： 简单\n题目描述 请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。\n让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。\n由于答案可能会很大，所以请你返回答案 模 mod 109 + 7 之后的结果即可。\n示例 1： 输入： n = 5\n输出： 12\n解释： 举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。\n示例 2： 输入： n = 100\n输出： 682289015\n提示： 1 \u0026lt;= n \u0026lt;= 100 解题思路 排列 不妨设 [1, n] 区间内的质数数量为 x，对应的质数下标数量也为 x。\n需要将这 x 个下标置于对应 x 个下标位置上，则有 x! 种方案。\n并且将其余的 n-x 个数置于其余位置上，有 (n-x)! 种方案。\n故完整排列的方案数为 x! * (n-x)!。\nfunc factorial(n int64, mod int64) int64 { ans := int64(1) for i := int64(2); i \u0026lt;= n; i++ { ans = (ans * i) % mod } return ans } func isPrime(x int) bool { for i := int(math.Sqrt(float64(x))); i \u0026gt; 1; i-- { if x%i == 0 { return true } } return false } func numPrimeArrangements(n int) int { const MOD = int64(1e9 + 7) // 统计质数数量 numPrimes := 0 for i := 2; i \u0026lt;= n; i++ { if !isPrime(i) { numPrimes++ } } return int(factorial(int64(numPrimes), MOD) * factorial(int64(n-numPrimes), MOD) % MOD) } 复杂度 时间复杂度：$ O(n\\sqrt{n}) $ 空间复杂度：$ O(1) $ ","date":"2022-06-30T10:15:46+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1175.-%E8%B4%A8%E6%95%B0%E6%8E%92%E5%88%97/","title":"Leetcode 1175. 质数排列"},{"content":"链接： https://leetcode.cn/problems/k-diff-pairs-in-an-array/\n难度： 中等\n题目描述 TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk 。请你设计一个类来加密与解密 TinyURL 。\n加密和解密算法如何设计和运作是没有限制的，你只需要保证一个 URL 可以被加密成一个 TinyURL ，并且这个 TinyURL 可以用解密方法恢复成原本的 URL 。\n实现 Solution 类：\nSolution() 初始化 TinyURL 系统对象。 String encode(String longUrl) 返回 longUrl 对应的 TinyURL 。 String decode(String shortUrl) 返回 shortUrl 原本的 URL 。题目数据保证给定的 shortUrl 是由同一个系统对象加密的。 示例： 输入： url = \u0026ldquo;https://leetcode.com/problems/design-tinyurl\"\n输出： \u0026ldquo;https://leetcode.com/problems/design-tinyurl\"\n解释：\nSolution obj = new Solution();\nstring tiny = obj.encode(url); // 返回加密后得到的 TinyURL 。\nstring ans = obj.decode(tiny); // 返回解密后得到的原本的 URL 。\n提示： 1 \u0026lt;= url.length \u0026lt;= 104 题目数据保证 url 是一个有效的 URL 解题思路 哈希 使用自增 id，维护该 id 到 longUrl 的映射，shortUrl 即为 \u0026quot;http://tinyurl.com/\u0026quot; 与 id 的连接。\n解码时，识别出 id，查询得到 longUrl。\ntype Codec struct { short2long map[int]string id int } func Constructor() Codec { return Codec{ short2long: make(map[int]string), id: 0, } } // Encodes a URL to a shortened URL. func (this *Codec) encode(longUrl string) string { this.id++ this.short2long[this.id] = longUrl return \u0026#34;http://tinyurl.com/\u0026#34; + strconv.Itoa(this.id) } // Decodes a shortened URL to its original URL. func (this *Codec) decode(shortUrl string) string { id, _ := strconv.Atoi(strings.TrimLeft(shortUrl, \u0026#34;http://tinyurl.com/\u0026#34;)) return this.short2long[id] } 复杂度 时间复杂度： Constructor：$ O(1) $ encode：$ O(1) $ decode：$ O(1) $ 空间复杂度：$ O(N), N 为 encode 的调用次数 $ ","date":"2022-06-29T10:17:53+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-535.-tinyurl-%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86/","title":"Leetcode 535. TinyURL 的加密与解密"},{"content":"链接： https://leetcode.cn/problems/wiggle-sort-ii/\n难度： 中等\n题目描述 给你一个整数数组 nums，将它重新排列成 nums[0] \u0026lt; nums[1] \u0026gt; nums[2] \u0026lt; nums[3]... 的顺序。\n你可以假设所有输入数组都可以得到满足题目要求的结果。\n示例 1： 输入： nums = [1,5,1,1,6,4]\n输出： [1,6,1,5,1,4]\n解释： [1,4,1,5,1,6] 同样是符合题目要求的结果，可以被判题程序接受。\n示例 2： 输入： nums = [1,3,2,2,3,1]\n输出： [2,3,1,3,1,2]\n提示： 1 \u0026lt;= nums.length \u0026lt;= 5 * 104 0 \u0026lt;= nums[i] \u0026lt;= 5000 题目数据保证，对于给定的输入 nums ，总能产生满足题目要求的结果 进阶： 你能用 $O(n)$ 时间复杂度和 / 或原地 $O(1)$ 额外空间来实现吗？\n解题思路 排序 由于输入一定会满足要求，则相同的元素数量一定不会超过 (len(nums)+1)/2，对于排序后的元素，从中间切分为较小和较大的两部分倒。为规避相同元素相邻，倒序写入。\nfunc wiggleSort(nums []int) { dup := make([]int, len(nums)) copy(dup, nums) sort.Ints(dup) l, r := (len(nums)-1)/2, len(nums)-1 for i := range nums { if i\u0026amp;1 == 0 { nums[i] = dup[l] l-- } else { nums[i] = dup[r] r-- } } } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2022-06-28T10:11:16+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-324.-%E6%91%86%E5%8A%A8%E6%8E%92%E5%BA%8F-ii/","title":"Leetcode 324. 摆动排序 II"},{"content":"链接： https://leetcode.cn/problems/JEj789/\n难度： 中等\n题目描述 假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。\n当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。\n例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。\n请计算出粉刷完所有房子最少的花费成本。\n示例 1： 输入： costs = [[17,2,17],[16,16,5],[14,3,19]]\n输出： 10\n解释： 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。\n最少花费: 2 + 5 + 3 = 10。\n示例 2： 输入： costs = [[7,6,2]]\n输出： 2\n提示 costs.length == n costs[i].length == 3 1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= costs[i][j] \u0026lt;= 20 解题思路 动态规划 如果按照顺序从头至尾粉刷所有的房子，则每一个房子可以被粉刷的颜色受到上一个房子粉刷的颜色约束。\n若已知一列被粉刷好的房子，最后一幢被粉刷的颜色对应的花费最小值，则在其后再加一幢房子，亦可计算得出其被粉刷为三种颜色对应的总花费最小值。\n设 dpRed[i][j] 表示第 i 幢房子被粉刷为颜色 j 的最小花费，则有状态转移方程：\n若将该幢房子粉刷为红色，则其前一个房子为蓝色或绿色，dp[i][0] = costs[i][0] + min(dp[i-1][1], dp[i-1][2]); 若将该幢房子粉刷为蓝色，则其前一个房子为红色或绿色，dp[i][1] = costs[i][1] + min(dp[i-1][0], dp[i-1][2]); 若将该幢房子粉刷为绿色，则其前一个房子为红色或蓝色，dp[i][2] = costs[i][2] + min(dp[i-1][0], dp[i-1][1]); 最后选择话费最小的染色方案即可。\n由于每个状态仅与前一个相关，采用滚动数组降低空间复杂度。\nfunc min(a int, nums ...int) int { for _, num := range nums { if a \u0026gt; num { a = num } } return a } func minCost(costs [][]int) int { dp, newDp := [3]int{}, [3]int{} for _, colors := range costs { newDp[0] = colors[0] + min(dp[1], dp[2]) newDp[1] = colors[1] + min(dp[0], dp[2]) newDp[2] = colors[2] + min(dp[0], dp[1]) dp = newDp } return min(dp[0], dp[1], dp[2]) } 复杂度 时间复杂度：$ O(N), N = len(costs) $ 空间复杂度：$ O(1) $ ","date":"2022-06-25T09:08:16+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-ii-091.-%E7%B2%89%E5%88%B7%E6%88%BF%E5%AD%90/","title":"剑指 Offer II 091. 粉刷房子"},{"content":"链接： https://leetcode.cn/problems/find-largest-value-in-each-tree-row/\n难度： 中等\n题目描述 给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。\n示例 1： 输入： root = [1,3,2,5,3,null,9]\n输出： [1,3,9]\n示例 2： 输入： root = [1,2,3]\n输出： [1,3]\n提示： 二叉树的节点个数的范围是 [1,104] -231 \u0026lt;= Node.val \u0026lt;= 231 - 1 解题思路 深度优先搜索 采用深度优先搜索遍历整颗二叉树，将深度信息传递下去，同一深度的节点，当遇到更大值时更新。\nfunc largestValues(root *TreeNode) []int { ans := make([]int, 0) var dfs func(node *TreeNode, depth int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if len(ans) \u0026lt;= depth { ans = append(ans, node.Val) } else if ans[depth] \u0026lt; node.Val { ans[depth] = node.Val } dfs(node.Left, depth+1) dfs(node.Right, depth+1) } dfs(root, 0) return ans } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-06-24T10:32:46+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-515.-%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/","title":"Leetcode 515. 在每个树行中找最大值"},{"content":"链接： https://leetcode.cn/problems/find-bottom-left-tree-value/\n难度： 中等\n题目描述 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。\n假设二叉树中至少有一个节点。\n示例 1： 输入： root = [2,1,3]\n输出： 1\n示例 2： 输入： [1,2,3,4,null,5,6,null,null,7]\n输出： 7\n提示： 二叉树的节点个数的范围是 [1,104] -231 \u0026lt;= Node.val \u0026lt;= 231 - 1 解题思路 深度优先搜索 + 哈希 采用深度优先搜索遍历整颗二叉树，采用先左后右到顺序遍历子节点，则对于某一层而言，最左的结点最先遍历到。\n将深度信息传递下去，当深度发生变更时，即得到下一层最左节点，更新记录。\nfunc findBottomLeftValue(root *TreeNode) int { ans := 0 maxDepth := 0 var dfs func(node *TreeNode, depth int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if maxDepth \u0026lt; depth { maxDepth = depth ans = node.Val } dfs(node.Left, depth+1) dfs(node.Right, depth+1) } dfs(root, 0) return LeftVal[maxDepth] } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-06-22T09:46:17+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-513.-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/","title":"Leetcode 513. 找树左下角的值"},{"content":"链接： https://leetcode.cn/problems/defanging-an-ip-address/\n难度： 简单\n题目描述 给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。\n所谓无效化 IP 地址，其实就是用 \u0026quot;[.]\u0026quot; 代替了每个 \u0026quot;.\u0026quot;。\n示例 1： 输入： address = \u0026ldquo;1.1.1.1\u0026rdquo;\n输出： \u0026ldquo;1[.]1[.]1[.]1\u0026rdquo;\n示例 2： 输入： address = \u0026ldquo;255.100.50.0\u0026rdquo;\n输出： \u0026ldquo;255[.]100[.]50[.]0\u0026rdquo;\n提示： 给出的 address 是一个有效的 IPv4 地址 解题思路 模拟 使用另一个字符串存储结果，遍历该地址，当遇到 \u0026quot;.\u0026quot; 时，将 \u0026quot;[.]\u0026quot; 添加到结果尾，否则添加原字符。\nfunc defangIPaddr(address string) string { ans := make([]byte, 0, len(address)+6) for i := range address { if address[i] != \u0026#39;.\u0026#39; { ans = append(ans, address[i]) continue } ans = append(ans, \u0026#39;[\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;]\u0026#39;) } return string(ans) } 复杂度 时间复杂度：$ O(N), N = len(address) $ 空间复杂度：$ O(1) $ ","date":"2022-06-22T09:33:43+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1108.-ip-%E5%9C%B0%E5%9D%80%E6%97%A0%E6%95%88%E5%8C%96/","title":"Leetcode 1108. IP 地址无效化"},{"content":"链接： https://leetcode.cn/problems/most-frequent-subtree-sum/\n难度： 中等\n题目描述 给你一个二叉树的根结点 root ，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。\n一个结点的 「子树元素和」 定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。\n示例 1： 输入： root = [5,2,-3]\n输出： [2,-3,4]\n示例 2： 输入： root = [5,2,-5]\n输出： [2]\n提示： 节点数在 [1, 104] 范围内 -105 \u0026lt;= Node.val \u0026lt;= 105 解题思路 深度优先搜索 + 哈希 遍历二叉树，计算以每个节点为根节点的子树的和，使用哈希表记录每个和出现的次数，并求得最大出现次数。\n遍历哈希表，找出最大次数的和返回。\nfunc findFrequentTreeSum(root *TreeNode) []int { sum2Cnt := make(map[int]int) maxCnt := 0 var dfs func(node *TreeNode) int dfs = func(node *TreeNode) int { if node == nil { return 0 } sum := node.Val + dfs(node.Left) + dfs(node.Right) sum2Cnt[sum]++ if maxCnt \u0026lt; sum2Cnt[sum] { maxCnt = sum2Cnt[sum] } return sum } dfs(root) ans := make([]int, 0, 1) for sum, cnt := range sum2Cnt { if cnt == maxCnt { ans = append(ans, sum) } } return ans } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(N) $ ","date":"2022-06-19T09:55:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-508.-%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AD%90%E6%A0%91%E5%85%83%E7%B4%A0%E5%92%8C/","title":"Leetcode 508. 出现次数最多的子树元素和"},{"content":"链接： https://leetcode.cn/problems/4ueAj6/\n难度： 中等\n题目描述 给定 循环单调非递减列表 中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的。\n给定的可以是这个列表中任意一个顶点的指针，并不一定是这个列表中最小元素的指针。\n如果有多个满足条件的插入位置，可以选择任意一个位置插入新的值，插入后整个列表仍然保持有序。\n如果列表为空（给定的节点是 null），需要创建一个循环有序列表并返回这个节点。否则。请返回原先给定的节点。\n示例 1： 输入： head = [3,4,1], insertVal = 2\n输出： [3,4,1,2]\n解释： 在上图中，有一个包含三个元素的循环有序列表，你获得值为 3 的节点的指针，我们需要向表中插入元素 2 。新插入的节点应该在 1 和 3 之间，插入之后，整个列表如上图所示，最后返回节点 3 。\n示例 2： 输入： head = [], insertVal = 1\n输出： [1]\n解释： 列表为空（给定的节点是 null），创建一个循环有序列表并返回这个节点。\n示例 3： 输入： head = [1], insertVal = 0\n输出： [1,0]\n提示 0 \u0026lt;= Number of Nodes \u0026lt;= 5 * 104 -106 \u0026lt;= Node.val \u0026lt;= 106 -106 \u0026lt;= insertVal \u0026lt;= 106 解题思路 遍历 遍历链表，找到最大值 max 和最小值 min，\n若 x ≥ max ，则将其插入到 max 之后， 否则，继续遍历寻找首个比 x 大的节点，将其插入到该节点之前。 当链表为空时，初始化循环链表。\nfunc insert(aNode *Node, x int) *Node { // 空链表，构造 if aNode == nil { node := \u0026amp;Node{ Val: x, Next: nil, } node.Next = node return node } // 寻找最小节点 cur，last为最大节点 last, cur := aNode, aNode.Next for ; cur != aNode; last, cur = cur, cur.Next { if last.Val \u0026gt; cur.Val { break } } // 当 x 小于最大节点时，寻找插入位置 if x \u0026lt; last.Val { for ; cur.Val \u0026lt; x; last, cur = cur, cur.Next { } } last.Next = \u0026amp;Node{ Val: x, Next: last.Next, } return aNode } 复杂度 时间复杂度：$ O(N) N = len(aNode) $ 空间复杂度：$ O(1) $ ","date":"2022-06-18T09:59:58+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-ii-029.-%E6%8E%92%E5%BA%8F%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/","title":"剑指 Offer II 029. 排序的循环链表"},{"content":"链接： https://leetcode.cn/problems/duplicate-zeros/\n难度： 简单\n题目描述 给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。\n注意：请不要在超过该数组长度的位置写入元素。\n要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。\n示例 1： 输入： [1,0,2,3,0,4,5,0]\n输出： null\n解释： 调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]\n示例 2： 输入： [1,2,3]\n输出： null\n解释： 调用函数后，输入的数组将被修改为：[1,2,3]\n提示： 1 \u0026lt;= arr.length \u0026lt;= 10000 0 \u0026lt;= arr[i] \u0026lt;= 9 解题思路 模拟 遍历一遍，统计复写后数字的数量，从而定位到最后一个元素。\n然后从此元素开始，倒序遍历，修改原数组。\n注意： 需要处理末尾一个 0 的情况。\nfunc duplicateZeros(arr []int) { cnt := 0 // 统计数量 tail := 0 // 标记最后一个元素下标 // 寻找最后一个元素 for ; cnt \u0026lt; len(arr); tail++ { cnt++ if arr[tail] == 0 { cnt++ } } tail-- i := len(arr) - 1 // 最后一个元素为 0 且只会有一个 if cnt \u0026gt; len(arr) { arr[len(arr)-1] = arr[tail] tail-- i-- } // 倒序填充之前的元素 for ; tail \u0026gt;= 0; tail-- { arr[i] = arr[tail] if arr[tail] == 0 { arr[i-1] = arr[tail] i-- } i-- } } 复杂度 时间复杂度：$ O(N), N = len(arr) $ 空间复杂度：$ O(1) $ ","date":"2022-06-17T11:51:55+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1089.-%E5%A4%8D%E5%86%99%E9%9B%B6/","title":"Leetcode 1089. 复写零"},{"content":"链接： https://leetcode.cn/problems/k-diff-pairs-in-an-array/\n难度： 中等\n题目描述 给定一个整数数组和一个整数 k，你需要在数组里找到 不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。\n这里将 k-diff 数对定义为一个整数对 (nums[i], nums[j])，并满足下述全部条件：\n0 \u0026lt;= i \u0026lt; j \u0026lt; nums.length |nums[i] - nums[j]| == k 注意，|val| 表示 val 的绝对值。\n示例 1： 输入： nums = [3, 1, 4, 1, 5], k = 2\n输出： 2\n解释： 数组中有两个 2-diff 数对, (1, 3) 和 (3, 5)。\n尽管数组中有两个1，但我们只应返回不同的数对的数量。\n示例 2： 输入： nums = [1, 2, 3, 4, 5], k = 1\n输出： 4\n解释： 数组中有四个 1-diff 数对, (1, 2), (2, 3), (3, 4) 和 (4, 5)。\n示例 3： 输入： nums = [1, 3, 1, 5, 4], k = 0\n输出： 1\n解释： 数组中只有一个 0-diff 数对，(1, 1)。\n提示： 1 \u0026lt;= nums.length \u0026lt;= 104 -107 \u0026lt;= nums[i] \u0026lt;= 107 0 \u0026lt;= k \u0026lt;= 107 解题思路 哈希 遍历整个数组，遍历过程中使用哈希表存储每个出现过的数，对于当前遍历到的数 nums[i]，在哈希表中寻找 nums[i]-k 或 nums[i]+k 即可。\n当找到符合条件的数对时，记录较大的那个数，进行去重操作。\nfunc findPairs(nums []int, k int) int { ans := make(map[int]struct{}) exist := make(map[int]struct{}) for _, num := range nums { if _, ok := exist[num-k]; ok { ans[num] = struct{}{} } if _, ok := exist[num+k]; ok { ans[num+k] = struct{}{} } exist[num] = struct{}{} } return len(ans) } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2022-06-16T11:08:20+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-532.-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84-k-diff-%E6%95%B0%E5%AF%B9/","title":"Leetcode 532. 数组中的 k-diff 数对"},{"content":"链接： https://leetcode.cn/problems/diagonal-traverse/\n难度： 中等\n题目描述 给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。\n示例 1： 输入： mat = [[1,2,3],[4,5,6],[7,8,9]]\n输出： [1,2,4,7,5,3,6,8,9]\n示例 2： 输入： mat = [[1,2],[3,4]]\n输出： [1,2,3,4]\n提示： m == mat.length n == mat[i].length 1 \u0026lt;= m, n \u0026lt;= 104 1 \u0026lt;= m * n \u0026lt;= 104 -105 \u0026lt;= mat[i][j] \u0026lt;= 105 解题思路 模拟 遍历方向有两个，右上 和 左下，初始从左上角首个元素开始，向 右上 方遍历，当到达矩阵边界时，变换遍历方向。\nfunc findDiagonalOrder(mat [][]int) []int { rows, cols := len(mat), len(mat[0]) // 判断是否在矩阵内 var valid = func(row int, col int) bool { if row \u0026lt; 0 || row \u0026gt;= rows || col \u0026lt; 0 || col \u0026gt;= cols { return false } return true } ans := make([]int, 0, rows*cols) rightUp := true for row, col := 0, 0; ; { // 发生越界 if !valid(row, col) { if rightUp { // 右上方越界， row++ if !valid(row, col) { row++ col-- } } else { // 左下方越界 col++ if !valid(row, col) { row-- col++ } } rightUp = !rightUp // 变换方向 } ans = append(ans, mat[row][col]) // 遍历结束 if row == rows-1 \u0026amp;\u0026amp; col == cols-1 { break } if rightUp { row-- col++ } else { row++ col-- } } return ans } 复杂度 时间复杂度：$ O(M*N), M = len(mat), N = len(mat[0]) $ 空间复杂度：$ O(1) $ ","date":"2022-06-14T10:15:24+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-498.-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/","title":"Leetcode 498. 对角线遍历"},{"content":"链接： https://leetcode.cn/problems/height-checker/\n难度： 简单\n题目描述 学校打算为全体学生拍一张年度纪念照。根据要求，学生需要按照 非递减 的高度顺序排成一行。\n排序后的高度情况用整数数组 expected 表示，其中 expected[i] 是预计排在这一行中第 i 位的学生的高度（下标从 0 开始）。\n给你一个整数数组 heights ，表示 当前学生站位 的高度情况。heights[i] 是这一行中第 i 位学生的高度（下标从 0 开始）。\n返回满足 heights[i] != expected[i] 的 下标数量 。\n示例 1： 输入： heights = [1,1,4,2,1,3]\n输出： 3\n解释：\n高度：[1,1,4,2,1,3]\n预期：[1,1,1,2,3,4]\n下标 2 、4 、5 处的学生高度不匹配。\n示例 2： 输入： heights = [5,1,2,3,4]\n输出： 5\n解释：\n高度：[5,1,2,3,4]\n预期：[1,2,3,4,5]\n所有下标的对应学生高度都不匹配。\n示例 3： 输入： heights = [1,2,3,4,5]\n输出： 0\n解释：\n高度：[1,2,3,4,5]\n预期：[1,2,3,4,5]\n所有下标的对应学生高度都匹配。\n提示： 1 \u0026lt;= heights.length \u0026lt;= 100 1 \u0026lt;= heights[i] \u0026lt;= 100 解题思路 排序 拷贝原数组，执行一次排序，然后比较得到不满足 heights[i] != expected[i] 的情况。\nfunc heightChecker(heights []int) int { ans := 0 sortedHeights := make([]int, len(heights)) copy(sortedHeights, heights) sort.Ints(sortedHeights) for i := range heights { if heights[i] != sortedHeights[i] { ans++ } } return ans } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(heights) $ 空间复杂度：$ O(N) $ ","date":"2022-06-13T10:52:02+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1051.-%E9%AB%98%E5%BA%A6%E6%A3%80%E6%9F%A5%E5%99%A8/","title":"Leetcode 1051. 高度检查器"},{"content":"链接： https://leetcode.cn/problems/find-and-replace-pattern/\n难度： 中等\n题目描述 你有一个单词列表 words 和一个模式 pattern，你想知道 words 中的哪些单词与模式匹配。\n如果存在字母的排列 p ，使得将模式中的每个字母 x 替换为 p(x) 之后，我们就得到了所需的单词，那么单词与模式是匹配的。\n（回想一下，字母的排列是从字母到字母的双射：每个字母映射到另一个字母，没有两个字母映射到同一个字母。）\n返回 words 中与给定模式匹配的单词列表。\n你可以按任何顺序返回答案。\n示例 1： 输入： s1 = \u0026ldquo;this apple is sweet\u0026rdquo;, s2 = \u0026ldquo;this apple is sour\u0026rdquo;\n输出： [\u0026ldquo;sweet\u0026rdquo;,\u0026ldquo;sour\u0026rdquo;]\n示例 2： 输入： s1 = \u0026ldquo;apple apple\u0026rdquo;, s2 = \u0026ldquo;banana\u0026rdquo;\n输出： [\u0026ldquo;banana\u0026rdquo;]\n提示： 1 \u0026lt;= s1.length, s2.length \u0026lt;= 200 s1 和 s2 由小写英文字母和空格组成 s1 和 s2 都不含前导或尾随空格 s1 和 s2 中的所有单词间均由单个空格分隔 解题思路 哈希 使用哈希表记录映射关系，当不存在冲突时，满足条件。\nfunc findAndReplacePattern(words []string, pattern string) []string { ans := make([]string, 0, len(words)) for _, word := range words { p2w := make(map[byte]byte) // 记录映射关系 cnt := make([]int, 26) valid := true for i := range pattern { char, ok := p2w[pattern[i]] // 记录映射关系 if !ok { p2w[pattern[i]] = word[i] // 判定是否存在多个字符映射到同一个字符 cnt[word[i]-\u0026#39;a\u0026#39;]++ if cnt[word[i]-\u0026#39;a\u0026#39;] \u0026gt; 1 { valid = false break } continue } if char != word[i] { valid = false break } } if !valid { continue } ans = append(ans, word) } return ans } 复杂度 时间复杂度：$ O(NL), N = len(words), L = len(pattern) $ 空间复杂度：$ O(L) $ ","date":"2022-06-13T09:57:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-890.-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%E6%A8%A1%E5%BC%8F/","title":"Leetcode 890. 查找和替换模式"},{"content":"链接： https://leetcode.cn/problems/flip-string-to-monotone-increasing/\n难度： 中等\n题目描述 如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。\n给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。\n返回使 s 单调递增的最小翻转次数。\n示例 1： 输入： s = \u0026ldquo;00110\u0026rdquo;\n输出： 1\n解释： 翻转最后一位得到 00111.\n示例 2： 输入： s = \u0026ldquo;010110\u0026rdquo;\n输出： 2\n解释： 翻转得到 011111，或者是 000111。\n示例 3： 输入： s = \u0026ldquo;00011000\u0026rdquo;\n输出： 2\n解释： 翻转得到 00000000。\n提示： 1 \u0026lt;= s.length \u0026lt;= 105 s[i] 为 '0' 或 '1' 解题思路 动态规划 每个字符有 0 和 1 两种情况，若已知反转后的一个 单调递增 字符串分别以 0 和 1 结尾的最小翻转次数，则容易求得在末尾新添一个子串的最小翻转次数。\n用 dp0[i] 和 dp1[i] 分别表示以 s[i] 结尾的前缀，经过翻转后以 0 和 1 结尾的最小翻转次数，则：\n若最后字符为 0，则 dp0[i+1] = dp0[i]，dp1[i+1] = min(dp1[i], dp0[i]) + 1; 若最后字符为 1，则 dp0[i+1] = dp0[i]+1，dp1[i+1] = min(dp1[i], dp0[i])。 使用滚动变量降低空间复杂度。\nfunc minFlipsMonoIncr(s string) int { dp0, dp1 := 0, 0 for i := range s { if dp1 \u0026gt; dp0 { dp1 = dp0 } if s[i] == \u0026#39;0\u0026#39; { dp1++ } else { dp0++ } } if dp0 \u0026lt; dp1 { return dp0 } return dp1 } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2022-06-11T09:38:44+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-926.-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BF%BB%E8%BD%AC%E5%88%B0%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E/","title":"Leetcode 926. 将字符串翻转到单调递增"},{"content":"链接： https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/\n难度： 中等\n题目描述 给定一个由非重叠的轴对齐矩形的数组 rects ，其中 rects[i] = [ai, bi, xi, yi] 表示 (ai, bi) 是第 i 个矩形的左下角点，(xi, yi) 是第 i 个矩形的右上角点。设计一个算法来随机挑选一个被某一矩形覆盖的整数点。矩形周长上的点也算做是被矩形覆盖。所有满足要求的点必须等概率被返回。\n在给定的矩形覆盖的空间内的任何整数点都有可能被返回。\n请注意 ，整数点是具有整数坐标的点。\n实现 Solution 类:\nSolution(int[][] rects) 用给定的矩形数组 rects 初始化对象。 int[] pick() 返回一个随机的整数点 [u, v] 在给定的矩形所覆盖的空间内。 示例 1： 输入：\n[\u0026ldquo;Solution\u0026rdquo;, \u0026ldquo;pick\u0026rdquo;, \u0026ldquo;pick\u0026rdquo;, \u0026ldquo;pick\u0026rdquo;, \u0026ldquo;pick\u0026rdquo;, \u0026ldquo;pick\u0026rdquo;]\n[[[[-2, -2, 1, 1], [2, 2, 4, 6]]], [], [], [], [], []]\n输出：\n[null, [1, -2], [1, -1], [-1, -2], [-2, -2], [0, 0]]\n解释：\nSolution solution = new Solution([[-2, -2, 1, 1], [2, 2, 4, 6]]);\nsolution.pick(); // 返回 [1, -2]\nsolution.pick(); // 返回 [1, -1]\nsolution.pick(); // 返回 [-1, -2]\nsolution.pick(); // 返回 [-2, -2]\nsolution.pick(); // 返回 [0, 0]\n提示： 1 \u0026lt;= rects.length \u0026lt;= 100 rects[i].length == 4 -109 \u0026lt;= ai \u0026lt; xi \u0026lt;= 109 -109 \u0026lt;= bi \u0026lt; yi \u0026lt;= 109 xi - ai \u0026lt;= 2000 yi - bi \u0026lt;= 2000 所有的矩形不重叠。 pick 最多被调用 104 次。 解题思路 前缀和 + 二分查找 由于矩形都不重叠，所以统计所有可能的点的数量，从中随机取得一个点。\n然后确定该点在哪个矩形中，确定其坐标。\ntype Solution struct { rects [][]int sum []int random *rand.Rand } func Constructor(rects [][]int) Solution { sum := make([]int, len(rects)+1) for i, rect := range rects { sum[i+1] = sum[i] + (rect[2]-rect[0]+1)*(rect[3]-rect[1]+1) } return Solution{ rects: rects, sum: sum, random: rand.New(rand.NewSource(time.Now().UnixNano())), } } func (this *Solution) Pick() []int { pointSeq := this.random.Intn(this.sum[len(this.sum)-1]) i := sort.SearchInts(this.sum, pointSeq+1) // 确定矩形 pointSeq -= this.sum[i-1] // 当前矩形第 pointSeq 个点 fmt.Println(pointSeq) rect := this.rects[i-1] return []int{rect[0] + pointSeq%(rect[2]-rect[0]+1), rect[1] + pointSeq/(rect[2]-rect[0]+1)} } 复杂度 时间复杂度： constructor：$ O(N), N = len(rects) $ pick：$ O(\\log{N}) $ 空间复杂度：$ O(N) $ ","date":"2022-06-09T10:55:33+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-497.-%E9%9D%9E%E9%87%8D%E5%8F%A0%E7%9F%A9%E5%BD%A2%E4%B8%AD%E7%9A%84%E9%9A%8F%E6%9C%BA%E7%82%B9/","title":"Leetcode 497. 非重叠矩形中的随机点"},{"content":"链接： https://leetcode.cn/problems/valid-boomerang/\n难度： 简单\n题目描述 给定一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点，如果这些点构成一个 回旋镖 则返回 true 。\n回旋镖 定义为一组三个点，这些点 各不相同 且 不在一条直线上 。\n示例 1： 输入： points = [[1,1],[2,3],[3,2]]\n输出： true\n示例 2： 输入： points = [[1,1],[2,2],[3,3]]\n输出： false\n提示： points.length == 3 points[i].length == 2 0 \u0026lt;= xi, yi \u0026lt;= 100 解题思路 数学 不妨设三个点为 A、B、C，分别求出直线 AB 和 AC 的斜率，若两条直线斜率相同，又因为有公共点 A，此时三个点在同一条直线上。如下公式：\n$$ \\frac{y_1-y_0}{x_1-x_0} = \\frac{y_2-y_0}{x_2-x_0} $$\n注意： 需要处理斜率为 ∞ 的情况，可以将上式进行交叉变换：$ (y_1-y_0)(x_2-x_0) = (y_2-y_0)(x_1-x_0) $\nfunc isBoomerang(points [][]int) bool { if (points[1][1]-points[0][1])*(points[2][0]-points[0][0]) == (points[2][1]-points[0][1])*(points[1][0]-points[0][0]) { return false } return true } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2022-06-09T10:04:08+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1037.-%E6%9C%89%E6%95%88%E7%9A%84%E5%9B%9E%E6%97%8B%E9%95%96/","title":"Leetcode 1037. 有效的回旋镖"},{"content":"链接： https://leetcode-cn.com/problems/reverse-only-letters/\n难度： 简单\n题目描述 每个 有效电子邮件地址 都由一个 本地名 和一个 域名 组成，以 '@' 符号分隔。除小写字母之外，电子邮件地址还可以含有一个或多个 '.' 或 '+' 。\n例如，在 alice@leetcode.com 中， alice 是 本地名 ，而 leetcode.com 是 域名 。 如果在电子邮件地址的 本地名 部分中的某些字符之间添加句点（'.'），则发往那里的邮件将会转发到本地名中没有点的同一地址。请注意，此规则 不适用于域名 。\n例如，\u0026quot;alice.z@leetcode.com” 和 “alicez@leetcode.com” 会转发到同一电子邮件地址。 如果在 本地名 中添加加号（'+'），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件。同样，此规则 不适用于域名 。\n例如 m.y+name@email.com 将转发到 my@email.com。 可以同时使用这两个规则。\n给你一个字符串数组 emails，我们会向每个 emails[i] 发送一封电子邮件。返回实际收到邮件的不同地址数目。\n示例 1： 输入： emails = [\u0026ldquo;test.email+alex@leetcode.com\u0026rdquo;,\u0026ldquo;test.e.mail+bob.cathy@leetcode.com\u0026rdquo;,\u0026ldquo;testemail+david@lee.tcode.com\u0026rdquo;]\n输出： 2\n解释： 实际收到邮件的是 \u0026ldquo;testemail@leetcode.com\u0026rdquo; 和 \u0026ldquo;testemail@lee.tcode.com\u0026rdquo;。\n示例 2： 输入： emails = [\u0026ldquo;a@leetcode.com\u0026rdquo;,\u0026ldquo;b@leetcode.com\u0026rdquo;,\u0026ldquo;c@leetcode.com\u0026rdquo;]\n输出： 3\n提示： 1 \u0026lt;= emails.length \u0026lt;= 100 1 \u0026lt;= emails[i].length \u0026lt;= 100 emails[i] 由小写英文字母、'+'、'.' 和 '@' 组成 每个 emails[i] 都包含有且仅有一个 '@' 字符 所有本地名和域名都不为空 本地名不会以 '+' 字符作为开头 解题思路 哈希 根据题设求得每个邮箱实际接受邮件的地址，使用哈希表去重，返回哈希表的大小。\nfunc numUniqueEmails(emails []string) int { exist := make(map[string]struct{}) for _, email := range emails { real := make([]byte, 0, len(email)) t := strings.Split(email, \u0026#34;@\u0026#34;) Outer: for _, char := range t[0] { switch char { case \u0026#39;.\u0026#39;: case \u0026#39;+\u0026#39;: break Outer default: real = append(real, byte(char)) } } real = append(real, \u0026#39;@\u0026#39;) real = append(real, t[1]...) exist[string(real)] = struct{}{} } return len(exist) } 复杂度 时间复杂度：$ O(N), N = \\sum{len(emails[i])} $ 空间复杂度：$ O(N) $ ","date":"2022-06-06T20:05:45+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-929.-%E7%8B%AC%E7%89%B9%E7%9A%84%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80/","title":"Leetcode 929. 独特的电子邮件地址"},{"content":"链接： https://leetcode.cn/problems/delete-node-in-a-bst/\n难度： 中等\n题目描述 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n一般来说，删除节点可分为两个步骤：\n首先找到需要删除的节点； 如果找到了，删除它。 示例 1： 输入： root = [5,3,6,2,4,null,7], key = 3\n输出： [5,4,6,2,null,null,7]\n解释： 给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。\n一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。\n另一个正确答案是 [5,2,6,null,4,null,7]。\n示例 2： 输入： root = [5,3,6,2,4,null,7], key = 0\n输出： [5,3,6,2,4,null,7]\n解释： 二叉树不包含值为 0 的节点\n示例 3： 输入： root = [], key = 0\n输出： []\n提示： 节点数的范围 [0, 104]. -105 \u0026lt;= Node.val \u0026lt;= 105 节点值唯一 root 是合法的二叉搜索树 -105 \u0026lt;= key \u0026lt;= 105 解题思路 值替换 删除 BST 的某个结点，则该结点被左子树的最右结点或右子树的最左结点取代，通过直接赋值解决。\n同时，将取代节点删除，因为是最右节点，所以将对应指针指向左子树即可。\nfunc deleteNode(root *TreeNode, key int) *TreeNode { node := \u0026amp;root for *node != nil { if key \u0026lt; (*node).Val { node = \u0026amp;(*node).Left } else if key \u0026gt; (*node).Val { node = \u0026amp;(*node).Right } else { // 左子树为空，置为右子树 if (*node).Left == nil { *node = (*node).Right break } // 右子树为空，置为左子树 if (*node).Right == nil { *node = (*node).Left break } // 找左子树的最右结点 replace := \u0026amp;(*node).Left for (*replace).Right != nil { replace = \u0026amp;(*replace).Right } (*node).Val = (*replace).Val // 修改值 *replace = (*replace).Left // 将该结点删除，因为没有右节点，直接置为左节点 } } return root } 复杂度 时间复杂度：$ O(\\log{N}), N = size(Tree) $ 空间复杂度：$ O(1) $ ","date":"2022-06-02T19:28:22+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-450.-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","title":"Leetcode 450. 删除二叉搜索树中的节点"},{"content":"链接： https://leetcode.cn/problems/matchsticks-to-square/\n难度： 中等\n题目描述 你将得到一个整数数组 matchsticks ，其中 matchsticks[i] 是第 i 个火柴棒的长度。你要用 所有的火柴棍 拼成一个正方形。你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次 。\n如果你能使这个正方形，则返回 true ，否则返回 false 。\n示例 1： 输入： matchsticks = [1,1,2,2,2]\n输出： true\n解释： 能拼成一个边长为2的正方形，每边两根火柴。\n示例 2： 输入： matchsticks = [3,3,3,3,4]\n输出： false\n解释： 不能用所有火柴拼成一个正方形。\n提示： 1 \u0026lt;= matchsticks.length \u0026lt;= 15 1 \u0026lt;= matchsticks[i] \u0026lt;= 108 解题思路 type Node struct { End bool Children [26]*Node } func findAllConcatenatedWordsInADict(words []string) []string { sort.Slice(words, func(i, j int) bool { return len(words[i]) \u0026lt; len(words[j]) }) root := \u0026amp;Node{ End: false, Children: [26]*Node{}, } var dfs func(word string) bool dfs = func(word string) bool { for node, i := root, 0; i \u0026lt; len(word); i++ { // 无法继续匹配 node = node.Children[word[i]-\u0026#39;a\u0026#39;] if node == nil { break } // 匹配到某个单词 if node.End { // 匹配到结尾，匹配成功 if i == len(word)-1 { return true } // 尝试匹配下一个 if dfs(word[i+1:]) { return true } } } return false } ans := make([]string, 0, len(words)) for _, word := range words { if dfs(word) { ans = append(ans, word) continue } // 添加到 Trie树 node := root for i := range word { if node.Children[word[i]-\u0026#39;a\u0026#39;] == nil { node.Children[word[i]-\u0026#39;a\u0026#39;] = \u0026amp;Node{ End: false, Children: [26]*Node{}, } } node = node.Children[word[i]-\u0026#39;a\u0026#39;] } node.End = true } return ans } 复杂度 时间复杂度：$ O(N\\log{N}+\\sum_{i=0}^{N-1}{{L_i}^2}), N = len(words), L_i = len(words[i]) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-06-01T10:00:01+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-473.-%E7%81%AB%E6%9F%B4%E6%8B%BC%E6%AD%A3%E6%96%B9%E5%BD%A2/","title":"Leetcode 473. 火柴拼正方形"},{"content":"链接： https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/\n难度： 简单\n题目描述 给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。\n例如，如果路径为 0 -\u0026gt; 1 -\u0026gt; 1 -\u0026gt; 0 -\u0026gt; 1，那么它表示二进制数 01101，也就是 13 。 对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。\n返回这些数字之和。题目数据保证答案是一个 32 位 整数。\n示例 1： 输入： root = [1,0,1,0,1,0,1]\n输出： 22\n解释： (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22\n示例 2： 输入： root = [0]\n输出： 0\n提示： 树中的节点数在 [1, 1000] 范围内 Node.val 仅为 0 或 1 解题思路 深度优先搜索 从根开始，以深度优先搜索的方式遍历整颗树，同时使用一个变量记录遍历到的二进制前缀。\n当遍历到叶结点时，将其类加到结果中。\nfunc sumRootToLeaf(root *TreeNode) int { var dfs func(node *TreeNode, prefix int) int dfs = func(node *TreeNode, prefix int) int { prefix \u0026lt;\u0026lt;= 1 prefix |= node.Val if node.Left == nil \u0026amp;\u0026amp; node.Right == nil { return prefix } sum := 0 if node.Left != nil { sum += dfs(node.Left, prefix) } if node.Right != nil { sum += dfs(node.Right, prefix) } return sum } return dfs(root, 0) } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-05-30T10:52:43+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1022.-%E4%BB%8E%E6%A0%B9%E5%88%B0%E5%8F%B6%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B9%8B%E5%92%8C/","title":"Leetcode 1022. 从根到叶的二进制数之和"},{"content":"链接： https://leetcode.cn/problems/validate-ip-address/\n难度： 中等\n题目描述 给定一个字符串 queryIP。如果是有效的 IPv4 地址，返回 \u0026quot;IPv4\u0026quot; ；如果是有效的 IPv6 地址，返回 \u0026quot;IPv6\u0026quot; ；如果不是上述类型的 IP 地址，返回 \u0026quot;Neither\u0026quot; 。\n有效的IPv4地址 是 “x1.x2.x3.x4” 形式的IP地址。 其中 0 \u0026lt;= xi \u0026lt;= 255 且 xi 不能包含 前导零。例如: “192.168.1.1” 、 “192.168.1.0” 为有效IPv4地址， “192.168.01.1” 为无效IPv4地址; “192.168.1.00” 、 “192.168@1.1” 为无效IPv4地址。\n一个有效的IPv6地址 是一个格式为 “x1:x2:x3:x4:x5:x6:x7:x8” 的IP地址，其中:\n1 \u0026lt;= xi.length \u0026lt;= 4 xi 是一个 十六进制字符串 ，可以包含数字、小写英文字母( 'a' 到 'f' )和大写英文字母( 'A' 到 'F' )。 在 xi 中允许前导零。 例如 \u0026quot;2001:0db8:85a3:0000:0000:8a2e:0370:7334\u0026quot; 和 \u0026quot;2001:db8:85a3:0:0:8A2E:0370:7334\u0026quot; 是有效的 IPv6 地址，而 \u0026quot;2001:0db8:85a3::8A2E:037j:7334\u0026quot; 和 \u0026quot;02001:0db8:85a3:0000:0000:8a2e:0370:7334\u0026quot; 是无效的 IPv6 地址。\n示例 1： 输入： queryIP = \u0026ldquo;172.16.254.1\u0026rdquo;\n输出： \u0026ldquo;IPv4\u0026rdquo;\n解释： 有效的 IPv4 地址，返回 \u0026ldquo;IPv4\u0026rdquo;\n示例 2： 输入： queryIP = \u0026ldquo;2001:0db8:85a3:0:0:8A2E:0370:7334\u0026rdquo;\n输出： \u0026ldquo;IPv6\u0026rdquo;\n解释： 有效的 IPv6 地址，返回 \u0026ldquo;IPv6\u0026rdquo;\n示例 3： 输入： queryIP = \u0026ldquo;256.256.256.256\u0026rdquo;\n输出： \u0026ldquo;Neither\u0026rdquo;\n解释： 既不是 IPv4 地址，又不是 IPv6 地址\n提示： queryIP 仅由英文字母，数字，字符 '.' 和 ':' 组成。 解题思路 分类讨论 func validIPAddress(queryIP string) string { if strings.Contains(queryIP, \u0026#34;.\u0026#34;) { // 判定是否为IPV4 items := strings.Split(queryIP, \u0026#34;.\u0026#34;) if len(items) != 4 { return \u0026#34;Neither\u0026#34; } for _, item := range items { // 不是有效整数 t, err := strconv.Atoi(item) if err != nil { return \u0026#34;Neither\u0026#34; } if t \u0026lt; 0 || t \u0026gt; 255 { return \u0026#34;Neither\u0026#34; } // 包含前导0 if item[0] == \u0026#39;0\u0026#39; \u0026amp;\u0026amp; len(item) \u0026gt; 1 { return \u0026#34;Neither\u0026#34; } } return \u0026#34;IPv4\u0026#34; } else if strings.Contains(queryIP, \u0026#34;:\u0026#34;) { // 判断是否为 IPV6 items := strings.Split(queryIP, \u0026#34;:\u0026#34;) if len(items) != 8 { return \u0026#34;Neither\u0026#34; } for _, item := range items { // 不是有效长度 if len(item) == 0 || len(item) \u0026gt; 4 { return \u0026#34;Neither\u0026#34; } // 包含无效字符 for i := range item { if !((item[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; item[i] \u0026lt;= \u0026#39;9\u0026#39;) || (item[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; item[i] \u0026lt;= \u0026#39;f\u0026#39;) || (item[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; item[i] \u0026lt;= \u0026#39;F\u0026#39;)) { return \u0026#34;Neither\u0026#34; } } } return \u0026#34;IPv6\u0026#34; } return \u0026#34;Neither\u0026#34; } 复杂度 时间复杂度：$ O(N), N = len(queryIP) $ 空间复杂度：$ O(1) $ ","date":"2022-05-29T10:38:10+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-468.-%E9%AA%8C%E8%AF%81ip%E5%9C%B0%E5%9D%80/","title":"Leetcode 468. 验证IP地址"},{"content":"链接： https://leetcode.cn/problems/univalued-binary-tree/\n难度： 简单\n题目描述 如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。\n只有给定的树是单值二叉树时，才返回 true；否则返回 false。\n示例 1： 输入： [1,1,1,1,1,null,1]\n输出： true\n示例 2： 输入： [2,2,2,5,2]\n输出： false\n提示： 给定树的节点数范围是 [1, 100]。 每个节点的值都是整数，范围为 [0, 99] 。 解题思路 先序遍历 遍历整棵树，检查是否每个结点的值都与根结点相同。\nfunc isUnivalTree(root *TreeNode) bool { val := root.Val var dfs func(node *TreeNode) bool dfs = func(node *TreeNode) bool { if node == nil { return true } return node.Val == val \u0026amp;\u0026amp; dfs(node.Left) \u0026amp;\u0026amp; dfs(node.Right) } return dfs(root) } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-05-28T09:49:16+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-965.-%E5%8D%95%E5%80%BC%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"Leetcode 965. 单值二叉树"},{"content":"链接： https://leetcode.cn/problems/remove-outermost-parentheses/\n难度： 简单\n题目描述 有效括号字符串为空 \u0026quot;\u0026quot;、\u0026quot;(\u0026quot; + A + \u0026quot;)\u0026quot; 或 A + B ，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。\n例如，\u0026quot;\u0026quot;，\u0026quot;()\u0026quot;，\u0026quot;(())()\u0026quot; 和 \u0026quot;(()(()))\u0026quot; 都是有效的括号字符串。 如果有效字符串 s 非空，且不存在将其拆分为 s = A + B 的方法，我们称其为 原语（primitive），其中 A 和 B 都是非空有效括号字符串。\n给出一个非空有效字符串 s，考虑将其进行原语化分解，使得：s = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。\n对 s 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 s 。\n示例 1： 输入： s = \u0026ldquo;(()())(())\u0026rdquo;\n输出： \u0026ldquo;()()()\u0026rdquo;\n解释：\n输入字符串为 \u0026ldquo;(()())(())\u0026quot;，原语化分解得到 \u0026ldquo;(()())\u0026rdquo; + \u0026ldquo;(())\u0026quot;，\n删除每个部分中的最外层括号后得到 \u0026ldquo;()()\u0026rdquo; + \u0026ldquo;()\u0026rdquo; = \u0026ldquo;()()()\u0026quot;。\n示例 2： 输入： s = \u0026ldquo;(()())(())(()(()))\u0026rdquo;\n输出： \u0026ldquo;()()()()(())\u0026rdquo;\n解释：\n输入字符串为 \u0026ldquo;(()())(())(()(()))\u0026quot;，原语化分解得到 \u0026ldquo;(()())\u0026rdquo; + \u0026ldquo;(())\u0026rdquo; + \u0026ldquo;(()(()))\u0026quot;，\n删除每个部分中的最外层括号后得到 \u0026ldquo;()()\u0026rdquo; + \u0026ldquo;()\u0026rdquo; + \u0026ldquo;()(())\u0026rdquo; = \u0026ldquo;()()()()(())\u0026quot;。\n示例 3： 输入： s = \u0026ldquo;()()\u0026rdquo;\n输出： \u0026quot;\u0026rdquo;\n解释：\n输入字符串为 \u0026ldquo;()()\u0026quot;，原语化分解得到 \u0026ldquo;()\u0026rdquo; + \u0026ldquo;()\u0026quot;，\n删除每个部分中的最外层括号后得到 \u0026quot;\u0026rdquo; + \u0026quot;\u0026rdquo; = \u0026ldquo;\u0026quot;。\n提示： 1 \u0026lt;= s.length \u0026lt;= 105 s[i] 为 '(' 或 ')' s 是一个有效括号字符串 解题思路 栈 使用栈进行括号匹配，则每个 原语 的最外层括号，是栈底 \u0026quot;(\u0026quot; 和与之配对的 \u0026quot;)\u0026quot;。将这部分括号删除，得到的剩余字符构成的字符串即为结果。\nfunc removeOuterParentheses(s string) string { stack := make([]byte, 0, len(s)) ans := make([]byte, 0, len(s)) for i := range s { switch s[i] { case \u0026#39;(\u0026#39;: stack = append(stack, s[i]) // 栈底 （ 忽略 if len(stack) == 1 { continue } case \u0026#39;)\u0026#39;: stack = stack[:len(stack)-1] // 配对 // 与栈底佩佩的 ） 忽略 if len(stack) == 0 { continue } } ans = append(ans, s[i]) } return string(ans) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(N) $ 计数 使用一个变量记录进入括号的嵌套深度，遇到\u0026quot;(\u0026quot; 则 +1，遇到 \u0026quot;)\u0026quot; 则 -1。将深度在 0 和 1 之间变换的括号删除。\nfunc removeOuterParentheses(s string) string { depth := 0 ans := make([]byte, 0, len(s)) for i := range s { switch s[i] { case \u0026#39;(\u0026#39;: depth++ if depth == 1 { continue } case \u0026#39;)\u0026#39;: depth-- if depth == 0 { continue } } ans = append(ans, s[i]) } return string(ans) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2022-05-28T09:21:42+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1021.-%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/","title":"Leetcode 1021. 删除最外层的括号"},{"content":"链接： https://leetcode.cn/problems/find-closest-lcci/\n难度： 中等\n题目描述 有个内含单词的超大文本文件，给定任意两个不同的单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。如果寻找过程在这个文件中会重复多次，而每次寻找的单词不同，你能对此优化吗?\n示例： 输入： words = [\u0026ldquo;I\u0026rdquo;,\u0026ldquo;am\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;student\u0026rdquo;,\u0026ldquo;from\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;university\u0026rdquo;,\u0026ldquo;in\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;city\u0026rdquo;], word1 = \u0026ldquo;a\u0026rdquo;, word2 = \u0026ldquo;student\u0026rdquo;\n输出： 1\n提示 words.length \u0026lt;= 100000 解题思路 遍历 当找到一个单词时(不妨设为 word1)，距离最近的另一个单词 word2，或者是在其左边最右的那一个，或者在其右边最左的那一个。\n对于第二种情况，也可以理解为找到了 word2，左边最右的那一个 word1。\n这样，遍历过程中，仅记录两个数字最后的下标，即可求得最短距离。\nfunc findClosest(words []string, word1 string, word2 string) int { min := math.MaxInt idx1 := -1 idx2 := -1 for i, word := range words { if word == word1 { idx1 = i } if word == word2 { idx2 = i } if idx1 == -1 || idx2 == -1 { continue } d := idx1 - idx2 if d \u0026lt; 0 { d = -d } if min \u0026gt; d { min = d } } return min } 复杂度 时间复杂度：$ O(N), N = \\sum{words[i]} $ 空间复杂度：$ O(1) $ ","date":"2022-05-27T10:08:47+08:00","permalink":"https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.11.-%E5%8D%95%E8%AF%8D%E8%B7%9D%E7%A6%BB/","title":"面试题 17.11. 单词距离"},{"content":"链接： https://leetcode.cn/problems/unique-substrings-in-wraparound-string/\n难度： 中等\n题目描述 把字符串 s 看作是 \u0026quot;abcdefghijklmnopqrstuvwxyz\u0026quot; 的无限环绕字符串，所以 s 看起来是这样的：\n\u0026quot;...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\u0026quot; . 现在给定另一个字符串 p 。返回 s 中 唯一 的 p 的 非空子串 的数量 。 示例 1： 输入： p = \u0026ldquo;a\u0026rdquo;\n输出： 1\n解释： 字符串 s 中只有一个\u0026quot;a\u0026quot;子字符。\n示例 2： 输入： p = \u0026ldquo;cac\u0026rdquo;\n输出： 2\n解释： 字符串 s 中的字符串“cac”只有两个子串“a”、“c”。.\n示例 3： 输入： p = \u0026ldquo;zab\u0026rdquo;\n输出： 6\n解释： 在字符串 s 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。\n提示： 1 \u0026lt;= p.length \u0026lt;= 105 p 由小写英文字母构成 解题思路 双指针 可以发现，对于满足条件的某个字串而言，其子串也满足条件。所以要寻找每部分最长满足条件的字串。\n同时，为解决重复问题，找寻以每个字符结尾的最长字串，已该字符为结尾的所有满足条件的字串即为最长字串的长度，以此进行去重。\nfunc findSubstringInWraproundString(p string) int { maxLength := make([]int, 26) length := 1 // 记录以当前遍历到的字符为结尾的，满足条件的最长子串长度 maxLength[p[0]-\u0026#39;a\u0026#39;] = 1 for i := 1; i \u0026lt; len(p); i++ { // 判断是否连续 if (p[i]+26-p[i-1])%26 == 1 { length++ } else { length = 1 } if maxLength[p[i]-\u0026#39;a\u0026#39;] \u0026lt; length { maxLength[p[i]-\u0026#39;a\u0026#39;] = length } } sum := 0 for _, l := range maxLength { sum += l } return sum } 复杂度 时间复杂度：$ O(N+\\Sigma), N = len(p), \\Sigma表示字符集，本题中为26 $ 空间复杂度：$ O(\\Sigma)$ ","date":"2022-05-25T19:09:27+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-467.-%E7%8E%AF%E7%BB%95%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E5%94%AF%E4%B8%80%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 467. 环绕字符串中唯一的子字符串"},{"content":"链接： https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/\n难度： 简单\n题目描述 给你一个整数数组 nums ，该数组具有以下属性：\nnums.length == 2 * n. nums 包含 n + 1 个 不同的 元素 nums 中恰有一个元素重复 n 次 找出并返回重复了 n 次的那个元素。\n示例 1： 输入： nums = [1,2,3,3]\n输出： 3\n示例 2： 输入： nums = [2,1,2,5,3,2]\n输出： 2\n示例 3： 输入： nums = [5,1,5,2,5,3,5,4]\n输出： 5\n提示： 2 \u0026lt;= n \u0026lt;= 5000 nums.length == 2 * n 0 \u0026lt;= nums[i] \u0026lt;= 104 nums 由 n + 1 个 不同的 元素组成，且其中一个元素恰好重复 n 次 解题思路 哈希 使用哈希表记录元素的出现次数，当重复出现时，返回。\nfunc repeatedNTimes(nums []int) int { exist := make(map[int]struct{}) for _, num := range nums { if _, ok := exist[num]; ok { return num } exist[num] = struct{}{} } return 0 } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2022-05-21T10:51:53+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-961.-%E5%9C%A8%E9%95%BF%E5%BA%A6-2n-%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D-n-%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0/","title":"Leetcode 961. 在长度 2N 的数组中找出重复 N 次的元素"},{"content":"链接： https://leetcode.cn/problems/find-right-interval/\n难度： 中等\n题目描述 给你一个区间数组 intervals ，其中 intervals[i] = [starti, endi] ，且每个 starti 都 不同 。\n区间 i 的 右侧区间 可以记作区间 j ，并满足 startj \u0026gt;= endi ，且 startj 最小化 。\n返回一个由每个区间 i 的 右侧区间 的最小起始位置组成的数组。如果某个区间 i 不存在对应的 右侧区间 ，则下标 i 处的值设为 -1 。\n示例 1： 输入： intervals = [[1,2]]\n输出： [-1]\n解释： 集合中只有一个区间，所以输出-1。\n示例 2： 输入： intervals = [[3,4],[2,3],[1,2]]\n输出： [-1,0,1]\n解释： 对于 [3,4] ，没有满足条件的“右侧”区间。\n对于 [2,3] ，区间[3,4]具有最小的“右”起点;\n对于 [1,2] ，区间[2,3]具有最小的“右”起点。\n示例 3： 输入： intervals = [[1,4],[2,3],[3,4]]\n输出： [-1,2,-1]\n解释： 对于区间 [1,4] 和 [3,4] ，没有满足条件的“右侧”区间。\n对于 [2,3] ，区间 [3,4] 有最小的“右”起点。\n提示： 1 \u0026lt;= intervals.length \u0026lt;= 2 * 104 intervals[i].length == 2 -106 \u0026lt;= starti \u0026lt;= endi \u0026lt;= 106 每个间隔的起点都 不相同 解题思路 哈希 + 排序 + 二分查找 遍历所有的区间，使用哈希表记录每个区间 左端点 starti 及对应的位置，然后按照 starti 大小进行排序。\n之后，对于每个区间，二分查找右侧区间的 左端点，并通过哈希表找定位到位置。\nfunc findRightInterval(intervals [][]int) []int { idx := make(map[int]int) start := make([]int, 0, len(intervals)) for i, interval := range intervals { idx[interval[0]] = i start = append(start, interval[0]) } sort.Ints(start) ans := make([]int, 0, len(intervals)) for _, interval := range intervals { i := sort.SearchInts(start, interval[1]) // 找不到大于等于 interval[1] if i == len(start) { ans = append(ans, -1) } else { ans = append(ans, idx[start[i]]) } } return ans } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(intervals) $ 空间复杂度：$ O(N) $ ","date":"2022-05-20T10:31:43+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-436.-%E5%AF%BB%E6%89%BE%E5%8F%B3%E5%8C%BA%E9%97%B4/","title":"Leetcode 436. 寻找右区间"},{"content":"链接： https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/\n难度： 简单\n题目描述 给你一个长度为 n 的整数数组 nums ，返回使所有数组元素相等需要的最少移动数。\n在一步操作中，你可以使数组中的一个元素加 1 或者减 1 。\n示例 1： 输入： nums = [1,2,3]\n输出： 2\n解释：\n只需要两步操作（每步操作指南使一个元素加 1 或减 1）：\n[1,2,3] =\u0026gt; [2,2,3] =\u0026gt; [2,2,2]\n示例 2： 输入： nums = [1,10,2,9]\n输出： 16\n提示： n == nums.length 1 \u0026lt;= nums.length \u0026lt;= 105 -109 \u0026lt;= nums[i] \u0026lt;= 109 解题思路 排序 将数组排序，首先计算出全部变换为最小数的移动次数。\n然后向后遍历，依次计算变换为每一个数的移动次数，从中找出最小值。\n设当前要变换的数下标为 i，则之前元素从 nums[i-1] 变换为 nums[i] 的变换次数 (nums[i] - nums[i-1]) * i 需要加上，之后多余计算的变换次数 (nums[i] - nums[i-1]) * (len(nums) - i) 需要减去。\nfunc minMoves2(nums []int) int { min := math.MaxInt for _, num := range nums { if min \u0026gt; num { min = num } } moves := 0 for _, num := range nums { moves += num - min } sort.Ints(nums) minMoves := moves for i := 1; i \u0026lt; len(nums); i++ { moves += (nums[i] - nums[i-1]) * (2*i - len(nums)) if minMoves \u0026gt; moves { minMoves = moves } } return minMoves } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(nums) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-05-19T10:27:46+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-462.-%E6%9C%80%E5%B0%91%E7%A7%BB%E5%8A%A8%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89-ii/","title":"Leetcode 462. 最少移动次数使数组元素相等 II"},{"content":"链接： https://leetcode.cn/problems/verifying-an-alien-dictionary/\n难度： 简单\n题目描述 某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。\n给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。\n示例 1： 输入： words = [\u0026ldquo;hello\u0026rdquo;,\u0026ldquo;leetcode\u0026rdquo;], order = \u0026ldquo;hlabcdefgijkmnopqrstuvwxyz\u0026rdquo;\n输出： true\n解释： 在该语言的字母表中，\u0026lsquo;h\u0026rsquo; 位于 \u0026rsquo;l\u0026rsquo; 之前，所以单词序列是按字典序排列的。\n示例 2： 输入： words = [\u0026ldquo;word\u0026rdquo;,\u0026ldquo;world\u0026rdquo;,\u0026ldquo;row\u0026rdquo;], order = \u0026ldquo;worldabcefghijkmnpqstuvxyz\u0026rdquo;\n输出： false\n解释： 在该语言的字母表中，\u0026rsquo;d\u0026rsquo; 位于 \u0026rsquo;l\u0026rsquo; 之后，那么 words[0] \u0026gt; words[1]，因此单词序列不是按字典序排列的。\n示例 3： 输入： words = [\u0026ldquo;apple\u0026rdquo;,\u0026ldquo;app\u0026rdquo;], order = \u0026ldquo;abcdefghijklmnopqrstuvwxyz\u0026rdquo;\n输出： false\n解释： 当前三个字符 \u0026ldquo;app\u0026rdquo; 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 \u0026ldquo;apple\u0026rdquo; \u0026gt; \u0026ldquo;app\u0026rdquo;，因为 \u0026rsquo;l\u0026rsquo; \u0026gt; \u0026lsquo;∅\u0026rsquo;，其中 \u0026lsquo;∅\u0026rsquo; 是空白字符，定义为比任何其他字符都小。\n提示： 1 \u0026lt;= words.length \u0026lt;= 100 1 \u0026lt;= words[i].length \u0026lt;= 20 order.length == 26 在 words[i] 和 order 中的所有字符都是英文小写字母。 解题思路 模拟 使用字典中字母下标，初始化字典序的权重，方便比较字符大小，然后实现字符串比较。\nfunc isAlienSorted(words []string, order string) bool { weight := make(map[byte]int) for i := range order { weight[order[i]] = i } cmp := func(s1 string, s2 string) int { i := 0 for ; i \u0026lt; len(s1) \u0026amp;\u0026amp; i \u0026lt; len(s2); i++ { if weight[s1[i]] \u0026lt; weight[s2[i]] { return -1 } else if weight[s1[i]] \u0026gt; weight[s2[i]] { return 1 } } if len(s1) == len(s2) { return 0 } else if len(s1) \u0026lt; len(s2) { return -1 } else { return 1 } } for i := 1; i \u0026lt; len(words); i++ { if cmp(words[i-1], words[i]) \u0026gt; 0 { return false } } return true } 复杂度 时间复杂度：$ O(N*L), N = len(words), L = avg(len(words[i])) $ 空间复杂度：$ O(\\Sigma), \\Sigma表示字符集，本题中为26 $ ","date":"2022-05-18T10:25:43+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-953.-%E9%AA%8C%E8%AF%81%E5%A4%96%E6%98%9F%E8%AF%AD%E8%AF%8D%E5%85%B8/","title":"Leetcode 953. 验证外星语词典"},{"content":"链接： https://leetcode.cn/problems/successor-lcci/\n难度： 中等\n题目描述 设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。\n如果指定节点没有对应的“下一个”节点，则返回 null。\n示例 1： 输入： root = [2,1,3], p = 1\n2 / \\ 1 3 输出： 2\n示例 2： 输入： root = [5,3,6,2,4,null,null,1], p = 6\n5 / \\ 3 6 / \\ 2 4 / 1 输出： null\n解题思路 中序遍历 中序遍历，先找到指定结点，标记已找到。继续向后遍历，寻找后继结点，当标记已找到指定结点时，则说明当前结点为后继结点，返回。\nfunc inorderSuccessor(root *TreeNode, p *TreeNode) *TreeNode { exist := false var dfs func(node *TreeNode) *TreeNode dfs = func(node *TreeNode) *TreeNode { if node == nil { return nil } t := dfs(node.Left) if t != nil { return t } if exist { return node } if node == p { exist = true } return dfs(node.Right) } return dfs(root) } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-05-16T10:46:10+08:00","permalink":"https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-04.06.-%E5%90%8E%E7%BB%A7%E8%80%85/","title":"面试题 04.06. 后继者"},{"content":"链接： https://leetcode.cn/problems/largest-triangle-area/\n难度： 简单\n题目描述 给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。\n示例： 输入： points = [[0,0],[0,1],[1,0],[0,2],[2,0]]\n输出： 2\n解释：\n这五个点如下图所示。组成的橙色三角形是最大的，面积为2。\n注意： 3 \u0026lt;= points.length \u0026lt;= 50 不存在重复的点。 -50 \u0026lt;= points[i][j] \u0026lt;= 50 结果误差值在 106 以内都认为是正确答案。 解题思路 枚举 依次枚举三个顶点，计算构成三角形的面积，求得最大值。\nfunc largestTriangleArea(points [][]int) float64 { maxArea := 0. for i := len(points) - 3; i \u0026gt;= 0; i-- { for j := len(points) - 2; j \u0026gt; i; j-- { for k := len(points) - 1; k \u0026gt; j; k-- { area := math.Abs(float64( points[i][0]*points[j][1]+points[j][0]*points[k][1]+points[k][0]*points[i][1]- points[i][0]*points[k][1]-points[j][0]*points[i][1]-points[k][0]*points[j][1], )) / 2 maxArea = math.Max(maxArea, area) } } } return maxArea } 复杂度 时间复杂度：$ O(N^3), N = len(points) $ 空间复杂度：$ O(1) $ ","date":"2022-05-15T11:49:45+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-812.-%E6%9C%80%E5%A4%A7%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF/","title":"Leetcode 812. 最大三角形面积"},{"content":"链接： https://leetcode.cn/problems/one-away-lcci/\n难度： 中等\n题目描述 字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。\n示例 1： 输入：\nfirst = \u0026ldquo;pale\u0026rdquo;\nsecond = \u0026ldquo;ple\u0026rdquo;\n输出： True\n示例 2： 输入：\nfirst = \u0026ldquo;pales\u0026rdquo;\nsecond = \u0026ldquo;pal\u0026rdquo;\n输出： False\n解题思路 分类讨论 符合条件的两个字符串的长度应 ≤ 1。\n当两个字符串相等时，判断是否仅有 ≤ 1 个字符不同； 当两个字符串不相同时，判断较短的是否为较长字符串的子序列。 func oneEditAway(first string, second string) bool { if len(first) \u0026gt; len(second) { first, second = second, first } if len(second)-len(first) \u0026gt; 1 { return false } // 等长，统计不同字符数量，要求 ≤ 1 if len(first) == len(second) { diff := 0 for i := range first { if first[i] != second[i] { diff++ if diff \u0026gt; 1 { return false } } } return true } // 不等长，寻找首个不同的字符 i := 0 for ; i \u0026lt; len(first); i++ { if first[i] != second[i] { break } } // 判断后缀是否相同 return first[i:] == second[i+1:] } 复杂度 时间复杂度：$ O(N), N = len(first) $ 空间复杂度：$ O(1) $ ","date":"2022-05-13T10:05:12+08:00","permalink":"https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-01.05.-%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91/","title":"面试题 01.05. 一次编辑"},{"content":"链接： https://leetcode.cn/problems/delete-columns-to-make-sorted/\n难度： 简单\n题目描述 给你由 n 个小写字母字符串组成的数组 strs，其中每个字符串长度相等。\n这些字符串可以每个一行，排成一个网格。例如，strs = [\u0026quot;abc\u0026quot;, \u0026quot;bce\u0026quot;, \u0026quot;cae\u0026quot;] 可以排列为：\nabc\nbce\ncae\n你需要找出并删除 不是按字典序升序排列的 列。在上面的例子（下标从 0 开始）中，列 0（'a', 'b', 'c'）和列 2（'c', 'e', 'e'）都是按升序排列的，而列 1（'b', 'c', 'a'）不是，所以要删除列 1 。\n返回你需要删除的列数。\n示例 1： 输入： strs = [\u0026ldquo;cba\u0026rdquo;,\u0026ldquo;daf\u0026rdquo;,\u0026ldquo;ghi\u0026rdquo;]\n输出： 1\n解释： 网格示意如下：\ncba\ndaf\nghi\n列 0 和列 2 按升序排列，但列 1 不是，所以只需要删除列 1 。\n示例 2： 输入： strs = [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;]\n输出： 0\n解释： 网格示意如下：\na\nb\n只有列 0 这一列，且已经按升序排列，所以不用删除任何列。\n示例 3： 输入： strs = [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;]\n输出： 0\n解释： 网格示意如下：\na\nb\n只有列 0 这一列，且已经按升序排列，所以不用删除任何列。\n提示： n == strs.length 1 \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= strs[i].length \u0026lt;= 1000 strs[i] 由小写英文字母组成 解题思路 模拟 从上至下逐列进行扫描，当下面字母比上面小时，该列被删除，计数。\nfunc minDeletionSize(strs []string) int { ans := 0 for col := 0; col \u0026lt; len(strs[0]); col++ { for row := 1; row \u0026lt; len(strs); row++ { if strs[row][col] \u0026lt; strs[row-1][col] { ans++ break } } } return ans } 复杂度 时间复杂度：$ O(N*M), N = len(strs), M = len(strs[i]) $ 空间复杂度：$ O(1) $ ","date":"2022-05-12T20:06:07+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-944.-%E5%88%A0%E5%88%97%E9%80%A0%E5%BA%8F/","title":"Leetcode 944. 删列造序"},{"content":"链接： https://leetcode.cn/problems/serialize-and-deserialize-bst/\n难度： 中等\n题目描述 序列化是将数据结构或对象转换为一系列位的过程，以便它可以存储在文件或内存缓冲区中，或通过网络连接链路传输，以便稍后在同一个或另一个计算机环境中重建。\n设计一个算法来序列化和反序列化 二叉搜索树 。 对序列化/反序列化算法的工作方式没有限制。 您只需确保二叉搜索树可以序列化为字符串，并且可以将该字符串反序列化为最初的二叉搜索树。\n编码的字符串应尽可能紧凑。\n示例 1： 输入： root = [2,1,3]\n输出： [2,1,3]\n示例 2： 输入： root = []\n输出： []\n提示： 树中节点数范围是 [0, 104] 0 \u0026lt;= Node.val \u0026lt;= 104 题目数据 保证 输入的树是一棵二叉搜索树。 解题思路 先序遍历 根据二叉搜索树的特性，对于每个结点，可以得出左右子数的数据范围。\n故序列化时，进行先序遍历存储顺序即可；反序列化时，根据确定的数据范围，递归构建即可。\ntype Codec struct { } func Constructor() Codec { return Codec{} } // Serializes a tree to a single string. func (this *Codec) serialize(root *TreeNode) string { sVals := make([]string, 0, 5) var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } sVals = append(sVals, strconv.Itoa(node.Val)) dfs(node.Left) dfs(node.Right) } dfs(root) return strings.Join(sVals, \u0026#34;,\u0026#34;) } // Deserializes your encoded data to tree. func (this *Codec) deserialize(data string) *TreeNode { if data == \u0026#34;\u0026#34; { return nil } sVals := strings.Split(data, \u0026#34;,\u0026#34;) var dfs func(min, max int) *TreeNode dfs = func(min, max int) *TreeNode { if len(sVals) == 0 { return nil } val, _ := strconv.Atoi(sVals[0]) if val \u0026lt;= min || val \u0026gt;= max { return nil } sVals = sVals[1:] return \u0026amp;TreeNode{ Val: val, Left: dfs(min, val), Right: dfs(val, max), } } return dfs(-1, 1e4+1) } 复杂度 时间复杂度： serialize: $ O(N_1), N_1 = size(Tree) $ deserialize: $ O(N_2), N_2 = len(data) $ 空间复杂度： serialize: $ O(N_1) $ deserialize: $ O(N_2) $ ","date":"2022-05-11T10:35:14+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-449.-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","title":"Leetcode 449. 序列化和反序列化二叉搜索树"},{"content":"链接： https://leetcode-cn.com/problems/range-sum-of-bst/\n难度： 简单\n题目描述 由范围 [0,n] 内所有整数组成的 n + 1 个整数的排列序列可以表示为长度为 n 的字符串 s ，其中:\n如果 perm[i] \u0026lt; perm[i + 1] ，那么 s[i] == 'I' 如果 perm[i] \u0026gt; perm[i + 1] ，那么 s[i] == 'D' 给定一个字符串 s ，重构排列 perm 并返回它。如果有多个有效排列 perm，则返回其中 任何一个 。\n示例 1： 输入： s = \u0026ldquo;IDID\u0026rdquo;\n输出： [0,4,1,3,2]\n示例 2： 输入： s = \u0026ldquo;III\u0026rdquo;\n输出： [0,1,2,3]\n示例 3： 输入： s = \u0026ldquo;DDI\u0026rdquo;\n输出： [3,2,0,1]\n提示： 1 \u0026lt;= s.length \u0026lt;= 105 s 只包含字符 \u0026quot;I\u0026quot; 或 \u0026quot;D\u0026quot; 解题思路 贪心 根据题目描述，当为字符为 I 时，表示前一个数字小，为 D 时，表示前一个数字大。\n对于首个字符，当其为 I 时，选择排列中的最小值；为 D 时，选择排列中的最大值。则后续处理变为相同的子问题，不断重复处理直到排列中的元素选择完毕。\nfunc diStringMatch(s string) []int { ans := make([]int, 0, len(s)) iNum, dNum := 0, len(s) for i := range s { if s[i] == \u0026#39;I\u0026#39; { ans = append(ans, iNum) iNum++ } else { ans = append(ans, dNum) dNum-- } } ans = append(ans, iNum) return ans } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2022-05-09T09:59:48+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-942.-%E5%A2%9E%E5%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/","title":"Leetcode 942. 增减字符串匹配"},{"content":"链接： https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/\n难度： 中等\n题目描述 给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。\n你必须设计并实现一个时间复杂度为 $ O(n) $ 且仅使用常量额外空间的算法解决此问题。\n示例 1： 输入： nums = [4,3,2,7,8,2,3,1]\n输出： [2,3]\n示例 2： 输入： nums = [1,1,2]\n输出： [1]\n示例 3： 输入： nums = [1]\n输出： []\n提示： n == nums.length 1 \u0026lt;= n \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= n nums 中的每个元素出现 一次 或 两次 解题思路 哈希 要确定 $ O(1) $ 的判断某个元素是否出现，需要使用到哈希表。\n另外，为满足常量空间复杂度要求，采用原地哈希：将元素交换到对应的下标处。\nfunc findDuplicates(nums []int) []int { ans := make([]int, 0, len(nums)) for i := 0; i \u0026lt; len(nums); i++ { idx := nums[i] - 1 // 对应下标 // 存在相同元素 if i != idx \u0026amp;\u0026amp; nums[i] == nums[idx] { ans = append(ans, nums[i]) continue } nums[i], nums[idx] = nums[idx], nums[i] // 交换 // 交换后的元素未处理，继续处理 if idx \u0026gt; i { i-- } } return ans } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2022-05-08T10:39:10+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-442.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE/","title":"Leetcode 442. 数组中重复的数据"},{"content":"链接： hhttps://leetcode-cn.com/problems/minimum-genetic-mutation/\n难度： 中等\n题目描述 基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 'A'、'C'、'G' 和 'T' 之一。\n假设我们需要调查从基因序列 start 变为 end 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。\n例如，\u0026quot;AACCGGTT\u0026quot; --\u0026gt; \u0026quot;AACCGGTA\u0026quot; 就是一次基因变化。 另有一个基因库 bank 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。\n给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使 start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。\n注意：起始基因序列 start 默认是有效的，但是它并不一定会出现在基因库中。\n示例 1： 输入： start = \u0026ldquo;AACCGGTT\u0026rdquo;, end = \u0026ldquo;AACCGGTA\u0026rdquo;, bank = [\u0026ldquo;AACCGGTA\u0026rdquo;]\n输出： 1\n示例 2： 输入： start = \u0026ldquo;AACCGGTT\u0026rdquo;, end = \u0026ldquo;AAACGGTA\u0026rdquo;, bank = [\u0026ldquo;AACCGGTA\u0026rdquo;,\u0026ldquo;AACCGCTA\u0026rdquo;,\u0026ldquo;AAACGGTA\u0026rdquo;]\n输出： 2\n示例 3： 输入： start = \u0026ldquo;AAAAACCC\u0026rdquo;, end = \u0026ldquo;AACCCCCC\u0026rdquo;, bank = [\u0026ldquo;AAAACCCC\u0026rdquo;,\u0026ldquo;AAACCCCC\u0026rdquo;,\u0026ldquo;AACCCCCC\u0026rdquo;]\n输出： 3\n提示： start.length == 8 end.length == 8 0 \u0026lt;= bank.length \u0026lt;= 10 bank[i].length == 8 start、end 和 bank[i] 仅由字符 ['A', 'C', 'G', 'T'] 组成 解题思路 广度优先搜索 根据题意，每次变换仅涉及一个字符，并且变换后的基因必须存在于基因库中。\n每次变换可枚举所有的情况，找出符合要求的基因，并继续执行变换。由于需要找到最小变换次数，采用广度优先搜索策略。\nfunc minMutation(start string, end string, bank []string) int { chars := []byte(\u0026#34;ACGT\u0026#34;) valid := make(map[string]struct{}) for _, b := range bank { valid[b] = struct{}{} } q := list.New() q.PushBack(start) visit := make(map[string]struct{}) visit[start] = struct{}{} for step := 0; q.Len() \u0026gt; 0; step++ { for i := q.Len(); i \u0026gt; 0; i-- { s := q.Remove(q.Front()).(string) if s == end { return step } // 尝试变换每一个字符 for idx := range s { t := []byte(s) // 将对应字符变换为任意一个其他字符 for _, char := range chars { if t[idx] == char { continue } t[idx] = char next := string(t) // 已搜索过 if _, ok := visit[next]; ok { continue } visit[next] = struct{}{} // 无效序列 if _, ok := valid[next]; !ok { continue } q.PushBack(next) } } } } return -1 } 复杂度 时间复杂度：$ O(C*N * M), N = size(start), M = len(bank)，C表示字符集，本题目中为4 $ 空间复杂度：$ O(N*M) $ ","date":"2022-05-07T10:07:37+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-433.-%E6%9C%80%E5%B0%8F%E5%9F%BA%E5%9B%A0%E5%8F%98%E5%8C%96/","title":"Leetcode 433. 最小基因变化"},{"content":"链接： https://leetcode-cn.com/problems/number-of-recent-calls/\n难度： 简单\n题目描述 写一个 RecentCounter 类来计算特定时间范围内最近的请求。\n请你实现 RecentCounter 类：\nRecentCounter() 初始化计数器，请求数为 0 。 int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。 保证 每次对 ping 的调用都使用比之前更大的 t 值。\n示例： 输入：\n[\u0026ldquo;RecentCounter\u0026rdquo;, \u0026ldquo;ping\u0026rdquo;, \u0026ldquo;ping\u0026rdquo;, \u0026ldquo;ping\u0026rdquo;, \u0026ldquo;ping\u0026rdquo;]\n[[], [1], [100], [3001], [3002]]\n输出：\n[null, 1, 2, 3, 3]\n解释：\nRecentCounter recentCounter = new RecentCounter();\nrecentCounter.ping(1); // requests = [1]，范围是 [-2999,1]，返回 1\nrecentCounter.ping(100); // requests = [1, 100]，范围是 [-2900,100]，返回 2\nrecentCounter.ping(3001); // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3\nrecentCounter.ping(3002); // requests = [1, 100, 3001, 3002]，范围是 [2,3002]，返回 3\n提示： 1 \u0026lt;= t \u0026lt;= 109 保证每次对 ping 调用所使用的 t 值都 严格递增 至多调用 ping 方法 104 次 解题思路 遍历 存储所有的请求时间点，由于时间点是有序的，通过倒序遍历统计所有符合条件的请求数量。\ntype RecentCounter struct { time []int } func Constructor() RecentCounter { return RecentCounter{ time: nil, } } func (this *RecentCounter) Ping(t int) int { this.time = append(this.time, t) cnt := 0 for i := len(this.time) - 1; i \u0026gt;= 0; i-- { if this.time[i] \u0026lt; t-3000 { break } cnt++ } return cnt } 复杂度 时间复杂度： constructor：$ O(1) $ ping：$ O(N), N 为 ping 的调用次数 $ 空间复杂度：$ O(N) $ 队列 使用队列存储满足要求的区间内的请求，每次有新请求，执行出队操作直队列头元素满足 ≥ t - 3000。\ntype RecentCounter struct { queue *list.List } func Constructor() RecentCounter { return RecentCounter{ queue: list.New(), } } func (this *RecentCounter) Ping(t int) int { this.queue.PushBack(t) for this.queue.Front().Value.(int) \u0026lt; t-3000 { this.queue.Remove(this.queue.Front()) } return this.queue.Len() } 时间复杂度： constructor：$ O(1) $ ping：$ O(N), N 为 ping 的调用次数 $ 空间复杂度：$ O(N) $ ","date":"2022-05-06T09:25:11+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-933.-%E6%9C%80%E8%BF%91%E7%9A%84%E8%AF%B7%E6%B1%82%E6%AC%A1%E6%95%B0/","title":"Leetcode 933. 最近的请求次数"},{"content":"链接： https://leetcode-cn.com/problems/subarray-product-less-than-k/\n难度： 中等\n题目描述 给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。\n示例 1： 输入： nums = [10,5,2,6], k = 100\n输出： 8\n解释： 8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。\n需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。\n示例 2： 输入： nums = [1,2,3], k = 0\n输出： 0\n提示： 1 \u0026lt;= nums.length \u0026lt;= 3 * 104 1 \u0026lt;= nums[i] \u0026lt;= 1000 0 \u0026lt;= k \u0026lt;= 106 解题思路 枚举 枚举每个子数组的起始点，向后遍历并不断累乘。\n每次类乘后的积 \u0026lt; k，即找到了一个子数组；当积 ≥ k 时，则该起始点相关的符合要求的子数组已查找完，继续从下一个起始点开始。\nfunc numSubarrayProductLessThanK(nums []int, k int) int { ans := 0 for i := range nums { product := 1 for j := i; j \u0026lt; len(nums); j++ { product *= nums[j] if product \u0026lt; k { ans++ } else { break } } } return ans } 复杂度 时间复杂度：$ O(N^2), N = len(nums) $ 空间复杂度：$ O(1) $ 滑动窗口 当某个子数组满足要求时，则该子数组的子数组也满足要求。\n对于某个满足条件的子数组（不妨设下标区间为 [l, r]） 中的最右元素 r 而言，均可与它之前的元素构成子数组，则有满足题设的下标区间 [l, r]、\u0026hellip;、[r-1,r], [r]，其数量为 r - l + 1。\n由上述原则，需要得知每个元素对应最左的边界，故采用滑动窗口寻找满足条件的各最长子数组，便可求解。\nfunc numSubarrayProductLessThanK(nums []int, k int) int { ans := 0 product := 1 for l, r := 0, 0; r \u0026lt; len(nums); r++ { product *= nums[r] // 收缩左端点 for l \u0026lt;= r \u0026amp;\u0026amp; product \u0026gt;= k { product /= nums[l] l++ } if product \u0026lt; k { ans += r - l + 1 } } return ans } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2022-05-05T10:25:13+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-713.-%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8E-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","title":"Leetcode 713. 乘积小于 K 的子数组"},{"content":"链接： https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/\n难度： 中等\n题目描述 共有 n 名小伙伴一起做游戏。小伙伴们围成一圈，按 顺时针顺序 从 1 到 n 编号。确切地说，从第 i 名小伙伴顺时针移动一位会到达第 (i+1) 名小伙伴的位置，其中 1 \u0026lt;= i \u0026lt; n ，从第 n 名小伙伴顺时针移动一位会回到第 1 名小伙伴的位置。\n游戏遵循如下规则：\n从第 1 名小伙伴所在位置 开始 。 沿着顺时针方向数 k 名小伙伴，计数时需要 包含 起始时的那位小伙伴。逐个绕圈进行计数，一些小伙伴可能会被数过不止一次。 你数到的最后一名小伙伴需要离开圈子，并视作输掉游戏。 如果圈子中仍然有不止一名小伙伴，从刚刚输掉的小伙伴的 顺时针下一位 小伙伴 开始，回到步骤 2 继续执行。 否则，圈子中最后一名小伙伴赢得游戏。 给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。\n示例 1： 输入： n = 5, k = 2\n输出： 3\n解释： 游戏运行步骤如下：\n从小伙伴 1 开始。 顺时针数 2 名小伙伴，也就是小伙伴 1 和 2 。 小伙伴 2 离开圈子。下一次从小伙伴 3 开始。 顺时针数 2 名小伙伴，也就是小伙伴 3 和 4 。 小伙伴 4 离开圈子。下一次从小伙伴 5 开始。 顺时针数 2 名小伙伴，也就是小伙伴 5 和 1 。 小伙伴 1 离开圈子。下一次从小伙伴 3 开始。 顺时针数 2 名小伙伴，也就是小伙伴 3 和 5 。 小伙伴 5 离开圈子。只剩下小伙伴 3 。所以小伙伴 3 是游戏的获胜者。 示例 2： 输入： n = 6, k = 5\n输出： 1\n解释： 小伙伴离开圈子的顺序：5、4、6、2、3 。小伙伴 1 是游戏的获胜者。\n提示： 1 \u0026lt;= k \u0026lt;= n \u0026lt;= 500 解题思路 模拟 使用链表模拟此过程，返回最后剩余的结点。\nfunc findTheWinner(n int, k int) int { q := list.New() for i := 1; i \u0026lt;= n; i++ { q.PushBack(i) } ptr := q.Front() for q.Len() \u0026gt; 1 { // 寻找待淘汰 for i := 1; i \u0026lt; k; i++ { ptr = ptr.Next() // 尾部的下一个重新定位到头部 if ptr == nil { ptr = q.Front() } } t := ptr ptr = ptr.Next() // 尾部的下一个重新定位到头部 if ptr == nil { ptr = q.Front() } q.Remove(t) // 淘汰 } return q.Front().Value.(int) } 复杂度 时间复杂度：$ O(n*k) $ 空间复杂度：$ O(n) $ 递归 令 f(n, k) 表示从 n 个小伙伴中不断淘汰第 k 个小伙伴后获胜的小伙伴， 则对应淘汰的小伙伴为 (k-1) % n + 1，然后转换为了从 n-1 个小伙伴中不断淘汰第 k 个小伙伴。\nf(n-1, k) 从 n-1 个小伙伴中不断淘汰第 k 个小伙伴而获胜的小伙伴，是从第一位开始计数；然而在转换前，是从 ((k-1) % n + 1) + 1 = k%n + 1 开始计数，故需要找到两者间的映射关系，即 f(n, k) = F(f(n-1, k))。\nf(n-1, k) 1 2 \u0026hellip; n-1 f(n, k) k%n+1 (k+1)%n+1 \u0026hellip; (k-1+n-1)%n+1 通过上表得到递归公式： f(n, k) = (k-1 + f(n-1, k)) % n + 1；\n当仅剩一个数字时，返回该数字，递归中止条件为 f(1, k) = 1。\nfunc findTheWinner(n int, k int) int { if n == 1 { return 1 } return (k-1+findTheWinner(n-1, k))%n + 1 } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(n) $ 迭代 将上述递归修改为迭代，降低空间复杂度。\nfunc findTheWinner(n int, k int) int { ans := 1 for i := 2; i \u0026lt;= n; i++ { ans = (k-1+ans)%i + 1 } return ans } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2022-05-04T11:40:52+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1823.-%E6%89%BE%E5%87%BA%E6%B8%B8%E6%88%8F%E7%9A%84%E8%8E%B7%E8%83%9C%E8%80%85/","title":"Leetcode 1823. 找出游戏的获胜者"},{"content":"链接： https://leetcode-cn.com/problems/reorder-data-in-log-files/\n难度： 简单\n题目描述 给你一个日志数组 logs。每条日志都是以空格分隔的字串，其第一个字为字母与数字混合的 标识符 。\n有两种不同类型的日志：\n字母日志：除标识符之外，所有字均由小写字母组成 数字日志：除标识符之外，所有字均由数字组成 请按下述规则将日志重新排序：\n所有 字母日志 都排在 数字日志 之前。 字母日志 在内容不同时，忽略标识符后，按内容字母顺序排序；在内容相同时，按标识符排序。 数字日志 应该保留原来的相对顺序。 返回日志的最终顺序。\n示例 1： 输入： logs = [\u0026ldquo;dig1 8 1 5 1\u0026rdquo;,\u0026ldquo;let1 art can\u0026rdquo;,\u0026ldquo;dig2 3 6\u0026rdquo;,\u0026ldquo;let2 own kit dig\u0026rdquo;,\u0026ldquo;let3 art zero\u0026rdquo;]\n输出： [\u0026ldquo;let1 art can\u0026rdquo;,\u0026ldquo;let3 art zero\u0026rdquo;,\u0026ldquo;let2 own kit dig\u0026rdquo;,\u0026ldquo;dig1 8 1 5 1\u0026rdquo;,\u0026ldquo;dig2 3 6\u0026rdquo;]\n解释：\n字母日志的内容都不同，所以顺序为 \u0026ldquo;art can\u0026rdquo;, \u0026ldquo;art zero\u0026rdquo;, \u0026ldquo;own kit dig\u0026rdquo; 。\n数字日志保留原来的相对顺序 \u0026ldquo;dig1 8 1 5 1\u0026rdquo;, \u0026ldquo;dig2 3 6\u0026rdquo; 。\n示例 2： 输入： logs = [\u0026ldquo;a1 9 2 3 1\u0026rdquo;,\u0026ldquo;g1 act car\u0026rdquo;,\u0026ldquo;zo4 4 7\u0026rdquo;,\u0026ldquo;ab1 off key dog\u0026rdquo;,\u0026ldquo;a8 act zoo\u0026rdquo;]\n输出： [\u0026ldquo;g1 act car\u0026rdquo;,\u0026ldquo;a8 act zoo\u0026rdquo;,\u0026ldquo;ab1 off key dog\u0026rdquo;,\u0026ldquo;a1 9 2 3 1\u0026rdquo;,\u0026ldquo;zo4 4 7\u0026rdquo;]\n提示： 1 \u0026lt;= logs.length \u0026lt;= 100 3 \u0026lt;= logs[i].length \u0026lt;= 100 logs[i] 中，字与字之间都用 单个 空格分隔 题目数据保证 logs[i] 都有一个标识符，并且在标识符之后至少存在一个字 解题思路 自定义排序 对每个日志 logs[i] 预处理，识别出标识符和内容，并确定是 字母日志 还是 数字日志。\n然后按照题述比较规则进行排序，由于 数字日志 要保持原来的顺序，使用稳定排序。\nfunc reorderLogFiles(logs []string) []string { // 解析标识符，内容，日志类型 parse := func(log string) (token, content string, isDigit bool) { t := strings.SplitN(log, \u0026#34; \u0026#34;, 2) return t[0], t[1], t[1][0] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; t[1][0] \u0026lt;= \u0026#39;9\u0026#39; } // 使用稳定排序，确保数字日志 sort.SliceStable(logs, func(i, j int) bool { iToken, iContent, iIsDigit := parse(logs[i]) jToken, jContent, jIsDigit := parse(logs[j]) // 类型不一致 if iIsDigit != jIsDigit { // 字母日志在前 if !iIsDigit { return true } return false } // 类型一致 // 数字日志按照原下标排序 if iIsDigit { return false } // 字母日志先按照内容排序 if iContent \u0026lt; jContent { return true } else if iContent \u0026gt; jContent { return false } else { // 当内容一致，再按照标识符排序 return iToken \u0026lt; jToken } }) return logs } ","date":"2022-05-03T11:48:49+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-937.-%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/","title":"Leetcode 937. 重新排列日志文件"},{"content":"链接： https://leetcode-cn.com/problems/tag-validator/\n难度： 困难\n题目描述 给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。合法的代码片段需要遵守以下的所有规则：\n代码必须被合法的闭合标签包围。否则，代码是无效的。 闭合标签（不一定合法）要严格符合格式：\u0026lt;TAG_NAME\u0026gt;TAG_CONTENT\u0026lt;/TAG_NAME\u0026gt;。其中，\u0026lt;TAG_NAME\u0026gt;是起始标签，\u0026lt;/TAG_NAME\u0026gt;是结束标签。起始和结束标签中的 TAG_NAME 应当相同。当且仅当 TAG_NAME 和 TAG_CONTENT 都是合法的，闭合标签才是合法的。 合法的 TAG_NAME 仅含有大写字母，长度在范围 [1,9] 之间。否则，该 TAG_NAME 是不合法的。 合法的 TAG_CONTENT 可以包含其他合法的闭合标签，cdata （请参考规则7）和任意字符（注意参考规则1）除了不匹配的 \u0026lt;、不匹配的起始和结束标签、不匹配的或带有不合法 TAG_NAME 的闭合标签。否则，TAG_CONTENT 是不合法的。 一个起始标签，如果没有具有相同 TAG_NAME 的结束标签与之匹配，是不合法的。反之亦然。不过，你也需要考虑标签嵌套的问题。 一个 \u0026lt;，如果你找不到一个后续的 \u0026gt; 与之匹配，是不合法的。并且当你找到一个 \u0026lt; 或\u0026lt;/ 时，所有直到下一个 \u0026gt; 的前的字符，都应当被解析为 TAG_NAME（不一定合法）。 cdata 有如下格式：\u0026lt;![CDATA[CDATA_CONTENT]]\u0026gt;。CDATA_CONTENT 的范围被定义成 \u0026lt;![CDATA[ 和后续的第一个 ]]\u0026gt; 之间的字符。 CDATA_CONTENT 可以包含任意字符。cdata 的功能是阻止验证器解析 CDATA_CONTENT，所以即使其中有一些字符可以被解析为标签（无论合法还是不合法），也应该将它们视为常规字符。 合法代码的例子： 输入： \u0026quot;\u0026lt;DIV\u0026gt;This is the first line \u0026lt;![CDATA[\u0026lt;div\u0026gt;]]\u0026gt;\u0026lt;/DIV\u0026gt;\u0026quot;\n输出： True\n解释：\n代码被包含在了闭合的标签内： \u0026lt;DIV\u0026gt; 和 \u0026lt;/DIV\u0026gt; 。\nTAG_NAME 是合法的，TAG_CONTENT 包含了一些字符和 cdata 。\n即使 CDATA_CONTENT 含有不匹配的起始标签和不合法的 TAG_NAME，它应该被视为普通的文本，而不是标签。\n所以 TAG_CONTENT 是合法的，因此代码是合法的。最终返回True。\n输入： \u0026quot;\u0026lt;DIV\u0026gt;\u0026gt;\u0026gt; ![cdata[]] \u0026lt;![CDATA[\u0026lt;div\u0026gt;]\u0026gt;]]\u0026gt;]]\u0026gt;\u0026gt;]\u0026lt;/DIV\u0026gt;\\\u0026quot;\n输出： True\n解释：\n我们首先将代码分割为： start_tag|tag_content|end_tag 。\nstart_tag -\u0026gt; \u0026quot;\u0026lt;DIV\u0026gt;\u0026quot;\nend_tag -\u0026gt; \u0026quot;\u0026lt;/DIV\u0026gt;\u0026quot;\ntag_content 也可被分割为： text1|cdata|text2 。 text1 -\u0026gt; \u0026quot;\u0026gt;\u0026gt; ![cdata[]] \u0026quot;\ncdata -\u0026gt; \u0026quot;\u0026lt;![CDATA[\u0026lt;div\u0026gt;]\u0026gt;]]\u0026gt;\u0026quot; ，其中 CDATA_CONTENT 为 \u0026quot;\u0026lt;div\u0026gt;]\u0026gt;\u0026quot;\ntext2 -\u0026gt; \u0026quot;]]\u0026gt;\u0026gt;]\u0026quot;\nstart_tag 不是 \u0026quot;\u0026lt;DIV\u0026gt;\u0026gt;\u0026gt;\u0026quot; 的原因参照规则 6 。\ncdata 不是 \u0026quot;\u0026lt;![CDATA[\u0026lt;div\u0026gt;]\u0026gt;]]\u0026gt;]]\u0026gt;\u0026quot; 的原因参照规则 7 。\n不合法代码的例子： 输入： \u0026quot;\u0026lt;A\u0026gt; \u0026lt;B\u0026gt; \u0026lt;/A\u0026gt; \u0026lt;/B\u0026gt;\u0026quot;\n输出： False\n解释： 不合法。如果 \u0026quot;\u0026lt;A\u0026gt;\u0026quot; 是闭合的，那么 \u0026quot;\u0026lt;B\u0026gt;\u0026quot; 一定是不匹配的，反之亦然。\n输入： \u0026quot;\u0026lt;DIV\u0026gt; div tag is not closed \u0026lt;DIV\u0026gt;\u0026quot;\n输出： False\n输入： \u0026quot;\u0026lt;DIV\u0026gt; unmatched \u0026lt; \u0026lt;/DIV\u0026gt;\u0026quot;\n输出： False\n输入： \u0026quot;\u0026lt;DIV\u0026gt; closed tags with invalid tag name \u0026lt;b\u0026gt;123\u0026lt;/b\u0026gt; \u0026lt;/DIV\u0026gt;\u0026quot;\n输出： False\n输入： \u0026quot;\u0026lt;DIV\u0026gt; unmatched tags with invalid tag name \u0026lt;/1234567890\u0026gt; and \u0026lt;CDATA[[]]\u0026gt; \u0026lt;/DIV\u0026gt;\u0026quot;\n输出： False\n输入： \u0026quot;\u0026lt;DIV\u0026gt; unmatched start tag \u0026lt;B\u0026gt; and unmatched end tag \u0026lt;/C\u0026gt; \u0026lt;/DIV\u0026gt;\u0026quot;\n输出： False\n提示： 为简明起见，你可以假设输入的代码（包括提到的任意字符）只包含数字, 字母, '\u0026lt;','\u0026gt;','/','!','[',']'和' '。 解题思路 栈 标签是成对出现的，有嵌套关系，并且每个结束标签 \u0026lt;/TAG_NAME\u0026gt; 必须和前一个开始标签 \u0026lt;TAG_NAME\u0026gt; 匹配，类似于括号匹配的原则，可以用利用栈求解。\n除了常规字符外，还有三种特殊模式需要识别和处理，对于开始和结束标签，还有 cdata：\n以 '\u0026lt;' 开头，寻找下一个最近的 '\u0026gt;'，在此之间的即为开始标签的 TAG_NAME，需要判定其合法性，并入栈； 以 \u0026quot;\u0026lt;/\u0026quot; 开头，寻找下一个最近的 '\u0026gt;'，在此之间的即为结束标签的 TAG_NAME，其必须和栈顶开始标签的 TAG_NAME 匹配； 以 \u0026quot;\u0026lt;![CDATA[\u0026quot; 开头，寻在下一个最近的 \u0026quot;]]\u0026gt;\u0026quot;，整个部分构成模式 cdata，不做处理； 其余常规字符，不做处理。 整个字符串需要由一对标签包围，即最外层不能有标签并列。\n根据上述情形，解析此字符串，判断是否有效。\nfunc isValid(code string) bool { stack := make([]string, 0, 1) for code != \u0026#34;\u0026#34; { // 非特定模式 if code[0] != \u0026#39;\u0026lt;\u0026#39; { // 没有被包围，无效 if len(stack) == 0 { return false } // 不做处理 code = code[1:] continue } // 模式匹配，至少为三个字符 \u0026lt;TAG_NAME\u0026gt; if len(code) \u0026lt;= 2 { return false } switch code[1] { case \u0026#39;/\u0026#39;: // 结束标签 idx := strings.IndexByte(code, \u0026#39;\u0026gt;\u0026#39;) // 没有被 \u0026lt;/ 和 \u0026gt; 包围，无效 if idx == -1 { return false } tagName := code[2:idx] // 和栈顶开始标签不匹配，无效 if len(stack) == 0 || stack[len(stack)-1] != tagName { return false } stack = stack[:len(stack)-1] // 出栈 code = code[len(tagName)+3:] // 最外层未被一对标签包围，无效 if len(stack) == 0 \u0026amp;\u0026amp; code != \u0026#34;\u0026#34; { return false } case \u0026#39;!\u0026#39;: // cdata if !strings.HasPrefix(code, \u0026#34;\u0026lt;![CDATA[\u0026#34;) { return false } idx := strings.Index(code[9:], \u0026#34;]]\u0026gt;\u0026#34;) // 没有被 \u0026lt;![CDATA[ 和 ]]\u0026gt; 包围，无效 if idx == -1 { return false } // 没有被包围，无效 if len(stack) == 0 { return false } code = code[9+idx+3:] default: // 开始标签 idx := strings.IndexByte(code, \u0026#39;\u0026gt;\u0026#39;) // 没有被 \u0026lt; 和 \u0026gt; 包围，无效 if idx == -1 { return false } tagName := code[1:idx] // 标签名长度不合法，无效 if len(tagName) == 0 || len(tagName) \u0026gt; 9 { return false } for i := range tagName { // 标签名包含非大写字母，无效 if tagName[i] \u0026lt; \u0026#39;A\u0026#39; || tagName[i] \u0026gt; \u0026#39;Z\u0026#39; { return false } } stack = append(stack, tagName) // 入栈 code = code[len(tagName)+2:] } } return len(stack) == 0 } 复杂度 时间复杂度：$ O(N), N = len(code) $ 空间复杂度：$ O(N) $ ","date":"2022-05-02T12:14:17+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-591.-%E6%A0%87%E7%AD%BE%E9%AA%8C%E8%AF%81%E5%99%A8/","title":"Leetcode 591. 标签验证器"},{"content":"链接： https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/\n难度： 中等\n题目描述 给你 root1 和 root2 这两棵二叉搜索树。请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。\n示例 1： 输入： root1 = [2,1,4], root2 = [1,0,3]\n输出： [0,1,1,2,3,4]\n示例 2： 输入： root1 = [1,null,8], root2 = [8,1]\n输出： [1,1,8,8]\n提示： 每棵树的节点数在 [0, 5000] 范围内 -105 \u0026lt;= Node.val \u0026lt;= 105 解题思路 中序遍历 + 归并排序 两颗树都是二叉搜索树，所以分别对齐进行中序遍历，将得到两个有序的数组。\n最后将这两个有序数组合并为一个有序数组，采用归并排序。\nfunc getAllElements(root1 *TreeNode, root2 *TreeNode) []int { // 中序遍历 var dfs func(node *TreeNode, nums *[]int) dfs = func(node *TreeNode, nums *[]int) { if node == nil { return } dfs(node.Left, nums) *nums = append(*nums, node.Val) dfs(node.Right, nums) } nums1, nums2 := make([]int, 0, 1), make([]int, 0, 1) dfs(root1, \u0026amp;nums1) dfs(root2, \u0026amp;nums2) // 归并排序 ans := make([]int, 0, len(nums1)+len(nums2)) i, j := 0, 0 for i \u0026lt; len(nums1) \u0026amp;\u0026amp; j \u0026lt; len(nums2) { if nums1[i] \u0026lt; nums2[j] { ans = append(ans, nums1[i]) i++ } else { ans = append(ans, nums2[j]) j++ } } ans = append(ans, nums1[i:]...) ans = append(ans, nums2[j:]...) return ans } 复杂度 时间复杂度：$ O(N_1 + N_2), N_1 = size(Tree1), N_2 = size(Tree2) $ 空间复杂度：$ O(N_1 + N_2) $ ","date":"2022-05-01T09:22:48+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1305.-%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0/","title":"Leetcode 1305. 两棵二叉搜索树中的所有元素"},{"content":"链接： https://leetcode-cn.com/problems/smallest-range-i/\n难度： 简单\n题目描述 给你一个整数数组 nums ，和一个整数 k 。\n在一个操作中，您可以选择 0 \u0026lt;= i \u0026lt; nums.length 的任何索引 i 。将 nums[i] 改为 nums[i] + x ，其中 x 是一个范围为 [-k, k] 的整数。对于每个索引 i ，最多 只能 应用 一次 此操作。\nnums 的 分数 是 nums 中最大和最小元素的差值。 在对 nums 中的每个索引最多应用一次上述操作后，返回 nums 的最低 分数 。\n示例 1： 输入： nums = [1], k = 0\n输出： 0\n解释： 分数是 max(nums) - min(nums) = 1 - 1 = 0。\n示例 2： 输入： nums = [0,10], k = 2\n输出： 6\n解释： 将 nums 改为 [2,8]。分数是 max(nums) - min(nums) = 8 - 2 = 6。\n示例 3： 输入： nums = [1,3,6], k = 3\n输出： 0\n解释： 将 nums 改为 [4,4,4]。分数是 max(nums) - min(nums) = 4 - 4 = 0。\n提示： 1 \u0026lt;= nums.length \u0026lt;= 104 0 \u0026lt;= nums[i] \u0026lt;= 104 0 \u0026lt;= k \u0026lt;= 104 解题思路 模拟 根据题意，数组的 分数 由其中的 最大值max 和 最小值min 决定。\n当这两者的差值 max - min ≤ 2k 时，则可以将数组中的所有元素经过变换，变为同一元素，返回 0； 否则，其他元素经过变化后，其范围可以维持在 [min+k, max-k] 之间，故最低分数为 max - min - 2k。 func smallestRangeI(nums []int, k int) int { max, min := 0, math.MaxInt for _, num := range nums { if max \u0026lt; num { max = num } if min \u0026gt; num { min = num } } if max-min \u0026lt;= k*2 { return 0 } return max - min - k*2 } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2022-04-30T09:40:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-908.-%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC-i/","title":"Leetcode 908. 最小差值 I"},{"content":"链接： https://leetcode-cn.com/problems/construct-quad-tree/\n难度： 中等\n题目描述 给你一个 n * n 矩阵 grid ，矩阵由若干 0 和 1 组成。请你用四叉树表示该矩阵 grid 。\n你需要返回能表示矩阵的 四叉树 的根结点。\n注意，当 isLeaf 为 False 时，你可以把 True 或者 False 赋值给节点，两种值都会被判题机制 接受 。\n四叉树数据结构中，每个内部节点只有四个子节点。此外，每个节点都有两个属性：\nval：储存叶子结点所代表的区域的值。1 对应 True，0 对应 False； isLeaf: 当这个节点是一个叶子结点时为 True，如果它有 4 个子节点则为 False 。 class Node { public boolean val; public boolean isLeaf; public Node topLeft; public Node topRight; public Node bottomLeft; public Node bottomRight; } 我们可以按以下步骤为二维区域构建四叉树：\n如果当前网格的值相同（即，全为 0 或者全为 1），将 isLeaf 设为 True ，将 val 设为网格相应的值，并将四个子节点都设为 Null 然后停止。 如果当前网格的值不同，将 isLeaf 设为 False， 将 val 设为任意值，然后如下图所示，将当前网格划分为四个子网格。 使用适当的子网格递归每个子节点。 如果你想了解更多关于四叉树的内容，可以参考 wiki 。\n四叉树格式：\n输出为使用层序遍历后四叉树的序列化形式，其中 null 表示路径终止符，其下面不存在节点。\n它与二叉树的序列化非常相似。唯一的区别是节点以列表形式表示 [isLeaf, val] 。\n如果 isLeaf 或者 val 的值为 True ，则表示它在列表 [isLeaf, val] 中的值为 1 ；如果 isLeaf 或者 val 的值为 False ，则表示值为 0 。\n示例 1： 输入： grid = [[0,1],[1,0]]\n输出： [[0,1],[1,0],[1,1],[1,1],[1,0]]\n解释： 此示例的解释如下：\n请注意，在下面四叉树的图示中，0 表示 false，1 表示 True 。\n示例 2： 输入： grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\n输出： [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\n解释： 网格中的所有值都不相同。我们将网格划分为四个子网格。\ntopLeft，bottomLeft 和 bottomRight 均具有相同的值。\ntopRight 具有不同的值，因此我们将其再分为 4 个子网格，这样每个子网格都具有相同的值。\n解释如下图所示：\n示例 3： 输入： grid = [[1,1],[1,1]]\n输出： [[1,1]]\n示例 4： 输入： grid = [[0]]\n输出： [[1,0]]\n示例 5： 输入： grid = [[1,1,0,0],[1,1,0,0],[0,0,1,1],[0,0,1,1]]\n输出： [[0,1],[1,1],[1,0],[1,0],[1,1]]\n提示： n == grid.length == grid[i].length n == 2x 其中 0 \u0026lt;= x \u0026lt;= 6 解题思路 递归 将整个矩阵分为4个子矩阵，依次判定四个区域是否全为 0 或 1，若满足则设置对应叶结点，若不满足则递归处理。\nfunc construct(grid [][]int) *Node { var dfs func(row0, col0, row1, col1 int) *Node dfs = func(row0, col0, row1, col1 int) *Node { same := true Outer: for i := row0; i \u0026lt; row1; i++ { for j := col0; j \u0026lt; col1; j++ { if grid[i][j] != grid[row0][col0] { same = false break Outer } } } // 全部相同，设为叶结点 if same { return \u0026amp;Node{ Val: grid[row0][col0] == 1, IsLeaf: true, } } // 递归 midRow := (row0 + row1) / 2 midCol := (col0 + col1) / 2 return \u0026amp;Node{ TopLeft: dfs(row0, col0, midRow, midCol), TopRight: dfs(row0, midCol, midRow, col1), BottomLeft: dfs(midRow, col0, row1, midCol), BottomRight: dfs(midRow, midCol, row1, col1), } } return dfs(0, 0, len(grid), len(grid[0])) } 复杂度 时间复杂度：$ O(n^2\\log{n}) $ 空间复杂度：$ O(\\log{n}) $ ","date":"2022-04-29T10:02:29+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-427.-%E5%BB%BA%E7%AB%8B%E5%9B%9B%E5%8F%89%E6%A0%91/","title":"Leetcode 427. 建立四叉树"},{"content":"链接： https://leetcode-cn.com/problems/sort-array-by-parity/\n难度： 简单\n题目描述 给你一个整数数组 nums，将 nums 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。\n返回满足此条件的 任一数组 作为答案。\n示例 1： 输入： nums = [3,1,2,4]\n输出： [2,4,3,1]\n解释： [4,2,3,1]、[2,4,1,3] 和 [4,2,1,3] 也会被视作正确答案。\n示例 2： 输入： nums = [0]\n输出： [0]\n提示： 1 \u0026lt;= nums.length \u0026lt;= 5000 0 \u0026lt;= nums[i] \u0026lt;= 5000 解题思路 双指针 使用两个指针分别标记 已排好序的偶数元素尾 以及 当前遍历到的元素，初始两个指针均为 0。\n依次遍历，当遍历到偶数元素时，将其与 已排好序的偶数元素尾 的元素交换。如此，则可将所有偶数元素全部置于前面。\nfunc sortArrayByParity(nums []int) []int { idx := 0 for i := range nums { if nums[i]\u0026amp;1 == 1 { continue } nums[idx], nums[i] = nums[i], nums[idx] idx++ } return nums } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2022-04-28T09:51:16+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-905.-%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/","title":"Leetcode 905. 按奇偶排序数组"},{"content":"链接： https://leetcode-cn.com/problems/pacific-atlantic-water-flow/\n难度： 中等\n题目描述 有一个 m × n 的矩形岛屿，与 太平洋 和 大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。\n这个岛被分割成一个由若干方形单元格组成的网格。给定一个 m x n 的整数矩阵 heights ， heights[r][c] 表示坐标 (r, c) 上单元格 高于海平面的高度 。\n岛上雨水较多，如果相邻单元格的高度 小于或等于 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。\n返回 网格坐标 result 的 2D列表 ，其中 result[i] = [ri, ci] 表示雨水可以从单元格 (ri, ci) 流向 太平洋和大西洋 。\n示例 1： 输入： heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]\n输出： [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n示例 2： 输入： heights = [[2,1],[1,2]]\n输出： [[0,0],[0,1],[1,0],[1,1]]\n提示： m == heights.length n == heights[r].length 1 \u0026lt;= m, n \u0026lt;= 200 0 \u0026lt;= heights[r][c] \u0026lt;= 105 解题思路 广度优先搜索 雨水按照 高度 非严格递减的方向，流入 太平洋 和 大西洋，反之，可以按照 高度 非严格递增的顺序，找出分别可以流入 太平洋 和 大西洋 的单元格，从中挑选去能同时流入 太平洋 和 大西洋 的单元格。\n采用多源广度优先搜索策略，初始时，从紧邻 太平洋/大西洋 的单元格开始搜索。\nfunc pacificAtlantic(heights [][]int) [][]int { m, n := len(heights), len(heights[0]) visit := make([][]int, m) for i := range heights { visit[i] = make([]int, n) } dirs := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} bfs := func(row, col int, flag int) { queue := list.New() // 初始单元格入队 for i := 0; i \u0026lt; n; i++ { queue.PushBack([]int{row, i}) visit[row][i] |= flag } for i := 0; i \u0026lt; m; i++ { queue.PushBack([]int{i, col}) visit[i][col] |= flag } for queue.Len() \u0026gt; 0 { cur := queue.Remove(queue.Front()).([]int) for _, dir := range dirs { next := []int{cur[0] + dir[0], cur[1] + dir[1]} // 越界检查 if next[0] \u0026lt; 0 || next[0] \u0026gt;= m || next[1] \u0026lt; 0 || next[1] \u0026gt;= n { continue } // 通过其他单元格流入 if visit[next[0]][next[1]]\u0026amp;flag != 0 { continue } // 无法通过当前单元格流入 if heights[next[0]][next[1]] \u0026lt; heights[cur[0]][cur[1]] { continue } queue.PushBack(next) visit[next[0]][next[1]] |= flag } } } bfs(0, 0, 1) // 太平洋 bfs(m-1, n-1, 2) // 大西洋 ans := make([][]int, 0, 5) for i, line := range visit { for j, cell := range line { if cell == 3 { ans = append(ans, []int{i,j}) } } } return ans } 复杂度 时间复杂度：$ O(m*n) $ 空间复杂度：$ O(m*n) $ 深度优先搜索 接上述广度优先思路，从边界每个单元格出发采用深度优先搜索实现，区分源是属于 太平洋 和 大西洋。\nfunc pacificAtlantic(heights [][]int) [][]int { m, n := len(heights), len(heights[0]) visit := make([][]int, m) for i := range heights { visit[i] = make([]int, n) } dirs := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} var dfs func(row, col int, flag int) dfs = func(row, col int, flag int) { visit[row][col] |= flag // 越界检查 if row \u0026lt; 0 || row \u0026gt;= m || col \u0026lt; 0 || col \u0026gt;= n { return } for _, dir := range dirs { next := []int{row + dir[0], col + dir[1]} if next[0] \u0026lt; 0 || next[0] \u0026gt;= m || next[1] \u0026lt; 0 || next[1] \u0026gt;= n { continue } // 通过其他单元格流入 if visit[next[0]][next[1]]\u0026amp;flag != 0 { continue } // 无法通过当前单元格流入 if heights[next[0]][next[1]] \u0026lt; heights[row][col] { continue } dfs(next[0], next[1], flag) } } for i := 0; i \u0026lt; n; i++ { dfs(0, i, 1) // 太平洋 dfs(m-1, i, 2) // 大西洋 } for i := 0; i \u0026lt; m; i++ { dfs(i, 0, 1) // 太平洋 dfs(i, n-1, 2) // 大西洋 } ans := make([][]int, 0, 5) for i, line := range visit { for j, cell := range line { if cell == 3 { ans = append(ans, []int{i, j}) } } } return ans } 复杂度 时间复杂度：$ O(m*n) $ 空间复杂度：$ O(m*n) $ ","date":"2022-04-27T10:34:55+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-417.-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/","title":"Leetcode 417. 太平洋大西洋水流问题"},{"content":"链接： https://leetcode-cn.com/problems/projection-area-of-3d-shapes/\n难度： 中等\n题目描述 在 n x n 的网格 grid 中，我们放置了一些与 x，y，z 三轴对齐的 1 x 1 x 1 立方体。\n每个值 v = grid[i][j] 表示 v 个正方体叠放在单元格 (i, j) 上。\n现在，我们查看这些立方体在 xy 、yz 和 zx 平面上的投影。\n投影 就像影子，将 三维 形体映射到一个 二维 平面上。从顶部、前面和侧面看立方体时，我们会看到“影子”。\n返回 所有三个投影的总面积 。\n示例 1： \u0026lt;img src=\u0026quot;/img/883.shadow.png\u0026quot; width=\u0026gt;\u0026ldquo;800px\u0026rdquo;\u0026gt;\n输入： [[1,2],[3,4]]\n输出： 17\n解释： 这里有该形体在三个轴对齐平面上的三个投影(“阴影部分”)。\n示例 2： 输入： grid = [[2]]\n输出： 5\n示例 3： 输入： [[1,0],[0,2]]\n输出： 8\n提示： n == grid.length == grid[i].length 1 \u0026lt;= n \u0026lt;= 50 0 \u0026lt;= grid[i][j] \u0026lt;= 50 解题思路 模拟 xy的投影面积，即为 grid 中，不为 0 的数量。 xz的投影面积，对于每个 x 而言，取最大的 z 坐标，然后求和。 yz的投影面积，对于每个 y 而言，取最大的 z 坐标，然后求和。 将上述三部分加起来。\nfunc projectionArea(grid [][]int) int { xy := 0 xz := 0 yz := 0 for x := 0; x \u0026lt; len(grid); x++ { xzMaxZ := 0 // 相同x坐标，z坐标最大值 yzMaxZ := 0 // 相同y坐标，z坐标最大值 for y := 0; y \u0026lt; len(grid); y++ { if grid[x][y] != 0 { xy++ } if xzMaxZ \u0026lt; grid[x][y] { xzMaxZ = grid[x][y] } if yzMaxZ \u0026lt; grid[y][x] { yzMaxZ = grid[y][x] } } xz += xzMaxZ yz += yzMaxZ } return xy + xz + yz } 复杂度 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(1) $ ","date":"2022-04-26T10:14:52+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-883.-%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E6%8A%95%E5%BD%B1%E9%9D%A2%E7%A7%AF/","title":"Leetcode 883. 三维形体投影面积"},{"content":"链接： https://leetcode-cn.com/problems/random-pick-index/\n难度： 中等\n题目描述 给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。\n注意：\n数组大小可能非常大。 使用太多额外空间的解决方案将不会通过测试。\n示例： int[] nums = new int[] {1,2,3,3,3}; Solution solution = new Solution(nums); // pick(3) 应该返回索引 2,3 或者 4。每个索引的返回概率应该相等。 solution.pick(3); // pick(1) 应该返回 0。因为只有nums[0]等于1。 solution.pick(1); 解题思路 哈希 使用哈希表记录每个重复元素出现过的所有下标，每次从这些下标中随机选出一个即可。\ntype Solution struct { idxes map[int][]int random *rand.Rand } func Constructor(nums []int) Solution { idxes := make(map[int][]int) for i, num := range nums { idxes[num] = append(idxes[num], i) } return Solution{ idxes: idxes, random: rand.New(rand.NewSource(time.Now().UnixNano())), } } func (this *Solution) Pick(target int) int { return this.idxes[target][this.random.Intn(len(this.idxes[target]))] } 复杂度 时间复杂度： constructor：$ O(N), N = len(nums) $ pick：$ O(1) $ 空间复杂度：$ O(N) $ ","date":"2022-04-25T09:42:51+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-398.-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%B4%A2%E5%BC%95/","title":"Leetcode 398. 随机数索引"},{"content":"链接： https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/\n难度： 中等\n题目描述 给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离 。如果不存在两个相邻的 1，返回 0 。\n如果只有 0 将两个 1 分隔开（可能不存在 0 ），则认为这两个 1 彼此 相邻 。两个 1 之间的距离是它们的二进制表示中位置的绝对差。例如，\u0026quot;1001\u0026quot; 中的两个 1 的距离为 3 。\n示例 1： 输入： n = 22\n输出： 2\n解释： 22 的二进制是 \u0026ldquo;10110\u0026rdquo; 。\n在 22 的二进制表示中，有三个 1，组成两对相邻的 1 。\n第一对相邻的 1 中，两个 1 之间的距离为 2 。\n第二对相邻的 1 中，两个 1 之间的距离为 1 。\n答案取两个距离之中最大的，也就是 2 。\n示例 2： 输入： n = 8\n输出： 0\n解释： 8 的二进制是 \u0026ldquo;1000\u0026rdquo; 。\n在 8 的二进制表示中没有相邻的两个 1，所以返回 0 。\n示例 3： 输入： n = 5\n输出： 2\n解释： 5 的二进制是 \u0026ldquo;101\u0026rdquo; 。\n提示： 1 \u0026lt;= n \u0026lt;= 109 解题思路 移位 对 n 执行右移运算，当末尾为 1 时，判断相邻的两个 1 之间的距离。\nfunc binaryGap(n int) int { ans := 0 for lastIdx, i := -1, 0; n \u0026gt; 0; n, i = n\u0026gt;\u0026gt;1, i+1 { if n\u0026amp;1 == 0 { continue } if lastIdx != -1 \u0026amp;\u0026amp; ans \u0026lt; i-lastIdx { ans = i - lastIdx } lastIdx = i } return ans } 复杂度 时间复杂度：$ O(\\log{n}) $ 空间复杂度：$ O(1) $ ","date":"2022-04-24T09:42:33+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-868.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%97%B4%E8%B7%9D/","title":"Leetcode 868. 二进制间距"},{"content":"链接： https://leetcode-cn.com/problems/rotate-function/\n难度： 中等\n题目描述 给定一个长度为 n 的整数数组 nums 。\n假设 arrk 是数组 nums 顺时针旋转 k 个位置后的数组，我们定义 nums 的 旋转函数 F 为：\nF(k) = 0 * arrk[0] + 1 * arrk[1] + \u0026hellip; + (n - 1) * arrk[n - 1] 返回 F(0), F(1), ..., F(n-1) 中的最大值 。\n生成的测试用例让答案符合 32 位 整数。\n示例 1： 输入： nums = [4,3,2,6]\n输出： 26\n解释：\nF(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\nF(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\nF(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\nF(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n所以 F(0), F(1), F(2), F(3) 中的最大值是 F(3) = 26 。\n示例 2： 输入： nums = [100]\n输出： 0\n提示： n == nums.length 1 \u0026lt;= n \u0026lt;= 105 -100 \u0026lt;= nums[i] \u0026lt;= 100 解题思路 模拟 不进行任何旋转时，旋转函数值为 F(0) = 0 * nums[0] + 1 * nums[1] + ... + (n-2) * nums[n-2] + (n-1) * nums[n-1]\n进行 1 次旋转后，旋转函数值为 F(1) = 1 * nums[0] + 2 * nums[1] + ... + (n-1) * nums[n-2] + 0 * nums[n-1]\n二者求差，可得 F(1) - F(0) = nums[0] + nums[1] + ... + nums[n-2] - (n-1) * nums[n-1] = nums[0] + nums[1] + ... + nums[n-1] - n * nums[n-1]；\n设 sum 为数组元素和，则F(1) = F(0) + sum - n * nums[n-1]\n进行 2 次旋转，可以理解为在进行一次旋转生成新数组的基础上，再进行 1 次旋转。只是此次末尾元素变为了 nums[n-2]，故 F(2) = F(1) + sum - n * nums[n-2]\n从而得到递推公式：F(k) = F(k-1) + sum - n * nums[n-k]\n依据递推公式，求得所有旋转函数值，并从中找出最大值。\nfunc maxRotateFunction(nums []int) int { sum := 0 f := 0 for i, num := range nums { sum += num f += i * num } maxF := f for i := len(nums) - 1; i \u0026gt; 0; i-- { f += sum - nums[i]*len(nums) if maxF \u0026lt; f { maxF = f } } return maxF } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2022-04-22T09:32:20+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-396.-%E6%97%8B%E8%BD%AC%E5%87%BD%E6%95%B0/","title":"Leetcode 396. 旋转函数"},{"content":"链接： https://leetcode-cn.com/problems/goat-latin/\n难度： 简单\n题目描述 给你一个由若干单词组成的句子 sentence ，单词间由空格分隔。每个单词仅由大写和小写英文字母组成。\n请你将句子转换为 “山羊拉丁文（Goat Latin）”（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。山羊拉丁文的规则如下：\n如果单词以元音开头（'a', 'e', 'i', 'o', 'u'），在单词后添加 \u0026quot;ma\u0026quot;。 例如，单词 \u0026quot;apple\u0026quot; 变为 \u0026quot;applema\u0026quot; 。 如果单词以辅音字母开头（即，非元音字母），移除第一个字符并将它放到末尾，之后再添加\u0026quot;ma\u0026quot;。 例如，单词 \u0026quot;goat\u0026quot; 变为 \u0026quot;oatgma\u0026quot; 。 根据单词在句子中的索引，在单词最后添加与索引相同数量的字母'a'，索引从 1 开始。 例如，在第一个单词后添加 \u0026quot;a\u0026quot; ，在第二个单词后添加 \u0026quot;aa\u0026quot; ，以此类推。 返回将 sentence 转换为山羊拉丁文后的句子。\n示例 1： 输入： sentence = \u0026ldquo;I speak Goat Latin\u0026rdquo;\n输出： \u0026ldquo;Imaa peaksmaaa oatGmaaaa atinLmaaaaa\u0026rdquo;\n示例 2： 输入： sentence = \u0026ldquo;The quick brown fox jumped over the lazy dog\u0026rdquo;\n输出： \u0026ldquo;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\u0026rdquo;\n提示： 1 \u0026lt;= sentence.length \u0026lt;= 150 sentence 由英文字母和空格组成 sentence 不含前导或尾随空格 sentence 中的所有单词由单个空格分隔 解题思路 模拟 以空格为单位，识别出每个单词，按照题设规则做相应变换。最后组成新的句子。\nfunc toGoatLatin(sentence string) string { ans := make([]byte, 0, len(sentence)) wordCnt := 1 begin := 0 for i := 0; i \u0026lt;= len(sentence); i++ { if i == len(sentence) || sentence[i] == \u0026#39; \u0026#39; { switch sentence[begin] { case \u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;U\u0026#39;: ans = append(ans, sentence[begin:i]...) ans = append(ans, \u0026#39;m\u0026#39;, \u0026#39;a\u0026#39;) default: ans = append(ans, sentence[begin+1:i]...) ans = append(ans, sentence[begin], \u0026#39;m\u0026#39;, \u0026#39;a\u0026#39;) } for j := 0; j \u0026lt; wordCnt; j++ { ans = append(ans, \u0026#39;a\u0026#39;) } ans = append(ans, \u0026#39; \u0026#39;) begin = i + 1 wordCnt++ } } return string(ans[:len(ans)-1]) } 复杂度 时间复杂度：$ O(N^2), N = len(sentence) $ 空间复杂度：$ O(1) $ ","date":"2022-04-21T10:21:43+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-824.-%E5%B1%B1%E7%BE%8A%E6%8B%89%E4%B8%81%E6%96%87/","title":"Leetcode 824. 山羊拉丁文"},{"content":"链接： https://leetcode-cn.com/problems/lexicographical-numbers/\n难度： 中等\n题目描述 假设有一个同时存储文件和目录的文件系统。下图展示了文件系统的一个示例：\n这里将 dir 作为根目录中的唯一目录。dir 包含两个子目录 subdir1 和 subdir2 。subdir1 包含文件 file1.ext 和子目录 subsubdir1；subdir2 包含子目录 subsubdir2，该子目录下包含文件 file2.ext 。\n在文本格式中，如下所示(⟶表示制表符)：\ndir\n⟶ subdir1\n⟶ ⟶ file1.ext\n⟶ ⟶ subsubdir1\n⟶ subdir2\n⟶ ⟶ subsubdir2\n⟶ ⟶ ⟶ file2.ext\n如果是代码表示，上面的文件系统可以写为 \u0026quot;dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\u0026quot; 。'\\n' 和 '\\t' 分别是换行符和制表符。\n文件系统中的每个文件和文件夹都有一个唯一的 绝对路径 ，即必须打开才能到达文件/目录所在位置的目录顺序，所有路径用 '/' 连接。上面例子中，指向 file2.ext 的 绝对路径 是 \u0026quot;dir/subdir2/subsubdir2/file2.ext\u0026quot; 。每个目录名由字母、数字和/或空格组成，每个文件名遵循 name.extension 的格式，其中 name 和 extension 由字母、数字和/或空格组成。\n给定一个以上述格式表示文件系统的字符串 input ，返回文件系统中 指向 文件 的 最长绝对路径 的长度 。 如果系统中没有文件，返回 0。\n示例 1： 输入： input = \u0026ldquo;dir\\n\\tsubdir1\\n\\tsubdir2\\n\\t\\tfile.ext\u0026rdquo;\n输出： 20\n解释： 只有一个文件，绝对路径为 \u0026ldquo;dir/subdir2/file.ext\u0026rdquo; ，路径长度 20\n示例 2： 输入： input = \u0026ldquo;dir\\n\\tsubdir1\\n\\t\\tfile1.ext\\n\\t\\tsubsubdir1\\n\\tsubdir2\\n\\t\\tsubsubdir2\\n\\t\\t\\tfile2.ext\u0026rdquo;\n输出： 32\n解释： 存在两个文件：\n\u0026ldquo;dir/subdir1/file1.ext\u0026rdquo; ，路径长度 21\n\u0026ldquo;dir/subdir2/subsubdir2/file2.ext\u0026rdquo; ，路径长度 32\n返回 32 ，因为这是最长的路径\n示例 3： 输入： input = \u0026ldquo;a\u0026rdquo;\n输出： 0\n解释： 不存在任何文件\n示例 4： 输入： input = \u0026ldquo;file1.txt\\nfile2.txt\\nlongfile.txt\u0026rdquo;\n输出： 12\n解释： 根目录下有 3 个文件。\n因为根目录中任何东西的绝对路径只是名称本身，所以答案是 \u0026ldquo;longfile.txt\u0026rdquo; ，路径长度为 12\n提示： 1 \u0026lt;= input.length \u0026lt;= 104 input 可能包含小写或大写的英文字母，一个换行符 '\\n'，一个制表符 '\\t'，一个点 '.'，一个空格 ' '，和数字。 解题思路 栈 文件/目录嵌套深度是以每行前的字符 '\\t' 的数量确定的。\n当深度增加时，若为目录则入栈；若为文件判定路径长度。 当深度减少时，需要恢复到当前目录。通过执行出栈操作，直到栈元素数量少于深度为止。然后执行和上述相同的操作。 func lengthLongestPath(input string) int { maxLength := 0 stack := make([]string, 0, 5) // 目录栈 length := 0 // 当前路径长度 lineStart := 0 // 行首 for i := 0; i \u0026lt;= len(input); i++ { // 每一行 if i == len(input) || input[i] == \u0026#39;\\n\u0026#39; { // 计算深度 depth := 1 for ; input[lineStart] == \u0026#39;\\t\u0026#39;; lineStart++ { depth++ } name := input[lineStart:i] // 文件/目录名 // 恢复到当前所在目录 for len(stack) \u0026gt;= depth { length -= len(stack[len(stack)-1]) + 1 stack = stack[:len(stack)-1] } // 文件，判断是否是最长路径 if strings.Contains(name, \u0026#34;.\u0026#34;) { if maxLength \u0026lt; length+len(name) { maxLength = length + len(name) } } else { // 目录加入到栈中 stack = append(stack, name) length += len(name) + 1 } lineStart = i + 1 // 下一行 } } return maxLength } 复杂度 时间复杂度：$ O(N), N = len(input) $ 空间复杂度：$ O(N) $ ","date":"2022-04-20T09:34:01+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-388.-%E6%96%87%E4%BB%B6%E7%9A%84%E6%9C%80%E9%95%BF%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/","title":"Leetcode 388. 文件的最长绝对路径"},{"content":"链接： https://leetcode-cn.com/problems/shortest-distance-to-a-character/\n难度： 简单\n题目描述 给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n示例 1： 输入： s = \u0026ldquo;loveleetcode\u0026rdquo;, c = \u0026ldquo;e\u0026rdquo;\n输出： [3,2,1,0,1,0,0,1,2,2,1,0]\n解释： 字符 \u0026rsquo;e\u0026rsquo; 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 \u0026rsquo;e\u0026rsquo; 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 \u0026rsquo;e\u0026rsquo; 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 \u0026rsquo;e\u0026rsquo; 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 \u0026rsquo;e\u0026rsquo; 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n示例 2： 输入： s = \u0026ldquo;aaab\u0026rdquo;, c = \u0026ldquo;b\u0026rdquo;\n输出： [3,2,1,0]\n提示： 1 \u0026lt;= s.length \u0026lt;= 104 s[i] 和 c 均为小写英文字母 题目数据保证 c 在 s 中至少出现一次 解题思路 滑动窗口 以字符 c 所在位置为区间的端点进行滑动，则在区间内的字符与其最近的 距离 必然是区间的端点。\nfunc shortestToChar(s string, c byte) []int { distance := make([]int, len(s)) l, r := -1, 0 for i := range s { if i \u0026lt; len(s)-1 \u0026amp;\u0026amp; s[i] != c { continue } l, r = r, i for j := l; j \u0026lt;= r; j++ { distance[j] = math.MaxInt if s[l] == c \u0026amp;\u0026amp; distance[j] \u0026gt; j-l { distance[j] = j - l } if s[r] == c \u0026amp;\u0026amp; distance[j] \u0026gt; r-j { distance[j] = r - j } } } return distance } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2022-04-19T10:08:56+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-821.-%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/","title":"Leetcode 821. 字符的最短距离"},{"content":"链接： https://leetcode-cn.com/problems/lexicographical-numbers/\n难度： 中等\n题目描述 给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。\n你必须设计一个时间复杂度为 $ O(n) $ 且使用 $ O(1) $ 额外空间的算法。\n示例 1： 输入： n = 13\n输出： [1,10,11,12,13,2,3,4,5,6,7,8,9]\n示例 2： 输入： n = 2\n输出： [1,2]\n提示： 1 \u0026lt;= n \u0026lt;= 5 * 104 解题思路 自定义排序 生成 [1, n] 的数组，自定义排序规则：将两个数转化为字符串进行比较。完成一轮排序返回即可。\nfunc lexicalOrder(n int) []int { nums := make([]int, 0, n) for i := 1; i \u0026lt;= n; i++ { nums = append(nums, i) } sort.Slice(nums, func(i, j int) bool { return strconv.Itoa(nums[i]) \u0026lt; strconv.Itoa(nums[j]) }) return nums } 复杂度 时间复杂度：$ O(n\\log{n}) $ 空间复杂度：$ O(\\log{n}) $ 深度优先搜索 沿上述思路，字符串比较时，实际上是前缀的比较：\n当前缀大时，后面的字符不会影响字符串的大小； 仅当前缀相同时，长度短的较小。 在处理时尽量保持前缀相同，所以每次对后缀进行 +1 操作，直到到达上限后，后缀部分前移一位。\nfunc lexicalOrder(n int) []int { ans := make([]int, 0, n) var dfs func(num int) dfs = func(num int) { if num \u0026gt; n { return } ans = append(ans, num) // 当前位数字增加 for i := 0; i \u0026lt;= 9; i++ { t := num*10 + i if t \u0026gt; n { break } dfs(t) // 优先处理后缀 } } for i := 1; i \u0026lt;= 9; i++ { dfs(i) } return ans } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(\\log{n}) $ ","date":"2022-04-18T09:33:32+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-386.-%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0/","title":"Leetcode 386. 字典序排数"},{"content":"链接： https://leetcode-cn.com/problems/most-common-word/\n难度： 简单\n题目描述 给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。\n题目保证至少有一个词不在禁用列表中，而且答案唯一。\n禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。\n示例： 输入：\nparagraph = \u0026ldquo;Bob hit a ball, the hit BALL flew far after it was hit.\u0026rdquo;\nbanned = [\u0026ldquo;hit\u0026rdquo;]\n输出： \u0026ldquo;ball\u0026rdquo;\n解释：\n\u0026ldquo;hit\u0026rdquo; 出现了3次，但它是一个禁用的单词。\n\u0026ldquo;ball\u0026rdquo; 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。\n注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 \u0026ldquo;ball,\u0026quot;），\n\u0026ldquo;hit\u0026quot;不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。\n提示： 1 \u0026lt;= 段落长度 \u0026lt;= 1000 0 \u0026lt;= 禁用单词个数 \u0026lt;= 100 1 \u0026lt;= 禁用单词长度 \u0026lt;= 10 答案是唯一的, 且都是小写字母 (即使在 paragraph 里是大写的，即使是一些特定的名词，答案都是小写的。) paragraph 只包含字母、空格和下列标点符号!?',;. 不存在没有连字符或者带有连字符的单词。 单词里只包含字母，不会出现省略号或者其他标点符号。 解题思路 哈希 以非字母符字符为分隔符，识别出每个单词并转换为小写，使用哈希表统计每个单词出现的次数，在此过程中找寻出现次数最多的单词。\n被禁用单词列表的数量，初始化时，将其次数记为极小值，确保其次数不会变正，不影响结果。\nfunc mostCommonWord(paragraph string, banned []string) string { cnt := make(map[string]int) // 禁用单词数量初始化为最小值，不影响结果 for _, b := range banned { cnt[b] = math.MinInt } ans := \u0026#34;\u0026#34; start := 0 // 单词开始 for i := 0; i \u0026lt;= len(paragraph); i++ { // 单词结尾处：段落位 或 非字母 if i == len(paragraph) || !unicode.IsLetter(rune(paragraph[i])) { // 存在单词 if start \u0026lt; i { word := strings.ToLower(paragraph[start:i]) // 转换为小写 cnt[word]++ if cnt[ans] \u0026lt; cnt[word] { ans = word } } start = i + 1 } } return ans } 复杂度 时间复杂度：$ O(N_1+N_2), N_1 = len(paragraph), N_2 = len(banned))$ 空间复杂度：$ O(N_1+N_2) $ ","date":"2022-04-17T09:08:03+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-819.-%E6%9C%80%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%95%E8%AF%8D/","title":"Leetcode 819. 最常见的单词"},{"content":"链接： https://leetcode-cn.com/problems/mini-parser/\n难度： 中等\n题目描述 给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 NestedInteger 。\n列表中的每个元素只可能是整数或整数嵌套列表\n示例 1： 输入： s = \u0026ldquo;324\u0026rdquo;,\n输出： 324\n解释： 你应该返回一个 NestedInteger 对象，其中只包含整数值 324。\n示例 2： 输入： s = \u0026ldquo;[123,[456,[789]]]\u0026rdquo;,\n输出： [123,[456,[789]]]\n解释： 返回一个 NestedInteger 对象包含一个有两个元素的嵌套列表：\n一个 integer 包含值 123 一个包含两个元素的嵌套列表：\ni. 一个 integer 包含值 456\nii. 一个包含一个元素的嵌套列表\na. 一个 integer 包含值 789 提示： 1 \u0026lt;= s.length \u0026lt;= 5 * 104 s 由数字、方括号 \u0026quot;[]\u0026quot;、负号 '-' 、逗号 ',' 组成 用例保证 s 是可解析的 NestedInteger 输入中的所有值的范围是 [-106, 106] 解题思路 深度优先搜索 嵌套列表只有两种情况，要么是一个值，要么是嵌套列表，在字符串中的体现是以 '[' 开头进行区分。\n使用深度优先搜索策略，当遍历到的字符以 '[' 开始，说明这是一个嵌套列表；否则，说明这是一个值。\n值的处理比较简单，因为题目保证了输入的有效性，故向后遍历找到不为数字或 '-' 的符号为止，将这段字串转换为值。\n对于嵌套列表，从下个字符开始，递归搜索每个元素，',' 作为分隔符直接忽略，继续向后搜索，直到遇到 ']' 时说明该嵌套列表构造完毕，返回即可；\nfunc deserialize(s string) *NestedInteger { i := 0 var dfs func() *NestedInteger dfs = func() *NestedInteger { start := i t := new(NestedInteger) // 元素为嵌套列表 if s[i] == \u0026#39;[\u0026#39; { i++ // 嵌套列表结束 for s[i] != \u0026#39;]\u0026#39; { switch s[i] { case \u0026#39;,\u0026#39;: // 逗号忽略 i++ default: // 递归求得子元素并添加 t.Add(*dfs()) } } i++ return t } // 元素为值 for ; i \u0026lt; len(s) \u0026amp;\u0026amp; (s[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;9\u0026#39; || s[i] == \u0026#39;-\u0026#39;); i++ { } integer, _ := strconv.Atoi(s[start:i]) t.SetInteger(integer) return t } return dfs() } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(N) $ 栈 沿上述思路，使用栈进行模拟。\nfunc deserialize(s string) *NestedInteger { stack := make([]*NestedInteger, 0, 10) cur := (*NestedInteger)(nil) // 当前嵌套列表 for i := 0; i \u0026lt; len(s); i++ { switch s[i] { case \u0026#39;[\u0026#39;: // 新嵌套列表，上层入栈 if cur != nil { stack = append(stack, cur) } cur = new(NestedInteger) case \u0026#39;]\u0026#39;: // 嵌套列表结束 // 最顶层嵌套列表 if len(stack) == 0 { continue } // 将其添加进上层嵌套列表中 stack[len(stack)-1].Add(*cur) cur = stack[len(stack)-1] stack = stack[:len(stack)-1] case \u0026#39;,\u0026#39;: // 分隔符，忽略 default: // 元素为值 start := i for ; i \u0026lt; len(s) \u0026amp;\u0026amp; (s[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;9\u0026#39; || s[i] == \u0026#39;-\u0026#39;); i++ { } integer, _ := strconv.Atoi(s[start:i]) t := new(NestedInteger) t.SetInteger(integer) if cur == nil { cur = t // 没有嵌套列表，单一的值 } else { cur.Add(*t) // 添加进嵌套列表中 } i-- } } return cur } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(N) $ ","date":"2022-04-15T09:32:19+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-385.-%E8%BF%B7%E4%BD%A0%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8/","title":"Leetcode 385. 迷你语法分析器"},{"content":"链接： https://leetcode-cn.com/problems/richest-customer-wealth/\n难度： 简单\n题目描述 给你一个 m x n 的整数网格 accounts ，其中 accounts[i][j] 是第 i​​​​​​​​​​​​ 位客户在第 j 家银行托管的资产数量。返回最富有客户所拥有的 资产总量 。\n客户的 资产总量 就是他们在各家银行托管的资产数量之和。最富有客户就是 资产总量 最大的客户。\n示例 1： 输入： accounts = [[1,2,3],[3,2,1]]\n输出： 6\n解释：\n第 1 位客户的资产总量 = 1 + 2 + 3 = 6\n第 2 位客户的资产总量 = 3 + 2 + 1 = 6\n两位客户都是最富有的，资产总量都是 6 ，所以返回 6 。\n示例 2： 输入： accounts = [[1,5],[7,3],[3,5]]\n输出： 10\n解释：\n第 1 位客户的资产总量 = 6\n第 2 位客户的资产总量 = 10\n第 3 位客户的资产总量 = 8\n第 2 位客户是最富有的，资产总量是 10\n示例 3： 输入： accounts = [[2,8,7],[7,1,3],[1,9,5]]\n输出： 17\n提示： m == accounts.length n == accounts[i].length 1 \u0026lt;= m, n \u0026lt;= 50 1 \u0026lt;= accounts[i][j] \u0026lt;= 100 解题思路 模拟 对矩阵的每一行求和即可得到每位客户的总资产，找出其中总资产最大的那一个客户。\nfunc maximumWealth(accounts [][]int) int { max := 0 for _, property := range accounts { sum := 0 for _, p := range property { sum += p } if max \u0026lt; sum { max = sum } } return max } 复杂度 时间复杂度：$ O(m*n) $ 空间复杂度：$ O(1) $ ","date":"2022-04-14T09:42:42+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1672.-%E6%9C%80%E5%AF%8C%E6%9C%89%E5%AE%A2%E6%88%B7%E7%9A%84%E8%B5%84%E4%BA%A7%E6%80%BB%E9%87%8F/","title":"Leetcode 1672. 最富有客户的资产总量"},{"content":"链接： https://leetcode-cn.com/problems/insert-delete-getrandom-o1/\n难度： 中等\n题目描述 实现 RandomizedSet 类：\nRandomizedSet() 初始化 RandomizedSet 对象 bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。 bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。 int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。 你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 $O(1)$ 。\n示例： 输入\n[\u0026ldquo;RandomizedSet\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;remove\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;getRandom\u0026rdquo;, \u0026ldquo;remove\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;getRandom\u0026rdquo;]\n[[], [1], [2], [2], [], [1], [2], []]\n输出\n[null, true, false, true, 2, true, false, 2]\n解释\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // 向集合中插入 1 。返回 true 表示 1 被成功地插入。\nrandomizedSet.remove(2); // 返回 false ，表示集合中不存在 2 。\nrandomizedSet.insert(2); // 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。\nrandomizedSet.getRandom(); // getRandom 应随机返回 1 或 2 。\nrandomizedSet.remove(1); // 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。\nrandomizedSet.insert(2); // 2 已在集合中，所以返回 false 。\nrandomizedSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。\n提示： -231 \u0026lt;= val \u0026lt;= 231 - 1 最多调用 insert、remove 和 getRandom 函数 2 * 105 次 在调用 getRandom 方法时，数据结构中 至少存在一个 元素。 解题思路 数组 + 哈希 因为该类是个集合，元素需要去重，所以使用哈希表，这样插入和删除都是 $O(1)$ 复杂度。\n另需要在 $O(1)$ 复杂度内实现返回随机元素，可以使用数组实现。这样哈希表中需要存储的是对应元素所在的下标。插入时，添加到数组中元素尾；删除时，将最后一个元素移动到待删除元素处覆盖即可。\ntype RandomizedSet struct { idx map[int]int elems []int random *rand.Rand } func Constructor() RandomizedSet { return RandomizedSet{ idx: make(map[int]int), elems: make([]int, 0, 2e5), random: rand.New(rand.NewSource(time.Now().UnixNano())), } } func (this *RandomizedSet) Insert(val int) bool { // 已存在，返回false if _, ok := this.idx[val]; ok { return false } this.elems = append(this.elems, val) // 添加到数组尾部 this.idx[val] = len(this.elems) - 1 // 哈希表记录下标 return true } func (this *RandomizedSet) Remove(val int) bool { delIdx, ok := this.idx[val] // 不存在，返回false if !ok { return false } this.elems[delIdx] = this.elems[len(this.elems)-1] // 使用最后一个元素覆盖 this.idx[this.elems[delIdx]] = delIdx // 更新元素下标 this.elems = this.elems[:len(this.elems)-1] // 长度-1 delete(this.idx, val) // 从哈希表中删除 return true } func (this *RandomizedSet) GetRandom() int { return this.elems[this.random.Intn(len(this.elems))] // 返回随机下标处的元素 } 复杂度 时间复杂度： constructor：$ O(1) $ insert：$ O(1) $ remove：$ O(1) $ getRandom：$ O(1) $ 空间复杂度：$ O(N) $ ","date":"2022-04-13T09:26:31+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-380.-o1-%E6%97%B6%E9%97%B4%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4%E5%92%8C%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%85%83%E7%B4%A0/","title":"Leetcode 380. O(1) 时间插入、删除和获取随机元素"},{"content":"链接： https://leetcode-cn.com/problems/unique-morse-code-words/\n难度： 简单\n题目描述 我们要把给定的字符串 S 从左到右写到每一行上，每一行的最大宽度为100个单位，如果我们在写某个字母的时候会使这行超过了100 个单位，那么我们应该把这个字母写到下一行。我们给定了一个数组 widths ，这个数组 widths[0] 代表 'a' 需要的单位， widths[1] 代表 'b' 需要的单位，\u0026hellip;， widths[25] 代表 'z' 需要的单位。\n现在回答两个问题：至少多少行能放下 S ，以及最后一行使用的宽度是多少个单位？将你的答案作为长度为2的整数列表返回。\n示例 1： 输入：\nwidths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\nS = \u0026ldquo;abcdefghijklmnopqrstuvwxyz\u0026rdquo;\n输出： [3, 60]\n解释：\n所有的字符拥有相同的占用单位10。所以书写所有的26个字母，\n我们需要2个整行和占用60个单位的一行。\n示例 2： 示例 2: 输入：\nwidths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10]\nS = \u0026ldquo;bbbcccdddaaa\u0026rdquo;\n输出： [2, 4]\n解释：\n除去字母\u0026rsquo;a\u0026rsquo;所有的字符都是相同的单位10，并且字符串 \u0026ldquo;bbbcccdddaa\u0026rdquo; 将会覆盖 9 * 10 + 2 * 4 = 98 个单位.\n最后一个字母 \u0026lsquo;a\u0026rsquo; 将会被写到第二行，因为第一行只剩下2个单位了。\n所以，这个答案是2行，第二行有4个单位宽度。\n提示： 字符串 S 的长度在 [1, 1000] 的范围。 S 只包含小写字母。 widths 是长度为 26 的数组。 widths[i] 值的范围在 [2, 10]。 解题思路 模拟 遍历字符串，记录当前行的已经使用部分的宽度，当新增一个字母不能放置到当前行时，将其放置到下一行，行数 +1。\nfunc numberOfLines(widths []int, s string) []int { rows := 1 width := 0 for i := range s { width += widths[s[i]-\u0026#39;a\u0026#39;] // 超过行上限，将该字母放置到下一行 if width \u0026gt; 100 { width = widths[s[i]-\u0026#39;a\u0026#39;] rows++ } } return []int{rows, width} } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2022-04-12T09:50:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-806.-%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E8%A1%8C%E6%95%B0/","title":"Leetcode 806. 写字符串需要的行数"},{"content":"链接： https://leetcode-cn.com/problems/count-numbers-with-unique-digits/\n难度： 中等\n题目描述 给你一个整数 n ，统计并返回各位数字都不同的数字 x 的个数，其中 0 \u0026lt;= x \u0026lt; 10n\n示例 1： 输入： n = 2\n输出： 91\n解释： 答案应为除去 11、22、33、44、55、66、77、88、99 外，在 0 ≤ x \u0026lt; 100 范围内的所有数字。\n示例 2： 输入： n = 0 输出： 1\n提示： 0 \u0026lt;= n \u0026lt;= 8 解题思路 排列 对于给定长度的数字而言，由于不存在前导 0 ，其首个数字只能从 1～9 内选取，为保证每一位数均不重复，则第二个数字只能从剩余 9 个数字中选择，第三个数字只能从剩余 8 个数字中选择，以此类推。\n当长度为 1 时，数字 0 是个特例，其是 0 开头，但其必然存在于所有答案中，故初始就将其累加到结果中。\n则对于连续的 [1,10\u0026lt;sup\u0026gt;n\u0026lt;/sup\u0026gt;] 范围内的数字，有：\n1位数部分，9 2位数部分, 9 * 9 3位数部分，9 * 9 * 8 \u0026hellip; n位数部分，9 * 9 * 8 * \u0026hellip; * (11-n) 对以上所有情况求和，得到结果为 9 * (1 + 9 * (1 + 8 * (...(1 + (11-n) * 1))))\n对数位为 n = 0 的情况特判。\nfunc countNumbersWithUniqueDigits(n int) int { if n == 0 { return 1 } ans := 1 // 除首位部分求和 for i := 11 - n; i \u0026lt;= 9; i++ { ans = ans*i + 1 } ans *= 9 // 首位部分 return ans + 1 // 0必然存在 } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2022-04-11T09:36:55+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-357.-%E7%BB%9F%E8%AE%A1%E5%90%84%E4%BD%8D%E6%95%B0%E5%AD%97%E9%83%BD%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E5%AD%97%E4%B8%AA%E6%95%B0/","title":"Leetcode 357. 统计各位数字都不同的数字个数"},{"content":"链接： https://leetcode-cn.com/problems/unique-morse-code-words/\n难度： 简单\n题目描述 国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如:\n'a' 对应 \u0026quot;.-\u0026quot; ， 'b' 对应 \u0026quot;-...\u0026quot; ， 'c' 对应 \u0026quot;-.-.\u0026quot; ，以此类推。 为了方便，所有 26 个英文字母的摩尔斯密码表如下：\n[\u0026quot;.-\u0026quot;,\u0026quot;-...\u0026quot;,\u0026quot;-.-.\u0026quot;,\u0026quot;-..\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;..-.\u0026quot;,\u0026quot;--.\u0026quot;,\u0026quot;....\u0026quot;,\u0026quot;..\u0026quot;,\u0026quot;.---\u0026quot;,\u0026quot;-.-\u0026quot;,\u0026quot;.-..\u0026quot;,\u0026quot;--\u0026quot;,\u0026quot;-.\u0026quot;,\u0026quot;---\u0026quot;,\u0026quot;.--.\u0026quot;,\u0026quot;--.-\u0026quot;,\u0026quot;.-.\u0026quot;,\u0026quot;...\u0026quot;,\u0026quot;-\u0026quot;,\u0026quot;..-\u0026quot;,\u0026quot;...-\u0026quot;,\u0026quot;.--\u0026quot;,\u0026quot;-..-\u0026quot;,\u0026quot;-.--\u0026quot;,\u0026quot;--..\u0026quot;]\n给你一个字符串数组 words ，每个单词可以写成每个字母对应摩尔斯密码的组合。\n例如，\u0026quot;cab\u0026quot; 可以写成 \u0026quot;-.-..--...\u0026quot; ，(即 \u0026quot;-.-.\u0026quot; + \u0026quot;.-\u0026quot; + \u0026quot;-...\u0026quot; 字符串的结合)。我们将这样一个连接过程称作 单词翻译 。\n对 words 中所有单词进行单词翻译，返回不同 单词翻译 的数量。\n示例 1： 输入： words = [\u0026ldquo;gin\u0026rdquo;, \u0026ldquo;zen\u0026rdquo;, \u0026ldquo;gig\u0026rdquo;, \u0026ldquo;msg\u0026rdquo;]\n输出： 2\n解释：\n各单词翻译如下:\n\u0026ldquo;gin\u0026rdquo; -\u0026gt; \u0026ldquo;\u0026ndash;\u0026hellip;-.\u0026rdquo;\n\u0026ldquo;zen\u0026rdquo; -\u0026gt; \u0026ldquo;\u0026ndash;\u0026hellip;-.\u0026rdquo;\n\u0026ldquo;gig\u0026rdquo; -\u0026gt; \u0026ldquo;\u0026ndash;\u0026hellip;\u0026ndash;.\u0026rdquo;\n\u0026ldquo;msg\u0026rdquo; -\u0026gt; \u0026ldquo;\u0026ndash;\u0026hellip;\u0026ndash;.\u0026rdquo;\n共有 2 种不同翻译, \u0026ldquo;\u0026ndash;\u0026hellip;-.\u0026rdquo; 和 \u0026ldquo;\u0026ndash;\u0026hellip;\u0026ndash;.\u0026rdquo;.\n示例 2： 输入： words = [\u0026ldquo;a\u0026rdquo;]\n输出： 1\n提示： 1 \u0026lt;= words.length \u0026lt;= 100 1 \u0026lt;= words[i].length \u0026lt;= 12 words[i] 由小写英文字母组成 解题思路 哈希 将每个单词翻译后的结果记录到哈希表中，进行去重，然后返回哈希表中元素数量。\nvar morse = []string{\u0026#34;.-\u0026#34;, \u0026#34;-...\u0026#34;, \u0026#34;-.-.\u0026#34;, \u0026#34;-..\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;..-.\u0026#34;, \u0026#34;--.\u0026#34;, \u0026#34;....\u0026#34;, \u0026#34;..\u0026#34;, \u0026#34;.---\u0026#34;, \u0026#34;-.-\u0026#34;, \u0026#34;.-..\u0026#34;, \u0026#34;--\u0026#34;, \u0026#34;-.\u0026#34;, \u0026#34;---\u0026#34;, \u0026#34;.--.\u0026#34;, \u0026#34;--.-\u0026#34;, \u0026#34;.-.\u0026#34;, \u0026#34;...\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;..-\u0026#34;, \u0026#34;...-\u0026#34;, \u0026#34;.--\u0026#34;, \u0026#34;-..-\u0026#34;, \u0026#34;-.--\u0026#34;, \u0026#34;--..\u0026#34;} func uniqueMorseRepresentations(words []string) int { exist := make(map[string]struct{}) for _, word := range words { t := make([]byte, 0, len(word)*4) for i := range word { t = append(t, morse[word[i]-\u0026#39;a\u0026#39;]...) } exist[string(t)] = struct{}{} } return len(exist) } 复杂度 时间复杂度：$ O(\\sum{len(words_i)}) $ 空间复杂度：$ O(\\sum{len(words_i)}) $ ","date":"2022-04-10T11:12:54+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-804.-%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/","title":"Leetcode 804. 唯一摩尔斯密码词"},{"content":"链接： https://leetcode-cn.com/problems/reaching-points/\n难度： 简单\n题目描述 给定四个整数 sx , sy ，tx 和 ty，如果通过一系列的 转换 可以从起点 (sx, sy) 到达终点 (tx, ty)，则返回 true，否则返回 false。\n从点 (x, y) 可以 转换 到 (x, x+y) 或者 (x+y, y)。\n示例 1： 输入： sx = 1, sy = 1, tx = 3, ty = 5\n输出： true\n解释：\n可以通过以下一系列转换从起点转换到终点：\n(1, 1) -\u0026gt; (1, 2)\n(1, 2) -\u0026gt; (3, 2)\n(3, 2) -\u0026gt; (3, 5)\n示例 2： 输入： sx = 1, sy = 1, tx = 2, ty = 2\n输出： false\n示例 3： 输入： sx = 1, sy = 1, tx = 1, ty = 1\n输出： true\n提示： 1 \u0026lt;= sx, sy, tx, ty \u0026lt;= 109 解题思路 逆推 若从起点出发进行搜索，每个结点均有两个方向，搜索范围过大。\n注意到转换的规则是将其中一个坐标加到另一个坐标上，则可以得知，对于坐标 (x, y)：\n当 x \u0026gt; y 时，其必然是由 (x-y, y) 转移而来； 当 x \u0026lt; y 时，其必然是由 (x, y-x) 转移而来； 当 x = y 时，其无法通过转移得到。 逆推的路径是唯一的，故从终点开始，进行逆推。可能存在其中一个坐标远大于另一个坐标的情况，使用取模运算加快推导速度。\n设递推的坐标为 (tx', ty')\n从终点坐标递推，直到 tx' ≤ sx 且 ty' ≤ sy 为止 然后进行分类讨论，有以下三种情况 若此时 (sx, sy) 与 (tx', ty') 相同，则返回 true 当其中一个坐标与起始坐标相同，另一个坐标更大时；判断其坐标差值是否为对应起始坐标的整数倍即可。 func reachingPoints(sx int, sy int, tx int, ty int) bool { for tx \u0026gt; sx \u0026amp;\u0026amp; ty \u0026gt; sy { if tx \u0026gt; ty { tx %= ty } else { ty %= tx } } return (tx == sx \u0026amp;\u0026amp; ty == sy) || // 与起点坐标相同 (tx == sx \u0026amp;\u0026amp; ty \u0026gt; sy \u0026amp;\u0026amp; (ty-sy)%sx == 0) || // 横坐标相同，判定纵坐标是否可以转移得到 (ty == sy \u0026amp;\u0026amp; tx \u0026gt; sx \u0026amp;\u0026amp; (tx-sx)%sy == 0) // 纵坐标相同，判定横坐标是否可以转移得到 } 复杂度 时间复杂度：$ O(\\log{max(tx, ty)}) $ 空间复杂度：$ O(1) $ ","date":"2022-04-09T11:35:40+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-780.-%E5%88%B0%E8%BE%BE%E7%BB%88%E7%82%B9/","title":"Leetcode 780. 到达终点"},{"content":"链接： https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/\n难度： 中等\n题目描述 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。\n树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。\n示例 1： 输入： root = [1,null,3,2,4,null,5,6]\n输出： [[1],[3,2,4],[5,6]]\n示例 2： 输入： root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n输出： [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n提示： 树的高度不会超过 1000 树的节点总数在 [0, 104] 之间 解题思路 层序遍历 使用队列记录遍历到的结点，从左往右逐层扫描。\nfunc levelOrder(root *Node) [][]int { if root == nil { return nil } ans := make([][]int, 0, 1) queue := list.New() queue.PushBack(root) layerCnt := 1 // 记录下一层的结点数，提前开辟空间 for queue.Len() \u0026gt; 0 { layerElems := make([]int, 0, layerCnt) // 当前层元素 layerCnt = 0 // 归零，计算下一层的结点数 // 遍历当前层 for i := queue.Len(); i \u0026gt; 0; i-- { node := queue.Remove(queue.Front()).(*Node) layerElems = append(layerElems, node.Val) layerCnt += len(node.Children) // 下一层结点数累加 for _, child := range node.Children { queue.PushBack(child) } } ans = append(ans, layerElems) } return ans } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(N) $ ","date":"2022-04-08T09:27:41+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-429.-n-%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","title":"Leetcode 429. N 叉树的层序遍历"},{"content":"链接： https://leetcode-cn.com/problems/rotate-string/\n难度： 简单\n题目描述 给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。\ns 的 旋转操作 就是将 s 最左边的字符移动到最右边。 例如, 若 s = 'abcde'，在旋转一次之后结果就是 'bcdea' 。\n示例 1： 输入： s = \u0026ldquo;abcde\u0026rdquo;, goal = \u0026ldquo;cdeab\u0026rdquo;\n输出： true\n示例 2： 输入： s = \u0026ldquo;abcde\u0026rdquo;, goal = \u0026ldquo;abced\u0026rdquo;\n输出： false\n提示： 1 \u0026lt;= s.length, goal.length \u0026lt;= 100 s 和 goal 由小写英文字母组成 解题思路 模拟 对字符串 s 进行 n 次旋转后，其结果将是从第 n 个字符开始，循环遍历到第 n-1 个字符为止，后续坐标需要对 len(s) 取模。\n模拟所有的旋转结果，直到其与 goal 相同，或所有旋转后的结果均不匹配。\nfunc rotateString(s string, goal string) bool { if len(s) != len(goal) { return false } Outer: for i := 0; i \u0026lt; len(s); i++ { for j := 0; j \u0026lt; len(s); j++ { if s[(i+j)%len(s)] != goal[j] { continue Outer } } return true } return false } 复杂度 时间复杂度：$ O(N^2), N = len(s) $ 空间复杂度：$ O(1) $ 查找 将两个 s 拼接，则所有的旋转结果都将包含在其中。\n在该串中查找 goal 字串，找到则说明其可以通过旋转 s 得到。\nfunc rotateString(s string, goal string) bool { return len(s) == len(goal) \u0026amp;\u0026amp; strings.Contains(s+s, goal) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(N) $ ","date":"2022-04-07T09:30:04+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-796.-%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 796. 旋转字符串"},{"content":"链接： https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/\n难度： 简单\n题目描述 给你两个整数 left 和 right ，在闭区间 [left, right] 范围内，统计并返回 计算置位位数为质数 的整数个数。\n计算置位位数 就是二进制表示中 1 的个数。\n例如， 21 的二进制表示 10101 有 3 个计算置位。 示例 1： 输入： left = 6, right = 10\n输出： 4\n解释：\n6 -\u0026gt; 110 (2 个计算置位，2 是质数)\n7 -\u0026gt; 111 (3 个计算置位，3 是质数)\n9 -\u0026gt; 1001 (2 个计算置位，2 是质数)\n10-\u0026gt; 1010 (2 个计算置位，2 是质数)\n共计 4 个计算置位为质数的数字。\n示例 2： 输入： left = 10, right = 15\n输出： 5\n解释：\n10 -\u0026gt; 1010 (2 个计算置位, 2 是质数)\n11 -\u0026gt; 1011 (3 个计算置位, 3 是质数)\n12 -\u0026gt; 1100 (2 个计算置位, 2 是质数)\n13 -\u0026gt; 1101 (3 个计算置位, 3 是质数)\n14 -\u0026gt; 1110 (3 个计算置位, 3 是质数)\n15 -\u0026gt; 1111 (4 个计算置位, 4 不是质数)\n共计 5 个计算置位为质数的数字。\n提示： 1 \u0026lt;= left \u0026lt;= right \u0026lt;= 106 0 \u0026lt;= right - left \u0026lt;= 104 解题思路 枚举 枚举区间内的每一个数字，判断其是否满足 计算置位位数为质数。\nfunc countPrimeSetBits(left int, right int) int { isPrime := map[int]struct{}{ 2: {}, 3: {}, 5: {}, 7: {}, 11: {}, 13: {}, 17: {}, 19: {}, 23: {}, 29: {}, } cnt := 0 for i := left; i \u0026lt;= right; i++ { ones := 0 for t := i; t \u0026gt; 0; t \u0026amp;= t - 1 { ones++ } if _, ok := isPrime[ones]; ok { cnt++ } } return cnt } 复杂度 时间复杂度：$ O((right-left)*\\log{right}) $ 空间复杂度：$ O(1) $ ","date":"2022-04-05T11:27:20+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-762.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E8%B4%A8%E6%95%B0%E4%B8%AA%E8%AE%A1%E7%AE%97%E7%BD%AE%E4%BD%8D/","title":"Leetcode 762. 二进制表示中质数个计算置位"},{"content":"链接： https://leetcode-cn.com/problems/range-sum-query-mutable/\n难度： 中等\n题目描述 给你一个数组 nums ，请你完成两类查询。\n其中一类查询要求 更新 数组 nums 下标对应的值 另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left \u0026lt;= right 实现 NumArray 类：\nNumArray(int[] nums) 用整数数组 nums 初始化对象 void update(int index, int val) 将 nums[index] 的值 更新 为 val int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 （即，nums[left] + nums[left + 1], ..., nums[right]） 示例： 输入：\n[\u0026ldquo;NumArray\u0026rdquo;, \u0026ldquo;sumRange\u0026rdquo;, \u0026ldquo;update\u0026rdquo;, \u0026ldquo;sumRange\u0026rdquo;]\n[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]\n输出：\n[null, 9, null, 8]\n解释：\nNumArray numArray = new NumArray([1, 3, 5]);\nnumArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9\nnumArray.update(1, 2); // nums = [1,2,5]\nnumArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8\n提示： 1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -100 \u0026lt;= nums[i] \u0026lt;= 100 0 \u0026lt;= index \u0026lt; nums.length -100 \u0026lt;= val \u0026lt;= 100 0 \u0026lt;= left \u0026lt;= right \u0026lt; nums.length 调用 update 和 sumRange 方法次数不大于 3 * 104 解题思路 分段求和 将整个数组以等长度分段进行求和，并维护该数组。\nNumArray，按照段长度，求得分段和； update，更新对应元素和对应分段和； sumRange，区间中的包含整段，累加整段和；剩余元素，遍历求和。 不妨设段长度为 $L$，则求和时间复杂度为 $L + \\frac{len(nums)}{L}$，根据均值不等式可知，当分段长度 $L = \\sqrt{len(nums)}$ 时，时间复杂度最低，为 $\\sqrt{len(nums)}$。\ntype NumArray struct { nums []int segmentSize int segmentSum []int } func Constructor(nums []int) NumArray { numArray := NumArray{ nums: nums, } numArray.segmentSize = int(math.Sqrt(float64(len(nums)))) numArray.segmentSum = make([]int, 0, len(nums)/numArray.segmentSize+1) // 分段求和 for i := 0; i \u0026lt; len(nums); i += numArray.segmentSize { segmentSum := 0 j := i + numArray.segmentSize - 1 // 最后一段不足 if j \u0026gt;= len(nums) { j = len(nums) - 1 } for ; j \u0026gt;= i; j-- { segmentSum += nums[j] } numArray.segmentSum = append(numArray.segmentSum, segmentSum) } return numArray } func (this *NumArray) Update(index int, val int) { this.segmentSum[index/this.segmentSize] += val - this.nums[index] // 更新该段和 this.nums[index] = val // 更新值 } func (this *NumArray) SumRange(left int, right int) int { sum := 0 for i := left; i \u0026lt;= right; { // 整段包含在区间内，累加整段和 if i%this.segmentSize == 0 \u0026amp;\u0026amp; i+this.segmentSize-1 \u0026lt;= right { sum += this.segmentSum[i/this.segmentSize] i += this.segmentSize continue } // 非整段情况，遍历元素求和 sum += this.nums[i] i++ } return sum } 复杂度 时间复杂度： constructor ：$ O(N), N = len(nums) $ update ：$ O(1) $ sumRange ：$ O(\\sqrt(N)) $ 空间复杂度：$ O(N) $ ","date":"2022-04-04T10:35:06+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-307.-%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E5%8F%AF%E4%BF%AE%E6%94%B9/","title":"Leetcode 307. 区域和检索 - 数组可修改"},{"content":"链接： https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/\n难度： 简单\n题目描述 给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。\n在比较时，字母是依序循环出现的。举个例子：\n如果目标字母 target = 'z' 并且字符列表为 letters = ['a', 'b']，则答案返回 'a' 示例 1： 输入： letters = [\u0026ldquo;c\u0026rdquo;, \u0026ldquo;f\u0026rdquo;, \u0026ldquo;j\u0026rdquo;]，target = \u0026ldquo;a\u0026rdquo;\n输出： \u0026ldquo;c\u0026rdquo;\n示例 2： 输入： letters = [\u0026ldquo;c\u0026rdquo;,\u0026ldquo;f\u0026rdquo;,\u0026ldquo;j\u0026rdquo;], target = \u0026ldquo;c\u0026rdquo;\n输出： \u0026ldquo;f\u0026rdquo;\n示例 3： 输入： letters = [\u0026ldquo;c\u0026rdquo;,\u0026ldquo;f\u0026rdquo;,\u0026ldquo;j\u0026rdquo;], target = \u0026ldquo;d\u0026rdquo;\n输出： \u0026ldquo;f\u0026rdquo;\n提示： 2 \u0026lt;= letters.length \u0026lt;= 104 letters[i] 是一个小写字母 letters 按非递减顺序排序 letters 最少包含两个不同的字母 target 是一个小写字母 解题思路 模拟 由于给定的字母是有序的，只需遍历 letters 列表，找出首个比 target 大的字母并返回。\n若不能找到，则说明需要进行一次循环，返回首个字母。\nfunc nextGreatestLetter(letters []byte, target byte) byte { for _, letter := range letters { if letter \u0026gt; target { return letter } } return letters[0] } 复杂度 时间复杂度：$ O(N), N = len(letters) $ 空间复杂度：$ O(1) $ 二分查找 同上述思路，使用二分查找快速定位。\nfunc nextGreatestLetter(letters []byte, target byte) byte { l, r := 0, len(letters)-1 for l \u0026lt; r { // 直到 l == r 为止 mid := (l + r) / 2 if letters[mid] \u0026lt;= target { l = mid + 1 } else { r = mid } } if letters[l] \u0026gt; target { return letters[l] } return letters[0] } 复杂度 时间复杂度：$ O(\\log{N}), N = len(letters) $ 空间复杂度：$ O(1) $ ","date":"2022-04-03T10:30:01+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-744.-%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D/","title":"Leetcode 744. 寻找比目标字母大的最小字母"},{"content":"链接： https://leetcode-cn.com/problems/range-sum-of-bst/\n难度： 中等\n题目描述 给定一个长度为偶数的整数数组 arr，只有对 arr 进行重组后可以满足 “对于每个 0 \u0026lt;= i \u0026lt; len(arr) / 2，都有 arr[2 * i + 1] = 2 * arr[2 * i]” 时，返回 true；否则，返回 false。\n示例 1： 输入： arr = [3,1,3,6]\n输出： false\n示例 2： 输入： arr = [2,1,2,6]\n输出： false\n示例 3： 输入： arr = [4,-2,2,-4]\n输出： true\n解释： 可以用 [-2,-4] 和 [2,4] 这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4]\n提示： 0 \u0026lt;= arr.length \u0026lt;= 3 * 104 arr.length 是偶数 -105 \u0026lt;= arr[i] \u0026lt;= 105 解题思路 哈希 + 排序 根据题目描述，要求下标为奇数的数是其前一个的数的两倍。按照此方式可以尝试将 arr 中的数两两成对，若能全部配对完成，则返回 true；否则返回 false。\n采用哈希表记录所有遍历到的数字，方便快速找到另一个与之配对的数。\n另外当一个数即是某个数的两倍，同时又是另一个数的二分之一时，无法界定其应该与哪个数配对，所以需要对出现过的数进行一次排序，然后从小到大进行处理，以解决前述问题：\n当是负数时，寻找是其二分之一的数； 当是非负数时，寻找是其两倍的数； func canReorderDoubled(arr []int) bool { cnt := make(map[int]int) noRepeatedNums := make([]int, 0, len(arr)) for _, num := range arr { if cnt[num] == 0 { noRepeatedNums = append(noRepeatedNums, num) } cnt[num]++ } sort.Ints(noRepeatedNums) for _, num := range noRepeatedNums { // 已配对完成 if cnt[num] == 0 { continue } // 当前数全部配对完成 if num \u0026lt; 0 { // 负数 // 奇数，不满足 if num%2 != 0 { return false } // 配对失败 if cnt[num/2] \u0026lt; cnt[num] { return false } cnt[num/2] -= cnt[num] // 配对成功 } else { // 非负数 // 配对失败 if cnt[num*2] \u0026lt; cnt[num] { return false } cnt[num*2] -= cnt[num] // 配对成功 } } return true } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(arr) $ 空间复杂度：$ O(N) $ ","date":"2022-04-01T10:21:31+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-954.-%E4%BA%8C%E5%80%8D%E6%95%B0%E5%AF%B9%E6%95%B0%E7%BB%84/","title":"Leetcode 954. 二倍数对数组"},{"content":"链接： https://leetcode-cn.com/problems/self-dividing-numbers/\n难度： 简单\n题目描述 自除数 是指可以被它包含的每一位数整除的数。\n例如，128 是一个 自除数 ，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。 自除数 不允许包含 0 。\n给定两个整数 left 和 right ，返回一个列表，列表的元素是范围 [left, right] 内所有的 自除数 。\n示例 1： 输入： left = 1, right = 22\n输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]\n示例 2： 输入： left = 47, right = 85\n输出： [48,55,66,77]\n提示： 1 \u0026lt;= left \u0026lt;= right \u0026lt;= 104 解题思路 枚举 一次枚举区间 [left, right] 内的所有树，判断其是否是自除数。\nfunc selfDividingNumbers(left int, right int) []int { isSelfDividingNumber := func(num int) bool { for n := num; n \u0026gt; 0; n /= 10 { t := n % 10 if t == 0 || num%t != 0 { return false } } return true } ans := make([]int, 0, right-left) for i := left; i \u0026lt;= right; i++ { if isSelfDividingNumber(i) { ans = append(ans, i) } } return ans } 复杂度 时间复杂度：$ O(N\\log{right}), N = right - left + 1 $ 空间复杂度：$ O(1) $ ","date":"2022-03-31T09:48:40+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-728.-%E8%87%AA%E9%99%A4%E6%95%B0/","title":"Leetcode 728. 自除数"},{"content":"链接： https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/\n难度： 中等\n题目描述 一位老师正在出一场由 n 道判断题构成的考试，每道题的答案为 true （用 'T' 表示）或者 false （用 'F' 表示）。老师想增加学生对自己做出答案的不确定性，方法是 最大化 有 连续相同 结果的题数。（也就是连续出现 true 或者连续出现 false）。\n给你一个字符串 answerKey ，其中 answerKey[i] 是第 i 个问题的正确结果。除此以外，还给你一个整数 k ，表示你能进行以下操作的最多次数：\n每次操作中，将问题的正确答案改为 'T' 或者 'F' （也就是将 answerKey[i] 改为 'T' 或者 'F' ）。 请你返回在不超过 k 次操作的情况下，最大 连续 'T' 或者 'F' 的数目。\n示例 1： 输入： answerKey = \u0026ldquo;TTFF\u0026rdquo;, k = 2\n输出： 4\n解释： 我们可以将两个 \u0026lsquo;F\u0026rsquo; 都变为 \u0026lsquo;T\u0026rsquo; ，得到 answerKey = \u0026ldquo;TTTT\u0026rdquo; 。\n总共有四个连续的 \u0026lsquo;T\u0026rsquo; 。\n示例 2： 输入： answerKey = \u0026ldquo;TFFT\u0026rdquo;, k = 1\n输出： 3\n解释： 我们可以将最前面的 \u0026lsquo;T\u0026rsquo; 换成 \u0026lsquo;F\u0026rsquo; ，得到 answerKey = \u0026ldquo;FFFT\u0026rdquo; 。\n或者，我们可以将第二个 \u0026lsquo;T\u0026rsquo; 换成 \u0026lsquo;F\u0026rsquo; ，得到 answerKey = \u0026ldquo;TFFF\u0026rdquo; 。\n两种情况下，都有三个连续的 \u0026lsquo;F\u0026rsquo; 。\n示例 3： 输入： answerKey = \u0026ldquo;TTFTTFTT\u0026rdquo;, k = 1\n输出： 5\n解释： 我们可以将第一个 \u0026lsquo;F\u0026rsquo; 换成 \u0026lsquo;T\u0026rsquo; ，得到 answerKey = \u0026ldquo;TTTTTFTT\u0026rdquo; 。\n或者我们可以将第二个 \u0026lsquo;F\u0026rsquo; 换成 \u0026lsquo;T\u0026rsquo; ，得到 answerKey = \u0026ldquo;TTFTTTTT\u0026rdquo; 。\n两种情况下，都有五个连续的 \u0026lsquo;T\u0026rsquo; 。\n提示： n == answerKey.length 1 \u0026lt;= n \u0026lt;= 5 * 104 answerKey[i] 要么是 'T' ，要么是 'F' 1 \u0026lt;= k \u0026lt;= n 解题思路 模拟 由于可更改的上限为 k，尝试将一段内的 'T' 或者 'F' 全部完成替换。\n可以使用滑动窗口，针对修改 T 和 F 分别计算：当更换数目达到上限后，左端点收缩，右端点扩展，寻找最大值。\nfunc maxConsecutiveAnswers(answerKey string, k int) int { maxConsecutiveAnswersByChar := func(char byte) int { max := 0 for l, r, remain := 0, 0, k; r \u0026lt; len(answerKey); r++ { // 需要替换 if answerKey[r] != char { // 到达上限，左端点收缩 if remain == 0 { for ; l \u0026lt;= r \u0026amp;\u0026amp; answerKey[l] == char; l++ { } l++ remain++ // 可用修改增加 } remain-- // 可用修改减少 } if max \u0026lt; r-l+1 { max = r - l + 1 } } return max } // 返回最长的 T 或 F 中更长的那一个 return func(a, b int) int { if a \u0026gt; b { return a } return b }(maxConsecutiveAnswersByChar(\u0026#39;T\u0026#39;), maxConsecutiveAnswersByChar(\u0026#39;F\u0026#39;)) } 复杂度 时间复杂度：$ O(N), N = len(answerKey) $ 空间复杂度：$ O(1) $ ","date":"2022-03-29T11:40:26+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2024.-%E8%80%83%E8%AF%95%E7%9A%84%E6%9C%80%E5%A4%A7%E5%9B%B0%E6%89%B0%E5%BA%A6/","title":"Leetcode 2024. 考试的最大困扰度"},{"content":"链接： https://leetcode-cn.com/problems/binary-number-with-alternating-bits/\n难度： 简单\n题目描述 给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。\n示例 1： 输入： n = 5\n输出： true\n解释： 5 的二进制表示是：101\n示例 2： 输入： n = 7\n输出： false\n解释： 7 的二进制表示是：111.\n示例 3： 输入： n = 11\n输出： false\n解释： 11 的二进制表示是：1011.\n提示： 1 \u0026lt;= n \u0026lt;= 231 - 1 解题思路 模拟 从最低位开始，依次检查相邻两位是否相同。\nfunc hasAlternatingBits(n int) bool { last := n \u0026amp; 1 for n \u0026gt;\u0026gt;= 1; n \u0026gt; 0; n \u0026gt;\u0026gt;= 1 { if n\u0026amp;1 == last { return false } last = n \u0026amp; 1 } return true } 复杂度 时间复杂度：$ O(\\log{n}) $ 空间复杂度：$ O(1) $ 位运算 将原数右移一位，则对应位与比其高的原数的位对齐。要求相邻的数字不同，则通过异或运算后，所有的位全部被置为 1，否则说明有相同的相邻位。\n需要检查异或结果数是否所有的位全为 1，在其基础上 +1，则：\n当各位全为 1 时，进位传递到最高位，比最高位的更高的一位变为 1，其余所有位变为 0； 当各位不全为 1 时，则进位到最低的为 0 位就会终止，更高的位保持不变。 通过与操作结果是否为 0 判断即可。\nfunc hasAlternatingBits(n int) bool { t := n ^ (n \u0026gt;\u0026gt; 1) return t\u0026amp;(t+1) == 0 } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2022-03-28T11:02:16+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-693.-%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/","title":"Leetcode 693. 交替位二进制数"},{"content":"链接： https://leetcode-cn.com/problems/find-missing-observations/\n难度： 中等\n题目描述 现有一份 n + m 次投掷单个 六面 骰子的观测数据，骰子的每个面从 1 到 6 编号。观测数据中缺失了 n 份，你手上只拿到剩余 m 次投掷的数据。幸好你有之前计算过的这 n + m 次投掷数据的 平均值 。\n给你一个长度为 m 的整数数组 rolls ，其中 rolls[i] 是第 i 次观测的值。同时给你两个整数 mean 和 n 。\n返回一个长度为 n 的数组，包含所有缺失的观测数据，且满足这 n + m 次投掷的 平均值 是 mean 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。\nk 个数字的 平均值 为这些数字求和后再除以 k 。\n注意 mean 是一个整数，所以 n + m 次投掷的总和需要被 n + m 整除。\n示例 1： 输入： rolls = [3,2,4,3], mean = 4, n = 2\n输出： [6,6]\n解释： 所有 n + m 次投掷的平均值是 (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4 。\n示例 2： 输入： rolls = [1,5,6], mean = 3, n = 4\n输出： [2,3,2,2]\n解释： 所有 n + m 次投掷的平均值是 (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3 。\n示例 3： 输入： rolls = [1,2,3,4], mean = 6, n = 4\n输出： []\n解释： 无论丢失的 4 次数据是什么，平均值都不可能是 6 。\n示例 4： 输入： rolls = [1], mean = 3, n = 1\n输出： [5]\n解释： 所有 n + m 次投掷的平均值是 (1 + 5) / 2 = 3 。\n提示： m == rolls.length 1 \u0026lt;= n, m \u0026lt;= 105 1 \u0026lt;= rolls[i], mean \u0026lt;= 6 解题思路 根据题设可知 n + m 个骰子的点数平均值为需要是 mean * (n + m) ，目前已知 m 个骰子的和，则可求得剩余 n 个骰子的点数和。\n因为每个骰子的点数和为 1 ~ 6，故当点数和 \u0026lt; n 或 \u0026gt; 6n 时，不存在答案；否则，尝试将点数均匀的分配到每个骰子，没法均匀分配时，将多余出来的点数均匀加到其中的几个骰子上。\nfunc missingRolls(rolls []int, mean int, n int) []int { sum := 0 for _, r := range rolls { sum += r } sum = mean*(n+len(rolls)) - sum // 没有答案 if sum \u0026lt; n || sum \u0026gt; 6*n { return nil } point := sum / n // 平均点数 more := sum % n // 多余点数 ans := make([]int, n) for i := range ans { ans[i] = point // 多余点数均匀分配 if more \u0026gt; 0 { ans[i]++ more-- } } return ans } 复杂度 时间复杂度：$ O(n+m) $ 空间复杂度：$ O(1) $ ","date":"2022-03-27T11:20:26+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2028.-%E6%89%BE%E5%87%BA%E7%BC%BA%E5%A4%B1%E7%9A%84%E8%A7%82%E6%B5%8B%E6%95%B0%E6%8D%AE/","title":"Leetcode 2028. 找出缺失的观测数据"},{"content":"链接： https://leetcode-cn.com/problems/baseball-game/\n难度： 简单\n题目描述 你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。\n比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：\n整数 x - 表示本回合新获得分数 x \u0026quot;+\u0026quot; - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。 \u0026quot;D\u0026quot; - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。 \u0026quot;C\u0026quot; - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。 请你返回记录中所有得分的总和。\n示例 1： 输入： ops = [\u0026ldquo;5\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;D\u0026rdquo;,\u0026quot;+\u0026quot;]\n输出： 30\n解释：\n\u0026ldquo;5\u0026rdquo; - 记录加 5 ，记录现在是 [5]\n\u0026ldquo;2\u0026rdquo; - 记录加 2 ，记录现在是 [5, 2]\n\u0026ldquo;C\u0026rdquo; - 使前一次得分的记录无效并将其移除，记录现在是 [5].\n\u0026ldquo;D\u0026rdquo; - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].\n\u0026ldquo;+\u0026rdquo; - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].\n所有得分的总和 5 + 10 + 15 = 30\n示例 2： 输入： ops = [\u0026ldquo;5\u0026rdquo;,\u0026quot;-2\u0026quot;,\u0026ldquo;4\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;D\u0026rdquo;,\u0026ldquo;9\u0026rdquo;,\u0026quot;+\u0026quot;,\u0026quot;+\u0026quot;]\n输出： 27\n解释：\n\u0026ldquo;5\u0026rdquo; - 记录加 5 ，记录现在是 [5]\n\u0026ldquo;-2\u0026rdquo; - 记录加 -2 ，记录现在是 [5, -2]\n\u0026ldquo;4\u0026rdquo; - 记录加 4 ，记录现在是 [5, -2, 4]\n\u0026ldquo;C\u0026rdquo; - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]\n\u0026ldquo;D\u0026rdquo; - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]\n\u0026ldquo;9\u0026rdquo; - 记录加 9 ，记录现在是 [5, -2, -4, 9]\n\u0026ldquo;+\u0026rdquo; - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]\n\u0026ldquo;+\u0026rdquo; - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]\n所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27\n示例 3： 输入： ops = [\u0026ldquo;1\u0026rdquo;]\n输出： 1\n提示： 1 \u0026lt;= ops.length \u0026lt;= 1000 ops[i] 为 \u0026quot;C\u0026quot;、\u0026quot;D\u0026quot;、\u0026quot;+\u0026quot;，或者一个表示整数的字符串。整数范围是 [-3 * 104, 3 * 104] 对于 \u0026quot;+\u0026quot; 操作，题目数据保证记录此操作时前面总是存在两个有效的分数 对于 \u0026quot;C\u0026quot; 和 \u0026quot;D\u0026quot; 操作，题目数据保证记录此操作时前面总是存在一个有效的分数 解题思路 栈 通过使用栈来记录所有有效的记录，每次按照操作要求进行模拟，记录有效的得分或移除无效的得分，将栈中数据累加即可。\nfunc calPoints(ops []string) int { sum := 0 stack := make([]int, 0, len(ops)) for _, op := range ops { num := 0 switch op { case \u0026#34;C\u0026#34;: sum -= stack[len(stack)-1] // 上一个数从和中去除 stack = stack[:len(stack)-1] // 撤销上一个 continue case \u0026#34;+\u0026#34;: num = stack[len(stack)-1] + stack[len(stack)-2] case \u0026#34;D\u0026#34;: num = stack[len(stack)-1] \u0026lt;\u0026lt; 1 default: num, _ = strconv.Atoi(op) } sum += num // 求和 stack = append(stack, num) // 入栈 } return sum } 复杂度 时间复杂度：$ O(N), N = len(ops) $ 空间复杂度：$ O(N) $ ","date":"2022-03-26T10:48:13+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-682.-%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/","title":"Leetcode 682. 棒球比赛"},{"content":"链接： https://leetcode-cn.com/problems/factorial-trailing-zeroes/\n难度： 中等\n题目描述 给定一个整数 n ，返回 n! 结果中尾随零的数量。\n提示 n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1\n示例 1： 输入： n = 3\n输出： 0\n解释： 3! = 6 ，不含尾随 0\n示例 2： 输入： n = 5\n输出： 1\n解释： 5! = 120 ，有一个尾随 0\n示例 3： 输入： n = 0\n输出： 0\n提示： 0 \u0026lt;= n \u0026lt;= 104 进阶： 你可以设计并实现对数时间复杂度的算法来解决此问题吗？\n解题思路 数学 唯一可能在结尾出现0的情况是 2 * 5，所以需要统计所有阶乘因数中因子 2 和 5 的数量。\n由于阶乘中 2 的数量一定是比 5 的数量多的，只需要统计 5 的数量，即为结尾零的数量。\nfunc trailingZeroes(n int) int { ans := 0 for i := 5; i \u0026lt;= n; i += 5 { t := i for t%5 == 0 { ans++ t /= 5 } } return ans } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ 优化 对于阶乘因数中含有因子 5 的因数数量，通过简单的除法运算即可求得 n / 5。\n单部分因数中可能含有多个因子 5 ，还需要统计这一部分。例如含有因子 25 会包含两个因子 5，125 含有3个，同理进行统计，只记录多出来的这部分即可。\nfunc trailingZeroes(n int) int { ans := 0 for i := 5; i \u0026lt;= n; i *= 5 { ans += n / i } return ans } 复杂度 时间复杂度：$ O(\\log{n}) $ 空间复杂度：$ O(1) $ ","date":"2022-03-25T10:13:24+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-172.-%E9%98%B6%E4%B9%98%E5%90%8E%E7%9A%84%E9%9B%B6/","title":"Leetcode 172. 阶乘后的零"},{"content":"链接： https://leetcode-cn.com/problems/image-smoother/\n难度： 简单\n题目描述 图像平滑器 是大小为 3 x 3 的过滤器，用于对图像的每个单元格平滑处理，平滑处理后单元格的值为该单元格的平均灰度。\n每个单元格的 平均灰度 定义为：该单元格自身及其周围的 8 个单元格的平均值，结果需向下取整。（即，需要计算蓝色平滑器中 9 个单元格的平均值）。\n如果一个单元格周围存在单元格缺失的情况，则计算平均灰度时不考虑缺失的单元格（即，需要计算红色平滑器中 4 个单元格的平均值）。\n给你一个表示图像灰度的 m x n 整数矩阵 img ，返回对图像的每个单元格平滑处理后的图像 。\n示例 1： 输入： img = [[1,1,1],[1,0,1],[1,1,1]]\n输出： [[0, 0, 0],[0, 0, 0], [0, 0, 0]]\n解释：\n对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0\n对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0\n对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0\n示例 2： 输入： img = [[100,200,100],[200,50,200],[100,200,100]]\n输出： [[137,141,137],[141,138,141],[137,141,137]]\n解释：\n对于点 (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\n对于点 (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\n对于点 (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138\n提示： m == img.length n == img[i].length 1 \u0026lt;= m, n \u0026lt;= 200 0 \u0026lt;= img[i][j] \u0026lt;= 255 解题思路 模拟 按照题设方式，求解新矩阵。\nfunc imageSmoother(img [][]int) [][]int { ans := make([][]int, len(img)) for row, line := range img { ans[row] = make([]int, len(line)) for col := range line { sum := 0 // 求和 cnt := 0 // 单元格数量 // 自身\u0026amp;周围单元格求和 for i := row - 1; i \u0026lt;= row+1; i++ { for j := col - 1; j \u0026lt;= col+1; j++ { if i \u0026lt; 0 || i \u0026gt;= len(img) || j \u0026lt; 0 || j \u0026gt;= len(line) { continue } sum += img[i][j] cnt++ } } ans[row][col] = sum / cnt // 平均值 } } return ans } 复杂度 时间复杂度：$ O(mnC^2), C表示灰度计算涉及的子矩阵边长，本题中为3 $ 空间复杂度：$ O(1) $ ","date":"2022-03-24T10:53:11+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-661.-%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8/","title":"Leetcode 661. 图片平滑器"},{"content":"链接： https://leetcode-cn.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/\n难度： 中等\n题目描述 总共有 n 个颜色片段排成一列，每个颜色片段要么是 'A' 要么是 'B' 。给你一个长度为 n 的字符串 colors ，其中 colors[i] 表示第 i 个颜色片段的颜色。\nAlice 和 Bob 在玩一个游戏，他们 轮流 从这个字符串中删除颜色。Alice 先手 。\n如果一个颜色片段为 'A' 且 相邻两个颜色 都是颜色 'A' ，那么 Alice 可以删除该颜色片段。Alice 不可以 删除任何颜色 'B' 片段。 如果一个颜色片段为 'B' 且 相邻两个颜色 都是颜色 'B' ，那么 Bob 可以删除该颜色片段。Bob 不可以 删除任何颜色 'A' 片段。 Alice 和 Bob 不能 从字符串两端删除颜色片段。 如果其中一人无法继续操作，则该玩家 输 掉游戏且另一玩家 获胜 。 假设 Alice 和 Bob 都采用最优策略，如果 Alice 获胜，请返回 true，否则 Bob 获胜，返回 false。\n示例 1： 输入： colors = \u0026ldquo;AAABABB\u0026rdquo;\n输出： true\n解释：\nAAABABB -\u0026gt; AABABB\nAlice 先操作。\n她删除从左数第二个 \u0026lsquo;A\u0026rsquo; ，这也是唯一一个相邻颜色片段都是 \u0026lsquo;A\u0026rsquo; 的 \u0026lsquo;A\u0026rsquo; 。\n现在轮到 Bob 操作。\nBob 无法执行任何操作，因为没有相邻位置都是 \u0026lsquo;B\u0026rsquo; 的颜色片段 \u0026lsquo;B\u0026rsquo; 。\n因此，Alice 获胜，返回 true 。\n示例 2: 输入： colors = \u0026ldquo;AA\u0026rdquo;\n输出： false\n解释：\nAlice 先操作。\n只有 2 个 \u0026lsquo;A\u0026rsquo; 且它们都在字符串的两端，所以她无法执行任何操作。\n因此，Bob 获胜，返回 false 。\n示例 3： 输入： colors = \u0026ldquo;ABBBBBBBAAA\u0026rdquo;\n输出： false\n解释：\nABBBBBBBAAA -\u0026gt; ABBBBBBBAA\nAlice 先操作。\n她唯一的选择是删除从右数起第二个 \u0026lsquo;A\u0026rsquo; 。\nABBBBBBBAA -\u0026gt; ABBBBBBAA\n接下来轮到 Bob 操作。\n他有许多选择，他可以选择任何一个 \u0026lsquo;B\u0026rsquo; 删除。\n然后轮到 Alice 操作，她无法删除任何片段。\n所以 Bob 获胜，返回 false 。\n提示： 1 \u0026lt;= colors.length \u0026lt;= 105 colors 只包含字母 'A' 和 'B' 解题思路 模拟 由于 Alice 和 Bob 的操作互不影响，故统计 Alice 和 Bob 可以操作的最大次数。\n当 Alice 操作的最大次数大于 Bob 时，ALice获胜；否则，Bob 获胜。\nfunc winnerOfGame(colors string) bool { a, b := 0, 0 last := byte(\u0026#39;0\u0026#39;) cnt := 0 for i := range colors { // 连续相同字母，数量 +1 if colors[i] == last { cnt++ } // 不到末尾或相同字母结尾，继续遍历 if i \u0026lt; len(colors)-1 \u0026amp;\u0026amp; colors[i] == last { continue } // 连续相同字母结束，统计可操作数量，数量需大于2 if cnt \u0026gt; 2 { if last == \u0026#39;A\u0026#39; { a += cnt - 2 } else { b += cnt - 2 } } // 重新统计 last = colors[i] cnt = 1 } return a \u0026gt; b } 复杂度 时间复杂度：$ O(N), N = len(colors) $ 空间复杂度：$ O(1) $ ","date":"2022-03-22T10:48:43+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2038.-%E5%A6%82%E6%9E%9C%E7%9B%B8%E9%82%BB%E4%B8%A4%E4%B8%AA%E9%A2%9C%E8%89%B2%E5%9D%87%E7%9B%B8%E5%90%8C%E5%88%99%E5%88%A0%E9%99%A4%E5%BD%93%E5%89%8D%E9%A2%9C%E8%89%B2/","title":"Leetcode 2038. 如果相邻两个颜色均相同则删除当前颜色"},{"content":"链接： https://leetcode-cn.com/problems/2-keys-keyboard/\n难度： 中等\n题目描述 给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。\n示例 1： 输入： root = [5,3,6,2,4,null,7], k = 9\n输出： true\n示例 2： 输入： root = [5,3,6,2,4,null,7], k = 28\n输出： false\n提示： 二叉树的节点个数的范围是 [1, 104]. -104 \u0026lt;= Node.val \u0026lt;= 104 root 为二叉搜索树 -105 \u0026lt;= k \u0026lt;= 105 解题思路 先序遍历 + 哈希 采用先序遍历遍历整颗树，将之前遍历到的所有数记录到哈希表中。\n对于每个新遍历到的数字，在哈希表中寻找令其和为 k 的数。\nfunc findTarget(root *TreeNode, k int) bool { exist := make(map[int]struct{}) var dfs func(*TreeNode) bool dfs = func(node *TreeNode) bool { if node == nil { return false } if _, ok := exist[k-node.Val]; ok { return true } exist[node.Val] = struct{}{} return dfs(node.Left) || dfs(node.Right) } return dfs(root) } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(N) $ 二分查找 遍历整颗树，使用二分查找寻找对应的另一个数。\nfunc findTarget(root *TreeNode, k int) bool { binSearch := func(num int) bool { for node := root; node != nil; { if num == node.Val { return true } else if num \u0026lt; node.Val { node = node.Left } else { node = node.Right } } return false } var dfs func(*TreeNode) bool dfs = func(node *TreeNode) bool { if node == nil { return false } if k-node.Val != node.Val \u0026amp;\u0026amp; binSearch(k-node.Val) { return true } return dfs(node.Left) || dfs(node.Right) } return dfs(root) } 复杂度 时间复杂度：$ O(N\\log{N}), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-03-21T10:22:46+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-653.-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-iv-%E8%BE%93%E5%85%A5-bst/","title":"Leetcode 653. 两数之和 IV - 输入 BST"},{"content":"链接： https://leetcode-cn.com/problems/stock-price-fluctuation/\n难度： 中等\n题目描述 给你一个有 n 个服务器的计算机网络，服务器编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示服务器 ui 和 vi 之间有一条信息线路，在 一秒 内它们之间可以传输 任意 数目的信息。再给你一个长度为 n 且下标从 0 开始的整数数组 patience 。\n题目保证所有服务器都是 相通 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。\n编号为 0 的服务器是 主 服务器，其他服务器为 数据 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 最优 线路传输，也就是说每个信息都会以 最少时间 到达主服务器。主服务器会处理 所有 新到达的信息并 立即 按照每条信息来时的路线 反方向 发送回复信息。\n在 0 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 1 秒开始，每 一秒最 开始 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：\n如果还没收到任何回复信息，那么该服务器会周期性 重发 信息。数据服务器 i 每 patience[i] 秒都会重发一条信息，也就是说，数据服务器 i 在上一次发送信息给主服务器后的 patience[i] 秒 后 会重发一条信息给主服务器。 否则，该数据服务器 不会重发 信息。 当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 空闲 状态。\n请返回计算机网络变为 空闲 状态的 最早秒数 。\n示例： **输入：**edges = [[0,1],[1,2]], patience = [0,2,1]\n**输出：**8\n解释：\n0 秒最开始时，\n数据服务器 1 给主服务器发出信息（用 1A 表示）。 数据服务器 2 给主服务器发出信息（用 2A 表示）。 1 秒时，\n信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 \u0026lt; patience[1] = 2），所以不会重发信息。 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。 2 秒时，\n回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。 服务器 2 重发一条信息（用 2C 表示）。\n\u0026hellip; 4 秒时，\n回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。\n\u0026hellip; 7 秒时，回复信息 2D 到达服务器 2 。\n从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。\n所以第 8 秒是网络变空闲的最早时刻。\n示例 2： 输入： edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]\n输出： 3\n解释： 数据服务器 1 和 2 第 2 秒初收到回复信息。\n从第 3 秒开始，网络变空闲。\n提示： n == patience.length 2 \u0026lt;= n \u0026lt;= 105 patience[0] == 0 对于 1 \u0026lt;= i \u0026lt; n ，满足 1 \u0026lt;= patience[i] \u0026lt;= 105 1 \u0026lt;= edges.length \u0026lt;= min(105, n * (n - 1) / 2) edges[i].length == 2 0 \u0026lt;= ui, vi \u0026lt; n ui != vi 不会有重边。 每个服务器都直接或间接与别的服务器相连。 解题思路 广度优先搜索 由于是等权图，可使用广度优先算法求的 数据 服务器到 主 服务器到最短路径。\n路径长度的两倍即为当前 数据 服务器接收到回复的时间。在此期间若有重发消息，则以最后一次重发并接受的恢复的时间修正。这样求得当前 数据 服务器空闲的时间。\n找出所有 数据 服务器均空闲的最大时间，再过一秒网络到变为 空闲 状态。\nfunc networkBecomesIdle(edges [][]int, patience []int) int { // 构造邻接链表 next := make([][]int, len(patience)) for _, edge := range edges { next[edge[0]] = append(next[edge[0]], edge[1]) next[edge[1]] = append(next[edge[1]], edge[0]) } minTime := make([]int, len(patience)) // 记录最短时间 visit := make([]bool, len(patience)) queue := list.New() queue.PushBack(0) visit[0] = true for time := 0; queue.Len() \u0026gt; 0; time++ { // 同一时间到达 for i := queue.Len(); i \u0026gt; 0; i-- { cur := queue.Remove(queue.Front()).(int) minTime[cur] = time // 记录最短时间 // 遍历下个结点 for _, n := range next[cur] { if !visit[n] { queue.PushBack(n) visit[n] = true } } } } ans := 0 for i, m := range minTime { t := m \u0026lt;\u0026lt; 1 // 有重发消息，接收到最后一次消息后空闲 if patience[i] \u0026lt; (m \u0026lt;\u0026lt; 1) { t = (m \u0026lt;\u0026lt; 1) + (m\u0026lt;\u0026lt;1-1)/patience[i]*patience[i] } if ans \u0026lt; t { ans = t } } return ans + 1 } 复杂度 时间复杂度：$ O(n+E), E = len(edges) $ 空间复杂度：$ O(n+E) $ ","date":"2022-03-20T10:47:12+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2039.-%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B2%E7%9A%84%E6%97%B6%E5%88%BB/","title":"Leetcode 2039. 网络空闲的时刻"},{"content":"链接： https://leetcode-cn.com/problems/construct-string-from-binary-tree/\n难度： 简单\n题目描述 你需要采用前序遍历的方式，将一个二叉树转换成一个由括号和整数组成的字符串。\n空节点则用一对空括号 \u0026ldquo;()\u0026rdquo; 表示。而且你需要省略所有不影响字符串与原始二叉树之间的一对一映射关系的空括号对。\n示例 1： 输入： 二叉树: [1,2,3,4]\n1\n/ \\\n2 3\n/ 4\n输出： \u0026ldquo;1(2(4))(3)\u0026rdquo;\n解释： 原本将是“1(2(4)())(3())”，\n在你省略所有不必要的空括号对之后，\n它将是“1(2(4))(3)”。\n示例 2： 输入： 二叉树: [1,2,3,null,4]\n1\n/ \\\n2 3\n\\\n4\n输出： \u0026ldquo;1(2()(4))(3)\u0026rdquo;\n解释： 和第一个示例相似，\n除了我们不能省略第一个对括号来中断输入和输出之间的一对一映射关系。\n解题思路 先序遍历 采用先序遍历遍历整棵树。对于遍历到的结点而言，当遍历子树时，需要在两侧加上括号，有如下两种情况：\n当任意子树不为空时，左子树遍历结果必然需要加上括号； 仅当右子树不为空时，右子树需要加括号，否则会产生无效的空括号对。 func tree2str(root *TreeNode) string { ans := make([]byte, 0, 10) var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } ans = append(ans, strconv.Itoa(node.Val)...) if node.Left != nil || node.Right != nil { ans = append(ans, \u0026#39;(\u0026#39;) dfs(node.Left) ans = append(ans, \u0026#39;)\u0026#39;) } if node.Right != nil { ans = append(ans, \u0026#39;(\u0026#39;) dfs(node.Right) ans = append(ans, \u0026#39;)\u0026#39;) } } dfs(root) return string(ans) } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-03-19T10:59:32+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-606.-%E6%A0%B9%E6%8D%AE%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 606. 根据二叉树创建字符串"},{"content":"链接： https://leetcode-cn.com/problems/simple-bank-system/\n难度： 中等\n题目描述 你的任务是为一个很受欢迎的银行设计一款程序，以自动化执行所有传入的交易（转账，存款和取款）。银行共有 n 个账户，编号从 1 到 n 。每个账号的初始余额存储在一个下标从 0 开始的整数数组 balance 中，其中第 (i + 1) 个账户的初始余额是 balance[i] 。\n请你执行所有 有效的 交易。如果满足下面全部条件，则交易 有效 ：\n指定的账户数量在 1 和 n 之间，且 取款或者转账需要的钱的总数 小于或者等于 账户余额。 实现 Bank 类：\nBank(long[] balance) 使用下标从 0 开始的整数数组 balance 初始化该对象。 boolean transfer(int account1, int account2, long money) 从编号为 account1 的账户向编号为 account2 的账户转帐 money 美元。如果交易成功，返回 true ，否则，返回 false 。 boolean deposit(int account, long money) 向编号为 account 的账户存款 money 美元。如果交易成功，返回 true ；否则，返回 false 。 boolean withdraw(int account, long money) 从编号为 account 的账户取款 money 美元。如果交易成功，返回 true ；否则，返回 false 。 示例： 输入：\n[\u0026ldquo;Bank\u0026rdquo;, \u0026ldquo;withdraw\u0026rdquo;, \u0026ldquo;transfer\u0026rdquo;, \u0026ldquo;deposit\u0026rdquo;, \u0026ldquo;transfer\u0026rdquo;, \u0026ldquo;withdraw\u0026rdquo;]\n[[[10, 100, 20, 50, 30]], [3, 10], [5, 1, 20], [5, 20], [3, 4, 15], [10, 50]]\n输出：\n[null, true, true, true, false, false]\n解释：\nBank bank = new Bank([10, 100, 20, 50, 30]);\nbank.withdraw(3, 10); // 返回 true ，账户 3 的余额是 $20 ，所以可以取款 $10 。\n// 账户 3 余额为 $20 - $10 = $10 。\nbank.transfer(5, 1, 20); // 返回 true ，账户 5 的余额是 $30 ，所以可以转账 $20 。\n// 账户 5 的余额为 $30 - $20 = $10 ，账户 1 的余额为 $10 + $20 = $30 。\nbank.deposit(5, 20); // 返回 true ，可以向账户 5 存款 $20 。\n// 账户 5 的余额为 $10 + $20 = $30 。\nbank.transfer(3, 4, 15); // 返回 false ，账户 3 的当前余额是 $10 。\n// 所以无法转账 $15 。\nbank.withdraw(10, 50); // 返回 false ，交易无效，因为账户 10 并不存在。\n提示： n == balance.length 1 \u0026lt;= n, account, account1, account2 \u0026lt;= 105 0 \u0026lt;= balance[i], money \u0026lt;= 1012 transfer, deposit, withdraw 三个函数，每个 最多调用 104 次 解题思路 模拟 按照题设要求，模拟实现即可。\ntype Bank struct { balance []int64 } func Constructor(balance []int64) Bank { return Bank{ balance: balance, } } func (this *Bank) Transfer(account1 int, account2 int, money int64) bool { // 账户不存在或余额不足，返回失败 if account1 \u0026gt; len(this.balance) || account2 \u0026gt; len(this.balance) || this.balance[account1-1] \u0026lt; money { return false } this.balance[account1-1] -= money this.balance[account2-1] += money return true } func (this *Bank) Deposit(account int, money int64) bool { // 账户不存在，返回失败 if account \u0026gt; len(this.balance) { return false } this.balance[account-1] += money return true } func (this *Bank) Withdraw(account int, money int64) bool { // 账户不存在或余额不足，返回失败 if account \u0026gt; len(this.balance) || this.balance[account-1] \u0026lt; money { return false } this.balance[account-1] -= money return true } 复杂度 时间复杂度： constructor：$ O(1) $ transfer：$ O(1) $ deposit：$ O(1) $ withdraw：$ O(1) $ 空间复杂度：$ O(N), N = len(balance) $ ","date":"2022-03-18T10:31:34+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2043.-%E7%AE%80%E6%98%93%E9%93%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F/","title":"Leetcode 2043. 简易银行系统"},{"content":"链接： https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/\n难度： 简单\n题目描述 给出一个字符串数组 words 组成的一本英语词典。返回 words 中最长的一个单词，该单词是由 words 词典中其他单词逐步添加一个字母组成。\n若其中有多个可行的答案，则返回答案中字典序最小的单词。若无答案，则返回空字符串。\n示例 1： 输入： words = [\u0026ldquo;w\u0026rdquo;,\u0026ldquo;wo\u0026rdquo;,\u0026ldquo;wor\u0026rdquo;,\u0026ldquo;worl\u0026rdquo;, \u0026ldquo;world\u0026rdquo;]\n输出： \u0026ldquo;world\u0026rdquo;\n解释： 单词\u0026quot;world\u0026quot;可由\u0026quot;w\u0026quot;, \u0026ldquo;wo\u0026rdquo;, \u0026ldquo;wor\u0026rdquo;, 和 \u0026ldquo;worl\u0026quot;逐步添加一个字母组成。\n示例 2： 输入： words = [\u0026ldquo;a\u0026rdquo;, \u0026ldquo;banana\u0026rdquo;, \u0026ldquo;app\u0026rdquo;, \u0026ldquo;appl\u0026rdquo;, \u0026ldquo;ap\u0026rdquo;, \u0026ldquo;apply\u0026rdquo;, \u0026ldquo;apple\u0026rdquo;]\n输出： \u0026ldquo;apple\u0026rdquo;\n解释： \u0026ldquo;apply\u0026rdquo; 和 \u0026ldquo;apple\u0026rdquo; 都能由词典中的单词组成。但是 \u0026ldquo;apple\u0026rdquo; 的字典序小于 \u0026ldquo;apply\u0026rdquo;\n提示： 1 \u0026lt;= words.length \u0026lt;= 1000 1 \u0026lt;= words[i].length \u0026lt;= 30 所有输入的字符串 words[i] 都只包含小写字母。 解题思路 排序+哈希 对字符串数组按照长度进行一轮排序，然后进行遍历，可以保证前缀先进行遍历。\n将遍历过的满足条件的字符串加入到哈希表中，每次遍历查看前缀是否在哈希表中，若满足条件也将起加入到哈希表中。\n遍历过程中维护最长且字典序最小的字符串。\nfunc longestWord(words []string) string { sort.Slice(words, func(i, j int) bool { return words[i] \u0026lt; words[j] }) exist := map[string]struct{}{ \u0026#34;\u0026#34;: {}, } ans := \u0026#34;\u0026#34; for _, word := range words { if _, ok := exist[word[:len(word)-1]]; !ok { continue } if len(ans) \u0026lt; len(word) || (len(ans) == len(word) \u0026amp;\u0026amp; ans \u0026gt; word) { ans = word } exist[word] = struct{}{} } return ans } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(words[i]) $ 空间复杂度：$ O(N) $ ","date":"2022-03-17T09:59:59+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-720.-%E8%AF%8D%E5%85%B8%E4%B8%AD%E6%9C%80%E9%95%BF%E7%9A%84%E5%8D%95%E8%AF%8D/","title":"Leetcode 720. 词典中最长的单词"},{"content":"链接： https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/\n难度： 中等\n题目描述 给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。\n如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。\n对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR \u0026hellip; OR a[a.length - 1]（下标从 0 开始）。\n示例 1： 输入： nums = [3,1]\n输出： 2\n解释： 子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：\n[3] [3,1] 示例 2： 输入： nums = [2,2,2]\n输出： 7\n解释： [2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。\n示例 3： 输入： nums = [3,2,1,5]\n输出： 6\n解释： 子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：\n[3,5] [3,1,5] [3,2,5] [3,2,1,5] [2,5] [2,1,5] 提示： 1 \u0026lt;= nums.length \u0026lt;= 16 1 \u0026lt;= nums[i] \u0026lt;= 105 解题思路 枚举 利用位来枚举出所有子集，计算最大值，同时统计满足条件的子集数目。\nfunc countMaxOrSubsets(nums []int) int { max := 0 cnt := 0 for bits := (1 \u0026lt;\u0026lt; len(nums)) - 1; bits \u0026gt; 0; bits-- { or := 0 for i := 0; i \u0026lt; len(nums); i++ { if bits\u0026amp;(1\u0026lt;\u0026lt;i) != 0 { or |= nums[i] } } if max \u0026lt; or { max = or cnt = 1 } else if max == or { cnt++ } } return cnt } 复杂度 时间复杂度：$ O(2^N*N), N = len(nums) $ 空间复杂度：$ O(1) $ 回溯 对于数组的子集，每个元素都有存在和不存在两种情况，按照此方式进行回溯，找出所有可能的子集。\n对于每个子集，判定其是否为最大值，同时统计满足条件的子集数目。\nfunc countMaxOrSubsets(nums []int) int { max := 0 cnt := 0 var dfs func(i int, or int) dfs = func(i int, or int) { // 子集筛选完毕，判定最大值 if i \u0026gt;= len(nums) { if max \u0026lt; or { max = or cnt = 1 } else if or == max { cnt++ } return } dfs(i+1, or) // 当前元素不在子集中 dfs(i+1, or|nums[i]) // 当前元素位于子集中 } dfs(0, 0) return cnt } 复杂度 时间复杂度：$ O(2^N), N = len(nums) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-03-15T10:55:01+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2044.-%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/","title":"Leetcode 2044. 统计按位或能得到最大值的子集数目"},{"content":"链接： https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/\n难度： 简单\n题目描述 假设 Andy 和 Doris 想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。\n你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设答案总是存在。\n示例 1： 输入： list1 = [\u0026ldquo;Shogun\u0026rdquo;, \u0026ldquo;Tapioca Express\u0026rdquo;, \u0026ldquo;Burger King\u0026rdquo;, \u0026ldquo;KFC\u0026rdquo;]，list2 = [\u0026ldquo;Piatti\u0026rdquo;, \u0026ldquo;The Grill at Torrey Pines\u0026rdquo;, \u0026ldquo;Hungry Hunter Steakhouse\u0026rdquo;, \u0026ldquo;Shogun\u0026rdquo;]\n输出： [\u0026ldquo;Shogun\u0026rdquo;]\n解释： 他们唯一共同喜爱的餐厅是“Shogun”。\n示例 2： 输入： list1 = [\u0026ldquo;Shogun\u0026rdquo;, \u0026ldquo;Tapioca Express\u0026rdquo;, \u0026ldquo;Burger King\u0026rdquo;, \u0026ldquo;KFC\u0026rdquo;]，list2 = [\u0026ldquo;KFC\u0026rdquo;, \u0026ldquo;Shogun\u0026rdquo;, \u0026ldquo;Burger King\u0026rdquo;]\n输出： [\u0026ldquo;Shogun\u0026rdquo;]\n解释： 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。\n注意： 1 \u0026lt;= list1.length, list2.length \u0026lt;= 1000 1 \u0026lt;= list1[i].length, list2[i].length \u0026lt;= 30 list1[i] 和 list2[i] 由空格 ' ' 和英文字母组成。 list1 的所有字符串都是 唯一 的。 list2 中的所有字符串都是 唯一 的。 解题思路 暴力求解 两层循环暴力寻找两个人都喜爱的餐厅，然后找出所有下标和最小的餐厅。\nfunc findRestaurant(list1 []string, list2 []string) []string { sum := math.MaxInt ans := make([]string, 0) for i, l1 := range list1 { for j, l2 := range list2 { if l1 == l2 { if sum \u0026gt; i+j { sum = i + j ans = []string{l1} } else if sum == i+j { ans = append(ans, l1) } } } } return ans } 复杂度 时间复杂度：$ O(N_1N_2), N_1 = \\sum{len(list1[i])}, N_2 = \\sum{len(list2[i])} $ 空间复杂度：$ O(1) $ 哈希 使用哈希表记录Andy喜爱餐厅的下标，然后遍历Doris的餐厅，寻找相同并且下标和最小的值。\nfunc findRestaurant(list1 []string, list2 []string) []string { idx := make(map[string]int) for i, l := range list1 { idx[l] = i } sum := math.MaxInt ans := make([]string, 0) for i, l := range list2 { if _, ok := idx[l]; ok { if sum \u0026gt; idx[l]+i { sum = idx[l] + i ans = []string{l} } else if sum == idx[l]+i { ans = append(ans, l) } } } return ans } 复杂度 时间复杂度：$ O(N_1+N_2), N_1 = \\sum{len(list1[i])}, N_2 = \\sum{len(list2[i])} $ 空间复杂度：$ O(N_1) $ ","date":"2022-03-14T10:36:50+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-599.-%E4%B8%A4%E4%B8%AA%E5%88%97%E8%A1%A8%E7%9A%84%E6%9C%80%E5%B0%8F%E7%B4%A2%E5%BC%95%E6%80%BB%E5%92%8C/","title":"Leetcode 599. 两个列表的最小索引总和"},{"content":"链接： https://leetcode-cn.com/problems/utf-8-validation/\n难度： 中等\n题目描述 给定一个表示数据的整数数组 data ，返回它是否为有效的 UTF-8 编码。\nUTF-8 中的一个字符可能的长度为 1 到 4 字节，遵循以下的规则：\n对于 1 字节 的字符，字节的第一位设为 0 ，后面 7 位为这个符号的 unicode 码。 对于 n 字节 的字符 (n \u0026gt; 1)，第一个字节的前 n 位都设为1，第 n+1 位设为 0 ，后面字节的前两位一律设为 10 。剩下的没有提及的二进制位，全部为这个符号的 unicode 码。 这是 UTF-8 编码的工作方式：\nChar. number range | UTF-8 octet sequence (hexadecimal) | (binary) --------------------+--------------------------------------------- 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 注意： 输入是整数数组。只有每个整数的 最低 8 个有效位 用来存储数据。这意味着每个整数只表示 1 字节的数据。\n示例 1： 输入： data = [197,130,1]\n输出： true\n解释： 数据表示字节序列:11000101 10000010 00000001。\n这是有效的 utf-8 编码，为一个 2 字节字符，跟着一个 1 字节字符。\n示例 2： 输入： data = [235,140,4]\n输出： false\n解释： 数据表示 8 位的序列: 11101011 10001100 00000100.\n前 3 位都是 1 ，第 4 位为 0 表示它是一个 3 字节字符。\n下一个字节是开头为 10 的延续字节，这是正确的。\n但第二个延续字节不以 10 开头，所以是不符合规则的。\n提示： 1 \u0026lt;= data.length \u0026lt;= 2 * 104 0 \u0026lt;= data[i] \u0026lt;= 255 解题思路 模拟 根据首个字符开头连续 1 的数量来确认编码长度，后续字符均必须以 10 开头。\nfunc validUtf8(data []int) bool { for i := 0; i \u0026lt; len(data); { ones := 0 // 统计开头连续 1 的数量 for mask := 0b10000000; mask \u0026gt;= 0b00001000; mask \u0026gt;\u0026gt;= 1 { if data[i]\u0026amp;mask == 0 { break } ones++ } length := ones switch ones { case 0: // 数量为0，长度为1 length = 1 case 1, 5: // 数量为 1 或 5，无效编码 return false } // 后续字符数量不够 if i+length \u0026gt; len(data) { return false } // 后续 length-1 个字符需以 10 开头 for j := 1; j \u0026lt; length; j++ { if data[i+j]\u0026amp;0xC0 != 0x80 { return false } } i += length } return true } 复杂度 时间复杂度：$ O(N), N = len(data) $ 空间复杂度：$ O(1) $ ","date":"2022-03-13T09:56:52+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-393.-utf-8-%E7%BC%96%E7%A0%81%E9%AA%8C%E8%AF%81/","title":"Leetcode 393. UTF-8 编码验证"},{"content":"链接： https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/\n难度： 简单\n题目描述 给定一个 n 叉树的根节点 root ，返回 其节点值的 后序遍历 。\nn 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。\n示例 1： 输入： root = [1,null,3,2,4,null,5,6]\n输出： [5,6,3,2,4,1]\n示例 2： 输入： root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n输出： [2,6,14,11,7,3,12,8,4,13,9,10,5,1]\n提示： 节点总数在范围 [0, 104] 内 0 \u0026lt;= Node.val \u0026lt;= 104 n 叉树的高度小于或等于 1000 进阶： 递归法很简单，你可以使用迭代法完成此题吗?\n解题思路 递归 对于当前遍历到的结点，构造一个队列，递归的遍历每个子结点，将找到的值添加到队列尾，然后将当前结点的值添加到队列尾部。\nfunc preorder(root *Node) []int { if root == nil { return nil } elems := []int{root.Val} for _, child := range root.Children { elems = append(elems, preorder(child)...) } return elems } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ 迭代 需要使用栈来模拟递归的调用栈。\nn 叉树的后序遍历，即为从右向左先序遍历的倒序。参考次特性，对于当前遍历到的结点，首先需要将值加入到结果队列中，然后从右往左依序遍历剩余子树。\n为使得栈顶元素即为下一个遍历到的结点，子结点从左往右入栈。\n最后将所得遍历结果反转即可。\nfunc postorder(root *Node) []int { if root == nil { return nil } ans := make([]int, 0, 1) stack := []*Node{root} for len(stack) \u0026gt; 0 { cur := stack[len(stack)-1] // 当前遍历的结点 stack = stack[:len(stack)-1] // 出栈 ans = append(ans, cur.Val) // 子结点从右往左入栈 for i := 0; i \u0026lt; len(cur.Children); i++ { if cur.Children[i] == nil { continue } stack = append(stack, cur.Children[i]) } } for i := len(ans)/2 - 1; i \u0026gt;= 0; i-- { ans[i], ans[len(ans)-1-i] = ans[len(ans)-1-i], ans[i] } return ans } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(N) $ ","date":"2022-03-12T09:47:52+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-590.-n-%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","title":"Leetcode 590. N 叉树的后序遍历"},{"content":"链接： https://leetcode-cn.com/problems/count-nodes-with-the-highest-score/\n难度： 中等\n题目描述 给你一棵根节点为 0 的 二叉树 ，它总共有 n 个节点，节点编号为 0 到 n - 1 。同时给你一个下标从 0 开始的整数数组 parents 表示这棵树，其中 parents[i] 是节点 i 的父节点。由于节点 0 是根，所以 parents[0] == -1 。\n一个子树的 大小 为这个子树内节点的数目。每个节点都有一个与之关联的 分数 。求出某个节点分数的方法是，将这个节点和与它相连的边全部 删除 ，剩余部分是若干个 非空 子树，这个节点的 分数 为所有这些子树 大小的乘积 。\n请你返回有 最高得分 节点的 数目 。\n示例 1： 输入： parents = [-1,2,0,2,0]\n输出： 3\n解释：\n节点 0 的分数为：3 * 1 = 3 节点 1 的分数为：4 = 4 节点 2 的分数为：1 * 1 * 2 = 2 节点 3 的分数为：4 = 4 节点 4 的分数为：4 = 4\n最高得分为 4 ，有三个节点得分为 4 （分别是节点 1，3 和 4 ）。 示例 2： 输入： parents = [-1,2,0]\n输出： 2\n解释：\n节点 0 的分数为：2 = 2 节点 1 的分数为：2 = 2 节点 2 的分数为：1 * 1 = 1\n最高分数为 2 ，有两个节点分数为 2 （分别为节点 0 和 1 ）。 提示： n == parents.length 2 \u0026lt;= n \u0026lt;= 105 parents[0] == -1 对于 i != 0 ，有 0 \u0026lt;= parents[i] \u0026lt;= n - 1 parents 表示一棵二叉树。 解题思路 深度优先搜索 每个结点将与她相连的边删除后，剩余的子树最多可能有三颗子树：该结点的左右子树，以及删除该结点为根结点的子树后剩余的子树。\n采用深度优先搜索的方式，分别统计左右子树的节点数量，则便可求得三颗子树的结点数目，进而当前结点分数。\n结点数目为 0 时，子树不存在，忽略该部分。\nfunc countHighestScoreNodes(parents []int) int { children := make([][]int, len(parents)) for child := 1; child \u0026lt; len(parents); child++ { children[parents[child]] = append(children[parents[child]], child) } max := 0 // 最高分 cnt := 0 // 最高分数量 var divideAndConquer func(int) int divideAndConquer = func(node int) int { score := 1 // 记录当前分数 nodes := 1 // 记录当前子树结点数 // 当前结点左右子树纳入计算 for _, child := range children[node] { tmp := divideAndConquer(child) score *= tmp nodes += tmp } // 排除当前子树剩余部分 if len(parents) \u0026gt; nodes { score *= len(parents) - nodes } // 更新最大值 if max \u0026lt; score { max = score cnt = 1 } else if max == score { cnt++ } return nodes } divideAndConquer(0) return cnt } 复杂度 时间复杂度：$ O(N), N = len(parents) $ 空间复杂度：$ O(N) $ ","date":"2022-03-11T10:21:02+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2049.-%E7%BB%9F%E8%AE%A1%E6%9C%80%E9%AB%98%E5%88%86%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE/","title":"Leetcode 2049. 统计最高分的节点数目"},{"content":"链接： https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/\n难度： 简单\n题目描述 给定一个 n 叉树的根节点 root ，返回 其节点值的 前序遍历 。\nn 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。\n示例 1： 输入： root = [1,null,3,2,4,null,5,6]\n输出： [1,3,5,6,2,4]\n示例 2： 输入： root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n输出： [1,2,3,6,7,11,14,4,8,12,5,9,13,10]\n提示： 节点总数在范围 [0, 104] 内 0 \u0026lt;= Node.val \u0026lt;= 104 n 叉树的高度小于或等于 1000 进阶： 递归法很简单，你可以使用迭代法完成此题吗?\n解题思路 递归 对于当前遍历到的结点，构造一个队列，首个元素即为当前结点的值。然后递归的遍历每个子结点，将获得的结点值添加到队列尾部。\nfunc preorder(root *Node) []int { if root == nil { return nil } elems := []int{root.Val} for _, child := range root.Children { elems = append(elems, preorder(child)...) } return elems } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ 迭代 需要使用栈来模拟递归的调用栈。\n对于当前遍历到的结点，首先需要将值加入到结果队列中，然后从左往右依序遍历剩余子树。\n为使得栈顶元素即为下一个遍历到的结点，子结点从右往左入栈。\nfunc preorder(root *Node) []int { if root == nil { return nil } ans := make([]int, 0, 1) stack := []*Node{root} for len(stack) \u0026gt; 0 { cur := stack[len(stack)-1] // 当前遍历的结点 stack = stack[:len(stack)-1] // 出栈 ans = append(ans, cur.Val) // 子结点从右往左入栈 for i := len(cur.Children) - 1; i \u0026gt;= 0; i-- { if cur.Children[i] == nil { continue } stack = append(stack, cur.Children[i]) } } return ans } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-03-10T10:18:21+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-589.-n-%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/","title":"Leetcode 589. N 叉树的前序遍历"},{"content":"链接： https://leetcode-cn.com/problems/plates-between-candles/\n难度： 中等\n题目描述 给你一个长桌子，桌子上盘子和蜡烛排成一列。给你一个下标从 0 开始的字符串 s ，它只包含字符 '*' 和 '|' ，其中 '*' 表示一个 盘子 ，'|' 表示一支 蜡烛 。\n同时给你一个下标从 0 开始的二维整数数组 queries ，其中 queries[i] = [lefti, righti] 表示 子字符串 s[lefti\u0026hellip;righti] （包含左右端点的字符）。对于每个查询，你需要找到 子字符串中 在 两支蜡烛之间 的盘子的 数目 。如果一个盘子在 子字符串中 左边和右边 都 至少有一支蜡烛，那么这个盘子满足在 两支蜡烛之间 。\n比方说，s = \u0026quot;||**||**|*\u0026quot; ，查询 [3, 8] ，表示的是子字符串 \u0026quot;*||**|\u0026quot; 。子字符串中在两支蜡烛之间的盘子数目为 2 ，子字符串中右边两个盘子在它们左边和右边 都 至少有一支蜡烛。 请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。\n示例 1： 输入： s = \u0026ldquo;**|**|***|\u0026rdquo;, queries = [[2,5],[5,9]]\n输出： [2,3]\n解释：\nqueries[0] 有两个盘子在蜡烛之间。 queries[1] 有三个盘子在蜡烛之间。 示例 2： 输入： s = \u0026ldquo;***|**|*****|**||**|*\u0026rdquo;, queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]\n输出： [9,0,0,0,0]\n解释：\nqueries[0] 有 9 个盘子在蜡烛之间。 另一个查询没有盘子在蜡烛之间。 提示： 3 \u0026lt;= s.length \u0026lt;= 105 s 只包含字符 '*' 和 '|' 。 1 \u0026lt;= queries.length \u0026lt;= 105 queries[i].length == 2 0 \u0026lt;= lefti \u0026lt;= righti \u0026lt; s.length 解题思路 前缀和 + 哈希 使用 preSum[i] 表示前缀部分 [0,i] 中满足条件的盘子数量。\n对于每个查询区间，由于左侧没有蜡烛时不计数，需要左端点向右寻找到首个蜡烛处作为新的左端点，这块可以使用哈希表，通过倒叙遍历一遍的方式，记录下一个蜡烛的位置；而右侧没有蜡烛时不会计入到前缀和中，两个前缀和求差即可。\nfunc platesBetweenCandles(s string, queries [][]int) []int { preSum := make([]int, len(s)) leftCandle := -1 // 标记最新蜡烛位置 if s[0] == \u0026#39;|\u0026#39; { leftCandle = 0 } rightCandle := make([]int, len(s)) // 下一个蜡烛位置 rightCandle[len(s)-1] = len(s) - 1 for i := 1; i \u0026lt; len(s); i++ { // 与上一个保持一致 preSum[i] = preSum[i-1] // 蜡烛，将与前一个蜡烛之间的盘子加入到当前前缀和中 if s[i] == \u0026#39;|\u0026#39; { // 左侧存在蜡烛 if leftCandle != -1 { preSum[i] += i - leftCandle - 1 // 加上区间内的盘子 } leftCandle = i // 刷新蜡烛位置 } // 记录下一个蜡烛位置 if s[len(s)-1-i] == \u0026#39;|\u0026#39; { rightCandle[len(s)-1-i] = len(s) - 1 - i // 若为蜡烛则为当前位置 } else { rightCandle[len(s)-1-i] = rightCandle[len(s)-i] // 若为盘子则与下一个相同 } } // 查询结果 ans := make([]int, 0, len(s)) for _, query := range queries { if rightCandle[query[0]] \u0026gt;= query[1] { ans = append(ans, 0) continue } ans = append(ans, preSum[query[1]]-preSum[rightCandle[query[0]]]) } return ans } 复杂度 时间复杂度：$ O(NQ), N = len(s), Q = len(queries) $ 空间复杂度：$ O(N) $ ","date":"2022-03-08T17:12:30+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2055.-%E8%9C%A1%E7%83%9B%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%98%E5%AD%90/","title":"Leetcode 2055. 蜡烛之间的盘子"},{"content":"链接： https://leetcode-cn.com/problems/base-7/\n难度： 简单\n题目描述 给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。\n示例 1： 输入： num = 100\n输出： \u0026ldquo;202\u0026rdquo;\n示例 2： 输入： num = -7\n输出： \u0026ldquo;-10\u0026rdquo;\n提示： -107 \u0026lt;= num \u0026lt;= 107 解题思路 数学 除7取余，逆序排列。负数需要转换为对应相反数求得7进制，之后再在前面加上 '-'。\nfunc convertToBase7(num int) string { if num == 0 { return \u0026#34;0\u0026#34; } convertPositiveToBase7 := func(num int) string { ans := make([]byte, 0, 11) for ; num \u0026gt; 0; num /= 7 { ans = append(ans, byte(\u0026#39;0\u0026#39;+num%7)) } for i := len(ans)/2 - 1; i \u0026gt;= 0; i-- { ans[i], ans[len(ans)-1-i] = ans[len(ans)-1-i], ans[i] } return string(ans) } if num \u0026lt; 0 { return \u0026#34;-\u0026#34; + convertPositiveToBase7(-num) } return convertPositiveToBase7(num) } 复杂度 时间复杂度：$ O(\\log{\\lvert{num}\\rvert}) $ 空间复杂度：$ O(1) $ ","date":"2022-03-07T09:33:06+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-504.-%E4%B8%83%E8%BF%9B%E5%88%B6%E6%95%B0/","title":"Leetcode 504. 七进制数"},{"content":"链接： https://leetcode-cn.com/problems/find-good-days-to-rob-the-bank/\n难度： 中等\n题目描述 你和一群强盗准备打劫银行。给你一个下标从 0 开始的整数数组 security ，其中 security[i] 是第 i 天执勤警卫的数量。日子从 0 开始编号。同时给你一个整数 time 。\n如果第 i 天满足以下所有条件，我们称它为一个适合打劫银行的日子：\n第 i 天前和后都分别至少有 time 天。 第 i 天前连续 time 天警卫数目都是非递增的。 第 i 天后连续 time 天警卫数目都是非递减的。 更正式的，第 i 天是一个合适打劫银行的日子当且仅当：security[i - time] \u0026gt;= security[i - time + 1] \u0026gt;= ... \u0026gt;= security[i] \u0026lt;= ... \u0026lt;= security[i + time - 1] \u0026lt;= security[i + time].\n请你返回一个数组，包含 所有 适合打劫银行的日子（下标从 0 开始）。返回的日子可以 任意 顺序排列。\n示例 1： 输入： security = [5,3,3,3,5,6,2], time = 2\n输出： [2,3]\n解释：\n第 2 天，我们有 security[0] \u0026gt;= security[1] \u0026gt;= security[2] \u0026lt;= security[3] \u0026lt;= security[4] 。\n第 3 天，我们有 security[1] \u0026gt;= security[2] \u0026gt;= security[3] \u0026lt;= security[4] \u0026lt;= security[5] 。\n没有其他日子符合这个条件，所以日子 2 和 3 是适合打劫银行的日子。\n示例 2： 输入： security = [1,1,1,1,1], time = 0\n输出： [0,1,2,3,4]\n解释：\n因为 time 等于 0 ，所以每一天都是适合打劫银行的日子，所以返回每一天。\n示例 3： 输入： security = [1,2,3,4,5,6], time = 2\n输出： []\n解释：\n没有任何一天的前 2 天警卫数目是非递增的。\n所以没有适合打劫银行的日子，返回空数组。\n示例 4： 输入： security = [1], time = 5\n输出： []\n解释：\n没有日子前面和后面有 5 天时间。\n所以没有适合打劫银行的日子，返回空数组。\n提示： 1 \u0026lt;= security.length \u0026lt;= 105 0 \u0026lt;= security[i], time \u0026lt;= 105 解题思路 哈希 据题意可知，可以打劫的日子前 time 天警卫数量不增加，并且后 time 天警卫数量不减少。\n使用两个哈希表 descDays 和 ascDays 分别记录对于第 i 天而言：\ndescDays[i] 表示之前有多少天警卫数量不增加； ascDays[i] 之后有多少天警卫数量不减少。 对于每 i 天，判定其 descDays[i] ≥ time 且 ascDays[i] ≥ time，该天是可以打劫的。\nfunc goodDaysToRobBank(security []int, time int) []int { descDays := make([]int, len(security)) ascDays := make([]int, len(security)) for i := 1; i \u0026lt; len(security); i++ { if security[i] \u0026lt;= security[i-1] { descDays[i] = descDays[i-1] + 1 } if security[len(security)-1-i] \u0026lt;= security[len(security)-i] { ascDays[len(security)-1-i] = ascDays[len(security)-i] + 1 } } ans := make([]int, 0, len(security)) for i := len(security) - 1 - time; i \u0026gt;= time; i-- { if descDays[i] \u0026gt;= time \u0026amp;\u0026amp; ascDays[i] \u0026gt;= time { ans = append(ans, i) } } return ans } 复杂度 时间复杂度：$ O(N), N = len(security) $ 空间复杂度：$ O(N) $ 双指针 在一段先不递增后不递减的区间上，若能确定区间两侧的端点，则可以很容易的判定是否满足条件，节省掉哈希表的空间。\n采用双指针的方案，使用指针 l 和 r 分别表示区间的端点，对于第 i 天有如下情况：\n当相较于前一天发生递增时，说明当天已不满足之前的不递增，区间发生了变化，更新 l = i； 否则，从当天出发寻找右边界，由于存在连续相等的区间段，可能在之前遍历过程中已经确定，仅当 i \u0026gt; r 时向后便利直到发生递减为止。 确定左右边界后，判定是否满足要求即可。\nfunc goodDaysToRobBank(security []int, time int) []int { ans := make([]int, 0, len(security)) for l, r, i := 0, 0, 0; i \u0026lt; len(security)-time; i++ { // 确定左边界 if i == 0 || security[i] \u0026gt; security[i-1] { l = i } // 确定右边界 if r \u0026lt; i { for r = i; r+1 \u0026lt; len(security) \u0026amp;\u0026amp; security[r+1] \u0026gt;= security[r]; r++ { } } // 是否满足 if i-l \u0026gt;= time \u0026amp;\u0026amp; r-i \u0026gt;= time { ans = append(ans, i) } } return ans } 复杂度 时间复杂度：$ O(N), N = len(security) $ 空间复杂度：$ O(1) $ ","date":"2022-03-06T08:59:19+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2100.-%E9%80%82%E5%90%88%E6%89%93%E5%8A%AB%E9%93%B6%E8%A1%8C%E7%9A%84%E6%97%A5%E5%AD%90/","title":"Leetcode 2100. 适合打劫银行的日子"},{"content":"链接： https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/\n难度： 简单\n题目描述 给你两个字符串 a 和 b，请返回 这两个字符串中 最长的特殊序列 。如果不存在，则返回 -1 。\n「最长特殊序列」 定义如下：该序列为 某字符串独有的最长子序列（即不能是其他字符串的子序列） 。\n字符串 s 的子序列是在从 s 中删除任意数量的字符后可以获得的字符串。\n例如，\u0026quot;abc\u0026quot; 是 \u0026quot;aebdc\u0026quot; 的子序列，因为删除 \u0026ldquo;aebdc\u0026rdquo; 中斜体加粗的字符可以得到 \u0026quot;abc\u0026quot; 。 \u0026quot;aebdc\u0026quot; 的子序列还包括 \u0026quot;aebdc\u0026quot; 、 \u0026quot;aeb\u0026quot; 和 \u0026quot;\u0026quot; (空字符串)。\n示例 1： 输入： a = \u0026ldquo;aba\u0026rdquo;, b = \u0026ldquo;cdc\u0026rdquo;\n输出： 3\n解释： 最长特殊序列可为 \u0026ldquo;aba\u0026rdquo; (或 \u0026ldquo;cdc\u0026rdquo;)，两者均为自身的子序列且不是对方的子序列。\n示例 2： 输入： a = \u0026ldquo;aaa\u0026rdquo;, b = \u0026ldquo;bbb\u0026rdquo;\n输出： 3\n解释： 最长特殊序列是 \u0026ldquo;aaa\u0026rdquo; 和 \u0026ldquo;bbb\u0026rdquo; 。\n示例 3： 输入： a = \u0026ldquo;aaa\u0026rdquo;, b = \u0026ldquo;aaa\u0026rdquo;\n输出： -1\n解释： 字符串 a 的每个子序列也是字符串 b 的每个子序列。同样，字符串 b 的每个子序列也是字符串 a 的子序列。\n提示： 1 \u0026lt;= a.length, b.length \u0026lt;= 100 a 和 b 由小写英文字母组成 解题思路 分类讨论 由于返回的是最长的子序列，从字符串长度开始进行分类讨论：\n当两个字符串长度不一致时，较长的串一定不会是较短的子序列，返回长的那一个串的长度； 当两个字符串长度一致时： 若两个串不相等，则返回串长度； 若两个串相等，则其中一个的子序列也会是另一个的子序列，返回 -1； func findLUSlength(a string, b string) int { switch { case len(a) \u0026gt; len(b): return len(a) case len(a) \u0026lt; len(b): return len(b) case a != b: return len(a) default: return -1 } } 复杂度 时间复杂度：$ O(N), N = min(len(a), len(b)) $ 空间复杂度：$ O(1) $ ","date":"2022-03-05T10:15:10+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-521.-%E6%9C%80%E9%95%BF%E7%89%B9%E6%AE%8A%E5%BA%8F%E5%88%97/","title":"Leetcode 521. 最长特殊序列 Ⅰ"},{"content":"链接： https://leetcode-cn.com/problems/sum-of-subarray-ranges/\n难度： 中等\n题目描述 给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。\n返回 nums 中 所有 子数组范围的 和 。\n子数组是数组中一个连续 非空 的元素序列。\n示例 1： 输入： nums = [1,2,3]\n输出： 4\n解释： nums 的 6 个子数组如下所示：\n[1]，范围 = 最大 - 最小 = 1 - 1 = 0\n[2]，范围 = 2 - 2 = 0\n[3]，范围 = 3 - 3 = 0\n[1,2]，范围 = 2 - 1 = 1\n[2,3]，范围 = 3 - 2 = 1\n[1,2,3]，范围 = 3 - 1 = 2\n所有范围的和是 0 + 0 + 0 + 1 + 1 + 2 = 4\n示例 2： 输入： nums = [1,3,3]\n输出： 4\n解释： nums 的 6 个子数组如下所示：\n[1]，范围 = 最大 - 最小 = 1 - 1 = 0\n[3]，范围 = 3 - 3 = 0\n[3]，范围 = 3 - 3 = 0\n[1,3]，范围 = 3 - 1 = 2\n[3,3]，范围 = 3 - 3 = 0\n[1,3,3]，范围 = 3 - 1 = 2\n所有范围的和是 0 + 0 + 0 + 2 + 0 + 2 = 4\n示例 3： 输入： nums = [4,-2,-3,4,1]\n输出： 59\n解释： nums 中所有子数组范围的和是 59\n提示： 1 \u0026lt;= nums.length \u0026lt;= 1000 -109 \u0026lt;= nums[i] \u0026lt;= 109 进阶： 你可以设计一种时间复杂度为 $O(n)$ 的解决方案吗？\n解题思路 暴力求解 枚举子数组的左边界，向右枚举右边界的过程中，同更新字数组的最大值和最小值，累加求得的子数组范围。\nfunc subArrayRanges(nums []int) int64 { sum := int64(0) for i := len(nums) - 2; i \u0026gt;= 0; i-- { min := nums[i] max := nums[i] for j := i + 1; j \u0026lt; len(nums); j++ { if max \u0026lt; nums[j] { max = nums[j] } if min \u0026gt; nums[j] { min = nums[j] } sum += int64(max - min) } } return sum } 复杂度 时间复杂度：$ O(N^2), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2022-03-04T09:43:11+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2104.-%E5%AD%90%E6%95%B0%E7%BB%84%E8%8C%83%E5%9B%B4%E5%92%8C/","title":"Leetcode 2104. 子数组范围和"},{"content":"链接： https://leetcode-cn.com/problems/add-digits/\n难度： 简单\n题目描述 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。\n示例 1： 输入： num = 38\n输出： 2\n解释： 各位相加的过程为：\n38 \u0026ndash;\u0026gt; 3 + 8 \u0026ndash;\u0026gt; 11\n11 \u0026ndash;\u0026gt; 1 + 1 \u0026ndash;\u0026gt; 2\n由于 2 是一位数，所以返回 2。\n示例 2： 输入： num = 0\n输出： 0\n提示： 0 \u0026lt;= num \u0026lt;= 231 - 1 进阶： 你可以不使用循环或者递归，在 $O(1)$ 时间复杂度内解决这个问题吗？\n解题思路 模拟 根据题设描述方式，反复对上次计算结果中的每一位进行求和，直至结果小于 10 为止。\nfunc addDigits(num int) int { for num \u0026gt; 9 { sum := 0 for ; num \u0026gt; 0; num /= 10 { sum += num % 10 } num = sum } return num } 复杂度 时间复杂度：$ O(\\log{num}) $ 空间复杂度：$ O(1) $ ","date":"2022-03-03T09:28:32+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-258.-%E5%90%84%E4%BD%8D%E7%9B%B8%E5%8A%A0/","title":"Leetcode 258. 各位相加"},{"content":"链接： https://leetcode-cn.com/problems/zigzag-conversion/\n难度： 中等\n题目描述 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。\n比如输入字符串为 \u0026quot;PAYPALISHIRING\u0026quot; 行数为 3 时，排列如下：\nP A H N A P L S I I G Y I R 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\u0026quot;PAHNAPLSIIGYIR\u0026quot;。\n请你实现这个将字符串进行指定行数变换的函数：\nstring convert(string s, int numRows);\n示例 1： 输入： s = \u0026ldquo;PAYPALISHIRING\u0026rdquo;, numRows = 3\n输出： \u0026ldquo;PAHNAPLSIIGYIR\u0026rdquo;\n示例 2： 输入： s = \u0026ldquo;PAYPALISHIRING\u0026rdquo;, numRows = 4\n输出： \u0026ldquo;PINALSIGYAHRPI\u0026rdquo;\n解释：\nP I N A L S I G Y A H R P I 示例 3： 输入： s = \u0026ldquo;A\u0026rdquo;, numRows = 1\n输出： \u0026ldquo;A\u0026rdquo;\n示例 4： 输入: s = \u0026quot;\u0026quot;\n输出: 0\n提示： 1 \u0026lt;= s.length \u0026lt;= 1000 s 由英文字母（小写和大写）、',' 和 '.' 组成 1 \u0026lt;= numRows \u0026lt;= 1000 解题思路 模拟 根据题设含义，模拟构造 Z 字形排列。由于并不关心每个字符所在的列，确定每个字符的行之后，追加到末尾即可。\n注意： 对行为 1 的情况进行特判，直接返回原字符串。\nfunc convert(s string, numRows int) string { if numRows == 1 { return s } dir, row := -1, 0 matrix := make([][]byte, numRows) for i := range s { matrix[row] = append(matrix[row], s[i]) if row == 0 || row == numRows-1 { dir = -dir } row += dir } return string(bytes.Join(matrix, nil)) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(N) $ 规律 对于每一行而言，可以发觉从左往右其在原字符串中的下标是有规律的，从而推导出下一个字符的坐标。假设第 row 行首个坐标为 i。\n对于第一行和最后一行，下一个坐标是 i+(numRows-1)*2; 对于其它行，之后每连续两个字符的坐标分别是 i+(row-1)*2 和 i+(numRows-1)*2; 逐行推导下一个字符的位置，直接构造新字符串。\n注意： 对行为 1 的情况进行特判，直接返回原字符串。\nfunc convert(s string, numRows int) string { if numRows == 1 { return s } ans := make([]byte, 0, len(s)) for row := 0; row \u0026lt; numRows; row++ { if row \u0026gt;= len(s) { break } ans = append(ans, s[row]) for idx := row; idx \u0026lt; len(s); idx += (numRows - 1) \u0026lt;\u0026lt; 1 { // 非首尾行，中间多加一次字符 if row \u0026gt; 0 \u0026amp;\u0026amp; row \u0026lt; numRows-1 \u0026amp;\u0026amp; idx+(numRows-row-1)\u0026lt;\u0026lt;1 \u0026lt; len(s) { ans = append(ans, s[idx+(numRows-row-1)\u0026lt;\u0026lt;1]) } if idx+(numRows-1)\u0026lt;\u0026lt;1 \u0026lt; len(s) { ans = append(ans, s[idx+(numRows-1)\u0026lt;\u0026lt;1]) } } } return string(ans) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2022-03-01T09:27:15+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-6.-z-%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/","title":"Leetcode 6. Z 字形变换"},{"content":"链接： https://leetcode-cn.com/problems/optimal-division/\n难度： 中等\n题目描述 给定一组 正整数，相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -\u0026gt; 2 / 3 / 4 。\n但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到 最大的 结果，并且返回相应的字符串格式的表达式。你的表达式不应该含有冗余的括号。\n示例： 输入： [1000,100,10,2]\n输出： \u0026ldquo;1000/(100/10/2)\u0026rdquo;\n解释：\n1000/(100/10/2) = 1000/((100/10)/2) = 200\n但是，以下加粗的括号 \u0026ldquo;1000/((100/10)/2)\u0026rdquo; 是冗余的，\n因为他们并不影响操作的优先级，所以你需要返回 \u0026ldquo;1000/(100/10/2)\u0026quot;。\n其他用例:\n1000/(100/10)/2 = 50\n1000/(100/(10/2)) = 50\n1000/100/10/2 = 0.5\n1000/100/(10/2) = 2\n说明： 输入数组的长度在 [1, 10] 之间。 数组中每个元素的大小都在 [2, 1000] 之间。 每个测试用例只有一个最优除法解。 解题思路 动态规划 对于一个除式而言，为使得其值最大，则要被除数尽量大，而除数尽量小。\n需要从原式中找出使得值最大的分割点，则前半部分结果最大，后半部分结果最小，两部分是原问题的子问题，用动态规划求解。\n使用 dp[i][j].max 和 dp[i][j].min 记录下标区间 [i, j] 的最大值和最小值，则有状态转移方程：\n初始时，dp[i][i].max = dp[i][j].min = nums[i] dp[i][j].max = max(dp[i][k].max / dp[k+1][j].min), dp[i][j].min = min(dp[i][k].min / dp[k+1][j].max), (i ≤ k \u0026lt; j) 同时需要记录加括号的方式，最后返回 dp[0][len(nums)-1].max 对应加括号方式的表达式。\nfunc optimalDivision(nums []int) string { type Node struct { max float64 min float64 maxEquation string minEquation string } dp := make([][]*Node, len(nums)) // 分母非单个数字，需要加括号 format := func(need bool, dividend, divisor string) string { if need { return fmt.Sprintf(\u0026#34;%s/(%s)\u0026#34;, dividend, divisor) } return fmt.Sprintf(\u0026#34;%s/%s\u0026#34;, dividend, divisor) } for i := len(nums) - 1; i \u0026gt;= 0; i-- { dp[i] = make([]*Node, len(nums)) dp[i][i] = \u0026amp;Node{ max: float64(nums[i]), min: float64(nums[i]), maxEquation: strconv.Itoa(nums[i]), minEquation: strconv.Itoa(nums[i]), } for j := i + 1; j \u0026lt; len(nums); j++ { node := \u0026amp;Node{ min: math.MaxFloat64, } for k := i; k \u0026lt; j; k++ { // 最大值，被除数最大，除数最小 if node.max \u0026lt; dp[i][k].max/dp[k+1][j].min { node.max = dp[i][k].max / dp[k+1][j].min node.maxEquation = format(j-k \u0026gt; 1, dp[i][k].maxEquation, dp[k+1][j].minEquation) } // 最小值，被除数最小，除数最大 if node.min \u0026gt; dp[i][k].min/dp[k+1][j].max { node.min = dp[i][k].min / dp[k+1][j].max node.minEquation = format(j-k \u0026gt; 1, dp[i][k].minEquation, dp[k+1][j].maxEquation) } } dp[i][j] = node } } return dp[0][len(nums)-1].maxEquation } 复杂度 时间复杂度：$ O(N^3), N = len(nums) $ 空间复杂度：$ O(N^3) $ ","date":"2022-02-27T09:54:09+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-553.-%E6%9C%80%E4%BC%98%E9%99%A4%E6%B3%95/","title":"Leetcode 553. 最优除法"},{"content":"链接： https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements/\n难度： 简单\n题目描述 给你一个下标从 0 开始的整数数组 nums ，该数组的大小为 n ，请你计算 nums[j] - nums[i] 能求得的 最大差值 ，其中 0 \u0026lt;= i \u0026lt; j \u0026lt; n 且 nums[i] \u0026lt; nums[j] 。\n返回 最大差值 。如果不存在满足要求的 i 和 j ，返回 -1 。\n示例 1： 输入： nums = [7,1,5,4]\n输出： 4\n解释：\n最大差值出现在 i = 1 且 j = 2 时，nums[j] - nums[i] = 5 - 1 = 4 。 注意，尽管 i = 1 且 j = 0 时 ，nums[j] - nums[i] = 7 - 1 = 6 \u0026gt; 4 ，但 i \u0026gt; j 不满足题面要求，所以 6 不是有效的答案。\n示例 2： 输入： nums = [9,4,3,2]\n输出： -1\n解释：\n不存在同时满足 i \u0026lt; j 和 nums[i] \u0026lt; nums[j] 这两个条件的 i, j 组合。\n示例 3： 输入： nums = [1,5,2,10]\n输出： 9\n解释：\n最大差值出现在 i = 0 且 j = 3 时，nums[j] - nums[i] = 10 - 1 = 9 。\n提示： n == nums.length 2 \u0026lt;= n \u0026lt;= 1000 1 \u0026lt;= nums[i] \u0026lt;= 109 解题思路 枚举 枚举所有可能的 i 和 j并求得差值，找出最大差值。\nfunc maximumDifference(nums []int) int { maxDiff := -1 for i := len(nums) - 1; i \u0026gt;= 0; i-- { for j := i + 1; j \u0026lt; len(nums); j++ { if nums[j] \u0026gt; nums[i] \u0026amp;\u0026amp; maxDiff \u0026lt; nums[j]-nums[i] { maxDiff = nums[j] - nums[i] } } } return maxDiff } 复杂度 时间复杂度：$ O(N^2), N = len(nums) $ 空间复杂度：$ O(1) $ 模拟 对于满足条件的i 和 j，对 j 而言，最大差值必定是 nums[j] 是与在其之前的最小值的差。\n故从左往右一次遍历，记录当前遍历到的最小值，在每个数与记录的最小值的差值中，寻找最大值。\nfunc maximumDifference(nums []int) int { maxDiff := -1 min := math.MaxInt for _, num := range nums { if num \u0026gt; min \u0026amp;\u0026amp; maxDiff \u0026lt; num-min { maxDiff = num - min } if min \u0026gt; num { min = num } } return maxDiff } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2022-02-26T09:40:51+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2016.-%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/","title":"Leetcode 2016. 增量元素之间的最大差值"},{"content":"链接： https://leetcode-cn.com/problems/complex-number-multiplication/\n难度： 中等\n题目描述 复数 可以用字符串表示，遵循 \u0026quot;实部+虚部i\u0026quot; 的形式，并满足下述条件：\n实部 是一个整数，取值范围是 [-100, 100] 虚部 也是一个整数，取值范围是 [-100, 100] i2 == -1 给你两个字符串表示的复数 num1 和 num2 ，请你遵循复数表示形式，返回表示它们乘积的字符串。\n示例 1： 输入： num1 = \u0026ldquo;1+1i\u0026rdquo;, num2 = \u0026ldquo;1+1i\u0026rdquo;\n输出： \u0026ldquo;0+2i\u0026rdquo;\n解释： (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。\n示例 2： 输入： num1 = \u0026ldquo;1+-1i\u0026rdquo;, num2 = \u0026ldquo;1+-1i\u0026rdquo;\n输出： \u0026ldquo;0+-2i\u0026rdquo;\n解释： (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。\n提示： num1 和 num2 都是有效的复数表示。 解题思路 数学 分析因数字符串求的两个复数的实部和虚部，求和得出积的实部和虚步，再转换为字符串。\nfunc complexNumberMultiply(num1 string, num2 string) string { var real1, real2, imag1, imag2 int fmt.Sscanf(num1, \u0026#34;%d+%di\u0026#34;, \u0026amp;real1, \u0026amp;imag1) fmt.Sscanf(num2, \u0026#34;%d+%di\u0026#34;, \u0026amp;real2, \u0026amp;imag2) return fmt.Sprintf(\u0026#34;%d+%di\u0026#34;, real1*real2-imag1*imag2, real1*imag2+real2*imag1) } 复杂度 时间复杂度：$ O(N_1N_2), N_1 = len(num1), N_2 = len(num2) $ 空间复杂度：$ O(1) $ ","date":"2022-02-25T09:45:57+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-537.-%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95/","title":"Leetcode 537. 复数乘法"},{"content":"链接： https://leetcode-cn.com/problems/where-will-the-ball-fall/\n难度： 中等\n题目描述 用一个大小为 m x n 的二维网格 grid 表示一个箱子。你有 n 颗球。箱子的顶部和底部都是开着的。\n箱子中的每个单元格都有一个对角线挡板，跨过单元格的两个角，可以将球导向左侧或者右侧。\n将球导向右侧的挡板跨过左上角和右下角，在网格中用 1 表示。 将球导向左侧的挡板跨过右上角和左下角，在网格中用 -1 表示。 在箱子每一列的顶端各放一颗球。每颗球都可能卡在箱子里或从底部掉出来。如果球恰好卡在两块挡板之间的 \u0026ldquo;V\u0026rdquo; 形图案，或者被一块挡导向到箱子的任意一侧边上，就会卡住。\n返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。\n示例 1： 输入： grid = [[1,1,1,-1,-1],[1,1,1,-1,-1],[-1,-1,-1,1,1],[1,1,1,1,-1],[-1,-1,-1,-1,-1]]\n输出： [1,-1,-1,-1,-1]\n解释： 示例如图：\nb0 球开始放在第 0 列上，最终从箱子底部第 1 列掉出。\nb1 球开始放在第 1 列上，会卡在第 2、3 列和第 1 行之间的 \u0026ldquo;V\u0026rdquo; 形里。\nb2 球开始放在第 2 列上，会卡在第 2、3 列和第 0 行之间的 \u0026ldquo;V\u0026rdquo; 形里。\nb3 球开始放在第 3 列上，会卡在第 2、3 列和第 0 行之间的 \u0026ldquo;V\u0026rdquo; 形里。\nb4 球开始放在第 4 列上，会卡在第 2、3 列和第 1 行之间的 \u0026ldquo;V\u0026rdquo; 形里。\n示例 2： 输入： grid = [[-1]]\n输出： [-1]\n解释： 球被卡在箱子左侧边上。\n示例 3： 输入： grid = [[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1],[1,1,1,1,1,1],[-1,-1,-1,-1,-1,-1]]\n输出： [0,1,2,3,4,-1]\n提示： m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 100 grid[i][j] 为 1 或 -1 解题思路 模拟 模拟球运动的轨迹，直到其掉出箱子或者卡住。\nfunc findBall(grid [][]int) []int { ans := make([]int, len(grid[0])) for i := 0; i \u0026lt; len(grid[0]); i++ { col := i for row := 0; row \u0026lt; len(grid); row++ { if grid[row][col] == 1 { // 卡住 if col+1 == len(grid[0]) || grid[row][col+1] == -1 { col = -1 break } col++ } else { // 卡住 if col == 0 || grid[row][col-1] == 1 { col = -1 break } col-- } } ans[i] = col } return ans } 复杂度 时间复杂度：$ O(m*n) $ 空间复杂度：$ O(1) $ ","date":"2022-02-24T09:27:19+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1706.-%E7%90%83%E4%BC%9A%E8%90%BD%E4%BD%95%E5%A4%84/","title":"Leetcode 1706. 球会落何处"},{"content":"链接： https://leetcode-cn.com/problems/reverse-only-letters/\n难度： 简单\n题目描述 给你一个字符串 s ，根据下述规则反转字符串：\n所有非英文字母保留在原有位置。 所有英文字母（小写或大写）位置反转。 返回反转后的 s 。\n示例 1： 输入： s = \u0026ldquo;ab-cd\u0026rdquo;\n输出： \u0026ldquo;dc-ba\u0026rdquo;\n示例 2： 输入： s = \u0026ldquo;a-bC-dEf-ghIj\u0026rdquo;\n输出： \u0026ldquo;j-Ih-gfE-dCba\u0026rdquo;\n示例 3： 输入： s = \u0026ldquo;Test1ng-Leet=code-Q!\u0026rdquo;\n输出： \u0026ldquo;Qedo1ct-eeLg=ntse-T!\u0026rdquo;\n提示： 1 \u0026lt;= s.length \u0026lt;= 100 s 仅由 ASCII 值在范围 [33, 122] 的字符组成 s 不含 '\\\u0026quot;' 或 '\\\\' 解题思路 双指针 使用两个指针分别从两端开始，向中间遍历。\n当任一指针指向字符不为字母时，向中间寻找下一个字母；当两个指针指向的字符均为字母时，交换并继续遍历；最终直到两个指针相遇。\nfunc reverseOnlyLetters(s string) string { t := []byte(s) for i, j := 0, len(t)-1; i \u0026lt; j; { if !unicode.IsLetter(rune(t[i])) { i++ continue } if !unicode.IsLetter(rune(t[j])) { j-- continue } t[i], t[j] = t[j], t[i] i++ j-- } return string(t) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2022-02-23T09:33:47+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-917.-%E4%BB%85%E4%BB%85%E5%8F%8D%E8%BD%AC%E5%AD%97%E6%AF%8D/","title":"Leetcode 917. 仅仅反转字母"},{"content":"链接： https://leetcode-cn.com/problems/push-dominoes/\n难度： 中等\n题目描述 n 张多米诺骨牌排成一行，将每张多米诺骨牌垂直竖立。在开始时，同时把一些多米诺骨牌向左或向右推。\n每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。\n如果一张垂直竖立的多米诺骨牌的两侧同时有多米诺骨牌倒下时，由于受力平衡， 该骨牌仍然保持不变。\n就这个问题而言，我们会认为一张正在倒下的多米诺骨牌不会对其它正在倒下或已经倒下的多米诺骨牌施加额外的力。\n给你一个字符串 dominoes 表示这一行多米诺骨牌的初始状态，其中：\ndominoes[i] = 'L'，表示第 i 张多米诺骨牌被推向左侧， dominoes[i] = 'R'，表示第 i 张多米诺骨牌被推向右侧， dominoes[i] = '.'，表示没有推动第 i 张多米诺骨牌。 返回表示最终状态的字符串。\n示例 1： 输入： dominoes = \u0026ldquo;RR.L\u0026rdquo;\n输出： \u0026ldquo;RR.L\u0026rdquo;\n解释： 第一张多米诺骨牌没有给第二张施加额外的力。\n示例 2： 输入： dominoes = \u0026ldquo;.L.R\u0026hellip;LR..L..\u0026rdquo;\n输出： \u0026ldquo;LL.RR.LLRRLL..\u0026rdquo;\n提示： -n == dominoes.length -1 \u0026lt;= n \u0026lt;= 105\ndominoes[i] 为 'L'、'R' 或 '.' 解题思路 广度优先搜索 所有一开始被推的骨牌为起始状态，进行广度优先搜索，判定倒向一侧的下一个多米诺骨牌的状态：\n当已经倒下时，忽略，不进行传递； 当另一侧存在同一时间与当前倒下方向相反的骨牌时，仍保持直立； 否则，保持与当前倒下方向一致，并加入到队列。 func pushDominoes(dominoes string) string { dominoesBytes := []byte(dominoes) times := make([]int, len(dominoesBytes)) // 记录倒下时间 queue := list.New() // 初始状态 for i := range dominoesBytes { if dominoesBytes[i] != \u0026#39;.\u0026#39; { queue.PushBack(i) } } for time := 1; queue.Len() \u0026gt; 0; time++ { for i := queue.Len(); i \u0026gt; 0; i-- { cur := queue.Remove(queue.Front()).(int) // 确定下一个受影响的骨牌 以及 另一侧的骨牌 next, another := cur-1, cur-2 if dominoesBytes[cur] == \u0026#39;R\u0026#39; { next, another = cur+1, cur+2 } // 到达边界 或 已倒下，忽略 if next \u0026lt; 0 || next \u0026gt;= len(dominoesBytes) || dominoesBytes[next] != \u0026#39;.\u0026#39; { continue } times[next] = time // 未能保持平衡（另一侧骨牌不存在 或 倒下时间不一致 或 方向不与当前相反） if another \u0026lt; 0 || another \u0026gt;= len(dominoes) || times[another] != times[cur] || dominoesBytes[another] == \u0026#39;.\u0026#39; || dominoesBytes[another] == dominoesBytes[cur] { dominoesBytes[next] = dominoesBytes[cur] queue.PushBack(next) // 传导到倒下骨牌 } } } return string(dominoesBytes) } 复杂度 时间复杂度：$ O(N), N = len(dominoes) $ 空间复杂度：$ O(N) $ 双指针 由于骨牌均按照初始倒下方向连续倒下，对于一段连续骨牌，有下述情况：\n骨牌从最左边开始，最右侧骨牌向左倒，则这一段骨牌均向左倒； 骨牌从最右边开始，最左侧骨牌向右倒，则这一段骨牌均向右倒； 两侧骨牌向中间倒，则这一段骨牌向中间倒； 两侧骨牌向同一侧倒，则这一段骨牌倒向同一方向； 除了上述4中之外的情况，不会影响这一段骨牌的状态。 使用双指针，从初始态寻找下个倒下的骨牌或尾部，判定构成的区间段，符合上述哪种条件，进行相应的变更。\nfunc pushDominoes(dominoes string) string { dominoesBytes := []byte(dominoes) // 初始状态 l, r := 0, 0 for r = range dominoesBytes { if r == len(dominoesBytes)-1 || dominoesBytes[r] != \u0026#39;.\u0026#39; { if dominoesBytes[l] == \u0026#39;R\u0026#39; \u0026amp;\u0026amp; dominoesBytes[r] == \u0026#39;L\u0026#39; { for i := 1; l+i \u0026lt; r-i; i++ { dominoesBytes[l+i] = dominoesBytes[l] dominoesBytes[r-i] = dominoesBytes[r] } } else if dominoesBytes[l] == \u0026#39;.\u0026#39; \u0026amp;\u0026amp; dominoesBytes[r] == \u0026#39;L\u0026#39; { for i := l; i \u0026lt; r; i++ { dominoesBytes[i] = \u0026#39;L\u0026#39; } } else if dominoesBytes[l] == \u0026#39;R\u0026#39; \u0026amp;\u0026amp; dominoesBytes[r] == \u0026#39;.\u0026#39; { for i := l + 1; i \u0026lt;= r; i++ { dominoesBytes[i] = \u0026#39;R\u0026#39; } } else if dominoesBytes[l] == dominoesBytes[r] { for i := l + 1; i \u0026lt; r; i++ { dominoesBytes[i] = dominoesBytes[l] } } l = r } } return string(dominoesBytes) } 复杂度 时间复杂度：$ O(N), N = len(dominoes) $ 空间复杂度：$ O(1) $ ","date":"2022-02-21T09:45:54+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-838.-%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/","title":"Leetcode 838. 推多米诺"},{"content":"链接： https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/\n难度： 简单\n题目描述 有两种特殊字符：\n第一种字符可以用一个比特 0 来表示 第二种字符可以用两个比特(10 或 11)来表示、 给定一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一位字符，则返回 true 。\n示例 1： 输入： bits = [1, 0, 0]\n输出： true\n解释： 唯一的编码方式是一个两比特字符和一个一比特字符。\n所以最后一个字符是一比特字符。\n示例 2： 输入： bits = [1, 1, 1, 0]\n输出： false\n解释： 唯一的编码方式是两比特字符和两比特字符。\n所以最后一个字符不是一比特字符。\n提示： 1 \u0026lt;= bits.length \u0026lt;= 1000 bits[i] == 0 or 1 解题思路 模拟 根据题意不难发现，排列的字符的表示方式没有歧义：\n当比特位为 0 时，其为第一种字符； 当比特位为 1 时，其余其后一个比特位构成第二种字符。 利用该特点进行遍历，不断识别并标记是第几种字符。\nfunc isOneBitCharacter(bits []int) bool { ans := false for i := 0; i \u0026lt; len(bits); { if bits[i] == 0 { i++ ans = true } else { i += 2 ans = false } } return ans } 复杂度 时间复杂度：$ O(N), N = len(bits) $ 空间复杂度：$ O(1) $ ","date":"2022-02-20T11:06:27+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-717.-1%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/","title":"Leetcode 717. 1比特与2比特字符"},{"content":"链接： https://leetcode-cn.com/problems/pancake-sorting/\n难度： 中等\n题目描述 给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。\n一次煎饼翻转的执行过程如下：\n选择一个整数 k ，1 \u0026lt;= k \u0026lt;= arr.length 反转子数组 arr[0...k-1]（下标从 0 开始） 例如，arr = [3,2,1,4] ，选择 k = 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr = [1,2,3,4] 。\n以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。\n示例 1： 输入： [3,2,4,1]\n输出： [4,2,4,3]\n解释：\n我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。\n初始状态 arr = [3, 2, 4, 1]\n第一次翻转后（k = 4）：arr = [1, 4, 2, 3]\n第二次翻转后（k = 2）：arr = [4, 1, 2, 3]\n第三次翻转后（k = 4）：arr = [3, 2, 1, 4]\n第四次翻转后（k = 3）：arr = [1, 2, 3, 4]，此时已完成排序。\n示例 2： 输入： [1,2,3]\n输出： []\n解释：\n输入已经排序，因此不需要翻转任何内容。\n请注意，其他可能的答案，如 [3，3] ，也将被判断为正确。\n提示： 1 \u0026lt;= arr.length \u0026lt;= 100 1 \u0026lt;= arr[i] \u0026lt;= arr.length = arr 中的所有整数互不相同（即，arr 是从 1 到 arr.length 整数的一个排列） 解题思路 深度优先搜索 注意到每次反转只会改变 k 之前部分元素的顺序，后续的元素位置不会变化。\n所以可以以倒序的方式，每次确定一个最后的元素，直到所有位置的元素均确定为止。\n而每次的操作，即为找出子数组中最大元素并放置到尾部，通过两次翻转即可实现（先置首，再置尾）。\nfunc pancakeSort(arr []int) []int { ans := make([]int, 0, len(arr)*2) // 反转[i,j]元素 reverse := func(k int) { for i := 0; i \u0026lt; k; i, k = i+1, k-1 { arr[i], arr[k] = arr[k], arr[i] } } for i := len(arr) - 1; i \u0026gt; 0; i-- { // 寻找最大元素下标 maxIdx := 0 for j := 0; j \u0026lt;= i; j++ { if arr[maxIdx] \u0026lt; arr[j] { maxIdx = j } } // 最大元素已在对应位置 if maxIdx == i { continue } reverse(maxIdx) // 最大元素置首 reverse(i) // 最大元素置尾 ans = append(ans, maxIdx+1, i+1) } return ans } 复杂度 时间复杂度：$ O(N^2), N = len(arr) $ 空间复杂度：$ O(1) $ ","date":"2022-02-19T10:07:04+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-969.-%E7%85%8E%E9%A5%BC%E6%8E%92%E5%BA%8F/","title":"Leetcode 969. 煎饼排序"},{"content":"链接： https://leetcode-cn.com/problems/find-center-of-star-graph/\n难度： 简单\n题目描述 有一个无向的 星型 图，由 n 个编号从 1 到 n 的节点组成。星型图有一个 中心 节点，并且恰有 n - 1 条边将中心节点与其他每个节点连接起来。\n给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。请你找出并返回 edges 所表示星型图的中心节点。\n示例 1： 输入： edges = [[1,2],[2,3],[4,2]]\n输出： 2\n解释： 如上图所示，节点 2 与其他每个节点都相连，所以节点 2 是中心节点。\n示例 2： 输入： edges = [[1,2],[5,1],[1,3],[1,4]]\n输出： 1\n提示： 3 \u0026lt;= n \u0026lt;= 105 edges.length == n - 1 edges[i].length == 2 1 \u0026lt;= ui, vi \u0026lt;= n ui != vi 题目数据给出的 edges 表示一个有效的星型图 解题思路 寻找公共结点 除中心结点外，其余的结点有且仅有一条边与其他结点相连，故只在整个 edges 数组中出现一次，而中心结点在会出现在每一条边上。\n只需要遍历任意两条边，找出重复出现的结点即为中心结点。\nfunc findCenter(edges [][]int) int { if edges[1][0] == edges[0][0] || edges[1][0] == edges[0][1] { return edges[1][0] } return edges[1][1] } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2022-02-18T09:34:18+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1791.-%E6%89%BE%E5%87%BA%E6%98%9F%E5%9E%8B%E5%9B%BE%E7%9A%84%E4%B8%AD%E5%BF%83%E8%8A%82%E7%82%B9/","title":"Leetcode 1791. 找出星型图的中心节点"},{"content":"链接： https://leetcode-cn.com/problems/knight-probability-in-chessboard/\n难度： 中等\n题目描述 在一个 n x n 的国际象棋棋盘上，一个骑士从单元格 (row, column) 开始，并尝试进行 k 次移动。行和列是 从 0 开始 的，所以左上单元格是 (0,0) ，右下单元格是 (n - 1, n - 1) 。\n象棋骑士有8种可能的走法，如下图所示。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格。\n每次骑士要移动时，它都会随机从8种可能的移动中选择一种(即使棋子会离开棋盘)，然后移动到那里。\n骑士继续移动，直到它走了 k 步或离开了棋盘。\n返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。\n示例 1： 输入： n = 3, k = 2, row = 0, column = 0\n输出： 0.0625\n解释： 有两步(到(1,2)，(2,1))可以让骑士留在棋盘上。\n在每一个位置上，也有两种移动可以让骑士留在棋盘上。\n骑士留在棋盘上的总概率是0.0625。\n示例 2： 输入： n = 1, k = 0, row = 0, column = 0\n输出： 1.00000\n提示： 1 \u0026lt;= n \u0026lt;= 25 0 \u0026lt;= k \u0026lt;= 100 0 \u0026lt;= row, column \u0026lt;= n 解题思路 动态规划 由于离开棋盘的时候，棋子后续将不在移动，只需处理每次移动后仍然保持在棋盘上的情况。\n每次概率的计算依赖于移动前后的单元格，考虑使用动态规划求解。\n使用 dp[step][i][j] 表示移动 step 次后，落在单元格 (i,j) 上的概率，则易得出状态转移方程：\n初始，dp[0][0][0] = 1； dp[step][i][j] = ∑ dp[step-1][i'][j'], (i',j') 表示可以移动到 (i,j) 的单元格。 由于每一步只从上一步转移而来，使用滚动矩阵降低空间复杂度。\nfunc knightProbability(n int, k int, row int, column int) float64 { dirs := [][]int{{-1, -2}, {-2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}} dp := make([][]float64, n) dp[row] = make([]float64, n) dp[row][column] = 1 for ; k \u0026gt; 0; k-- { dpTmp := make([][]float64, n) for i := range dp { for j := range dp[i] { // 上一步不可到达次单元格 if dp[i][j] == 0 { continue } for _, d := range dirs { next := []int{i + d[0], j + d[1]} // 越界判断 if next[0] \u0026lt; 0 || next[0] \u0026gt;= n || next[1] \u0026lt; 0 || next[1] \u0026gt;= n { continue } // 转移到下个单元格的概率累加 if len(dpTmp[next[0]]) == 0 { dpTmp[next[0]] = make([]float64, n) } dpTmp[next[0]][next[1]] += dp[i][j] * 0.125 } } } dp = dpTmp } // 概率求和 sum := 0. for i := range dp { for j := range dp[i] { sum += dp[i][j] } } return sum } 复杂度 时间复杂度：$ O(k*n^2) $ 空间复杂度：$ O(n*2) $ ","date":"2022-02-17T09:25:59+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-688.-%E9%AA%91%E5%A3%AB%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87/","title":"Leetcode 688. 骑士在棋盘上的概率"},{"content":"链接： https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/\n难度： 简单\n题目描述 给你一个 m * n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。\n幸运数是指矩阵中满足同时下列两个条件的元素：\n在同一行的所有元素中最小 在同一列的所有元素中最大 示例 1： 输入： matrix = [[3,7,8],[9,11,13],[15,16,17]]\n输出： [15]\n解释： 15 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。\n示例 2： 输入： matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]]\n输出： [12]\n解释： 12 是唯一的幸运数，因为它是其所在行中的最小值，也是所在列中的最大值。\n示例 3： 输入： matrix = [[7,8],[1,2]]\n输出： [7]\n提示： m == mat.length n == mat[i].length 1 \u0026lt;= n, m \u0026lt;= 50 1 \u0026lt;= matrix[i][j] \u0026lt;= 105 矩阵中的所有元素都是不同的 解题思路 暴力求解 遍历整个矩阵，依次判断每个数是否同时满足题设条件。\nfunc luckyNumbers(matrix [][]int) []int { ans := make([]int, 0, len(matrix)) for i := range matrix { for j := range matrix[i] { flag := true // 是否为行最小值 for k := len(matrix[0]) - 1; k \u0026gt;= 0; k-- { if matrix[i][k] \u0026lt; matrix[i][j] { flag = false break } } if !flag { continue } // 是否为列最大值 for k := len(matrix) - 1; k \u0026gt;= 0; k-- { if matrix[k][j] \u0026gt; matrix[i][j] { flag = false break } } if flag { ans = append(ans, matrix[i][j]) } } } return ans } 复杂度 时间复杂度：$ O(m*n * (m + n)) $ 空间复杂度：$ O(1) $ 哈希 使用哈希表记录每行的最大值和每列的最小值，寻找同时出现在两个哈希表中的数。\nfunc luckyNumbers(matrix [][]int) []int { ans := make([]int, 0, len(matrix)) rowMin := make([]int, len(matrix)) colMax := make([]int, len(matrix[0])) for i := range matrix { rowMin[i] = math.MaxInt32 for j := range matrix[i] { if matrix[i][j] \u0026lt; rowMin[i] { rowMin[i] = matrix[i][j] } if matrix[i][j] \u0026gt; colMax[j] { colMax[j] = matrix[i][j] } } } for _, num1 := range rowMin { for _, num2 := range colMax { if num1 == num2 { ans = append(ans, num1) } } } return ans } 复杂度 时间复杂度：$ O(m*n) $ 空间复杂度：$ O(m+n) $ ","date":"2022-02-15T09:30:05+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1380.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/","title":"Leetcode 1380. 矩阵中的幸运数"},{"content":"链接： https://leetcode-cn.com/problems/single-element-in-a-sorted-array/\n难度： 中等\n题目描述 给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。\n请你找出并返回只出现一次的那个数。\n你设计的解决方案必须满足 $ O(\\log{n}) $ 时间复杂度和 $ O(1) $ 空间复杂度。\n示例 1： 输入： nums = [1,1,2,3,3,4,4,8,8]\n输出： 2\n示例 2： 输入： nums = [3,3,7,7,10,11,11]\n输出： 10\n提示： 1 \u0026lt;= nums.length \u0026lt;= 105 0 \u0026lt;= nums[i] \u0026lt;= 105 解题思路 二分查找 由于数组有序，则成对的元素必然是相邻的，并且元素数量为奇数。当某一对数与左或右边的所有数字总数量为偶数时，目标数必然不在其中，而在另一边，可以使用二分查找。\n每次选取中间的数字，并与左右两边相邻的数字比较：\n若和其中一边的数字相同，将与该数对构成的偶数个元素的那一边排除，在另一边继续查找； 若与两边数字均不相同或者仅剩一个数，则返回该值。 func singleNonDuplicate(nums []int) int { for i, j := 0, len(nums)-1; i \u0026lt;= j; { if i == j { return nums[i] } mid := (i + j) / 2 if nums[mid] == nums[mid-1] { if (j-mid)\u0026amp;1 == 0 { // 右侧成对，向左寻找 j = mid - 2 } else { // 左侧成对，向右寻找 i = mid + 1 } } else if nums[mid] == nums[mid+1] { if (j-mid)\u0026amp;1 == 0 { // 左侧成对，向右寻找 i = mid + 2 } else { // 右侧成对，向做寻找 j = mid - 1 } } else { return nums[mid] } } return 0 } 复杂度 时间复杂度：$ O(\\log{N}) $ 空间复杂度：$ O(1) $ ","date":"2022-02-14T09:33:11+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-540.-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%8D%95%E4%B8%80%E5%85%83%E7%B4%A0/","title":"Leetcode 540. 有序数组中的单一元素"},{"content":"链接： https://leetcode-cn.com/problems/maximum-number-of-balloons/\n难度： 简单\n题目描述 给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 \u0026ldquo;balloon\u0026rdquo;（气球）。\n字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 \u0026ldquo;balloon\u0026rdquo;。\n示例 1： 输入： text = \u0026ldquo;nlaebolko\u0026rdquo;\n输出： 1\n示例 2： 输入： text = \u0026ldquo;loonbalxballpoon\u0026rdquo;\n输出： 2\n示例 3： 输入： text = \u0026ldquo;leetcode\u0026rdquo;\n输出： 0\n提示： 1 \u0026lt;= text.length \u0026lt;= 104 text 全部由小写英文字母组成 解题思路 哈希 使用哈希表记录可以组成 \u0026ldquo;balloon\u0026rdquo; 的每个字母的数量，然后遍历哈希表，求得可以组成balloon的最大数量。\nfunc maxNumberOfBalloons(text string) int { cnt := make(map[byte]int) for i := range text { switch text[i] { case \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;n\u0026#39;: cnt[text[i]]++ } } cnt[\u0026#39;l\u0026#39;] /= 2 cnt[\u0026#39;o\u0026#39;] /= 2 ans := 0 Outer: for { for _, char := range \u0026#34;balon\u0026#34; { if cnt[byte(char)] \u0026lt;= 0 { break Outer } cnt[byte(char)]-- } ans++ } return ans } 复杂度 时间复杂度：$ O(N+\\Sigma), N = len(text), \\Sigma表示目标单词字符集，本题中为5 $ 空间复杂度：$ O(\\Sigma) $ ","date":"2022-02-13T09:38:39+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1189.-%E6%B0%94%E7%90%83-%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/","title":"Leetcode 1189. “气球” 的最大数量"},{"content":"链接： https://leetcode-cn.com/problems/number-of-enclaves/\n难度： 中等\n题目描述 给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。\n一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。\n返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。\n示例 1： 输入： grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]\n输出： 3\n解释： 有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。\n示例 2： 输入： grid = [[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]\n输出： 0\n解释： 所有 1 都在边界上或可以到达边界。\n提示： m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 500 grid[i][j] 的值为 0 或 1 解题思路 广度优先搜索 从每个边界处出发，使用广度优先搜索，将可达的所有陆地标记出来，则剩余陆地为不可达，也即无法到达边界。\nfunc numEnclaves(grid [][]int) int { dirs := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} queue := list.New() // 首尾两列入队 for row := 0; row \u0026lt; len(grid); row++ { for _, col := range []int{0, len(grid[0]) - 1} { if grid[row][col] == 1 { queue.PushBack([]int{row, col}) grid[row][col] = 2 // 标记可达 } } } // 首尾两行入队 for col := 0; col \u0026lt; len(grid[0]); col++ { for _, row := range []int{0, len(grid) - 1} { if grid[row][col] == 1 { queue.PushBack([]int{row, col}) grid[row][col] = 2 // 标记可达 } } } // 广度优先搜索 for queue.Len() \u0026gt; 0 { pos := queue.Remove(queue.Front()).([]int) for _, d := range dirs { row, col := pos[0]+d[0], pos[1]+d[1] // 越界 if row \u0026lt; 0 || row \u0026gt;= len(grid) || col \u0026lt; 0 || col \u0026gt;= len(grid[0]) { continue } // 不可达 if grid[row][col] != 1 { continue } queue.PushBack([]int{row, col}) grid[row][col] = 2 // 标记可达 } } // 剩余陆地不可到达边界，统计数量 cnt := 0 for _, line := range grid { for _, cell := range line { if cell == 1 { cnt++ } } } return cnt } 复杂度 时间复杂度：$ O(m*n) $ 空间复杂度：$ O(m*n) $ 深度优先搜索 沿用上述广度优先搜索的思路，采用深度优先搜索实现。\nfunc numEnclaves(grid [][]int) int { // 深度优先搜索 dirs := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} var dfs func(row, col int) dfs = func(row, col int) { // 越界 if row \u0026lt; 0 || row \u0026gt;= len(grid) || col \u0026lt; 0 || col \u0026gt;= len(grid[0]) { return } // 不可达 if grid[row][col] != 1 { return } grid[row][col] = 2 // 标记可达 for _, d := range dirs { dfs(row+d[0], col+d[1]) } } // 首尾两列开始搜索 for row := 0; row \u0026lt; len(grid); row++ { for _, col := range []int{0, len(grid[0]) - 1} { dfs(row, col) } } // 首尾两行开始搜索 for col := 0; col \u0026lt; len(grid[0]); col++ { for _, row := range []int{0, len(grid) - 1} { dfs(row, col) } } // 剩余陆地不可到达边界，统计数量 cnt := 0 for _, line := range grid { for _, cell := range line { if cell == 1 { cnt++ } } } return cnt } 复杂度 时间复杂度：$ O(m*n) $ 空间复杂度：$ O(m*n) $ ","date":"2022-02-12T09:18:39+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1020.-%E9%A3%9E%E5%9C%B0%E7%9A%84%E6%95%B0%E9%87%8F/","title":"Leetcode 1020. 飞地的数量"},{"content":"链接： https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/\n难度： 简单\n题目描述 给你一个 下标从 0 开始 的整数数组 nums ，其中 nums[i] 表示第 i 名学生的分数。另给你一个整数 k 。\n从数组中选出任意 k 名学生的分数，使这 k 个分数间 最高分 和 最低分 的 差值 达到 最小化 。\n返回可能的 最小差值 。\n示例 1： 输入： nums = [90], k = 1\n输出： 0\n解释： 选出 1 名学生的分数，仅有 1 种方法：\n[90] 最高分和最低分之间的差值是 90 - 90 = 0\n可能的最小差值是 0 示例 2： 输入：nums = [9,4,1,7], k = 2\n输出：2\n解释：选出 2 名学生的分数，有 6 种方法：\n[9,4,1,7] 最高分和最低分之间的差值是 9 - 4 = 5 [9,4,1,7] 最高分和最低分之间的差值是 9 - 1 = 8 [9,4,1,7] 最高分和最低分之间的差值是 9 - 7 = 2 [9,4,1,7] 最高分和最低分之间的差值是 4 - 1 = 3 [9,4,1,7] 最高分和最低分之间的差值是 7 - 4 = 3 [9,4,1,7] 最高分和最低分之间的差值是 7 - 1 = 6\n可能的最小差值是 2 提示： 1 \u0026lt;= k \u0026lt;= nums.length \u0026lt;= 1000 0 \u0026lt;= nums[i] \u0026lt;= 105 解题思路 排序 按照分数排序，则为使得分数差距足够小，需要选出连续的同学。\n顺序遍历，每次找出连续 k 个同学，位于两侧的同学分数差距最大，求得最小值。\nfunc minimumDifference(nums []int, k int) int { min := math.MaxInt32 sort.Ints(nums) for i := k - 1; i \u0026lt; len(nums); i++ { if min \u0026gt; nums[i]-nums[i-k+1] { min = nums[i] - nums[i-k+1] } } return min } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(nums) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-02-11T18:09:21+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1984.-%E5%AD%A6%E7%94%9F%E5%88%86%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC/","title":"Leetcode 1984. 学生分数的最小差值"},{"content":"链接： https://leetcode-cn.com/problems/simplified-fractions/\n难度： 中等\n题目描述 给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于 n 的 最简 分数 。分数可以以 任意 顺序返回。\n示例 1： 输入： n = 2\n输出： [\u0026ldquo;1/2\u0026rdquo;]\n解释： \u0026ldquo;1/2\u0026rdquo; 是唯一一个分母小于等于 2 的最简分数。\n示例 2： 输入： n = 3\n输出： [\u0026ldquo;1/2\u0026rdquo;,\u0026ldquo;1/3\u0026rdquo;,\u0026ldquo;2/3\u0026rdquo;]\n示例 3： 输入： n = 4\n输出： [\u0026ldquo;1/2\u0026rdquo;,\u0026ldquo;1/3\u0026rdquo;,\u0026ldquo;1/4\u0026rdquo;,\u0026ldquo;2/3\u0026rdquo;,\u0026ldquo;3/4\u0026rdquo;]\n解释： \u0026ldquo;2/4\u0026rdquo; 不是最简分数，因为它可以化简为 \u0026ldquo;1/2\u0026rdquo; 。\n示例 4： 输入： n = 1\n输出： []\n提示： 1 \u0026lt;= n \u0026lt;= 100 解题思路 枚举 枚举分数值在区间 (0, 1) ，并且分母 ≤ n 的所有分子和分母，求得其最大公约数，当且仅当其为 1，是最简分数。\nfunc simplifiedFractions(n int) []string { ans := make([]string, 0, n) for denominator := 2; denominator \u0026lt;= n; denominator++ { for numerator := 1; numerator \u0026lt; denominator; numerator++ { a, b := denominator, numerator for a%b != 0 { a, b = b, a%b } if b == 1 { ans = append(ans, fmt.Sprintf(\u0026#34;%d/%d\u0026#34;, numerator, denominator)) } } } return ans } 复杂度 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(1) $ ","date":"2022-02-10T09:36:26+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1447.-%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/","title":"Leetcode 1447. 最简分数"},{"content":"链接： https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k/\n难度： 简单\n题目描述 给你一个整数数组 nums 和一个整数 k ，请你返回数对 (i, j) 的数目，满足 i \u0026lt; j 且 |nums[i] - nums[j]| == k 。\n|x| 的值定义为：\n如果 x \u0026gt;= 0 ，那么值为 x 。 如果 x \u0026lt; 0 ，那么值为 -x 。 示例 1： 输入： nums = [1,2,2,1], k = 1\n输出： 4\n解释： 差的绝对值为 1 的数对为：\n[1,2,2,1] [1,2,2,1] [1,2,2,1] [1,2,2,1] 示例 2： 输入：nums = [1,3], k = 3 输出：0 解释：没有任何数对差的绝对值为 3 。\n示例 3： 输入： nums = [3,2,1,5,4], k = 2\n输出： 3\n解释： 差的绝对值为 2 的数对为：\n[3,2,1,5,4] [3,2,1,5,4] [3,2,1,5,4] 提示： 1 \u0026lt;= nums.length \u0026lt;= 200 1 \u0026lt;= nums[i] \u0026lt;= 100 1 \u0026lt;= k \u0026lt;= 99 解题思路 枚举 枚举符合条件的数对 i 和 j，当符合题设要求时，累加进结果中。\nfunc countKDifference(nums []int, k int) int { ans := 0 for i := len(nums) - 2; i \u0026gt;= 0; i-- { for j := i + 1; j \u0026lt; len(nums); j++ { if nums[i]-nums[j] == k || nums[j]-nums[i] == k { ans++ } } } return ans } 复杂度 时间复杂度：$ O(N^2), N = len(nums) $ 空间复杂度：$ O(1) $ 哈希 使用哈希表记录遍历到当前数字 num 之前的数字出现的次数，然后寻找 num-k 和 num+k 是否存在，存在将其出现的次数累加进结果中。\nfunc countKDifference(nums []int, k int) int { ans := 0 cnt := make(map[int]int) for _, num := range nums { ans += cnt[num-k] ans += cnt[num+k] cnt[num]++ } return ans } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2022-02-09T10:28:57+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2006.-%E5%B7%AE%E7%9A%84%E7%BB%9D%E5%AF%B9%E5%80%BC%E4%B8%BA-k-%E7%9A%84%E6%95%B0%E5%AF%B9%E6%95%B0%E7%9B%AE/","title":"Leetcode 2006. 差的绝对值为 K 的数对数目"},{"content":"链接： https://leetcode-cn.com/problems/grid-illumination/\n难度： 困难\n题目描述 在大小为 n x n 的网格 grid 上，每个单元格都有一盏灯，最初灯都处于 关闭 状态。\n给你一个由灯的位置组成的二维数组 lamps ，其中 lamps[i] = [rowi, coli] 表示 打开 位于 grid[rowi][coli] 的灯。即便同一盏灯可能在 lamps 中多次列出，不会影响这盏灯处于 打开 状态。\n当一盏灯处于打开状态，它将会照亮 自身所在单元格 以及同一 行 、同一 列 和两条 对角线 上的 所有其他单元格 。\n另给你一个二维数组 queries ，其中 queries[j] = [rowj, colj] 。对于第 j 个查询，如果单元格 [rowj, colj] 是被照亮的，则查询结果为 1 ，否则为 0 。在第 j 次查询之后 [按照查询的顺序] ，关闭 位于单元格 grid[rowj][colj] 上及相邻 8 个方向上（与单元格 grid[rowi][coli] 共享角或边）的任何灯。\n返回一个整数数组 ans 作为答案， ans[j] 应等于第 j 次查询 queries[j] 的结果，1 表示照亮，0 表示未照亮。\n示例 1： 输入： n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]\n输出： [1,0]\n解释： 最初所有灯都是关闭的。在执行查询之前，打开位于 [0, 0] 和 [4, 4] 的灯。第 0 次查询检查 grid[1][1] 是否被照亮（蓝色方框）。该单元格被照亮，所以 ans[0] = 1 。然后，关闭红色方框中的所有灯。\n第 1 次查询检查 grid[1][0] 是否被照亮（蓝色方框）。该单元格没有被照亮，所以 ans[1] = 0 。然后，关闭红色矩形中的所有灯。\n示例 2： 输入： n = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,1]]\n输出： [1,1]\n示例 3： 输入： n = 5, lamps = [[0,0],[0,4]], queries = [[0,4],[0,1],[1,4]]\n输出： [1,1,0]\n提示： 1 \u0026lt;= n \u0026lt;= 109 0 \u0026lt;= lamps.length \u0026lt;= 20000 0 \u0026lt;= queries.length \u0026lt;= 20000 lamps[i].length == 2 0 \u0026lt;= rowi, coli \u0026lt; n queries[j].length == 2 0 \u0026lt;= rowj, colj \u0026lt; n 解题思路 哈希 使用哈希表记录出现的每盏灯，以及照亮的每行、列、对角线的灯的数量。\n行和列直接用使用灯所在位置的行列，对角线由于其斜率是固定的，可以使用一个点坐标代表，统一使用 0 行的列进行表示，有：\n对于正对角线：其斜率为 1， 使用 列-行 求得 列坐标； 对于反对角线：其斜率为 -1， 使用 列+行 求得 列坐标。 当判定某个单元格是否被照亮，判定其是否位于上述哈希表中记录的行、列、对角线其中一条上。\n灭灯时，当九宫格存在灯时，将其熄灭，其所在行、列、对角线的灯数量 -1。\n同一单元格中的灯按照一盏灯进行处理。\nfunc gridIllumination(n int, lamps [][]int, queries [][]int) []int { lampCoord := make(map[[2]int]struct{}) rows := make(map[int]int) // 行 cols := make(map[int]int) // 列 diagonal := make(map[int]int) // 对角线 backDiagonal := make(map[int]int) // 反对角线 for _, lamp := range lamps { // 同一个单元格里的灯当作一盏灯处理 if _, ok := lampCoord[[2]int{lamp[0], lamp[1]}]; ok { continue } lampCoord[[2]int{lamp[0], lamp[1]}] = struct{}{} rows[lamp[0]]++ cols[lamp[1]]++ diagonal[lamp[1]-lamp[0]]++ backDiagonal[lamp[1]+lamp[0]]++ } ans := make([]int, 0, len(queries)) for _, query := range queries { if rows[query[0]] \u0026gt; 0 || cols[query[1]] \u0026gt; 0 || diagonal[query[1]-query[0]] \u0026gt; 0 || backDiagonal[query[1]+query[0]] \u0026gt; 0 { ans = append(ans, 1) } else { ans = append(ans, 0) } // 关闭九宫格里的灯 for i := query[0] - 1; i \u0026lt;= query[0]+1; i++ { for j := query[1] - 1; j \u0026lt;= query[1]+1; j++ { if i \u0026lt; 0 || i \u0026gt;= n || j \u0026lt; 0 || j \u0026gt;= n { continue } lamp := [2]int{i, j} if _, ok := lampCoord[lamp]; !ok { continue } delete(lampCoord, lamp) rows[lamp[0]]-- cols[lamp[1]]-- diagonal[lamp[1]-lamp[0]]-- backDiagonal[lamp[1]+lamp[0]]-- } } } return ans } 复杂度 时间复杂度：$ O(N + L), N = len(lamps), Q = len(queries) $ 空间复杂度：$O(N) $ ","date":"2022-02-08T10:42:54+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1001.-%E7%BD%91%E6%A0%BC%E7%85%A7%E6%98%8E/","title":"Leetcode 1001. 网格照明"},{"content":"链接： https://leetcode-cn.com/problems/longest-happy-string/\n难度： 中等\n题目描述 如果字符串中不含有任何 'aaa'，'bbb' 或 'ccc' 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。\n给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s：\ns 是一个尽可能长的快乐字符串。 s 中 最多 有 a 个字母 'a'、b 个字母 'b'、c 个字母 'c' 。 s 中只含有 'a'、'b' 、'c' 三种字母。 如果不存在这样的字符串 s ，请返回一个空字符串\u0026quot;\u0026quot;。\n示例 1： 输入： a = 1, b = 1, c = 7\n输出： \u0026ldquo;ccaccbcc\u0026rdquo;\n解释： \u0026ldquo;ccbccacc\u0026rdquo; 也是一种正确答案。\n示例 2： 输入： a = 2, b = 2, c = 1\n输出： \u0026ldquo;aabbc\u0026rdquo;\n示例 3： 输入： a = 7, b = 1, c = 0\n输出： \u0026ldquo;aabaa\u0026rdquo;\n解释： 这是该测试用例的唯一正确答案。\n提示： 0 \u0026lt;= a, b, c \u0026lt;= 100 a + b + c \u0026gt; 0 解题思路 贪心 构成字符串时，优先选择剩余字母最多的，减小因同一字母后续剩余过多导致出现连续三个字母的情况。\n只有会导致出现连续的三个字母时，才从另外的两个字母中选择数量更多的那一个。\n当发现没有选择时，返回\u0026quot;\u0026quot;。\nfunc longestDiverseString(a int, b int, c int) string { s := make([]byte, 0, a+b+c) chars := []*struct { char byte cnt int }{{\u0026#39;a\u0026#39;, a}, {\u0026#39;b\u0026#39;, b}, {\u0026#39;c\u0026#39;, c}} for { sort.Slice(chars, func(i, j int) bool { return chars[i].cnt \u0026gt; chars[j].cnt }) exist := false for _, c := range chars { if c.cnt == 0 || (len(s) \u0026gt;= 2 \u0026amp;\u0026amp; s[len(s)-1] == c.char \u0026amp;\u0026amp; s[len(s)-2] == c.char) { continue } s = append(s, c.char) c.cnt-- exist = true break } if !exist { break } } return string(s) } 复杂度 时间复杂度：$ O((a+b+c)*\\Sigma\\log{\\Sigma}), \\Sigma表示字符集，本题中为3 $ 空间复杂度：$ O(\\Sigma) $ ","date":"2022-02-07T09:38:43+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1405.-%E6%9C%80%E9%95%BF%E5%BF%AB%E4%B9%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 1405. 最长快乐字符串"},{"content":"链接： https://leetcode-cn.com/problems/sum-of-unique-elements/\n难度： 简单\n题目描述 给你一个整数数组 nums 。数组中唯一元素是那些只出现 恰好一次 的元素。\n请你返回 nums 中唯一元素的 和 。\n示例 1： 输入： nums = [1,2,3,2]\n输出： 4\n解释： 唯一元素为 [1,3] ，和为 4 。\n示例 2： 输入： nums = [1,1,1,1,1]\n输出： 0\n解释： 没有唯一元素，和为 0 。\n示例 3： 输入： nums = [1,2,3,4,5]\n输出： 15\n解释： 唯一元素为 [1,2,3,4,5] ，和为 15 。\n提示： 1 \u0026lt;= nums.length \u0026lt;= 100 1 \u0026lt;= nums[i] \u0026lt;= 100 解题思路 哈希 使用哈希表统计每个数出现的次数，找出只出现一次的数，求和即可。\nfunc sumOfUnique(nums []int) (sum int) { cnt := make(map[int]int) for _, num := range nums { sw cnt[num]++ } for num, c := range cnt { if c == 1 { sum += num } } return sum } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ 优化 在上述题解的基础上进行优化，通过统计遍历到目前为止某个数出现的次数，来决定该执行一下哪项操作：\n对于首次出现的数，直接累加进结果中； 若之前已经出现过，则从结果中减去； 若之前已经减去，则不做任何操作。 用此方式将两次遍历优化到一次。\nfunc sumOfUnique(nums []int) (sum int) { cnt := make(map[int]int) for _, num := range nums { switch cnt[num] { case 0: sum += num case 1: sum -= num } cnt[num]++ } return sum } 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2022-02-06T10:47:39+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1748.-%E5%94%AF%E4%B8%80%E5%85%83%E7%B4%A0%E7%9A%84%E5%92%8C/","title":"Leetcode 1748. 唯一元素的和"},{"content":"链接： https://leetcode-cn.com/problems/path-with-maximum-gold/\n难度： 中等\n题目描述 你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。\n为了使收益最大化，矿工需要按以下规则来开采黄金：\n每当矿工进入一个单元，就会收集该单元格中的所有黄金。 矿工每次可以从当前位置向上下左右四个方向走。 每个单元格只能被开采（进入）一次。 不得开采（进入）黄金数目为 0 的单元格。 矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。 示例1： 输入： grid = [[0,6,0],[5,8,7],[0,9,0]]\n输出： 24\n解释：\n[[0,6,0],\n[5,8,7],\n[0,9,0]]\n一种收集最多黄金的路线是：9 -\u0026gt; 8 -\u0026gt; 7。\n示例 2： 输入： grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\n输出： 28\n解释：\n[[1,0,7],\n[2,0,6],\n[3,4,5],\n[0,3,0],\n[9,0,20]]\n一种收集最多黄金的路线是：1 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 4 -\u0026gt; 5 -\u0026gt; 6 -\u0026gt; 7。\n提示： 1 \u0026lt;= grid.length, grid[i].length \u0026lt;= 15 0 \u0026lt;= grid[i][j] \u0026lt;= 100 最多 25 个单元格中有黄金。 解题思路 回溯 以每个单元为起始结点，通过回溯找到路径的最大值，然后从中找出最大的那一个。\nfunc getMaximumGold(grid [][]int) (maxGold int) { rows, cols := len(grid), len(grid[0]) dirs := [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} var dfs func(row, col, gold int) dfs = func(row, col, gold int) { // 越界判断 if row \u0026lt; 0 || row \u0026gt;= rows || col \u0026lt; 0 || col \u0026gt;= cols { return } // 不可进入 if grid[row][col] == 0 { return } dup := grid[row][col] gold += dup // 开采 // 记录最大值 if maxGold \u0026lt; gold { maxGold = gold } grid[row][col] = 0 // 标记已开采 // 寻找后续路径 for _, d := range dirs { dfs(row+d[0], col+d[1], gold) } grid[row][col] = dup // 回溯 } // 以每个单元为起始，回溯查找 for row, line := range grid { for col, cell := range line { if cell \u0026gt; 0 { dfs(row, col, 0) } } } return } 复杂度 时间复杂度：$ O(m*n + G * 3^G), G 表示有黄金的单元格数量 $ 空间复杂度：$ O(G)$ ","date":"2022-02-05T10:32:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1219.-%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5/","title":"Leetcode 1219. 黄金矿工"},{"content":"链接： https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/\n难度： 简单\n题目描述 给你一个数组 rectangles ，其中 rectangles[i] = [li, wi] 表示第 i 个矩形的长度为 li 、宽度为 wi 。\n如果存在 k 同时满足 k \u0026lt;= li 和 k \u0026lt;= wi ，就可以将第 i 个矩形切成边长为 k 的正方形。例如，矩形 [4,6] 可以切成边长最大为 4 的正方形。\n设 maxLen 为可以从矩形数组 rectangles 切分得到的 最大正方形 的边长。\n请你统计有多少个矩形能够切出边长为 maxLen 的正方形，并返回矩形 数目 。\n示例 1： 输入： rectangles = [[5,8],[3,9],[5,12],[16,5]]\n输出： 3\n解释： 能从每个矩形中切出的最大正方形边长分别是 [5,3,5,5] 。\n最大正方形的边长为 5 ，可以由 3 个矩形切分得到。\n示例 2： 输入： rectangles = [[2,3],[3,7],[4,3],[3,7]]\n输出： 3\n提示： 1 \u0026lt;= rectangles.length \u0026lt;= 1000 rectangles[i].length == 2 1 \u0026lt;= li, wi \u0026lt;= 109 li != wi 解题思路 模拟 遍历所有的矩形，依次判定每个矩形能切出的边长最大的的正方形：\n当边长比当前记录的 maxLen 还大，说明找到了一个边长更大的正方形，更新 maxLen，数量置为 1； 当边长与当前记录的 maxLen 相同，说明又找到了一个边长最大的正方形，数量 + 1； 当边长比当前记录的 maxLen 下，则忽略； func countGoodRectangles(rectangles [][]int) int { maxLen := 0 cnt := 0 for _, r := range rectangles { // 长大于等于宽 if r[0] \u0026lt; r[1] { r[0], r[1] = r[1], r[0] } if r[1] \u0026gt; maxLen { maxLen = r[1] cnt = 1 } else if r[1] == maxLen { cnt++ } } return cnt } 复杂度 时间复杂度：$ O(N), N = len(rectangles) $ 空间复杂度：$ O(1) $ ","date":"2022-02-04T10:42:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1725.-%E5%8F%AF%E4%BB%A5%E5%BD%A2%E6%88%90%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E7%9F%A9%E5%BD%A2%E6%95%B0%E7%9B%AE/","title":"Leetcode 1725. 可以形成最大正方形的矩形数目"},{"content":"链接： https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/\n难度： 中等\n题目描述 给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。\n斐波那契数字定义为：\nF1 = 1 F2 = 1 Fn = Fn-1 + Fn-2 ， 其中 n \u0026gt; 2 。 数据保证对于给定的 k ，一定能找到可行解。\n示例 1： 输入： k = 7\n输出： 2\n解释： 斐波那契数字为：1，1，2，3，5，8，13，……\n对于 k = 7 ，我们可以得到 2 + 5 = 7 。\n示例 2： 输入： k = 10\n输出： 2\n解释： 对于 k = 10 ，我们可以得到 2 + 8 = 10 。\n示例 3： 输入： k = 19\n输出： 3\n解释： 对于 k = 19 ，我们可以得到 1 + 5 + 13 = 19 。\n提示： 1 \u0026lt;= k \u0026lt;= 109 解题思路 贪心 对于数字 k ，需要求得构成其和的斐波那契数最少的数量，不妨假设某一斐波那契数会选中两次。\n根据斐波那契递推公式，有 $$ f(n) = f(n-1) + f(n-2) $$ 当被选中两次时， $$ 2f(n) = f(n) + f(n-1) + f(n-2) \\tag{1} $$ 又 $$ f(n+1) = f(n) + f(n-1) $$ 则 $$ f(n-1) = f(n+1) - f(n) \\tag{2} $$ 将 $(2)$ 式带入 $(1)$ 式得： $$ \\begin{aligned} 2f(n) \u0026amp;= f(n) + f(n+1) - f(n) + f(n-2) \\\\ \u0026amp;= f(n+1) + f(n-1) \\end{aligned} $$ 可以发现若存在某个斐波那契数可以被选择两次则将其替换，最少数量不变。\n遵循上述原则，则可知，对于构成和为 k 的所有斐波那契数，均不相同。\n故使用贪心算法，每次选择最大的斐波那契数，即得到最小数量。\nfunc findMinFibonacciNumbers(k int) int { f := []int{1, 1} for f[len(f)-1] \u0026lt; k { f = append(f, f[len(f)-1]+f[len(f)-2]) } cnt := 0 for i := len(f) - 1; i \u0026gt;= 0; i-- { if k \u0026lt; f[i] { continue } k -= f[i] cnt++ if k == 0 { break } } return cnt } 复杂度 时间复杂度：$ O(\\log{k}) $ 空间复杂度：$ O(\\log{k}) $ ","date":"2022-02-03T11:11:52+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1414.-%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E6%9C%80%E5%B0%91%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%AD%97%E6%95%B0%E7%9B%AE/","title":"Leetcode 1414. 和为 K 的最少斐波那契数字数目"},{"content":"链接： https://leetcode-cn.com/problems/reverse-prefix-of-word/\n难度： 简单\n题目描述 给你一个下标从 0 开始的字符串 word 和一个字符 ch 。找出 ch 第一次出现的下标 i ，反转 word 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。如果 word 中不存在字符 ch ，则无需进行任何操作。\n例如，如果 word = \u0026quot;abcdefd\u0026quot; 且 ch = \u0026quot;d\u0026quot; ，那么你应该 反转 从下标 0 开始、直到下标 3 结束（含下标 3 ）。结果字符串将会是 \u0026quot;dcbaefd\u0026quot; 。 返回 结果字符串 。\n示例 1： 输入： word = \u0026ldquo;abcdefd\u0026rdquo;, ch = \u0026ldquo;d\u0026rdquo;\n输出： \u0026ldquo;dcbaefd\u0026rdquo;\n解释： \u0026ldquo;d\u0026rdquo; 第一次出现在下标 3 。\n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \u0026ldquo;dcbaefd\u0026rdquo; 。\n示例 2： 输入： word = \u0026ldquo;xyxzxe\u0026rdquo;, ch = \u0026ldquo;z\u0026rdquo;\n输出： \u0026ldquo;zxyxxe\u0026rdquo;\n解释： \u0026ldquo;z\u0026rdquo; 第一次也是唯一一次出现是在下标 3 。\n反转从下标 0 到下标 3（含下标 3）的这段字符，结果字符串是 \u0026ldquo;zxyxxe\u0026rdquo; 。\n示例 3： 输入： word = \u0026ldquo;abcd\u0026rdquo;, ch = \u0026ldquo;z\u0026rdquo;\n输出： \u0026ldquo;abcd\u0026rdquo;\n解释： \u0026ldquo;z\u0026rdquo; 不存在于 word 中。\n无需执行反转操作，结果字符串是 \u0026ldquo;abcd\u0026rdquo; 。\n提示： 1 \u0026lt;= word.length \u0026lt;= 250 word 由小写英文字母组成 ch 是一个小写英文字母 解题思路 模拟 顺序查找到目标字符首次出现的下标处，然后反转该段。\nfunc reversePrefix(word string, ch byte) string { for i := range word { // 找到 if word[i] == ch { t := []byte(word) // 反转 for j := 0; j \u0026lt; i; j, i = j+1, i-1 { t[j], t[i] = t[i], t[j] } word = string(t) break } } return word } 复杂度 时间复杂度：$ O(N), N = len(word) $ 空间复杂度：$ O(1) $ ","date":"2022-02-02T09:46:34+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2000.-%E5%8F%8D%E8%BD%AC%E5%8D%95%E8%AF%8D%E5%89%8D%E7%BC%80/","title":"Leetcode 2000. 反转单词前缀"},{"content":"链接： https://leetcode-cn.com/problems/longest-nice-substring/\n难度： 简单\n题目描述 当一个字符串 s 包含的每一种字母的大写和小写形式 同时 出现在 s 中，就称这个字符串 s 是 美好 字符串。比方说，\u0026quot;abABB\u0026quot; 是美好字符串，因为 'A' 和 'a' 同时出现了，且 'B' 和 'b' 也同时出现了。然而，\u0026quot;abA\u0026quot; 不是美好字符串因为 'b' 出现了，而 'B' 没有出现。\n给你一个字符串 s ，请你返回 s 最长的 美好子字符串 。如果有多个答案，请你返回 最早 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。\n示例 1： 输入： s = \u0026ldquo;YazaAay\u0026rdquo;\n输出： \u0026ldquo;aAa\u0026rdquo;\n解释： \u0026ldquo;aAa\u0026rdquo; 是一个美好字符串，因为这个子串中仅含一种字母，其小写形式 \u0026lsquo;a\u0026rsquo; 和大写形式 \u0026lsquo;A\u0026rsquo; 也同时出现了。\n\u0026ldquo;aAa\u0026rdquo; 是最长的美好子字符串。\n示例 2： 输入： s = \u0026ldquo;Bb\u0026rdquo;\n输出： \u0026ldquo;Bb\u0026rdquo;\n解释： \u0026ldquo;Bb\u0026rdquo; 是美好字符串，因为 \u0026lsquo;B\u0026rsquo; 和 \u0026lsquo;b\u0026rsquo; 都出现了。整个字符串也是原字符串的子字符串。\n示例 3： 输入： s = \u0026ldquo;c\u0026rdquo;\n输出： \u0026quot;\u0026quot;\n解释： 没有美好子字符串。\n示例 4： 输入： s = \u0026ldquo;dDzeE\u0026rdquo;\n输出： \u0026ldquo;dD\u0026rdquo;\n解释： \u0026ldquo;dD\u0026rdquo; 和 \u0026ldquo;eE\u0026rdquo; 都是最长美好子字符串。\n由于有多个美好子字符串，返回 \u0026ldquo;dD\u0026rdquo; ，因为它出现得最早。\n提示： 1 \u0026lt;= s.length \u0026lt;= 100 s 只包含大写和小写英文字母。 解题思路 枚举 + 哈希 枚举所有的子字符串，判定其是否为 美好子字符串，并记录最长的那一个。\n判定是否为 美好子字符串 时使用哈希表，确保每个出现的字母大下写均出现。\nfunc longestNiceSubstring(s string) string { result := \u0026#34;\u0026#34; for begin := 0; begin \u0026lt; len(s); begin++ { exist := make(map[byte]struct{}) Next: for i := begin; i \u0026lt; len(s); i++ { exist[s[i]] = struct{}{} // 长度不够，不用更新 if len(result) \u0026gt;= i-begin+1 { continue } // 判定是否为美好字符串 for char := range exist { if char \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; char \u0026lt;= \u0026#39;z\u0026#39; { if _, ok := exist[char-\u0026#39;a\u0026#39;+\u0026#39;A\u0026#39;]; !ok { continue Next } } else { if _, ok := exist[char-\u0026#39;A\u0026#39;+\u0026#39;a\u0026#39;]; !ok { continue Next } } } result = s[begin : i+1] } } return result } 复杂度 时间复杂度：$ O(N^3), N = len(s) $ 空间复杂度：$ O(N) $ 枚举 + 二进制 由于字符串仅包含大小写字母，美好子字符串 的判定可以采用二进制位，当代表大写字母和小写字母的两个二进制数完全相同时，才为 美好子字符串。\nfunc longestNiceSubstring(s string) string { result := \u0026#34;\u0026#34; for begin := 0; begin \u0026lt; len(s); begin++ { upper, lower := 0, 0 for i := begin; i \u0026lt; len(s); i++ { if s[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;z\u0026#39; { lower |= 1 \u0026lt;\u0026lt; (s[i] - \u0026#39;a\u0026#39;) } else { upper |= 1 \u0026lt;\u0026lt; (s[i] - \u0026#39;A\u0026#39;) } if lower == upper \u0026amp;\u0026amp; len(result) \u0026lt; i-begin+1 { result = s[begin : i+1] } } } return result } 复杂度 时间复杂度：$ O(N^2), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2022-02-01T09:45:38+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1763.-%E6%9C%80%E9%95%BF%E7%9A%84%E7%BE%8E%E5%A5%BD%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 1763. 最长的美好子字符串"},{"content":"链接： https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/\n难度： 简单\n题目描述 给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。\n示例 1： 输入： num = 14\n输出： 6\n解释：\n步骤 1) 14 是偶数，除以 2 得到 7 。\n步骤 2） 7 是奇数，减 1 得到 6 。\n步骤 3） 6 是偶数，除以 2 得到 3 。\n步骤 4） 3 是奇数，减 1 得到 2 。\n步骤 5） 2 是偶数，除以 2 得到 1 。\n步骤 6） 1 是奇数，减 1 得到 0 。\n示例 2： 输入： num = 8\n输出： 4\n解释：\n步骤 1） 8 是偶数，除以 2 得到 4 。\n步骤 2） 4 是偶数，除以 2 得到 2 。\n步骤 3） 2 是偶数，除以 2 得到 1 。\n步骤 4） 1 是奇数，减 1 得到 0 。\n示例 3： 输入： num = 123\n输出： 12\n提示： 0 \u0026lt;= num \u0026lt;= 106 解题思路 模拟 按照题设方法计算，使得 num 最后变为 0，统计所有的步数。\nfunc numberOfSteps(num int) int { steps := 0 for num \u0026gt; 0 { if num\u0026amp;1 == 1 { num-- } else { num /= 2 } steps++ } return steps } 复杂度 时间复杂度：$ O(\\log{num}) $ 空间复杂度：$ O(1) $ ","date":"2022-01-31T09:45:19+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1342.-%E5%B0%86%E6%95%B0%E5%AD%97%E5%8F%98%E6%88%90-0-%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","title":"Leetcode 1342. 将数字变成 0 的操作次数"},{"content":"链接： https://leetcode-cn.com/problems/uncommon-words-from-two-sentences/\n难度： 简单\n题目描述 句子 是一串由空格分隔的单词。每个 单词 仅由小写字母组成。\n如果某个单词在其中一个句子中恰好出现一次，在另一个句子中却 没有出现 ，那么这个单词就是 不常见的 。\n给你两个 句子 s1 和 s2 ，返回所有 不常用单词 的列表。返回列表中单词可以按 任意顺序 组织。\n示例 1： 输入： s1 = \u0026ldquo;this apple is sweet\u0026rdquo;, s2 = \u0026ldquo;this apple is sour\u0026rdquo;\n输出： [\u0026ldquo;sweet\u0026rdquo;,\u0026ldquo;sour\u0026rdquo;]\n示例 2： 输入： s1 = \u0026ldquo;apple apple\u0026rdquo;, s2 = \u0026ldquo;banana\u0026rdquo;\n输出： [\u0026ldquo;banana\u0026rdquo;]\n提示： 1 \u0026lt;= s1.length, s2.length \u0026lt;= 200 s1 和 s2 由小写英文字母和空格组成 s1 和 s2 都不含前导或尾随空格 s1 和 s2 中的所有单词间均由单个空格分隔 解题思路 哈希 使用哈希表记录两个句子中出现的每个单词的数量，将出现次数为 1 的取出并返回。\nfunc uncommonFromSentences(s1 string, s2 string) []string { cnt := make(map[string]int) for _, word := range strings.Fields(s1) { cnt[word]++ } for _, word := range strings.Fields(s2) { cnt[word]++ } words := make([]string, 0, len(cnt)) for word, c := range cnt { if c == 1 { words = append(words, word) } } return words } 复杂度 时间复杂度：$ O(N_1+N_2), N_1 = len(s1), N_2 = len(s2) $ 空间复杂度：$ O(N_1+N_2) $ ","date":"2022-01-30T09:10:05+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-884.-%E4%B8%A4%E5%8F%A5%E8%AF%9D%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%B8%B8%E8%A7%81%E5%8D%95%E8%AF%8D/","title":"Leetcode 884. 两句话中的不常见单词"},{"content":"链接： https://leetcode-cn.com/problems/map-of-highest-peak/\n难度： 中等\n题目描述 给你一个大小为 m x n 的整数矩阵 isWater ，它代表了一个由 陆地 和 水域 单元格组成的地图。\n如果 isWater[i][j] == 0 ，格子 (i, j) 是一个 陆地 格子。 如果 isWater[i][j] == 1 ，格子 (i, j) 是一个 水域 格子。 你需要按照如下规则给每个单元格安排高度：\n每个格子的高度都必须是非负的。 如果一个格子是是 水域 ，那么它的高度必须为 0 。 任意相邻的格子高度差 至多 为 1 。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边） 找到一种安排高度的方案，使得矩阵中的最高高度值 最大 。\n请你返回一个大小为 m x n 的整数矩阵 height ，其中 height[i][j] 是格子 (i, j) 的高度。如果有多种解法，请返回 任意一个 。\n示例 1： 输入： isWater = [[0,1],[0,0]]\n输出： [[1,0],[2,1]]\n解释： 上图展示了给各个格子安排的高度。\n蓝色格子是水域格，绿色格子是陆地格。\n示例 2： 输入： isWater = [[0,0,1],[1,0,0],[0,0,0]]\n输出： [[1,1,0],[0,1,1],[1,2,2]]\n解释： 所有安排方案中，最高可行高度为 2 。\n任意安排方案中，只要最高高度为 2 且符合上述规则的，都为可行方案。\n提示： m == isWater.length n == isWater[i].length 1 \u0026lt;= m, n \u0026lt;= 1000 isWater[i][j] 要么是 0 ，要么是 1 。 至少有 1 个水域格子。 解题思路 广度优先搜索 从水域开始进行广度优先搜索，每向外扩散一步，则高度 + 1。\n每个单元格的最高高度由距离最近的水域确定，初始时，所有水域入队，按照等高线扩散，既满足题目要求。\nfunc highestPeak(isWater [][]int) [][]int { height := make([][]int, len(isWater)) queue := list.New() visit := make([][]bool, len(isWater)) for i, line := range isWater { height[i] = make([]int, len(line)) visit[i] = make([]bool, len(line)) for j, cell := range line { if cell == 1 { queue.PushBack([]int{i, j}) visit[i][j] = true } } } directions := [][2]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} for h := 0; queue.Len() \u0026gt; 0; h++ { // 等高部分 for i := queue.Len(); i \u0026gt; 0; i-- { p := queue.Remove(queue.Front()).([]int) height[p[0]][p[1]] = h for _, d := range directions { nextPos := []int{p[0] + d[0], p[1] + d[1]} // 越界判断 if nextPos[0] \u0026lt; 0 || nextPos[0] \u0026gt;= len(isWater) || nextPos[1] \u0026lt; 0 || nextPos[1] \u0026gt;= len(isWater[0]) { continue } if !visit[nextPos[0]][nextPos[1]] { queue.PushBack(nextPos) visit[nextPos[0]][nextPos[1]] = true } } } } return height } 复杂度 时间复杂度：$ O(m*n) $ 空间复杂度：$ O(m*n) $ ","date":"2022-01-29T09:42:05+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1765.-%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E9%AB%98%E7%82%B9/","title":"Leetcode 1765. 地图中的最高点"},{"content":"链接： https://leetcode-cn.com/problems/number-of-valid-words-in-a-sentence/\n难度： 简单\n题目描述 句子仅由小写字母（'a' 到 'z'）、数字（'0' 到 '9'）、连字符（'-'）、标点符号（'!'、'.' 和 ','）以及空格（' '）组成。每个句子可以根据空格分解成 一个或者多个 token ，这些 token 之间由一个或者多个空格 ' ' 分隔。\n如果一个 token 同时满足下述条件，则认为这个 token 是一个有效单词：\n仅由小写字母、连字符和/或标点（不含数字）。 至多一个 连字符 '-' 。如果存在，连字符两侧应当都存在小写字母（\u0026quot;a-b\u0026quot; 是一个有效单词，但 \u0026quot;-ab\u0026quot; 和 \u0026quot;ab-\u0026quot; 不是有效单词）。 至多一个 标点符号。如果存在，标点符号应当位于 token 的 末尾 。 这里给出几个有效单词的例子：\u0026quot;a-b.\u0026quot;、\u0026quot;afad\u0026quot;、\u0026quot;ba-c\u0026quot;、\u0026quot;a!\u0026quot; 和 \u0026quot;!\u0026quot; 。\n给你一个字符串 sentence ，请你找出并返回 sentence 中 有效单词的数目 。\n示例 1： 输入： sentence = \u0026ldquo;cat and dog\u0026rdquo;\n输出： 3\n解释： 句子中的有效单词是 \u0026ldquo;cat\u0026rdquo;、\u0026ldquo;and\u0026rdquo; 和 \u0026ldquo;dog\u0026rdquo;\n示例 2： 输入： sentence = \u0026ldquo;!this 1-s b8d!\u0026rdquo;\n输出： 0\n解释： 句子中没有有效单词\n\u0026ldquo;!this\u0026rdquo; 不是有效单词，因为它以一个标点开头\n\u0026ldquo;1-s\u0026rdquo; 和 \u0026ldquo;b8d\u0026rdquo; 也不是有效单词，因为它们都包含数字\n示例 3： 输入： sentence = \u0026ldquo;alice and bob are playing stone-game10\u0026rdquo; 输出： 5 解释： 句子中的有效单词是 \u0026ldquo;alice\u0026rdquo;、\u0026ldquo;and\u0026rdquo;、\u0026ldquo;bob\u0026rdquo;、\u0026ldquo;are\u0026rdquo; 和 \u0026ldquo;playing\u0026rdquo; \u0026ldquo;stone-game10\u0026rdquo; 不是有效单词，因为它含有数字\n示例 4： 输入： sentence = \u0026ldquo;he bought 2 pencils, 3 erasers, and 1 pencil-sharpener.\u0026rdquo;\n输出： 6\n解释： 句子中的有效单词是 \u0026ldquo;he\u0026rdquo;、\u0026ldquo;bought\u0026rdquo;、\u0026ldquo;pencils,\u0026quot;、\u0026ldquo;erasers,\u0026quot;、\u0026ldquo;and\u0026rdquo; 和 \u0026ldquo;pencil-sharpener.\u0026rdquo;\n提示： 1 \u0026lt;= sentence.length \u0026lt;= 1000 sentence 由小写英文字母、数字（0-9）、以及字符（' '、'-'、'!'、'.' 和 ','）组成 句子中至少有 1 个 token 解题思路 模拟 遍历字符串，首先以空格为单位分割出 token， 然后判断 token 是否为有效的单词。\n遍历 token ，当存在一下情况时，不构成有效单词：\n存在数字； 标点符号不在末尾； 连字符数量超过1 或者 连字符后面不是小写字母 当存在上述情况之一时，便可跳过此次遍历，继续找寻下一个 token。\nfunc countValidWords(sentence string) int { cnt := 0 start := 0 for i := 0; i \u0026lt;= len(sentence); i++ { if i == len(sentence) || sentence[i] == \u0026#39; \u0026#39; { // 存在有效 token if start \u0026lt; i { hasHyphen := false for j := start; j \u0026lt; i; j++ { // 存在数字，不是有效单词 if sentence[j] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; sentence[j] \u0026lt;= \u0026#39;9\u0026#39; { cnt-- break } // 标点符号不在末尾，不是有效单词 if (sentence[j] == \u0026#39;,\u0026#39; || sentence[j] == \u0026#39;.\u0026#39; || sentence[j] == \u0026#39;!\u0026#39;) \u0026amp;\u0026amp; j != i-1 { cnt-- break } // if sentence[j] == \u0026#39;-\u0026#39; { // 连字符在头尾 或 后面是标点 或 数量超过1 if j == start || j == i-1 || sentence[j+1] == \u0026#39;,\u0026#39; || sentence[j+1] == \u0026#39;.\u0026#39; || sentence[j+1] == \u0026#39;!\u0026#39; || hasHyphen { cnt-- break } hasHyphen = true } } cnt++ } start = i + 1 } } return cnt } 复杂度 时间复杂度：$ O(N), N = len(sentence) $ 空间复杂度：$ O(1) $ ","date":"2022-01-27T09:58:43+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2047.-%E5%8F%A5%E5%AD%90%E4%B8%AD%E7%9A%84%E6%9C%89%E6%95%88%E5%8D%95%E8%AF%8D%E6%95%B0/","title":"Leetcode 2047. 句子中的有效单词数"},{"content":"链接： https://leetcode-cn.com/problems/detect-squares/\n难度： 中等\n题目描述 给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：\n添加 一个在数据流中的新点到某个数据结构中。可以添加 重复 的点，并会视作不同的点进行处理。 给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 面积为正 的 轴对齐正方形 ，统计 满足该要求的方案数目。 轴对齐正方形 是一个正方形，除四条边长度相同外，还满足每条边都与 x-轴 或 y-轴 平行或垂直。\n实现 DetectSquares 类：\nDetectSquares() 使用空数据结构初始化对象 void add(int[] point) 向数据结构添加一个新的点 point = [x, y] int count(int[] point) 统计按上述方式与点 point = [x, y] 共同构造 轴对齐正方形 的方案数。 示例： 输入：\n[\u0026ldquo;DetectSquares\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;count\u0026rdquo;, \u0026ldquo;count\u0026rdquo;, \u0026ldquo;add\u0026rdquo;, \u0026ldquo;count\u0026rdquo;]\n[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]\n输出：\n[null, null, null, null, 1, 0, null, 2]\n解释：\nDetectSquares detectSquares = new DetectSquares();\ndetectSquares.add([3, 10]);\ndetectSquares.add([11, 2]);\ndetectSquares.add([3, 2]);\ndetectSquares.count([11, 10]); // 返回 1 。你可以选择：\n// - 第一个，第二个，和第三个点\ndetectSquares.count([14, 8]); // 返回 0 。查询点无法与数据结构中的这些点构成正方形。\ndetectSquares.add([11, 2]); // 允许添加重复的点。\ndetectSquares.count([11, 10]); // 返回 2 。你可以选择：\n// - 第一个，第二个，和第三个点\n// - 第一个，第三个，和第四个点\n提示： point.length == 2 0 \u0026lt;= x, y \u0026lt;= 1000 调用 add 和 count 的 总次数 最多为 5000 解题思路 哈希 使用哈希表记录相同横坐标点的纵坐标及数量。\n统计构成正方形的数量时，首先找出所有与输入点横坐标相同的点。当这一对点确定后，则剩余两个点的坐标也可以计算得出，存在左右两种情况，分别进行计算求和。每个正方形的数量为与该点构成正方形的其余三个点的数量的乘积。\ntype DetectSquares struct { cnt map[int]map[int]int } func Constructor() DetectSquares { return DetectSquares{ cnt: make(map[int]map[int]int), } } func (this *DetectSquares) Add(point []int) { if this.cnt[point[0]] == nil { this.cnt[point[0]] = make(map[int]int) } this.cnt[point[0]][point[1]]++ } func (this *DetectSquares) Count(point []int) int { sum := 0 for y := range this.cnt[point[0]] { a := point[1] - y // 边长 // 面积为 0，跳过 if a == 0 { continue } sum += this.cnt[point[0]][y] * this.cnt[point[0]-a][point[1]] * this.cnt[point[0]-a][y] // 一侧 sum += this.cnt[point[0]][y] * this.cnt[point[0]+a][point[1]] * this.cnt[point[0]+a][y] // 另一侧 } return sum } 复杂度 时间复杂度： add：$ O(1) $ count：$ O(N), N = len(points) $ 空间复杂度：$ O(N) $ ","date":"2022-01-26T09:32:13+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2013.-%E6%A3%80%E6%B5%8B%E6%AD%A3%E6%96%B9%E5%BD%A2/","title":"Leetcode 2013. 检测正方形"},{"content":"链接： https://leetcode-cn.com/problems/count-of-matches-in-tournament/\n难度： 简单\n题目描述 给你一个整数 n ，表示比赛中的队伍数。比赛遵循一种独特的赛制：\n如果当前队伍数是 偶数 ，那么每支队伍都会与另一支队伍配对。总共进行 n / 2 场比赛，且产生 n / 2 支队伍进入下一轮。 如果当前队伍数为 奇数 ，那么将会随机轮空并晋级一支队伍，其余的队伍配对。总共进行 (n - 1) / 2 场比赛，且产生 (n - 1) / 2 + 1 支队伍进入下一轮。 返回在比赛中进行的配对次数，直到决出获胜队伍为止。\n示例 1： 输入： n = 7\n输出： 6\n解释： 比赛详情：\n第 1 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。 第 2 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。 第 3 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。\n总配对次数 = 3 + 2 + 1 = 6 示例 2： 输入： n = 14\n输出： 13\n解释： 比赛详情：\n第 1 轮：队伍数 = 14 ，配对次数 = 7 ，7 支队伍晋级。 第 2 轮：队伍数 = 7 ，配对次数 = 3 ，4 支队伍晋级。 第 3 轮：队伍数 = 4 ，配对次数 = 2 ，2 支队伍晋级。 第 4 轮：队伍数 = 2 ，配对次数 = 1 ，决出 1 支获胜队伍。\n总配对次数 = 7 + 3 + 2 + 1 = 13 提示： 1 \u0026lt;= n \u0026lt;= 200 解题思路 模拟 按照题设方案，求得每一轮配对次数并求和，直到剩余队伍数量为 1 为止。\nfunc numberOfMatches(n int) int { sum := 0 for n \u0026gt; 1 { sum += n / 2 if n\u0026amp;1 == 1 { n = n/2 + 1 } else { n /= 2 } } return sum } 复杂度 时间复杂度：$ O(\\log{n}) $ 空间复杂度：$ O(1) $ 数学 每次配对均会淘汰一支队伍，最后仅有一支队伍获胜，所以共淘汰了 n-1 支队伍，即完成了 n-1 次配对。\nfunc numberOfMatches(n int) int { return n - 1 } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2022-01-25T09:27:56+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1688.-%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E9%85%8D%E5%AF%B9%E6%AC%A1%E6%95%B0/","title":"Leetcode 1688. 比赛中的配对次数"},{"content":"链接： https://leetcode-cn.com/problems/stock-price-fluctuation/\n难度： 中等\n题目描述 给你一支股票价格的数据流。数据流中每一条记录包含一个 时间戳 和该时间点股票对应的 价格 。\n不巧的是，由于股票市场内在的波动性，股票价格记录可能不是按时间顺序到来的。某些情况下，有的记录可能是错的。如果两个有相同时间戳的记录出现在数据流中，前一条记录视为错误记录，后出现的记录 更正 前一条错误的记录。\n请你设计一个算法，实现：\n更新 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将 更正 之前的错误价格。 找到当前记录里 最新股票价格 。最新股票价格 定义为时间戳最晚的股票价格。 找到当前记录里股票的 最高价格 。 找到当前记录里股票的 最低价格 。 请你实现 StockPrice 类：\nStockPrice() 初始化对象，当前无股票价格记录。 void update(int timestamp, int price) 在时间点 timestamp 更新股票价格为 price 。 int current() 返回股票 最新价格 。 int maximum() 返回股票 最高价格 。 int minimum() 返回股票 最低价格 。 示例： 输入：\n[\u0026ldquo;StockPrice\u0026rdquo;, \u0026ldquo;update\u0026rdquo;, \u0026ldquo;update\u0026rdquo;, \u0026ldquo;current\u0026rdquo;, \u0026ldquo;maximum\u0026rdquo;, \u0026ldquo;update\u0026rdquo;, \u0026ldquo;maximum\u0026rdquo;, \u0026ldquo;update\u0026rdquo;, \u0026ldquo;minimum\u0026rdquo;]\n[[], [1, 10], [2, 5], [], [], [1, 3], [], [4, 2], []]\n输出：\n[null, null, null, 5, 10, null, 5, null, 2]\n解释：\nStockPrice stockPrice = new StockPrice();\nstockPrice.update(1, 10); // 时间戳为 [1] ，对应的股票价格为 [10] 。\nstockPrice.update(2, 5); // 时间戳为 [1,2] ，对应的股票价格为 [10,5] 。\nstockPrice.current(); // 返回 5 ，最新时间戳为 2 ，对应价格为 5 。\nstockPrice.maximum(); // 返回 10 ，最高价格的时间戳为 1 ，价格为 10 。\nstockPrice.update(1, 3); // 之前时间戳为 1 的价格错误，价格更新为 3 。\n// 时间戳为 [1,2] ，对应股票价格为 [3,5] 。\nstockPrice.maximum(); // 返回 5 ，更正后最高价格为 5 。\nstockPrice.update(4, 2); // 时间戳为 [1,2,4] ，对应价格为 [3,5,2] 。\nstockPrice.minimum(); // 返回 2 ，最低价格时间戳为 4 ，价格为 2 。\n提示： 1 \u0026lt;= timestamp, price \u0026lt;= 109 update，current，maximum 和 minimum 总 调用次数不超过 105 。 current，maximum 和 minimum 被调用时，update 操作 至少 已经被调用过 一次 。 解题思路 哈希表 + 堆 首先，统一时间戳可能会有多个价格，以最后到来的为准，则需要使用到哈希表，确保 timestamp 唯一。\n获取当前价格，即时间戳最晚的那个价格，使用一个变量记录时间戳的最大值，每次 update 时更新。\n对于获取最大值/最小值操作，可以各使用一个堆存储。由于存在错误的价格，在堆中不方便维护，故在每次获取最大值时判定：当堆中的价格与哈希表中的价格不一致时，说明该条记录是无效的，从堆中弹出；不断执行，直到找到与哈希表中一致的价格为止，返回该价格。\n注意： 当某一时刻新到来的价格与之前的一致时，该条记录没有效果，便将其忽略，降低堆的无效膨胀。\ntype Pair struct { timestamp int price int } type MinHeap struct { elems []*Pair } func (this *MinHeap) Len() int { return len(this.elems) } func (this *MinHeap) Less(i, j int) bool { return this.elems[i].price \u0026lt; this.elems[j].price } func (this *MinHeap) Swap(i, j int) { this.elems[i], this.elems[j] = this.elems[j], this.elems[i] } func (this *MinHeap) Push(elem interface{}) { this.elems = append(this.elems, elem.(*Pair)) } func (this *MinHeap) Pop() interface{} { elem := this.elems[this.Len()-1] this.elems = this.elems[:this.Len()-1] return elem } type MaxHeap struct { MinHeap } func (this *MaxHeap) Less(i, j int) bool { return this.MinHeap.Less(j, i) } type StockPrice struct { price map[int]int maxTime int maxHeap *MaxHeap minHeap *MinHeap } func Constructor() StockPrice { return StockPrice{ price: make(map[int]int), maxTime: 0, maxHeap: \u0026amp;MaxHeap{}, minHeap: \u0026amp;MinHeap{}, } } func (this *StockPrice) Update(timestamp int, price int) { if this.price[timestamp] == price { return } this.price[timestamp] = price if this.maxTime \u0026lt; timestamp { this.maxTime = timestamp } pair := \u0026amp;Pair{ timestamp: timestamp, price: price, } heap.Push(this.maxHeap, pair) heap.Push(this.minHeap, pair) } func (this *StockPrice) Current() int { return this.price[this.maxTime] } func (this *StockPrice) Maximum() int { for ; this.price[this.maxHeap.elems[0].timestamp] != this.maxHeap.elems[0].price; heap.Pop(this.maxHeap) { } return this.maxHeap.elems[0].price } func (this *StockPrice) Minimum() int { for ; this.price[this.minHeap.elems[0].timestamp] != this.minHeap.elems[0].price; heap.Pop(this.minHeap) { } return this.minHeap.elems[0].price } 复杂度 时间复杂度： update：$ O(\\log{N}), N = size(heap) $ current：$ O(1) $ maximum：$ O(\\log{N}) $ minumux：$ O(\\log{N}) $ 空间复杂度：$ O(N) $ ","date":"2022-01-23T10:22:12+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2034.-%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E6%B3%A2%E5%8A%A8/","title":"Leetcode 2034. 股票价格波动"},{"content":"链接： https://leetcode-cn.com/problems/remove-palindromic-subsequences/\n难度： 简单\n题目描述 给你一个字符串 s，它仅由字母 'a' 和 'b' 组成。每一次删除操作都可以从 s 中删除一个回文 子序列。\n返回删除给定字符串中所有字符（字符串为空）的最小删除次数。\n「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。\n「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。\n示例 1： 输入： s = \u0026ldquo;ababa\u0026rdquo;\n输出： 1\n解释： 字符串本身就是回文序列，只需要删除一次。\n示例 2： 输入： s = \u0026ldquo;abb\u0026rdquo;\n输出： 2\n解释： \u0026ldquo;abb\u0026rdquo; -\u0026gt; \u0026ldquo;bb\u0026rdquo; -\u0026gt; \u0026ldquo;\u0026rdquo;.\n先删除回文子序列 \u0026ldquo;a\u0026rdquo;，然后再删除 \u0026ldquo;bb\u0026rdquo;。\n示例 3： 输入： s = \u0026ldquo;baabb\u0026rdquo;\n输出： 2\n解释： \u0026ldquo;baabb\u0026rdquo; -\u0026gt; \u0026ldquo;b\u0026rdquo; -\u0026gt; \u0026ldquo;\u0026rdquo;.\n先删除回文子序列 \u0026ldquo;baab\u0026rdquo;，然后再删除 \u0026ldquo;b\u0026rdquo;。\n提示： 1 \u0026lt;= s.length \u0026lt;= 1000 s 仅包含字母 'a' 和 'b' 解题思路 由于给定的字符串中仅包含两种字符，可以通过先删除一种，在删除另一种的方式，从而得知最小删除次数 最大 为 2。\n若还有可能降低该次数，即最小删除次数降低到 1 次，这要求字符串本身就是一个回文串，进行一次判定即可。\nfunc removePalindromeSub(s string) int { for i, j := 0, len(s)-1; i \u0026lt; j; i, j = i+1, j-1 { // 不构成回文串 if s[i] != s[j] { return 2 } } return 1 } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2022-01-22T09:45:27+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1332.-%E5%88%A0%E9%99%A4%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/","title":"Leetcode 1332. 删除回文子序列"},{"content":"链接： https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/\n难度： 简单\n题目描述 给你一个整数数组 arr ，你一开始在数组的第一个元素处（下标为 0）。\n每一步，你可以从下标 i 跳到下标：\ni + 1 满足：i + 1 \u0026lt; arr.length i - 1 满足：i - 1 \u0026gt;= 0 j 满足：arr[i] == arr[j] 且 i != j 请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。\n注意： 任何时候你都不能跳到数组外面。\n示例 1： 输入： arr = [100,-23,-23,404,100,23,23,23,3,404]\n输出： 3\n解释： 那你需要跳跃 3 次，下标依次为 0 \u0026ndash;\u0026gt; 4 \u0026ndash;\u0026gt; 3 \u0026ndash;\u0026gt; 9 。下标 9 为数组的最后一个元素的下标。\n示例 2： 输入： arr = [7]\n输出： 0\n解释： 一开始就在最后一个元素处，所以你不需要跳跃。\n示例 3： 输入： arr = [7,6,9,6,9,6,9,7]\n输出： 1\n解释： 你可以直接从下标 0 处跳到下标 7 处，也就是数组的最后一个元素处。\n示例 4： 输入： arr = [6,1,9]\n输出： 2\n示例 5： 输入： arr = [11,22,7,7,7,7,7,7,7,22,13]\n输出： 3\n提示： 1 \u0026lt;= arr.length \u0026lt;= 5 * 104 -108 \u0026lt;= arr[i] \u0026lt;= 108 解题思路 广度优先搜索 对于相同元素，从其中任意下标处可以经过一跳到达其他下标处了；首先进行一次预处理，得到相同元素的所有下标。\n题目描述是一个权为 1 的有向图，寻找两个结点之间的最短路径，使用广度优先搜索策略。\n相同元素一次性全部处理，处理后删除这一部分，以降低因稠密导致的高时间复杂度。\nfunc minJumps(arr []int) int { sameIdxes := make(map[int]map[int]struct{}) for i, num := range arr { if sameIdxes[num] == nil { sameIdxes[num] = make(map[int]struct{}) } sameIdxes[num][i] = struct{}{} } visit := make([]bool, len(arr)) q := list.New() q.PushBack(0) visit[0] = true for step := 0; q.Len() \u0026gt; 0; step++ { for i := q.Len(); i \u0026gt; 0; i-- { curIdx := q.Remove(q.Front()).(int) if curIdx == len(arr)-1 { return step } if curIdx+1 \u0026lt; len(arr) \u0026amp;\u0026amp; !visit[curIdx+1] { q.PushBack(curIdx + 1) visit[curIdx+1] = true } if curIdx \u0026gt; 0 \u0026amp;\u0026amp; !visit[curIdx-1] { q.PushBack(curIdx - 1) visit[curIdx-1] = true } for idx := range sameIdxes[arr[curIdx]] { if !visit[idx] { q.PushBack(idx) visit[idx] = true } } delete(sameIdxes, arr[curIdx]) } } return len(arr) - 1 } 复杂度 时间复杂度：$ O(N), N = len(arr) $ 空间复杂度：$ O(N) $ ","date":"2022-01-21T10:32:55+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1345.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-iv/","title":"Leetcode 1345. 跳跃游戏 IV"},{"content":"链接： https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/\n难度： 简单\n题目描述 Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 stones ，其中 stones[i] 是第 i 个石子的价值。\nAlice 和 Bob 轮流进行自己的回合，Alice 先手。每一回合，玩家需要从 stones 中移除任一石子。\n如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 3 整除，那么该玩家就 输掉游戏 。 如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。 假设两位玩家均采用 最佳 决策。如果 Alice 获胜，返回 true ；如果 Bob 获胜，返回 false 。\n示例 1： 输入： stones = [2,1]\n输出： true\n解释： 游戏进行如下：\n回合 1：Alice 可以移除任意一个石子。 回合 2：Bob 移除剩下的石子。 已移除的石子的值总和为 1 + 2 = 3 且可以被 3 整除。因此，Bob 输，Alice 获胜。\n示例 2： 输入： stones = [2]\n输出： false\n解释： Alice 会移除唯一一个石子，已移除石子的值总和为 2 。\n由于所有石子都已移除，且值总和无法被 3 整除，Bob 获胜。\n示例 3： 输入： stones = [5,1,2,4,3]\n输出： false\n解释： Bob 总会获胜。其中一种可能的游戏进行方式如下：\n回合 1：Alice 可以移除值为 1 的第 2 个石子。已移除石子值总和为 1 。 回合 2：Bob 可以移除值为 3 的第 5 个石子。已移除石子值总和为 = 1 + 3 = 4 。 回合 3：Alices 可以移除值为 4 的第 4 个石子。已移除石子值总和为 = 1 + 3 + 4 = 8 。 回合 4：Bob 可以移除值为 2 的第 3 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 = 10. 回合 5：Alice 可以移除值为 5 的第 1 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 + 5 = 15. Alice 输掉游戏，因为已移除石子值总和（15）可以被 3 整除，Bob 获胜。\n提示： 1 \u0026lt;= stones.length \u0026lt;= 105 1 \u0026lt;= stones[i] \u0026lt;= 104 解题思路 模拟 由于 Bob 有多种获胜方法，而 Alice 仅一种，即迫使 Bob 移除石子后，移除石子的价值 总和 可以被 3 整除， 故对 Alice 的获胜条件进行分析。\n进行价值总和条件判断时，只需判断对被 3 整除的贡献度，即 1 与 4 对其贡献是一样的，所以对所有的石对 3 取模，得到价值分别为 0、1 和 2 的石子若干，不妨设对应的数量为 cnt[0]、cnt[1] 和 cnt[2]。\nAlice 首次移除时，只能移除价值为 1 或 2 的石子，后续可以移除并保持不败的序列是固定的：\n当 Alice 首次移除价值为 1 的石子时，移除序列为 1 -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; \u0026hellip; 当 Alice 首次移除价值为 2 的石子时，移除序列为 2 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; 2 -\u0026gt; \u0026hellip; 在上述序列中的任意位置插入价值为 0 的石子，不会对序列本身的顺序造成影响，但当 cnt[0] 为奇数时，相当于 Alice 和 Bob 进行了先后手的交换。\n通过分析以上情况，得知 Alice 的获胜条件：\n当 Alice 首次移除的是价值为 1 的石子时： 若价值为 cnt[0] 为偶数，则后续 Bob 每次都需要移除价值为 1 的石子，当数量不足时而被迫移除价值为 2 的石子时，就会落败；即 cnt[1] ≤ cnt[2]； 若价值为 cnt[0] 为奇数，则后续 Bob 每次都需要移除价值为 2 的石子，当数量不足时而被迫移除价值为 1 的石子时，就会落败；即 cnt[1] - cnt[2] ≥ 3； 当 Alice 首次移除的是价值为 2 的石子时： 若价值为 cnt[0] 为偶数，则后续 Bob 每次都需要移除价值为 2 的石子，当数量不足时而被迫移除价值为 1 的石子时，就会落败；即 cnt[2] ≤ cnt[1]； 若价值为 cnt[0] 为奇数，则后续 Bob 每次都需要移除价值为 1 的石子，当数量不足时而被迫移除价值为 2 的石子时，就会落败；即 cnt[2] - cnt[1] ≥ 3 ； 归纳上述 Alice 获胜的四种条件：\ncnt[0] % 2 == 0 \u0026amp;\u0026amp; 0 \u0026lt; cnt[1] ≤ cnt[2] cnt[0] % 2 == 0 \u0026amp;\u0026amp; 0 \u0026lt; cnt[2] ≤ cnt[1] cnt[0] % 2 == 1 \u0026amp;\u0026amp; cnt[1] - cnt[2] ≥ 3 cnt[0] % 2 == 1 \u0026amp;\u0026amp; cnt[2] - cnt[1] ≥ 3 整理合并得到如下两种情况，满足其一 Alice 即可：\ncnt[0] % 2 == 1 \u0026amp;\u0026amp; abs(cnt[2] - cnt[1]) ≥ 3 cnt[0] % 2 == 0 \u0026amp;\u0026amp; cnt[1] \u0026gt; 0 \u0026amp;\u0026amp; cnt[2] \u0026gt; 0 func stoneGameIX(stones []int) bool { if len(stones) \u0026lt; 2 { return false } cnt := [...]int{0, 0, 0} for _, stone := range stones { cnt[stone%3]++ } return (cnt[0]\u0026amp;1 == 1 \u0026amp;\u0026amp; (cnt[2]-cnt[1] \u0026gt;= 3 || cnt[1]-cnt[2] \u0026gt;= 3)) || (cnt[0]\u0026amp;1 == 0 \u0026amp;\u0026amp; cnt[1] \u0026gt; 0 \u0026amp;\u0026amp; cnt[2] \u0026gt; 0) } 复杂度 时间复杂度：$ O(N), N = len(stones) $ 空间复杂度：$ O(1) $ ","date":"2022-01-20T10:10:35+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2029.-%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F-ix/","title":"Leetcode 2029. 石子游戏 IX"},{"content":"链接： https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/\n难度： 中等\n题目描述 给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) \u0026lt;= k 。如果存在，返回 true ；否则，返回 false 。\n示例 1： 输入：nums = [1,2,3,1], k = 3 输出：true\n示例 2： 输入：nums = [1,0,1,1], k = 1 输出：true\n示例 3： 输入：nums = [1,2,3,1,2,3], k = 2 输出：false\n提示： 1 \u0026lt;= nums.length \u0026lt;= 105 -109 \u0026lt;= nums[i] \u0026lt;= 109 0 \u0026lt;= k \u0026lt;= 105 解题思路 暴力求解 对于每个 i，枚举满足 abs(i - j) \u0026lt;= k 的所有 j，判断是否存在与 nums[i] 相等的数。\nfunc containsNearbyDuplicate(nums []int, k int) bool { for i := 1; i \u0026lt; len(nums); i++ { j := i - k if j \u0026lt; 0 { j = 0 } for ; j \u0026lt; i; j++ { if nums[i] == nums[j] { return true } } } return false } 复杂度 时间复杂度：$ O(N*k), N = len(nums) $ 空间复杂度：$ O(1) $ 哈希 使用哈希表存储每个数的下标，当存在相同的数时，更新下标，以缩短与当前遍历到的数下标距离。\n遍历过程中，判定与其相同的数字下标是否满足 abs(i - j) \u0026lt;= k。\nfunc containsNearbyDuplicate(nums []int, k int) bool { idx := make(map[int]int) for i, num := range nums { if _, ok := idx[num]; ok \u0026amp;\u0026amp; i-idx[num] \u0026lt;= k { return true } idx[num] = i } return false } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ 哈希 + 滑动窗口 维护一个滑动窗口，则在此范围内的数字下标均满足 abs(i - j) \u0026lt;= k。\n另使用哈希表记录存在于滑动窗口中的数字，若存在与新加入滑动窗口相同的数，则返回 true。\nfunc containsNearbyDuplicate(nums []int, k int) bool { exist := make(map[int]struct{}) for i, num := range nums { if i \u0026gt; k { delete(exist, nums[i-k-1]) } if _, ok := exist[num]; ok { return true } exist[num] = struct{}{} } return false } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(k) $ ","date":"2022-01-19T09:31:46+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-219.-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii/","title":"Leetcode 219. 存在重复元素 II"},{"content":"链接： https://leetcode-cn.com/problems/random-pick-with-weight/\n难度： 中等\n题目描述 给定一个 24 小时制（小时:分钟 \u0026ldquo;HH:MM\u0026rdquo;）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。\n示例 1： 输入： timePoints = [\u0026ldquo;23:59\u0026rdquo;,\u0026ldquo;00:00\u0026rdquo;]\n输出： 1\n示例 2： 输入： timePoints = [\u0026ldquo;00:00\u0026rdquo;,\u0026ldquo;23:59\u0026rdquo;,\u0026ldquo;00:00\u0026rdquo;]\n输出： 0\n提示： 2 \u0026lt;= timePoints \u0026lt;= 2 * 104 timePoints[i] 格式为 \u0026ldquo;HH:MM\u0026rdquo; 解题思路 排序 根据时间的先后顺序排序，最小的差必定在相邻的两个时间中产生。\n通过一次遍历，找出最小时间差。\n注意： 首尾也构成一对相邻时间。\nfunc findMinDifference(timePoints []string) int { sort.Strings(timePoints) calcInternal := func(timePoints1, timePoints2 string) int { internal := int(timePoints1[4]) - int(timePoints2[4]) internal += (int(timePoints1[3]) - int(timePoints2[3])) * 10 internal += (int(timePoints1[1]) - int(timePoints2[1])) * 60 internal += (int(timePoints1[0]) - int(timePoints2[0])) * 600 if internal \u0026lt; 0 { internal = -internal } return internal } minInternal := 24*60 - calcInternal(timePoints[0], timePoints[len(timePoints)-1]) for i := 1; i \u0026lt; len(timePoints); i++ { internal := calcInternal(timePoints[i-1], timePoints[i]) if minInternal \u0026gt; internal { minInternal = internal } } return minInternal } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(timePoints) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2022-01-18T09:41:32+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-539.-%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE/","title":"Leetcode 539. 最小时间差"},{"content":"链接： https://leetcode-cn.com/problems/count-vowels-permutation/\n难度： 困难\n题目描述 给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串：\n字符串中的每个字符都应当是小写元音字母（'a', 'e', 'i', 'o', 'u'）\n每个元音 'a' 后面都只能跟着 'e' 每个元音 'e' 后面只能跟着 'a' 或者是 'i' 每个元音 'i' 后面 不能 再跟着另一个 'i' 每个元音 'o' 后面只能跟着 'i' 或者是 'u' 每个元音 'u' 后面只能跟着 'a' 由于答案可能会很大，所以请你返回 模 109 + 7 之后的结果。\n示例1： 输入： n = 1\n输出： 5\n解释： 所有可能的字符串分别是：\u0026ldquo;a\u0026rdquo;, \u0026ldquo;e\u0026rdquo;, \u0026ldquo;i\u0026rdquo; , \u0026ldquo;o\u0026rdquo; 和 \u0026ldquo;u\u0026rdquo;。\n示例 2： 输入： n = 2\n输出： 10\n解释： 所有可能的字符串分别是：\u0026ldquo;ae\u0026rdquo;, \u0026ldquo;ea\u0026rdquo;, \u0026ldquo;ei\u0026rdquo;, \u0026ldquo;ia\u0026rdquo;, \u0026ldquo;ie\u0026rdquo;, \u0026ldquo;io\u0026rdquo;, \u0026ldquo;iu\u0026rdquo;, \u0026ldquo;oi\u0026rdquo;, \u0026ldquo;ou\u0026rdquo; 和 \u0026ldquo;ua\u0026rdquo;。\n示例 3： 输入： n = 5\n输出： 68\n提示： 1 \u0026lt;= n \u0026lt;= 2 * 104 解题思路 动态规划 对于满足题设要求的串，后一个字母可以填哪些是由其之前的一个字母控制，其由之前的串的添加最后一个字母转移过来，考虑用动态规划求解。\n使用 dp[i][j] 表示以字符 i 结尾的长度为 j 的满足条件的字符串的数量。根据题设，每个字母之前的字母如下表所示：\n字母 前一个字母 a e,i,u e a,i i e,o o i u i,o 则得到状态转移方程：\ndp['a'][j+1] = dp['e'][j] + dp['i'][j] + dp['u'][j] dp['e'][j+1] = dp['a'][j] + dp['i'][j] dp['i'][j+1] = dp['e'][j] + dp['o'][j] dp['o'][j+1] = dp['i'][j] dp['u'][j+1] = dp['i'][j] + dp['o'][j] 可以发现，每次转移仅依赖上一次的状态，使用滚动变量降低空间复杂度。\nfunc countVowelPermutation(n int) int { const Mod = int(1e9 + 7) sum := func(nums ...int) int { sum := 0 for _, num := range nums { sum = (sum + num) % Mod } return sum } a, e, i, o, u := 1, 1, 1, 1, 1 for ; n \u0026gt; 1; n-- { a, e, i, o, u = sum(e, i, u), sum(a, i), sum(e, o), sum(i), sum(i, o) } return sum(a, e, i, o, u) } 复杂度 时间复杂度：$ O(\\Sigma*n), \\Sigma 表示字符集，本题中为 5 $ 空间复杂度：$ O(\\Sigma) $ 矩阵快速幂 沿用上题题解思路，已经得到了递推公式，采用矩阵快速幂求解。\nfunc countVowelPermutation(n int) int { const Mod = int(1e9 + 7) // 矩阵乘法 matrixMultiply := func(matrix1 [][]int, matrix2 [][]int) [][]int { result := make([][]int, len(matrix1)) for row1 := 0; row1 \u0026lt; len(matrix1); row1++ { result[row1] = make([]int, len(matrix2[0])) for col2 := 0; col2 \u0026lt; len(matrix2[0]); col2++ { for col1 := 0; col1 \u0026lt; len(matrix1[row1]); col1++ { result[row1][col2] += (matrix1[row1][col1] * matrix2[col1][col2]) % Mod result[row1][col2] %= Mod } } } return result } // 矩阵快速幂 matrixFastPower := func(matrix [][]int, n int) [][]int { result := make([][]int, len(matrix)) for i := range matrix { result[i] = make([]int, len(matrix[i])) result[i][i] = 1 } for ; n \u0026gt; 0; n \u0026gt;\u0026gt;= 1 { if n\u0026amp;1 == 1 { result = matrixMultiply(result, matrix) } matrix = matrixMultiply(matrix, matrix) } return result } // 求和 sum := 0 for _, line := range matrixMultiply(matrixFastPower([][]int{ {0, 1, 1, 0, 1}, {1, 0, 1, 0, 0}, {0, 1, 0, 1, 0}, {0, 0, 1, 0, 0}, {0, 0, 1, 1, 0}, }, n-1), [][]int{{1}, {1}, {1}, {1}, {1}}) { sum = (sum + line[0]) % Mod } return sum } 复杂度 时间复杂度：$ O(\\Sigma^{3}*\\log{n}), \\Sigma 表示字符集，本题中为 5 $ 空间复杂度：$ O(\\Sigma^{2}) $ ","date":"2022-01-17T10:39:20+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1220.-%E7%BB%9F%E8%AE%A1%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE/","title":"Leetcode 1220. 统计元音字母序列的数目"},{"content":"链接： https://leetcode-cn.com/problems/linked-list-random-node/\n难度： 中等\n题目描述 给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样 。\n实现 Solution 类：\nSolution(ListNode head) 使用整数数组初始化对象。 int getRandom() 从链表中随机选择一个节点并返回该节点的值。链表中所有节点被选中的概率相等。 示例： 输入：\n[\u0026ldquo;Solution\u0026rdquo;, \u0026ldquo;getRandom\u0026rdquo;, \u0026ldquo;getRandom\u0026rdquo;, \u0026ldquo;getRandom\u0026rdquo;, \u0026ldquo;getRandom\u0026rdquo;, \u0026ldquo;getRandom\u0026rdquo;]\n[[[1, 2, 3]], [], [], [], [], []]\n输出：\n[null, 1, 3, 2, 2, 3]\n解释：\nSolution solution = new Solution([1, 2, 3]);\nsolution.getRandom(); // 返回 1\nsolution.getRandom(); // 返回 3\nsolution.getRandom(); // 返回 2\nsolution.getRandom(); // 返回 2\nsolution.getRandom(); // 返回 3\n// getRandom() 方法应随机返回 1、2、3中的一个，每个元素被返回的概率相等。\n提示： 链表中的节点数在范围 [1, 104] 内 -104 \u0026lt;= Node.val \u0026lt;= 104 至多调用 getRandom 方法 104 次 进阶： 如果链表非常大且长度未知，该怎么处理？ 你能否在不使用额外空间的情况下解决此问题？ 解题思路 顺序表 将链表中的元素存放到顺序表中，每次随机选出一个下标，返回对应的元素。\ntype Solution struct { vals []int rand *rand.Rand } func Constructor(head *ListNode) Solution { vals := make([]int, 0, 10) for ; head != nil; head = head.Next { vals = append(vals, head.Val) } return Solution{ vals: vals, rand: rand.New(rand.NewSource(time.Now().UnixNano())), } } func (this *Solution) GetRandom() int { return this.vals[this.rand.Intn(len(this.vals))] } 复杂度 时间复杂度： Constructor：$ O(N), N = len(List) $ GetRandom：$ O(1) $ 空间复杂度：$ O(N) $ 遍历 遍历链表，记录其长度。每次随机选定一个索引，从头遍历到该索引处，返回值。\ntype Solution struct { len int head *ListNode rand *rand.Rand } func Constructor(head *ListNode) Solution { len := 0 for node := head; node != nil; node = node.Next { len++ } return Solution{ len: len, head: head, rand: rand.New(rand.NewSource(time.Now().UnixNano())), } } func (this *Solution) GetRandom() int { node := this.head for i := this.rand.Intn(this.len); i \u0026gt; 0; i-- { node = node.Next } return node.Val } 复杂度 时间复杂度： Constructor：$ O(N), N = len(List) $ GetRandom：$ O(N) $ 空间复杂度：$ O(1) $ ","date":"2022-01-16T09:57:49+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-382.-%E9%93%BE%E8%A1%A8%E9%9A%8F%E6%9C%BA%E8%8A%82%E7%82%B9/","title":"Leetcode 382. 链表随机节点"},{"content":"链接： https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/\n难度： 简单\n题目描述 Hercy 想要为购买第一辆车存钱。他 每天 都往力扣银行里存钱。\n最开始，他在周一的时候存入 1 块钱。从周二到周日，他每天都比前一天多存入 1 块钱。在接下来每一个周一，他都会比 前一个周一 多存入 1 块钱。\n给你 n ，请你返回在第 n 天结束的时候他在力扣银行总共存了多少块钱。\n示例 1： 输入： n = 4\n输出： 10\n解释： 第 4 天后，总额为 1 + 2 + 3 + 4 = 10 。\n示例 2: 输入： n = 10\n输出： 37\n解释： 第 10 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37 。注意到第二个星期一，Hercy 存入 2 块钱。\n示例 3: 输入： n = 20\n输出： 96\n解释： 第 20 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96 。\n提示： 1 \u0026lt;= n \u0026lt;= 1000 解题思路 模拟 根据题设，计算出每一天的钱，累加求和。\nfunc totalMoney(n int) int { sum := 0 mondayMoney := 1 for i := 0; i \u0026lt; n; i += 7 { // 当周 for j := 0; j \u0026lt; 7 \u0026amp;\u0026amp; i+j \u0026lt; n; j++ { sum += mondayMoney + j // 每天比前一天多 1 块 } mondayMoney++ // 每周比前一周多 1 块 } return sum } 复杂度 时间复杂度：$ O(n)$ 空间复杂度：$ O(1) $ 数学 可以发现每周存的钱都比前一周多 7 块，其构成一个公差为 7 的等差数列，根据求和公式计算。\n对于最后若不满七天，周内存的钱也构成公差为 1 的等差数列，而且每周周一存的钱也构成公差为 1 的等差数列，故仍可以快速求和。\nfunc totalMoney(n int) int { sum := 0 // 整周：首项28，公差为7 weeks := n / 7 // 项数 sum += weeks*28 + (weeks*weeks-weeks)*7/2 // 不满一周，公差为1 monday := n/7 + 1 // 首项 days := n % 7 // 项数 sum += monday*days + (days*days-days)/2 return sum } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2022-01-15T09:58:16+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1716.-%E8%AE%A1%E7%AE%97%E5%8A%9B%E6%89%A3%E9%93%B6%E8%A1%8C%E7%9A%84%E9%92%B1/","title":"Leetcode 1716. 计算力扣银行的钱"},{"content":"链接： https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/\n难度： 中等\n题目描述 给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。\n定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。\n请找到和最小的 k 个数对 (u1,v1), (u2,v2) \u0026hellip; (uk,vk) 。\n示例 1： 输入： nums1 = [1,7,11], nums2 = [2,4,6], k = 3\n输出： [1,2],[1,4],[1,6]\n解释： 返回序列中的前 3 对数：\n[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n示例 2： 输入： nums1 = [1,1,2], nums2 = [1,2,3], k = 2\n输出： [1,1],[1,1]\n解释： 返回序列中的前 2 对数：\n[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n示例 3： 输入： nums1 = [1,2], nums2 = [3], k = 3\n输出： [1,3],[2,3]\n解释： 也可能序列中所有的数对都被返回:[1,3],[2,3]\n提示： 1 \u0026lt;= nums1.length, nums2.length \u0026lt;= 104 -109 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 109 nums1, nums2 均为升序排列 1 \u0026lt;= k \u0026lt;= 1000 解题思路 堆 使用大顶堆保存和最小的前 k 个数对。\n按照顺序枚举 nums1 中的数，并依次和 nums2 中的构成数对，然后尝试加入到大顶堆中。\n当堆中数量达到 k 个时，若此时当前数对和比堆顶的大，由于数组按照升序排列，则后续的数对也无需判定。\ntype MaxHeap struct { elems [][]int } func (this *MaxHeap) Len() int { return len(this.elems) } func (this *MaxHeap) Less(i, j int) bool { return this.elems[i][0]+this.elems[i][1] \u0026gt; this.elems[j][0]+this.elems[j][1] } func (this *MaxHeap) Swap(i, j int) { this.elems[i], this.elems[j] = this.elems[j], this.elems[i] } func (this *MaxHeap) Push(elem interface{}) { this.elems = append(this.elems, elem.([]int)) } func (this *MaxHeap) Pop() interface{} { max := this.elems[this.Len()-1] this.elems = this.elems[:this.Len()-1] return max } func kSmallestPairs(nums1 []int, nums2 []int, k int) [][]int { h := \u0026amp;MaxHeap{elems: make([][]int, 0, k)} for _, num1 := range nums1 { for _, num2 := range nums2 { // 已满 if h.Len() \u0026gt;= k { // 比堆定元素大，无需遍历 if num1+num2 \u0026gt;= h.elems[0][0]+h.elems[0][1] { break } // 比堆定元素小，弹出最大元素 heap.Pop(h) } // 当前元素入堆栈 heap.Push(h, []int{num1, num2}) } } return h.elems } 复杂度 时间复杂度：$ O(min(L_1L_2, k^2) *\\log{k}), L_1 = len(nums1), L_2 = len(nums2) $ 空间复杂度：$ O(min(L_1L_2, k)) $ ","date":"2022-01-14T10:58:34+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-373.-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84k%E5%AF%B9%E6%95%B0%E5%AD%97/","title":"Leetcode 373. 查找和最小的K对数字"},{"content":"链接： https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/\n难度： 简单\n题目描述 给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。\n请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。\n示例 1： 输入： nums = [3,6,1,0]\n输出： 1\n解释： 6 是最大的整数，对于数组中的其他整数，6 大于数组中其他元素的两倍。6 的下标是 1 ，所以返回 1 。\n示例 2： 输入： nums = [1,2,3,4]\n输出： -1\n解释： 4 没有超过 3 的两倍大，所以返回 -1 。\n示例 3： 输入： nums = [1]\n输出： 0\n解释： 因为不存在其他数字，所以认为现有数字 1 至少是其他数字的两倍。\n提示： 1 \u0026lt;= nums.length \u0026lt;= 50 0 \u0026lt;= nums[i] \u0026lt;= 100 nums 中的最大元素是唯一的 解题思路 模拟 首先完成一遍遍历找出最大的数字，然后再次遍历判定其是否为其他数字的两倍。\nfunc dominantIndex(nums []int) int { idxOfMax := 0 for i, num := range nums { if nums[idxOfMax] \u0026lt; num { idxOfMax = i } } for i, num := range nums { if i != idxOfMax \u0026amp;\u0026amp; nums[idxOfMax] \u0026lt; num\u0026lt;\u0026lt;1 { return -1 } } return idxOfMax } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2022-01-13T10:11:31+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-747.-%E8%87%B3%E5%B0%91%E6%98%AF%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97%E4%B8%A4%E5%80%8D%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0/","title":"Leetcode 747. 至少是其他数字两倍的最大数"},{"content":"链接： https://leetcode-cn.com/problems/increasing-triplet-subsequence/\n难度： 中等\n题目描述 给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。\n如果存在这样的三元组下标 (i, j, k) 且满足 i \u0026lt; j \u0026lt; k ，使得 nums[i] \u0026lt; nums[j] \u0026lt; nums[k] ，返回 true ；否则，返回 false 。\n示例 1： 输入： nums = [1,2,3,4,5]\n输出： true\n解释： 任何 i \u0026lt; j \u0026lt; k 的三元组都满足题意\n示例 2： 输入： nums = [5,4,3,2,1]\n输出： false\n解释： 不存在满足题意的三元组\n示例 3： 输入： nums = [2,1,5,0,4,6]\n输出： true\n解释： 三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 \u0026lt; nums[4] == 4 \u0026lt; nums[5] == 6\n提示： 1 \u0026lt;= nums.length \u0026lt;= 5 * 105 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 解题思路 哈希 顺序遍历整个数组，采用记录最小值的方式，判断每个数前面是否有比其更小的数字，记录到哈希表中。\n然后倒序遍历，采用记录最大值的方式，当某个之后存在比其更大的数，若在哈希表中有记录存在比起更小的数，即找到了一个三元组，返回 true；遍历结束并未找到，返回 false。\nfunc increasingTriplet(nums []int) bool { existLess := make([]bool, len(nums)) min := nums[0] for i, num := range nums { // 前面存在比其小的数 if min \u0026lt; num { existLess[i] = true } else { min = num // 更新遍历过的最小值 } } max := nums[len(nums)-1] for i := len(nums) - 2; i \u0026gt;= 0; i-- { // 后面存在比起大的数字 if max \u0026gt; nums[i] { // 并且前面存在比起小的数字 if existLess[i] { return true } } else { max = nums[i] // 更新遍历过的最大值 } } return false } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2022-01-12T11:00:40+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-334.-%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97/","title":"Leetcode 334. 递增的三元子序列"},{"content":"链接： https://leetcode-cn.com/problems/additive-number/\n难度： 中等\n题目描述 累加数 是一个字符串，组成它的数字可以形成累加序列。\n一个有效的 累加序列 必须 至少 包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。\n给你一个只包含数字 '0'-'9' 的字符串，编写一个算法来判断给定输入是否是 累加数 。如果是，返回 true ；否则，返回 false 。\n说明： 累加序列里的数 不会 以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。\n示例 1： 输入： \u0026ldquo;112358\u0026rdquo;\n输出： true\n解释： 累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\n示例 2： 输入： \u0026ldquo;199100199\u0026rdquo;\n输出： true\n解释： 累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199\n提示： 1 \u0026lt;= num.length \u0026lt;= 35 num 仅由数字（0 - 9）组成 进阶： 你计划如何处理由过大的整数输入导致的溢出?\n解题思路 哈希 单前两个数字确定后，后续的累加序列可以依次算出。故枚举所有可能的两个初始数字，逐个往后计算，并在原始串中匹配。\n当存在有一种情况满足 累加数 的要求，即可以匹配到结尾时，返回 true , 否则返回 false 。\nfunc isAdditiveNumber(num string) bool { for i := 1; i \u0026lt;= len(num)/2; i++ { for j := i + 1; j \u0026lt; len(num); j++ { // 前导 0 跳过 if j-i \u0026gt; 1 \u0026amp;\u0026amp; num[i] == \u0026#39;0\u0026#39; { break } num1 := num[:i] num2 := num[i:j] // 计算是否是累加和 for k := j; k \u0026lt;= len(num); { sum := add(num1, num2) if !strings.HasPrefix(num[k:], sum) { break } k += len(sum) if k == len(num) { return true } num1, num2 = num2, sum } } } return false } func add(s1 string, s2 string) string { if len(s1) \u0026lt; len(s2) { s1, s2 = s2, s1 } result := make([]byte, len(s1)+1) c := byte(0) for i, j, k := len(s1)-1, len(s2)-1, len(result)-1; i \u0026gt;= 0 || j \u0026gt;= 0; i, j, k = i-1, j-1, k-1 { switch { case j \u0026lt; 0: result[k] = s1[i] + c default: result[k] = s1[i] + s2[j] - byte(\u0026#39;0\u0026#39;) + c } c = 0 if result[k] \u0026gt; \u0026#39;9\u0026#39; { result[k] -= 10 c = 1 } } if c == 1 { result[0] = \u0026#39;1\u0026#39; return string(result) } return string(result[1:]) } 复杂度 时间复杂度：$ O(N^3), N = len(num) $ 空间复杂度：$ O(N) $ ","date":"2022-01-10T10:14:54+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-306.-%E7%B4%AF%E5%8A%A0%E6%95%B0/","title":"Leetcode 306. 累加数"},{"content":"链接： https://leetcode-cn.com/problems/slowest-key/\n难度： 简单\n题目描述 LeetCode 设计了一款新式键盘，正在测试其可用性。测试人员将会点击一系列键（总计 n 个），每次一个。\n给你一个长度为 n 的字符串 keysPressed ，其中 keysPressed[i] 表示测试序列中第 i 个被按下的键。releaseTimes 是一个升序排列的列表，其中 releaseTimes[i] 表示松开第 i 个键的时间。字符串和数组的 下标都从 0 开始 。第 0 个键在时间为 0 时被按下，接下来每个键都 恰好 在前一个键松开时被按下。\n测试人员想要找出按键 持续时间最长 的键。第 i 次按键的持续时间为 releaseTimes[i] - releaseTimes[i - 1] ，第 0 次按键的持续时间为 releaseTimes[0] 。\n注意，测试期间，同一个键可以在不同时刻被多次按下，而每次的持续时间都可能不同。\n请返回按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。\n示例 1： 输入： releaseTimes = [9,29,49,50], keysPressed = \u0026ldquo;cbcd\u0026rdquo;\n输出： \u0026ldquo;c\u0026rdquo;\n解释： 按键顺序和持续时间如下：\n按下 \u0026lsquo;c\u0026rsquo; ，持续时间 9（时间 0 按下，时间 9 松开）\n按下 \u0026lsquo;b\u0026rsquo; ，持续时间 29 - 9 = 20（松开上一个键的时间 9 按下，时间 29 松开）\n按下 \u0026lsquo;c\u0026rsquo; ，持续时间 49 - 29 = 20（松开上一个键的时间 29 按下，时间 49 松开）\n按下 \u0026rsquo;d\u0026rsquo; ，持续时间 50 - 49 = 1（松开上一个键的时间 49 按下，时间 50 松开）\n按键持续时间最长的键是 \u0026lsquo;b\u0026rsquo; 和 \u0026lsquo;c\u0026rsquo;（第二次按下时），持续时间都是 20\n\u0026lsquo;c\u0026rsquo; 按字母顺序排列比 \u0026lsquo;b\u0026rsquo; 大，所以答案是 \u0026lsquo;c\u0026rsquo;\n示例 2： 输入： releaseTimes = [12,23,36,46,62], keysPressed = \u0026ldquo;spuda\u0026rdquo;\n输出： \u0026ldquo;a\u0026rdquo;\n解释： 按键顺序和持续时间如下：\n按下 \u0026rsquo;s\u0026rsquo; ，持续时间 12\n按下 \u0026lsquo;p\u0026rsquo; ，持续时间 23 - 12 = 11\n按下 \u0026lsquo;u\u0026rsquo; ，持续时间 36 - 23 = 13\n按下 \u0026rsquo;d\u0026rsquo; ，持续时间 46 - 36 = 10\n按下 \u0026lsquo;a\u0026rsquo; ，持续时间 62 - 46 = 16\n按键持续时间最长的键是 \u0026lsquo;a\u0026rsquo; ，持续时间 16\n提示： releaseTimes.length == n keysPressed.length == n 2 \u0026lt;= n \u0026lt;= 1000 1 \u0026lt;= releaseTimes[i] \u0026lt;= 109 releaseTimes[i] \u0026lt; releaseTimes[i+1] keysPressed 仅由小写英文字母组成 解题思路 顺序 计算每个按键的持续时长，找出持续时长最长的那个按键。\nfunc slowestKey(releaseTimes []int, keysPressed string) byte { key := keysPressed[0] duration := releaseTimes[0] for i := 1; i \u0026lt; len(keysPressed); i++ { // 持续时间长 或 持续时间相相等但字典序更大 if duration \u0026lt; releaseTimes[i]-releaseTimes[i-1] || (duration == releaseTimes[i]-releaseTimes[i-1] \u0026amp;\u0026amp; key \u0026lt; keysPressed[i]) { duration = releaseTimes[i] - releaseTimes[i-1] key = keysPressed[i] } } return key } 复杂度 时间复杂度：$ O(N), N = len(releaseTimes) = len(keysPressed) $ 空间复杂度：$ O(1) $ ","date":"2022-01-09T10:12:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1629.-%E6%8C%89%E9%94%AE%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%E6%9C%80%E9%95%BF%E7%9A%84%E9%94%AE/","title":"Leetcode 1629. 按键持续时间最长的键"},{"content":"链接： https://leetcode-cn.com/problems/gray-code/\n难度： 中等\n题目描述 n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：\n每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1） 第一个整数是 0 一个整数在序列中出现 不超过一次 每对 相邻 整数的二进制表示 恰好一位不同 ，且 第一个 和 最后一个 整数的二进制表示 恰好一位不同 给你一个整数 n ，返回任一有效的 n 位格雷码序列 。\n示例 1： 输入： n = 2\n输出： [0,1,3,2]\n解释：\n[0,1,3,2] 的二进制表示是 [00,01,11,10] 。\n00 和 01 有一位不同 01 和 11 有一位不同 11 和 10 有一位不同 10 和 00 有一位不同\n[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。 00 和 10 有一位不同 10 和 11 有一位不同 11 和 01 有一位不同 01 和 00 有一位不同 示例 2： 输入： n = 1\n输出： [0,1]\n提示： 1 \u0026lt;= n \u0026lt;= 16 解题思路 对称性 存在这样的一种格雷编码顺序，其二进制表示形式除最高位外，以对称的形式分布，并且对称的这两部分每一部分仍满足前述对称分布规律。例如：\n格雷码 二进制表示 0 000 1 001 3 011 2 010 6 110 7 111 5 101 4 100 依照此规律生成格雷码。\nfunc grayCode(n int) []int { greyCode := make([]int, 0, 1\u0026lt;\u0026lt;n) greyCode = append(greyCode, 0) for i := 0; i \u0026lt; n; i++ { digit := 1 \u0026lt;\u0026lt; i // 最高位 // 倒序遍历，最高位置1 for j := len(greyCode) - 1; j \u0026gt;= 0; j-- { greyCode = append(greyCode, digit|greyCode[j]) } } return greyCode } 复杂度 时间复杂度：$ O(2^n) $ 空间复杂度：$ O(1) $ ","date":"2022-01-08T12:11:16+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-89.-%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/","title":"Leetcode 89. 格雷编码"},{"content":"链接： https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/\n难度： 简单\n题目描述 如果字符串满足以下条件之一，则可以称之为 有效括号字符串（valid parentheses string，可以简写为 VPS）：\n字符串是一个空字符串 \u0026quot;\u0026quot;，或者是一个不为 \u0026quot;(\u0026quot; 或 \u0026quot;)\u0026quot; 的单字符。 字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。 字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。 类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)：\ndepth(\u0026quot;\u0026quot;) = 0 depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 \u0026quot;(\u0026quot; 或者 \u0026quot;)\u0026quot; depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串 depth(\u0026quot;(\u0026quot; + A + \u0026quot;)\u0026quot;) = 1 + depth(A)，其中 A 是一个 有效括号字符串 例如：\u0026quot;\u0026quot;、\u0026quot;()()\u0026quot;、\u0026quot;()(()())\u0026quot; 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 \u0026quot;)(\u0026quot; 、\u0026quot;(()\u0026quot; 都不是 有效括号字符串 。\n给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。\n示例 1： 输入： s = \u0026ldquo;(1+(2*3)+((8)/4))+1\u0026rdquo;\n输出： 3\n解释： 数字 8 在嵌套的 3 层括号中。\n示例 2： 输入： s = \u0026ldquo;(1)+((2))+(((3)))\u0026rdquo;\n输出： 3\n示例 3： 输入： s = \u0026ldquo;1+(2*3)/(2-1)\u0026rdquo;\n输出： 1\n示例 4： 输入： s = \u0026ldquo;1\u0026rdquo;\n输出： 0\n提示： 1 \u0026lt;= s.length \u0026lt;= 100 s 由数字 0-9 和字符 '+'、'-'、'*'、'/'、'('、')' 组成 题目数据保证括号表达式 s 是 有效的括号表达式 解题思路 栈思想 由于给定的字符串是 有效括号表达式，括号是成对出现的，不需要判定有效性，可省略栈空间，直接通过 '(' 的数量判定某个字符的嵌套深度：\n初始时，深度为 0 ; 每当遇到 '(' , 深度 +1 ; 当遇到 ')'，深度 -1 。 在上述过程中记录深度的最大值。\nfunc maxDepth(s string) int { maxDepth := 0 depth := 0 for i := range s { switch s[i] { case \u0026#39;(\u0026#39;: depth++ if maxDepth \u0026lt; depth { maxDepth = depth } case \u0026#39;)\u0026#39;: depth-- } } return maxDepth } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2022-01-07T10:22:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1614.-%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6/","title":"Leetcode 1614. 括号的最大嵌套深度"},{"content":"链接： https://leetcode-cn.com/problems/simplify-path/\n难度： 中等\n题目描述 给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。\n在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。\n请注意，返回的 规范路径 必须遵循下述格式：\n始终以斜杠 \u0026lsquo;/\u0026rsquo; 开头。 两个目录名之间必须只有一个斜杠 \u0026lsquo;/\u0026rsquo; 。 最后一个目录名（如果存在）不能 以 \u0026lsquo;/\u0026rsquo; 结尾。 此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 \u0026lsquo;.\u0026rsquo; 或 \u0026lsquo;..\u0026rsquo;）。 返回简化后得到的 规范路径 。\n示例 1： 输入： path = \u0026ldquo;/home/\u0026rdquo;\n输出： \u0026ldquo;/home\u0026rdquo;\n解释： 注意，最后一个目录名后面没有斜杠。\n示例 2： 输入： path = \u0026ldquo;/../\u0026rdquo;\n输出： \u0026ldquo;/\u0026rdquo;\n解释： 从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。\n示例 3： 输入： path = \u0026ldquo;/home//foo/\u0026rdquo;\n输出： \u0026ldquo;/home/foo\u0026rdquo;\n解释： 在规范路径中，多个连续斜杠需要用一个斜杠替换。\n示例 4： 输入： path = \u0026ldquo;/a/./b/../../c/\u0026rdquo;\n输出： \u0026ldquo;/c\u0026rdquo;\n提示： 1 \u0026lt;= path.length \u0026lt;= 3000 path 由英文字母，数字，'.'，'/' 或 '_' 组成。 path 是一个有效的 Unix 风格绝对路径。 解题思路 栈 从根目录开始，按顺序识别出目录存放于栈中，'.' 目录忽略，'..' 目录则将上个目录弹出。最后按照入栈顺序以 '/' 将栈中目录连接起来。\nfunc simplifyPath(path string) string { stack := make([]string, 0, 10) begin := 0 for i := 0; i \u0026lt;= len(path); i++ { // 目录分隔符 或 结尾 if i == len(path) || path[i] == \u0026#39;/\u0026#39; { // 存在有效 if i \u0026gt; begin { switch path[begin:i] { case \u0026#34;.\u0026#34;: case \u0026#34;..\u0026#34;: if len(stack) \u0026gt; 0 { stack = stack[:len(stack)-1] } default: stack = append(stack, path[begin:i]) } } begin = i + 1 } } return \u0026#34;/\u0026#34; + strings.Join(stack, \u0026#34;/\u0026#34;) } 复杂度 时间复杂度：$ O(N), N = len(path) $ 空间复杂度：$ O(N) $ ","date":"2022-01-06T10:19:10+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-71.-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/","title":"Leetcode 71. 简化路径"},{"content":"链接： https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/\n难度： 简单\n题目描述 给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。\n注意：你 不能 修改非 '?' 字符。\n题目测试用例保证 除 '?' 字符 之外，不存在连续重复的字符。\n在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。\n示例 1： 输入： s = \u0026ldquo;?zs\u0026rdquo;\n输出： \u0026ldquo;azs\u0026rdquo;\n解释： 该示例共有 25 种解决方案，从 \u0026ldquo;azs\u0026rdquo; 到 \u0026ldquo;yzs\u0026rdquo; 都是符合题目要求的。只有 \u0026ldquo;z\u0026rdquo; 是无效的修改，因为字符串 \u0026ldquo;zzs\u0026rdquo; 中有连续重复的两个 \u0026lsquo;z\u0026rsquo; 。\n示例 2： 输入： s = \u0026ldquo;ubv?w\u0026rdquo;\n输出： \u0026ldquo;ubvaw\u0026rdquo;\n解释： 该示例共有 24 种解决方案，只有替换成 \u0026ldquo;v\u0026rdquo; 和 \u0026ldquo;w\u0026rdquo; 不符合题目要求。因为 \u0026ldquo;ubvvw\u0026rdquo; 和 \u0026ldquo;ubvww\u0026rdquo; 都包含连续重复的字符。\n示例 3： 输入： s = \u0026ldquo;j?qg??b\u0026rdquo;\n输出： \u0026ldquo;jaqgacb\u0026rdquo;\n示例 4： 输入： s = \u0026ldquo;??yw?ipkj?\u0026rdquo;\n输出： \u0026ldquo;acywaipkja\u0026rdquo;\n提示： 1 \u0026lt;= s.length \u0026lt;= 100 s 仅包含小写英文字母和 '?' 字符 解题思路 模拟 按照 'a'-'z' 的顺序循环尝试填入，当不满足要求时继续使用下一个字符尝试，知道全部替换完成。\nfunc modifyString(s string) string { t := []byte(s) for i := 0; i \u0026lt; len(t); i++ { if t[i] != \u0026#39;?\u0026#39; { continue } // 前一个字符 prev := byte(\u0026#39;$\u0026#39;) if i \u0026gt; 0 { prev = t[i-1] } // 后一个字符 post := byte(\u0026#39;$\u0026#39;) if i \u0026lt; len(t)-1 \u0026amp;\u0026amp; t[i+1] != \u0026#39;?\u0026#39; { post = t[i+1] } // 寻找可以替换的字符 for char := byte(\u0026#39;a\u0026#39;); char \u0026lt; \u0026#39;z\u0026#39;; char++ { if char != prev \u0026amp;\u0026amp; char != post { t[i] = char break } } } return string(t) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2022-01-05T10:14:01+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1576.-%E6%9B%BF%E6%8D%A2%E6%89%80%E6%9C%89%E7%9A%84%E9%97%AE%E5%8F%B7/","title":"Leetcode 1576. 替换所有的问号"},{"content":"链接： https://leetcode-cn.com/problems/day-of-the-week/\n难度： 简单\n题目描述 给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。\n输入为三个整数：day、month 和 year，分别表示日、月、年。\n您返回的结果必须是这几个值中的一个 {\u0026quot;Sunday\u0026quot;, \u0026quot;Monday\u0026quot;, \u0026quot;Tuesday\u0026quot;, \u0026quot;Wednesday\u0026quot;, \u0026quot;Thursday\u0026quot;, \u0026quot;Friday\u0026quot;, \u0026quot;Saturday\u0026quot;}。\n示例 1： 输入： day = 31, month = 8, year = 2019\n输出： \u0026ldquo;Saturday\u0026rdquo;\n示例 2： 输入： day = 18, month = 7, year = 1999\n输出： \u0026ldquo;Sunday\u0026rdquo;\n示例 3： 输入： day = 15, month = 8, year = 1993\n输出： \u0026ldquo;Sunday\u0026rdquo;\n提示： 给出的日期一定是在 1971 到 2100 年之间的有效日期。 解题思路 模拟 根据给定年的范围，求得从 1970 年 12 月 31 日 （星期四）开始到给定日期经过的天数，进而推导得出。\nfunc dayOfTheWeek(day int, month int, year int) string { week := []string{\u0026#34;Sunday\u0026#34;, \u0026#34;Monday\u0026#34;, \u0026#34;Tuesday\u0026#34;, \u0026#34;Wednesday\u0026#34;, \u0026#34;Thursday\u0026#34;, \u0026#34;Friday\u0026#34;, \u0026#34;Saturday\u0026#34;} days := 0 days += 365 * (year - 1971) // 整年天数计入 days += (year - 1969) / 4 // 闰年计入，从1973年开始有闰年计入，范围内除了 2100 外 4的倍数都是闰年，2100不会计入 monthDays := []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} // 当年是闰年，二月 29 天 if (year%4 == 0 \u0026amp;\u0026amp; year%100 != 0) || (year%400 == 0) { monthDays[1]++ } // 当年月计入 for i := month - 2; i \u0026gt;= 0; i-- { days += monthDays[i] } // 当月天计入 days += day return week[(days+4)%7] } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2022-01-03T11:18:12+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1185.-%E4%B8%80%E5%91%A8%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9/","title":"Leetcode 1185. 一周中的第几天"},{"content":"链接： https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/\n难度： 简单\n题目描述 给你一个下标从 0 开始的一维整数数组 original 和两个整数 m 和 n 。你需要使用 original 中 所有 元素创建一个 m 行 n 列的二维数组。\noriginal 中下标从 0 到 n - 1 （都 包含 ）的元素构成二维数组的第一行，下标从 n 到 2 * n - 1 （都 包含 ）的元素构成二维数组的第二行，依此类推。\n请你根据上述过程返回一个 m x n 的二维数组。如果无法构成这样的二维数组，请你返回一个空的二维数组。\n示例 1： 输入： original = [1,2,3,4], m = 2, n = 2\n输出： [[1,2],[3,4]]\n解释：\n构造出的二维数组应该包含 2 行 2 列。\noriginal 中第一个 n=2 的部分为 [1,2] ，构成二维数组的第一行。\noriginal 中第二个 n=2 的部分为 [3,4] ，构成二维数组的第二行。\n示例 2： 输入： original = [1,2,3], m = 1, n = 3\n输出： [[1,2,3]]\n解释：\n构造出的二维数组应该包含 1 行 3 列。\n将 original 中所有三个元素放入第一行中，构成要求的二维数组。\n示例 3： 输入： original = [1,2], m = 1, n = 1\n输出： []\n解释：\noriginal 中有 2 个元素。\n无法将 2 个元素放入到一个 1x1 的二维数组中，所以返回一个空的二维数组。\n示例 4： 输入： original = [3], m = 1, n = 2\n输出： []\n解释：\noriginal 中只有 1 个元素。\n无法将 1 个元素放满一个 1x2 的二维数组，所以返回一个空的二维数组。\n提示： 1 \u0026lt;= original.length \u0026lt;= 5 * 104 1 \u0026lt;= original[i] \u0026lt;= 105 1 \u0026lt;= m, n \u0026lt;= 4 * 104 解题思路 模拟 首先需要判断是否能构成二维数组，要求一维数组长度等于 m x n ，若不成立即返回空。\n遍历一位数组，每 n 个构成一个新数组，添加到二维数组中。\nfunc construct2DArray(original []int, m int, n int) [][]int { if m*n != len(original) { return make([][]int, 0) } matrix := make([][]int, 0, m) for i := 0; i \u0026lt; len(original); i += n { matrix = append(matrix, original[i:i+n]) } return matrix } 复杂度 时间复杂度：$ O(N), N = len(original) $ 空间复杂度：$ O(1) $ ","date":"2022-01-01T23:01:45+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-2022.-%E5%B0%86%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8F%98%E6%88%90%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/","title":"Leetcode 2022. 将一维数组转变成二维数组"},{"content":"链接： https://leetcode-cn.com/problems/perfect-number/\n难度： 简单\n题目描述 对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。\n给定一个 整数 n， 如果是完美数，返回 true，否则返回 false\n示例 1： 输入： num = 28\n输出： true\n解释： 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, 和 14 是 28 的所有正因子。\n示例 2： 输入： num = 6\n输出： true\n示例 3： 输入： num = 496\n输出： true\n示例 4： 输入： num = 8128\n输出： true\n示例 5： 输入： num = 2\n输出： false\n提示： 1 \u0026lt;= num \u0026lt;= 108 解题思路 暴力求解 枚举并找出所有的因数，排除其自身，求和比较即可。\nfunc checkPerfectNumber(num int) bool { if num == 1 { return false } sum := 1 for i := int(math.Sqrt(float64(num))); i \u0026gt; 1; i-- { if num%i == 0 { sum += i if i != num/i { sum += num / i } } } return sum == num } 复杂度 时间复杂度：$ O(\\sqrt{num})) $ 空间复杂度：$ O(1) $ ","date":"2021-12-31T10:19:45+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-507.-%E5%AE%8C%E7%BE%8E%E6%95%B0/","title":"Leetcode 507. 完美数"},{"content":"链接： https://leetcode-cn.com/problems/count-special-quadruplets/\n难度： 简单\n题目描述 给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ：\nnums[a] + nums[b] + nums[c] == nums[d] ，且 a \u0026lt; b \u0026lt; c \u0026lt; d 示例 1： 输入： nums = [1,2,3,6]\n输出： 1\n解释： 满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。\n示例 2： 输入： nums = [3,3,6,4,5]\n输出： 0\n解释： [3,3,6,4,5] 中不存在满足要求的四元组。\n示例 3： 输入： nums = [1,1,1,3,5]\n输出： 4\n解释： 满足要求的 4 个四元组如下：\n(0, 1, 2, 3): 1 + 1 + 1 == 3 (0, 1, 3, 4): 1 + 1 + 3 == 5 (0, 2, 3, 4): 1 + 1 + 3 == 5 (1, 2, 3, 4): 1 + 1 + 3 == 5 提示： 4 \u0026lt;= nums.length \u0026lt;= 50 1 \u0026lt;= nums[i] \u0026lt;= 100 解题思路 暴力求解 由于数据量很小，直接枚举所有情况，找到满足条件的四元组。\nfunc countQuadruplets(nums []int) int { cnt := 0 for a := 0; a \u0026lt; len(nums)-3; a++ { for b := a + 1; b \u0026lt; len(nums)-2; b++ { for c := b + 1; c \u0026lt; len(nums)-1; c++ { for d := c + 1; d \u0026lt; len(nums); d++ { if nums[a]+nums[b]+nums[c] == nums[d] { cnt++ } } } } } return cnt } 复杂度 时间复杂度：$ O(N^4), N = len(nums) $ 空间复杂度：$ O(1) $ 哈希 当枚举出a、b、c 的时候， nums[d] 可以通过计算求得，只需要知道在 \u0026gt; c 的部分有几个 nums[d] 即可。\n通过倒序枚举 c 可使用哈希表记录 c 右侧每个数的数量。\nfunc countQuadruplets(nums []int) int { cnt := 0 hash := map[int]int{ nums[len(nums)-1]: 1, } for c := len(nums) - 2; c \u0026gt;= 2; c-- { for b := c - 1; b \u0026gt;= 1; b-- { for a := b - 1; a \u0026gt;= 0; a-- { cnt += hash[nums[a]+nums[b]+nums[c]] } } hash[nums[c]]++ } return cnt } 复杂度 时间复杂度：$ O(N^3), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2021-12-29T10:23:41+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1995.-%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E5%9B%9B%E5%85%83%E7%BB%84/","title":"Leetcode 1995. 统计特殊四元组"},{"content":"链接： https://leetcode-cn.com/problems/concatenated-words/\n难度： 困难\n题目描述 给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 。\n连接词 定义为：一个完全由给定数组中的至少两个较短单词组成的字符串。\n示例 1： 输入： words = [\u0026ldquo;cat\u0026rdquo;,\u0026ldquo;cats\u0026rdquo;,\u0026ldquo;catsdogcats\u0026rdquo;,\u0026ldquo;dog\u0026rdquo;,\u0026ldquo;dogcatsdog\u0026rdquo;,\u0026ldquo;hippopotamuses\u0026rdquo;,\u0026ldquo;rat\u0026rdquo;,\u0026ldquo;ratcatdogcat\u0026rdquo;]\n输出： [\u0026ldquo;catsdogcats\u0026rdquo;,\u0026ldquo;dogcatsdog\u0026rdquo;,\u0026ldquo;ratcatdogcat\u0026rdquo;]\n解释： \u0026ldquo;catsdogcats\u0026rdquo; 由 \u0026ldquo;cats\u0026rdquo;, \u0026ldquo;dog\u0026rdquo; 和 \u0026ldquo;cats\u0026rdquo; 组成;\n\u0026ldquo;dogcatsdog\u0026rdquo; 由 \u0026ldquo;dog\u0026rdquo;, \u0026ldquo;cats\u0026rdquo; 和 \u0026ldquo;dog\u0026rdquo; 组成;\n\u0026ldquo;ratcatdogcat\u0026rdquo; 由 \u0026ldquo;rat\u0026rdquo;, \u0026ldquo;cat\u0026rdquo;, \u0026ldquo;dog\u0026rdquo; 和 \u0026ldquo;cat\u0026rdquo; 组成。\n示例 2： 输入： words = [\u0026ldquo;cat\u0026rdquo;,\u0026ldquo;dog\u0026rdquo;,\u0026ldquo;catdog\u0026rdquo;]\n输出： [\u0026ldquo;catdog\u0026rdquo;]\n提示： 1 \u0026lt;= words.length \u0026lt;= 104 0 \u0026lt;= words[i].length \u0026lt;= 1000 words[i] 仅由小写字母组成 0 \u0026lt;= sum(words[i].length) \u0026lt;= 105 解题思路 排序 + Trie树 + 深度优先搜索 在一系列单词中进行字符串匹配，考虑使用 Trie树。\n满足条件的字符串由更短的串拼接而成，故按照字符串的长度排序，则能组成当前串的所有字串均在前面，在遍历过程中将其逐一添加到 Trie树 中，确保匹配时仅比其短的串在 Trie树 中。\n匹配时采用深度优先搜索策略，每当匹配到一个单词时，从下一个字符开始继续匹配另一个。当不能匹配时，回溯到上一个单词结尾的地方尝试匹配更长的单词。\n当能匹配到该单词结尾，因为不存在重复的单词，故说明是连接词，不必将其加入到 Trie树 中。否则，将该词加入到 Trie树 中。\ntype Node struct { End bool Children [26]*Node } func findAllConcatenatedWordsInADict(words []string) []string { sort.Slice(words, func(i, j int) bool { return len(words[i]) \u0026lt; len(words[j]) }) root := \u0026amp;Node{ End: false, Children: [26]*Node{}, } var dfs func(word string) bool dfs = func(word string) bool { for node, i := root, 0; i \u0026lt; len(word); i++ { // 无法继续匹配 node = node.Children[word[i]-\u0026#39;a\u0026#39;] if node == nil { break } // 匹配到某个单词 if node.End { // 匹配到结尾，匹配成功 if i == len(word)-1 { return true } // 尝试匹配下一个 if dfs(word[i+1:]) { return true } } } return false } ans := make([]string, 0, len(words)) for _, word := range words { if dfs(word) { ans = append(ans, word) continue } // 添加到 Trie树 node := root for i := range word { if node.Children[word[i]-\u0026#39;a\u0026#39;] == nil { node.Children[word[i]-\u0026#39;a\u0026#39;] = \u0026amp;Node{ End: false, Children: [26]*Node{}, } } node = node.Children[word[i]-\u0026#39;a\u0026#39;] } node.End = true } return ans } 复杂度 时间复杂度：$ O(N\\log{N}+\\sum_{i=0}^{N-1}{{L_i}^2}), N = len(words), L_i = len(words[i]) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-12-28T11:53:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-472.-%E8%BF%9E%E6%8E%A5%E8%AF%8D/","title":"Leetcode 472. 连接词"},{"content":"链接： https://leetcode-cn.com/problems/friends-of-appropriate-ages/\n难度： 中等\n题目描述 在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。\n如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：\nage[y] \u0026lt;= 0.5 * age[x] + 7 age[y] \u0026gt; age[x] age[y] \u0026gt; 100 \u0026amp;\u0026amp; age[x] \u0026lt; 100 否则，x 将会向 y 发送一条好友请求。\n注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。\n返回在该社交媒体网站上产生的好友请求总数。\n示例 1： 输入： ages = [16,16]\n输出： 2\n解释： 2 人互发好友请求。\n示例 2： 输入： ages = [16,17,18]\n输出： 2\n解释： 产生的好友请求为 17 -\u0026gt; 16 ，18 -\u0026gt; 17 。\n示例 3： 输入： ages = [20,30,100,110,120]\n输出： 3\n解释： 产生的好友请求为 110 -\u0026gt; 100 ，120 -\u0026gt; 110 ，120 -\u0026gt; 100 。\n提示： n == ages.length 1 \u0026lt;= n \u0026lt;= 2 * 104 1 \u0026lt;= ages[i] \u0026lt;= 120 解题思路 排序 根据题设可知，用户不会向比其年龄大的用户发送请求，故对年龄进行一轮排序，向前查找比起年龄小或相等的可发送请求的用户。\n对于每个用户 x，向前查找到恰不满足条件的用户 y , 其年龄为 age[y] \u0026lt;= 0.5 * age[x] + 7，则在 x 会向区间 (y, x) 内的所有用户均发送一条请求。\n注意： 相同年龄的用户按照最后一个用户计算。\nfunc numFriendRequests(ages []int) int { requests := 0 sort.Ints(ages) for x := 0; x \u0026lt; len(ages); x++ { cnt := 1 // 与待处理用户年龄相同的数量 // 相同年龄的用户统一处理 for ; x+1 \u0026lt; len(ages) \u0026amp;\u0026amp; ages[x+1] == ages[x]; x++ { cnt++ } min := ages[x]/2 + 7 // 不发送请求的用户，年龄最大者 y := x - 1 for ; y \u0026gt;= 0 \u0026amp;\u0026amp; ages[y] \u0026gt; min; y-- { } requests += (x - y - 1) * cnt } return requests } 复杂度 时间复杂度：$ O(N^2), N = len(ages) $ 空间复杂度：$ O(\\log{N}) $ 排序 + 二分查找 在以上的基础上，对于每个用户 x，向前查找时恰不满足条件的用户 y 使用二分查找。\nfunc numFriendRequests(ages []int) int { requests := 0 sort.Ints(ages) for x := 0; x \u0026lt; len(ages); x++ { cnt := 1 // 与待处理用户年龄相同的数量 // 相同年龄的用户统一处理 for ; x+1 \u0026lt; len(ages) \u0026amp;\u0026amp; ages[x+1] == ages[x]; x++ { cnt++ } min := ages[x]/2 + 7 // 不发送请求的用户，年龄最大者 y := x - 1 for i, j := 0, x-1; i \u0026lt;= j; { if i == j { if ages[i] \u0026gt; min { y = i - 1 } else { y = i } break } mid := (i + j + 1) / 2 if ages[mid] \u0026gt; min { j = mid - 1 } else { i = mid } } requests += (x - y - 1) * cnt } return requests } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(ages) $ 空间复杂度：$ O(\\log{N}) $ 排序 + 双指针 使用双指针记录满足发送条件的区间 [y, x)，在此区间内的用户 x 向其他所有区间内的用户发送请求。\nfunc numFriendRequests(ages []int) int { requests := 0 sort.Ints(ages) for x, y := 0, 0; x \u0026lt; len(ages); x++ { cnt := 1 // 与待处理用户年龄相同的数量 // 相同年龄的用户统一处理 for ; x+1 \u0026lt; len(ages) \u0026amp;\u0026amp; ages[x+1] == ages[x]; x++ { cnt++ } min := ages[x]/2 + 7 // 可发送请求的年龄最小者 for ; y \u0026lt; x \u0026amp;\u0026amp; ages[y] \u0026lt;= min; y++ { } requests += (x - y) * cnt } return requests } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(ages) $ 空间复杂度：$ O(\\log{N}) $ 前缀和 由于年龄区间比较小，统计每个年龄的人数，通过前缀和可快速求出某个年龄的用户 x 需要向多少人发送请求。\nfunc numFriendRequests(ages []int) int { // 统计每个年龄的用户数量 const MaxAge = 120 cnt := make([]int, MaxAge+1) for _, age := range ages { cnt[age]++ } // 前缀和 preSum := make([]int, MaxAge+1) for i := 1; i \u0026lt; len(cnt); i++ { preSum[i] += preSum[i-1] + cnt[i] } requests := 0 for age := 15; age \u0026lt;= MaxAge; age++ { if cnt[age] \u0026gt; 0 { // 相同年龄的用户统一处理 requests += cnt[age] * (preSum[age] - preSum[age/2+7] - 1) } } return requests } 复杂度 时间复杂度：$ O(N + \\Sigma), N = len(ages), \\Sigma = \\lceil ages[i] \\rceil $ 空间复杂度：$ O(\\Sigma) $ ","date":"2021-12-27T10:14:24+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-825.-%E9%80%82%E9%BE%84%E7%9A%84%E6%9C%8B%E5%8F%8B/","title":"Leetcode 825. 适龄的朋友"},{"content":"链接： https://leetcode-cn.com/problems/occurrences-after-bigram/\n难度： 简单\n题目描述 给出第一个词 first 和第二个词 second，考虑在某些文本 text 中可能以 \u0026quot;first second third\u0026quot; 形式出现的情况，其中 second 紧随 first 出现，third 紧随 second 出现。\n对于每种这样的情况，将第三个词 \u0026quot;third\u0026quot; 添加到答案中，并返回答案。\n示例 1： 输入： text = \u0026ldquo;alice is a good girl she is a good student\u0026rdquo;, first = \u0026ldquo;a\u0026rdquo;, second = \u0026ldquo;good\u0026rdquo;\n输出： [\u0026ldquo;girl\u0026rdquo;,\u0026ldquo;student\u0026rdquo;]\n示例 2： 输入： text = \u0026ldquo;we will we will rock you\u0026rdquo;, first = \u0026ldquo;we\u0026rdquo;, second = \u0026ldquo;will\u0026rdquo;\n输出： [\u0026ldquo;we\u0026rdquo;,\u0026ldquo;rock\u0026rdquo;]\n提示： 1 \u0026lt;= text.length \u0026lt;= 1000 text 由小写英文字母和空格组成 text 中的所有单词之间都由 单个空格字符 分隔 1 \u0026lt;= first.length, second.length \u0026lt;= 10 first 和 second 由小写英文字母组成 解题思路 模拟 遍历，对于连续的三个单词，当前两个分别于 first 和 second 成功匹配时，则找到一个符合条件的单词。\nfunc findOcurrences(text string, first string, second string) []string { words := strings.Split(text, \u0026#34; \u0026#34;) ans := make([]string, 0, len(words)-2) for i := 2; i \u0026lt; len(words); i++ { if words[i-2] == first \u0026amp;\u0026amp; words[i-1] == second { ans = append(ans, words[i]) } } return ans } 复杂度 时间复杂度：$ O(N), N = len(text) $ 空间复杂度：$ O(N) $ ","date":"2021-12-26T11:02:37+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1078.-bigram-%E5%88%86%E8%AF%8D/","title":"Leetcode 1078. Bigram 分词"},{"content":"链接： https://leetcode-cn.com/problems/even-odd-tree/\n难度： 中等\n题目描述 如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：\n二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。\n偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增 奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减 给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。 示例 1： 输入： root = [1,10,4,3,null,7,9,12,8,6,null,null,2]\n输出： true\n解释： 每一层的节点值分别是：\n0 层：[1]\n1 层：[10,4]\n2 层：[3,7,9]\n3 层：[12,8,6,2]\n由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。\n示例 2： 输入： root = [5,4,2,3,3,7]\n输出： false\n解释： 每一层的节点值分别是：\n0 层：[5]\n1 层：[4,2]\n2 层：[3,3,7]\n2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。\n示例 3： 输入： root = [5,9,1,3,5,7]\n输出： false\n解释： 1 层上的节点值应为偶数。\n示例 4： 输入： root = [1]\n输出： true\n示例 5： 输入： root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]\n输出： true\n提示： 树中节点数在范围 [1, 105] 内 1 \u0026lt;= Node.val \u0026lt;= 106 解题思路 层序遍历（广度优先搜索） 逐层遍历，奇数层元素均为偶数，降序排列；偶数层元素均为奇数，升序排列；一旦不满足则返回 false。\nfunc isEvenOddTree(root *TreeNode) bool { if root == nil { return true } deque := list.New() deque.PushBack(root) for even := true; deque.Len() \u0026gt; 0; even = !even { last := 0 // 偶数层递增，取最小值 if !even { last = math.MaxInt32 // 偶数层递减，取最大值 } // 遍历整层 for i := deque.Len(); i \u0026gt; 0; i-- { node := deque.Remove(deque.Front()).(*TreeNode) // 出队 // 下一层子元素入队 if node.Left != nil { deque.PushBack(node.Left) } if node.Right != nil { deque.PushBack(node.Right) } // 元素奇偶性不正确 或 偶数层非严格递增 或 奇数层非严格递减 if even == (node.Val\u0026amp;1 == 0) || (even \u0026amp;\u0026amp; node.Val \u0026lt;= last) || (!even \u0026amp;\u0026amp; node.Val \u0026gt;= last) { return false } last = node.Val } } return true } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$O(N) $ ","date":"2021-12-25T20:01:00+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1609.-%E5%A5%87%E5%81%B6%E6%A0%91/","title":"Leetcode 1609. 奇偶树"},{"content":"链接： https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/\n难度： 中等\n题目描述 有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。\n你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。\n给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。\n示例 1： 输入： apples = [1,2,3,5,2], days = [3,2,1,4,2]\n输出： 7\n解释： 你可以吃掉 7 个苹果：\n第一天，你吃掉第一天长出来的苹果。 第二天，你吃掉一个第二天长出来的苹果。 第三天，你吃掉一个第二天长出来的苹果。过了这一天，第三天长出来的苹果就已经腐烂了。 第四天到第七天，你吃的都是第四天长出来的苹果。 示例 2： 输入： apples = [3,0,0,0,0,2], days = [3,0,0,0,0,2]\n输出： 5\n解释： 你可以吃掉 5 个苹果：\n第一天到第三天，你吃的都是第一天长出来的苹果。 第四天和第五天不吃苹果。 第六天和第七天，你吃的都是第六天长出来的苹果。 提示： apples.length == n days.length == n 1 \u0026lt;= n \u0026lt;= 2 * 104 0 \u0026lt;= apples[i], days[i] \u0026lt;= 2 * 104 只有在 apples[i] = 0 时，days[i] = 0 才成立 解题思路 贪心 + 堆 + 哈希 按照苹果腐烂的时间先后顺序吃苹果，每天吃最早腐烂的那一个，这样可以保证吃到最多的苹果。\n使用堆进行维护，堆定维护最早腐烂的苹果的时间，同用哈希表记录到某天腐烂的苹果的数量。\ntype MinHeap struct { sort.IntSlice } func (this *MinHeap) Push(elem interface{}) { this.IntSlice = append(this.IntSlice, elem.(int)) } func (this *MinHeap) Pop() interface{} { elem := this.IntSlice[this.Len()-1] this.IntSlice = this.IntSlice[:this.Len()-1] return elem } func eatenApples(apples []int, days []int) int { eat := 0 h := \u0026amp;MinHeap{make([]int, 0, len(apples))} cnt := make(map[int]int, len(apples)) // 每个时间对应的腐烂苹果的数量 for i := range apples { // 新长出苹果 if days[i] != 0 { // 确保每个时间点仅有一个 heap.Push(h, i+days[i]) cnt[i+days[i]] += apples[i] } // 当天腐烂的苹果 丢弃 for h.Len() \u0026gt; 0 \u0026amp;\u0026amp; h.IntSlice[0] == i { heap.Pop(h) } // 可以吃苹果 if h.Len() \u0026gt; 0 { eat++ cnt[h.IntSlice[0]]-- if cnt[h.IntSlice[0]] == 0 { heap.Pop(h) } } } for day := len(apples); h.Len() \u0026gt; 0; { // 时间短，由时间决定 if h.IntSlice[0]-day \u0026lt; cnt[h.IntSlice[0]] { eat += h.IntSlice[0] - day day = h.IntSlice[0] } else { // 苹果少，由苹果数量决定 eat += cnt[h.IntSlice[0]] day += cnt[h.IntSlice[0]] } heap.Pop(h) } return eat } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(apples) = len(days) $ 空间复杂度：$ O(N) $ ","date":"2021-12-24T10:36:12+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1705.-%E5%90%83%E8%8B%B9%E6%9E%9C%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/","title":"Leetcode 1705. 吃苹果的最大数目"},{"content":"链接： https://leetcode-cn.com/problems/repeated-string-match/\n难度： 中等\n题目描述 给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。\n注意：字符串 \u0026quot;abc\u0026quot; 重复叠加 0 次是 \u0026quot;\u0026quot;，重复叠加 1 次是 \u0026quot;abc\u0026quot;，重复叠加 2 次是 \u0026quot;abcabc\u0026quot;。\n示例 1： 输入： a = \u0026ldquo;abcd\u0026rdquo;, b = \u0026ldquo;cdabcdab\u0026rdquo;\n输出： 3\n解释： a 重复叠加三遍后为 \u0026ldquo;abcdabcdabcd\u0026rdquo;, 此时 b 是其子串。\n示例 2： 输入： a = \u0026ldquo;a\u0026rdquo;, b = \u0026ldquo;aa\u0026rdquo;\n输出： 2\n示例 3： 输入： a = \u0026ldquo;a\u0026rdquo;, b = \u0026ldquo;a\u0026rdquo;\n输出： 1\n示例 4： 输入： a = \u0026ldquo;abc\u0026rdquo;, b = \u0026ldquo;wxyz\u0026rdquo;\n输出： -1\n注意： 1 \u0026lt;= a.length \u0026lt;= 104 1 \u0026lt;= b.length \u0026lt;= 104 a 和 b 由小写英文字母组成 解题思路 暴力求解 当 b 可以满足其是 a 叠加后的字串的时候，其从 a 中某个字符开始，之后按照 a 中字母的顺序循环。当 a 叠加后的长度为 $len(a)*\\lceil\\frac{len(b)}{len(a)}+1\\rceil$ 能覆盖所有情况。\n不断叠加 a 直到其长度为 $len(a)*\\lceil\\frac{len(b)}{len(a)}\\rceil$ 为止。\n若此时当 b 满足条件，返回叠加次数。否则，再叠加一次进行判断，若还不满足，返回 -1。\nfunc repeatedStringMatch(a string, b string) int { cnt := 0 s := make([]byte, 0, len(a)*(int(math.Ceil(float64(len(b))/float64(len(a))))+1)) for i := len(b); i \u0026gt; 0; i -= len(a) { s = append(s, a...) cnt++ } if bytes.Contains(s, []byte(b)) { return cnt } s = append(s, a...) cnt++ if bytes.Contains(s, []byte(b)) { return cnt } return -1 } 复杂度 时间复杂度：$ O(M), N = len(a), M = len(b) $ 空间复杂度：$ O(M) $ 循环匹配 若 b 为 a 叠加后的字串，则其从 a 中的某个字符开始，按照 a 的模式不断在 a 上循环匹配，能匹配到 b 结束。\n若能找到这个开始的字符返回返回循环匹配的次数，否则返回 -1。\nfunc repeatedStringMatch(a string, b string) int { Outer: for i := range a { if a[i] != b[0] { continue } for j := range b { if b[j] != a[(i+j)%len(a)] { continue Outer } } return int(math.Ceil(float64(i+len(b)) / float64(len(a)))) } return -1 } 复杂度 时间复杂度：$ O(N*M), N = len(a), M = len(b) $ 空间复杂度：$ O(1) $ ","date":"2021-12-22T10:15:24+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-686.-%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/","title":"Leetcode 686. 重复叠加字符串匹配"},{"content":"链接： https://leetcode-cn.com/problems/day-of-the-year/\n难度： 简单\n题目描述 给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。\n通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。\n示例 1： 输入： date = \u0026ldquo;2019-01-09\u0026rdquo;\n输出： 9\n示例 2： 输入： date = \u0026ldquo;2019-02-10\u0026rdquo;\n输出： 41\n示例 3： 输入： date = \u0026ldquo;2003-03-01\u0026rdquo;\n输出： 60\n示例 4： 输入： date = \u0026ldquo;2004-03-01\u0026rdquo;\n输出： 61\n提示： date.length == 10 date[4] == date[7] == '-'，其他的 date[i] 都是数字 date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日 解题思路 模拟 按照每月天数累加到前一个月，然后加上本月的天数。\n闰年二月多一天。\nfunc dayOfYear(date string) int { monthDays := []int{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31} year, _ := strconv.Atoi(date[:4]) month, _ := strconv.Atoi(date[5:7]) day, _ := strconv.Atoi(date[8:]) // 闰年二月多一天 if (year%400 == 0) || (year%4 == 0 \u0026amp;\u0026amp; year%100 != 0) { monthDays[1]++ } days := day for i := month - 2; i \u0026gt;= 0; i-- { days += monthDays[i] } return days } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-12-21T10:12:33+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1154.-%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9/","title":"Leetcode 1154. 一年中的第几天"},{"content":"链接： https://leetcode-cn.com/problems/heaters/\n难度： 中等\n题目描述 冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。\n在加热器的加热半径范围内的每个房屋都可以获得供暖。\n现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。\n说明： 所有供暖器都遵循你的半径标准，加热的半径也一样。\n示例 1： 输入: houses = [1,2,3], heaters = [2]\n输出: 1\n解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。\n示例 2： 输入: houses = [1,2,3,4], heaters = [1,4]\n输出: 1\n解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。\n示例 3： 输入： houses = [1,5], heaters = [2]\n输出： 3\n提示： 1 \u0026lt;= houses.length, heaters.length \u0026lt;= 3 * 104 1 \u0026lt;= houses[i], heaters[i] \u0026lt;= 109 解题思路 暴力求解 每个房子的加热由距离最近的那个加热器保障。\n对于每个房子，找到距离其最近的那个加热器，确定保障该房子的加热半径。\n在上述半径中选出最大的。\nfunc findRadius(houses []int, heaters []int) int { ans := 0 for _, house := range houses { radius := math.MaxInt32 for _, heater := range heaters { if heater \u0026gt; house { if radius \u0026gt; heater-house { radius = heater - house } } else { if radius \u0026gt; house-heater { radius = house - heater } } } if ans \u0026lt; radius { ans = radius } } return ans } 复杂度 时间复杂度：$ O(N * M), N = len(houses), M = len(heaters) $ 空间复杂度：$ O(1) $ 排序 + 二分查找 在上述基础上，通过排序后使用二分查找降低时间复杂度。\nfunc min(x, y int) int { if x \u0026lt; y { return x } return y } func findRadius(houses []int, heaters []int) int { sort.Ints(heaters) ans := 0 for _, house := range houses { radius := math.MaxInt32 for l, r := 0, len(heaters)-1; l \u0026lt;= r; { mid := (l + r) / 2 if heaters[mid] == house { radius = 0 break } else if heaters[mid] \u0026lt; house { radius = min(radius, house-heaters[mid]) l = mid + 1 } else { radius = min(radius, heaters[mid]-house) r = mid - 1 } } if ans \u0026lt; radius { ans = radius } } return ans } 复杂度 时间复杂度：$ O((N + M)\\log{M}), N = len(houses), M = len(heaters) $ 空间复杂度：$ O(\\log{M}) $ 排序 + 双指针 每个房子的加热由距离最近的那个加热器保障。\n首先对房子和加热器排序，使用双指针记录两个相邻的加热器 i, j (i \u0026lt; j)：\n当房子位于左侧时，其加热半径为到 i 的距离； 当房子位于中间时。其加热半径为到 i 和到 j 的距离的最小值； 当房子位于右侧时，无法界定距离其最近的加热器，寻找下一组相邻散热器； 当存在比最右侧的加热器还靠右的房子时，其加热半径为到最右侧散热器的距离。 在上述情况下，记录半径的最大值。\nfunc max(x, y int) int { if x \u0026gt; y { return x } return y } func findRadius(houses []int, heaters []int) int { sort.Ints(houses) sort.Ints(heaters) radius := 0 i, j := 0, 1 for k := 0; k \u0026lt; len(houses); { if houses[k] \u0026lt; heaters[i] { // 房子在两个加热器左侧，距离左边的距离最近 radius = max(radius, heaters[i]-houses[k]) } else if j \u0026gt;= len(heaters) { // 房子在最右侧加热器右边，距离该散热器最近 radius = max(radius, houses[k]-heaters[i]) } else if houses[k] \u0026gt; heaters[j] { // 房子在两个加热器右侧，无法界定，换下一组相邻加热器 i++ j++ continue } else { // 房子在两个加热器中间，选择最近的那一个 if houses[k]-heaters[i] \u0026lt; heaters[j]-houses[k] { radius = max(radius, houses[k]-heaters[i]) } else { radius = max(radius, heaters[j]-houses[k]) } } k++ } return radius } 复杂度 时间复杂度：$ O(N\\log{N} + M\\log{M}), N = len(houses), M = len(heaters) $ 空间复杂度：$ O(\\log{N} + \\log{M}) $ ","date":"2021-12-20T10:17:12+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-475.-%E4%BE%9B%E6%9A%96%E5%99%A8/","title":"Leetcode 475. 供暖器"},{"content":"链接： https://leetcode-cn.com/problems/find-the-town-judge/\n难度： 简单\n题目描述 在一个小镇里，按从 1 到 n 为 n 个人进行编号。传言称，这些人中有一个是小镇上的秘密法官。\n如果小镇的法官真的存在，那么：\n小镇的法官不相信任何人。 每个人（除了小镇法官外）都信任小镇的法官。 只有一个人同时满足条件 1 和条件 2 。 给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示编号为 a 的人信任编号为 b 的人。\n如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的编号。否则，返回 -1。\n示例 1： 输入： n = 2, trust = [[1,2]]\n输出： 2\n示例 2： 输入： n = 3, trust = [[1,3],[2,3]]\n输出： 3\n示例 3： 输入： n = 3, trust = [[1,3],[2,3],[3,1]]\n输出： -1\n示例 4： 输入： n = 3, trust = [[1,2],[2,3]]\n输出： -1\n示例 5： 输入： n = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]\n输出： 3\n提示： 1 \u0026lt;= n \u0026lt;= 1000 0 \u0026lt;= trust.length \u0026lt;= 104 trust[i].length == 2 trust[i] 互不相同 trust[i][0] != trust[i][1] 1 \u0026lt;= trust[i][0], trust[i][1] \u0026lt;= n 解题思路 哈希 当存在法官时，除了法官本身外，其余所有人都要相信他，使用哈希表记录每个人的被多少个人信任，要保证其严格等于 n-1；\n另外，法官不能信任任何人，需要使用另一个哈希表，记录每个人是否信任其他人。\nfunc findJudge(n int, trust [][]int) int { beTrusted := make([]int, n) trustOthers := make([]bool, n) for _, t := range trust { beTrusted[t[1]-1]++ trustOthers[t[0]-1] = true } for i, cnt := range beTrusted { if cnt == n-1 \u0026amp;\u0026amp; !trustOthers[i] { return i + 1 } } return -1 } 复杂度 时间复杂度：$ O(n * L), L = len(trust) $ 空间复杂度：$O(n) $ ","date":"2021-12-19T20:21:03+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-997.-%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98/","title":"Leetcode 997. 找到小镇的法官"},{"content":"链接： https://leetcode-cn.com/problems/battleships-in-a-board/\n难度： 中等\n题目描述 给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 'X' 或者是一个空位 '.' ，返回在甲板 board 上放置的 战舰 的数量。\n战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。\n示例 1： 输入： board = [[\u0026ldquo;X\u0026rdquo;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026ldquo;X\u0026rdquo;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026ldquo;X\u0026rdquo;],[\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026quot;.\u0026quot;,\u0026ldquo;X\u0026rdquo;]]\n输出： 2\n示例 2： 输入： board = [[\u0026quot;.\u0026quot;]]\n输出： 0\n提示： m == board.length n == board[i].length 1 \u0026lt;= m, n \u0026lt;= 200 board[i][j] 是 '.' 或 'X' 进阶： 你可以实现一次扫描算法，并只使用 $O(1)$ 额外空间，并且不修改 board 的值来解决这个问题吗？\n解题思路 标记计数 遍历整个 board，当遇到 \u0026quot;X\u0026quot; 时，战舰数量 +1，找到与之构成一艘战舰的所有 \u0026quot;X\u0026quot; 将其标记为 \u0026quot;.\u0026quot; 以达到去重目的。\n由于战舰只能水平或者垂直排列，题设保证不同战舰不能相邻，故向右和向下寻找即可。\nfunc countBattleships(board [][]byte) int { ans := 0 for i := range board { for j := range board[0] { if board[i][j] == \u0026#39;X\u0026#39; { ans++ board[i][j] = \u0026#39;.\u0026#39; // 向下找 for k := i + 1; k \u0026lt; len(board) \u0026amp;\u0026amp; board[k][j] == \u0026#39;X\u0026#39;; k++ { board[k][j] = \u0026#39;.\u0026#39; } // 向右找 for k := j + 1; k \u0026lt; len(board[0]) \u0026amp;\u0026amp; board[i][k] == \u0026#39;X\u0026#39;; k++ { board[i][k] = \u0026#39;.\u0026#39; } } } } return ans } 复杂度 时间复杂度：$ O(m*n *max(m,n)) $ 空间复杂度：$ O(1) $ 优化 当一个 \u0026quot;X\u0026quot;的左侧和上方出现 \u0026quot;X\u0026quot; 时，说明这个战舰已经被统计过了，可以利用这个方法作为去重的一种手段。\n遍历整个 board，当其左侧和上方均没有 \u0026quot;X\u0026quot;，说明找到了新的一艘战舰。\nfunc countBattleships(board [][]byte) int { ans := 0 for i := range board { for j := range board[0] { if board[i][j] == \u0026#39;X\u0026#39; { // 左侧和上方均没有 X if !((i \u0026gt; 0 \u0026amp;\u0026amp; board[i-1][j] == \u0026#39;X\u0026#39;) || (j \u0026gt; 0 \u0026amp;\u0026amp; board[i][j-1] == \u0026#39;X\u0026#39;)) { ans++ } } } } return ans } 复杂度 时间复杂度：$ O(m*n) $ 空间复杂度：$ O(1) $ ","date":"2021-12-18T11:06:52+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-419.-%E7%94%B2%E6%9D%BF%E4%B8%8A%E7%9A%84%E6%88%98%E8%88%B0/","title":"Leetcode 419. 甲板上的战舰"},{"content":"链接： https://leetcode-cn.com/problems/water-bottles/\n难度： 简单\n题目描述 小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。\n如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。\n请你计算 最多 能喝到多少瓶酒。\n示例 1： 输入： numBottles = 9, numExchange = 3\n输出： 13\n解释： 你可以用 3 个空酒瓶兑换 1 瓶酒。\n所以最多能喝到 9 + 3 + 1 = 13 瓶酒。\n示例 2： 输入： numBottles = 15, numExchange = 4\n输出： 19\n解释： 你可以用 4 个空酒瓶兑换 1 瓶酒。\n所以最多能喝到 15 + 3 + 1 = 19 瓶酒。\n示例 3： 输入： numBottles = 5, numExchange = 5\n输出： 6\n示例 4： 输入： numBottles = 2, numExchange = 3\n输出： 2\n提示： 1 \u0026lt;= numBottles \u0026lt;= 100 2 \u0026lt;= numExchange \u0026lt;= 100 解题思路 模拟 每次将所有的空酒瓶换为酒，不断进行，直到不可换为止，统计在此过程中的酒的数量。\nfunc numWaterBottles(numBottles int, numExchange int) int { ans := numBottles // 该开始的酒全部喝下 for numBottles \u0026gt;= numExchange { ans += numBottles / numExchange // 兑换的酒数量 numBottles = numBottles%numExchange + numBottles/numExchange // 兑换一次后的酒瓶数 } return ans } 复杂度 时间复杂度：$ O(\\log_E{B}), E = numExchange, B = numBottles $ 空间复杂度：$ O(1) $ 数学 每次兑换就瓶子数量将会减少 numExchange - 1 个，设兑换 n 次后，无法继续兑换，则有不等式：\n$$ numBottles - n * (numExchange - 1) \u0026lt; numExchange且 numBottles - (n-1) * (numExchange - 1) ≥ numExchange $$\n得到 $$ n = \\lfloor\\frac{numBottles - numExchange}{numExchange - 1}\\rfloor + 1 $$\nfunc numWaterBottles(numBottles int, numExchange int) int { // 不能兑换 if numBottles \u0026lt; numExchange { return numBottles } return numBottles + (numBottles-numExchange)/(numExchange-1) + 1 } 复杂度 时间复杂度：$ O(1), E = numExchange, B = numBottles $ 空间复杂度：$ O(1) $ ","date":"2021-12-17T10:14:30+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1518.-%E6%8D%A2%E9%85%92%E9%97%AE%E9%A2%98/","title":"Leetcode 1518. 换酒问题"},{"content":"链接： https://leetcode-cn.com/problems/loud-and-rich/\n难度： 中等\n题目描述 有一组 n 个人作为实验对象，从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值（quietness）。为了方便起见，我们将编号为 x 的人简称为 \u0026ldquo;person x \u0026ldquo;。\n给你一个数组 richer ，其中 richer[i] = [ai, bi] 表示 person ai 比 person bi 更有钱。另给你一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值。richer 中所给出的数据 逻辑自恰（也就是说，在 person x 比 person y 更有钱的同时，不会出现 person y 比 person x 更有钱的情况 ）。\n现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是，在所有拥有的钱肯定不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。\n示例 1： 输入： richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\n输出： [5,5,2,5,4,5,6,7]\n解释：\nanswer[0] = 5，\nperson 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。\n唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，\n但是目前还不清楚他是否比 person 0 更有钱。\nanswer[7] = 7，\n在所有拥有的钱肯定不少于 person 7 的人中（这可能包括 person 3，4，5，6 以及 7），\n最安静（有较低安静值 quiet[x]）的人是 person 7。\n其他的答案也可以用类似的推理来解释。\n示例 2： 输入： richer = [], quiet = [0]\n输出： [0]\n提示： n == quiet.length 1 \u0026lt;= n \u0026lt;= 500 0 \u0026lt;= quiet[i] \u0026lt; n quiet 的所有值 互不相同 0 \u0026lt;= richer.length \u0026lt;= n * (n - 1) / 2 0 \u0026lt;= ai, bi \u0026lt; n ai != bi richer 中的所有数对 互不相同 对 richer 的观察在逻辑上是一致的 解题思路 深度优先搜索（带备忘） 将存在 richer 关系的人维护到一个有向图中，边的方向表示富有程度增加。\n之后对于每个人，搜索比他富有的所有人，找到最安静的那个人。\n当找到 answer[x] = y，则对于后续当搜索到 person x 时，最安静的那个人为 person y ，可以使用备忘进行剪枝，降低时间复杂度。\nfunc loudAndRich(richer [][]int, quiet []int) []int { // 初始化图 graph := make([][]int, len(quiet)) for _, r := range richer { graph[r[1]] = append(graph[r[1]], r[0]) } // 结果.同时当备忘使用 ans := make([]int, len(quiet)) // 初始化为 -1 ,表示需要查找 for i := range ans { ans[i] = -1 } var dfs func(i int) dfs = func(i int) { // 去备忘查找 if ans[i] != -1 { return } // 找到最安静的 ans[i] = i for _, next := range graph[i] { dfs(next) if quiet[ans[i]] \u0026gt; quiet[ans[next]] { ans[i] = ans[next] } } } // 遍历图 for i := range ans { dfs(i) } return ans } 复杂度 时间复杂度：$ O(n+E), E = len(richer) $ 空间复杂度：$ O(n+E) $ 拓扑排序 在一条按照富有程度降序的链中，当某一个 person x 对应的 answer[x] 找到后，后续的一个结点 person y 其 person[y] 等于 min(y, answer[x])。\n基于以上原理，进行拓扑排序，对于每个选出来的结点，依次不断地更新后续结点，最终得到答案。\nfunc loudAndRich(richer [][]int, quiet []int) []int { graph := make([][]int, len(quiet)) inDegrees := make(map[int]int) ans := make([]int, len(quiet)) for i := range quiet { inDegrees[i] = 0 // 初始化入度 ans[i] = i // 初始化结果 } // 初始化图 for _, r := range richer { graph[r[0]] = append(graph[r[0]], r[1]) inDegrees[r[1]]++ } // 所有结点都被遍历 for len(inDegrees) \u0026gt; 0 { // 寻找入度为 0 的结点 for i, inDegree := range inDegrees { if inDegree != 0 { continue } delete(inDegrees, i) // 删除结点 for _, next := range graph[i] { // 更新后续结点 if quiet[ans[next]] \u0026gt; quiet[ans[i]] { ans[next] = ans[i] } inDegrees[next]-- // 删除出度 } break } } return ans } 复杂度 时间复杂度：$ O(n+E), E = len(richer) $ 空间复杂度：$ O(n+E) $ ","date":"2021-12-15T10:17:33+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-851.-%E5%96%A7%E9%97%B9%E5%92%8C%E5%AF%8C%E6%9C%89/","title":"Leetcode 851. 喧闹和富有"},{"content":"链接： https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline/\n难度： 中等\n题目描述 在二维数组 grid 中，grid[i][j] 代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。\n最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的“天际线”必须与原始数组的天际线相同。 城市的天际线是从远处观看时，由所有建筑物形成的矩形的外部轮廓。 请看下面的例子。\n建筑物高度可以增加的最大总和是多少？\n例子：\n输入： grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\n输出： 35\n解释：\nThe grid is: [ [3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0] ] 从数组竖直方向（即顶部，底部）看“天际线”是：[9, 4, 8, 7]\n从水平水平方向（即左侧，右侧）看“天际线”是：[8, 7, 9, 3]\n在不影响天际线的情况下对建筑物进行增高后，新数组如下：\ngridNew = [ [8, 4, 8, 7], [7, 4, 7, 7], [9, 4, 8, 7], [3, 3, 3, 3] ] 说明： 1 \u0026lt; grid.length = grid[0].length \u0026lt;= 50 grid[i][j] 的高度范围是： [0, 100] 。 一座建筑物占据一个 grid[i][j] ：换言之，它们是 1 x 1 x grid[i][j] 的长方体。 解题思路 贪心 每一行/列的天际线是该行/列的建筑物高度的最大值，故每个建筑物可以增加的高度由其所在位置的 行中建筑物最大值 和 列中建筑物的最大值 这两个值当中 较小 的那一个确定。\n依次求得每行和列的最大值，计算每个建筑物的可以增加的高度。\nfunc maxIncreaseKeepingSkyline(grid [][]int) int { rowMax := make([]int, len(grid)) colMax := make([]int, len(grid[0])) for i, row := range grid { for j, cell := range row { rowMax[i] = Max(rowMax[i], cell) // 第 i 行最大值 colMax[j] = Max(colMax[j], cell) // 第 j 列最大值 } } ans := 0 for i, row := range grid { for j, cell := range row { ans += Min(rowMax[i], colMax[j]) - cell // 计算可以增加的高度 } } return ans } func Max(x, y int) int { if x \u0026gt; y { return x } return y } func Min(x, y int) int { if x \u0026lt; y { return x } return y } 复杂度 时间复杂度：$ O(MN), M = len(grid), N = len(grid[0]) $ 空间复杂度：$ O(M+N) $ ","date":"2021-12-13T11:03:06+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-807.-%E4%BF%9D%E6%8C%81%E5%9F%8E%E5%B8%82%E5%A4%A9%E9%99%85%E7%BA%BF/","title":"Leetcode 807. 保持城市天际线"},{"content":"链接： https://leetcode-cn.com/problems/to-lower-case/\n难度： 简单\n题目描述 给你一个字符串 s ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。\n示例 1： 输入： s = \u0026ldquo;Hello\u0026rdquo; 输出： \u0026ldquo;hello\u0026rdquo;\n示例 2： 输入： s = \u0026ldquo;here\u0026rdquo; 输出： \u0026ldquo;here\u0026rdquo;\n示例 3： 输入： s = \u0026ldquo;LOVELY\u0026rdquo;\n输出： \u0026ldquo;lovely\u0026rdquo;\n提示： 1 \u0026lt;= s.length \u0026lt;= 100 s 由 ASCII 字符集中的可打印字符组成 解题思路 模拟 扫描字符串，将大写字母变为小写字母。\nfunc toLowerCase(s string) string { ans := make([]byte, 0, len(s)) for i := range s { if \u0026#39;A\u0026#39; \u0026lt;= s[i] \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;Z\u0026#39; { ans = append(ans, s[i]-\u0026#39;A\u0026#39;+\u0026#39;a\u0026#39;) } else { ans = append(ans, s[i]) } } return string(ans) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-12-12T10:17:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-709.-%E8%BD%AC%E6%8D%A2%E6%88%90%E5%B0%8F%E5%86%99%E5%AD%97%E6%AF%8D/","title":"Leetcode 709. 转换成小写字母"},{"content":"链接： https://leetcode-cn.com/problems/online-election/\n难度： 中等\n题目描述 给你两个整数数组 persons 和 times 。在选举中，第 i 张票是在时刻为 times[i] 时投给候选人 persons[i] 的。\n对于发生在时刻 t 的每个查询，需要找出在 t 时刻在选举中领先的候选人的编号。\n在 t 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。\n实现 TopVotedCandidate 类：\nTopVotedCandidate(int[] persons, int[] times) 使用 persons 和 times 数组初始化对象。 int q(int t) 根据前面描述的规则，返回在时刻 t 在选举中领先的候选人的编号。 示例： 输入：\n[\u0026ldquo;TopVotedCandidate\u0026rdquo;, \u0026ldquo;q\u0026rdquo;, \u0026ldquo;q\u0026rdquo;, \u0026ldquo;q\u0026rdquo;, \u0026ldquo;q\u0026rdquo;, \u0026ldquo;q\u0026rdquo;, \u0026ldquo;q\u0026rdquo;]\n[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\n输出：\n[null, 0, 1, 1, 0, 0, 1]\n解释：\nTopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, \u0026gt; 20, 25, 30]);\ntopVotedCandidate.q(3); // 返回 0 ，在时刻 3 ，票数分布为 [0] ，编号为 0 的候选人领先。\ntopVotedCandidate.q(12); // 返回 1 ，在时刻 12 ，票数分布为 [0,1,1] ，编号为 1 的候选人领先。\ntopVotedCandidate.q(25); // 返回 1 ，在时刻 25 ，票数分布为 [0,1,1,0,0,1] ，编号为 1 的候选人领先。（在平局\u0026gt; 的情况下，1 是最近获得投票的候选人）。\ntopVotedCandidate.q(15); // 返回 0\ntopVotedCandidate.q(24); // 返回 0\ntopVotedCandidate.q(8); // 返回 1\n提示： 1 \u0026lt;= persons.length \u0026lt;= 5000 times.length == persons.length 0 \u0026lt;= persons[i] \u0026lt; persons.length 0 \u0026lt;= times[i] \u0026lt;= 109 times 是一个严格递增的有序数组 times[0] \u0026lt;= t \u0026lt;= 109 每个测试用例最多调用 104 次 q 解题思路 哈希 + 二分查找 使用哈希表记录到 t 时刻为止，每个人可以获得的选票，求得在每个时刻 times[i] 中领先的那一个人记录到数组中。\n后续 q 操作通过二分查找寻找不超过 t 的 times[i] 时刻，返回当时领先的那一个人。\ntype TopVotedCandidate struct { times []int winers []int } func Constructor(persons []int, times []int) TopVotedCandidate { winers := make([]int, 0, len(times)) // 每个时刻赢家 votes := make(map[int]int) // 每个候选人获得的选票 max := -1 // 当前最大投票数 winer := 0 // 当前赢家 for i := range times { votes[persons[i]]++ // 更新最大票数，当前赢家，相同票数最近的候选人赢 if max \u0026lt;= votes[persons[i]] { max = votes[persons[i]] winer = persons[i] } winers = append(winers, winer) } return TopVotedCandidate{ times: times, winers: winers, } } func (this *TopVotedCandidate) Q(t int) int { l, r := 0, len(this.times) for l \u0026lt; r-1 { mid := (l + r) / 2 if t \u0026lt; this.times[mid] { r = mid } else { l = mid } } return this.winers[l] } 复杂度 时间复杂度： Constructor：$ O(N), N = len(times) $ Q：$ O(\\log{N}) $ 空间复杂度：$ O(N) $ Constructor：$ O(N), N = len(times) $ Q：$ O(1) $ ","date":"2021-12-11T09:52:59+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-911.-%E5%9C%A8%E7%BA%BF%E9%80%89%E4%B8%BE/","title":"Leetcode 911. 在线选举"},{"content":"链接： https://leetcode-cn.com/problems/shortest-completing-word/\n难度： 简单\n题目描述 给你一个字符串 licensePlate 和一个字符串数组 words ，请你找出并返回 words 中的 最短补全词 。\n补全词 是一个包含 licensePlate 中所有的字母的单词。在所有补全词中，最短的那个就是 最短补全词 。\n在匹配 licensePlate 中的字母时：\n忽略 licensePlate 中的 数字和空格 。 不区分大小写 。 如果某个字母在 licensePlate 中出现不止一次，那么该字母在补全词中的出现次数应当一致或者更多。 例如：licensePlate = \u0026quot;aBc 12c\u0026quot;，那么它的补全词应当包含字母 'a'、'b' （忽略大写）和两个 'c' 。可能的 补全词 有 \u0026quot;abccdef\u0026quot;、\u0026quot;caaacab\u0026quot; 以及 \u0026quot;cbca\u0026quot; 。\n请你找出并返回 words 中的 最短补全词 。题目数据保证一定存在一个最短补全词。当有多个单词都符合最短补全词的匹配条件时取 words 中 最靠前的 那个。\n示例 1： 输入： licensePlate = \u0026ldquo;1s3 PSt\u0026rdquo;, words = [\u0026ldquo;step\u0026rdquo;, \u0026ldquo;steps\u0026rdquo;, \u0026ldquo;stripe\u0026rdquo;, \u0026ldquo;stepple\u0026rdquo;]\n输出： \u0026ldquo;steps\u0026rdquo;\n解释： 最短补全词应该包括 \u0026ldquo;s\u0026rdquo;、\u0026ldquo;p\u0026rdquo;、\u0026ldquo;s\u0026rdquo;（忽略大小写） 以及 \u0026ldquo;t\u0026rdquo;。\n\u0026ldquo;step\u0026rdquo; 包含 \u0026ldquo;t\u0026rdquo;、\u0026ldquo;p\u0026rdquo;，但只包含一个 \u0026ldquo;s\u0026rdquo;，所以它不符合条件。\n\u0026ldquo;steps\u0026rdquo; 包含 \u0026ldquo;t\u0026rdquo;、\u0026ldquo;p\u0026rdquo; 和两个 \u0026ldquo;s\u0026rdquo;。\n\u0026ldquo;stripe\u0026rdquo; 缺一个 \u0026ldquo;s\u0026rdquo;。\n\u0026ldquo;stepple\u0026rdquo; 缺一个 \u0026ldquo;s\u0026rdquo;。\n因此，\u0026ldquo;steps\u0026rdquo; 是唯一一个包含所有字母的单词，也是本例的答案。\n示例 2： 输入： licensePlate = \u0026ldquo;1s3 456\u0026rdquo;, words = [\u0026ldquo;looks\u0026rdquo;, \u0026ldquo;pest\u0026rdquo;, \u0026ldquo;stew\u0026rdquo;, \u0026ldquo;show\u0026rdquo;]\n输出： \u0026ldquo;pest\u0026rdquo;\n解释： licensePlate 只包含字母 \u0026ldquo;s\u0026rdquo; 。所有的单词都包含字母 \u0026ldquo;s\u0026rdquo; ，其中 \u0026ldquo;pest\u0026rdquo;、\u0026ldquo;stew\u0026rdquo;、和 \u0026ldquo;show\u0026rdquo; 三者最短。答案是 \u0026ldquo;pest\u0026rdquo; ，因为它是三个单词中在 words 里最靠前的那个。\n示例 3： 输入： licensePlate = \u0026ldquo;Ah71752\u0026rdquo;, words = [\u0026ldquo;suggest\u0026rdquo;,\u0026ldquo;letter\u0026rdquo;,\u0026ldquo;of\u0026rdquo;,\u0026ldquo;husband\u0026rdquo;,\u0026ldquo;easy\u0026rdquo;,\u0026ldquo;education\u0026rdquo;,\u0026ldquo;drug\u0026rdquo;,\u0026ldquo;prevent\u0026rdquo;,\u0026ldquo;writer\u0026rdquo;,\u0026ldquo;old\u0026rdquo;]\n输出： \u0026ldquo;husband\u0026rdquo;\n示例 4： 输入： licensePlate = \u0026ldquo;OgEu755\u0026rdquo;, words = [\u0026ldquo;enough\u0026rdquo;,\u0026ldquo;these\u0026rdquo;,\u0026ldquo;play\u0026rdquo;,\u0026ldquo;wide\u0026rdquo;,\u0026ldquo;wonder\u0026rdquo;,\u0026ldquo;box\u0026rdquo;,\u0026ldquo;arrive\u0026rdquo;,\u0026ldquo;money\u0026rdquo;,\u0026ldquo;tax\u0026rdquo;,\u0026ldquo;thus\u0026rdquo;]\n输出： \u0026ldquo;enough\u0026rdquo;\n示例 5： 输入： licensePlate = \u0026ldquo;iMSlpe4\u0026rdquo;, words = [\u0026ldquo;claim\u0026rdquo;,\u0026ldquo;consumer\u0026rdquo;,\u0026ldquo;student\u0026rdquo;,\u0026ldquo;camera\u0026rdquo;,\u0026ldquo;public\u0026rdquo;,\u0026ldquo;never\u0026rdquo;,\u0026ldquo;wonder\u0026rdquo;,\u0026ldquo;simple\u0026rdquo;,\u0026ldquo;thought\u0026rdquo;,\u0026ldquo;use\u0026rdquo;]\n输出： \u0026ldquo;simple\u0026rdquo;\n提示： 1 \u0026lt;= licensePlate.length \u0026lt;= 7 licensePlate 由数字、大小写字母或空格 ' ' 组成 1 \u0026lt;= words.length \u0026lt;= 1000 1 \u0026lt;= words[i].length \u0026lt;= 15 words[i] 由小写英文字母组成 解题思路 哈希 使用哈希表记录 licensePlate 中字母的数量（存在大写字母则修改为对应小写字母），之后逐一的和 words 中每一个单词字母数量的哈希表比较，找出首个符合条件的单词并返回。\nfunc shortestCompletingWord(licensePlate string, words []string) string { charCnt := make(map[byte]int) for i := range licensePlate { if \u0026#39;A\u0026#39; \u0026lt;= licensePlate[i] \u0026amp;\u0026amp; licensePlate[i] \u0026lt;= \u0026#39;Z\u0026#39; { charCnt[licensePlate[i]-\u0026#39;A\u0026#39;+\u0026#39;a\u0026#39;]++ } else if \u0026#39;a\u0026#39; \u0026lt;= licensePlate[i] \u0026amp;\u0026amp; licensePlate[i] \u0026lt;= \u0026#39;z\u0026#39; { charCnt[licensePlate[i]]++ } } ans := \u0026#34;\u0026#34; Outer: for _, word := range words { t := make(map[byte]int) for i := range word { t[word[i]]++ } for k, v := range charCnt { if t[k] \u0026lt; v { continue Outer } } if ans == \u0026#34;\u0026#34; || len(ans) \u0026gt; len(word) { ans = word } } return ans } 复杂度 时间复杂度：$ O(L_1N\\bar{L}), L_1 = len(licensePlate), N = len(words), \\bar{L} = avg(len(words[i])) $ 空间复杂度：$ O(max(L, len(words[i])) $ ","date":"2021-12-10T17:25:57+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-748.-%E6%9C%80%E7%9F%AD%E8%A1%A5%E5%85%A8%E8%AF%8D/","title":"Leetcode 748. 最短补全词"},{"content":"链接： https://leetcode-cn.com/problems/valid-tic-tac-toe-state/\n难度： 中等\n题目描述 给你一个字符串数组 board 表示井字游戏的棋盘。当且仅当在井字游戏过程中，棋盘有可能达到 board 所显示的状态时，才返回 true 。\n井字游戏的棋盘是一个 3 x 3 数组，由字符 ' '，'X' 和 'O' 组成。字符 ' ' 代表一个空位。\n以下是井字游戏的规则：\n玩家轮流将字符放入空位（' '）中。 玩家 1 总是放字符 'X' ，而玩家 2 总是放字符 'O' 。 'X' 和 'O' 只允许放置在空位中，不允许对已放有字符的位置进行填充。 当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。 当所有位置非空时，也算为游戏结束。 如果游戏结束，玩家不允许再放置字符。 示例 1： 输入： board = [\u0026ldquo;O \u0026ldquo;,\u0026rdquo; \u0026ldquo;,\u0026rdquo; \u0026ldquo;]\n输出： false\n解释： 玩家 1 总是放字符 \u0026ldquo;X\u0026rdquo; 。\n示例 2： 输入： board = [\u0026ldquo;XOX\u0026rdquo;,\u0026rdquo; X \u0026ldquo;,\u0026rdquo; \u0026ldquo;]\n输出： false\n解释： 玩家应该轮流放字符。\n示例 3： 输入： board = [\u0026ldquo;XXX\u0026rdquo;,\u0026rdquo; \u0026ldquo;,\u0026ldquo;OOO\u0026rdquo;]\n输出： false\n示例 4： 输入： board = [\u0026ldquo;XOX\u0026rdquo;,\u0026ldquo;O O\u0026rdquo;,\u0026ldquo;XOX\u0026rdquo;]\n输出： true\n提示： board.length == 3 board[i].length == 3 board[i][j] 为 'X'、'O' 或 ' ' 解题思路 分类讨论 满足条件的情况有如下几种：\n双方均不满足获胜条件，此时 \u0026quot;X\u0026quot; 的数量或者与 \u0026quot;O\u0026quot; 的数量相等，或者多 1 个； 只有其中一个玩家满足获胜条件： 当仅玩家 1 获胜时，\u0026quot;X\u0026quot; 的数量要比 \u0026quot;O\u0026quot; 的数量多 1； 当仅玩家 2 获胜时，\u0026quot;X\u0026quot; 的数量要与 \u0026quot;O\u0026quot; 的数量相等； func validTicTacToe(board []string) bool { n := len(board) xNum, oNum := 0, 0 // 棋子数量统计 for _, line := range board { for j := range board { switch line[j] { case \u0026#39;X\u0026#39;: xNum++ case \u0026#39;O\u0026#39;: oNum++ } } } // 数量不符合题设 if xNum \u0026lt; oNum || xNum-oNum \u0026gt; 1 { return false } xWin, oWin := false, false // 是否满足获胜条件 // 是否有相同行，列，对角线，进行修正 win := func(same bool, ch byte) { if !same { return } switch ch { case \u0026#39;X\u0026#39;: xWin = true case \u0026#39;O\u0026#39;: oWin = true } } for i := 0; i \u0026lt; n; i++ { rowSame, colSame := true, true for j := 1; j \u0026lt; n; j++ { // 行扫描 if board[i][j] != board[i][0] { rowSame = false } // 列扫描 if board[j][i] != board[0][i] { colSame = false } } win(rowSame, board[i][0]) win(colSame, board[0][i]) } // 对角线扫描 forwordSame, backSame := true, true for i := n - 1; i \u0026gt; 0; i-- { if board[i][i] != board[0][0] { forwordSame = false } if board[i][n-1-i] != board[0][n-1] { backSame = false } } win(forwordSame, board[0][0]) win(backSame, board[0][n-1]) // 不满足题设条件 if (xWin \u0026amp;\u0026amp; oWin) || (xWin \u0026amp;\u0026amp; xNum \u0026lt;= oNum) || (oWin \u0026amp;\u0026amp; xNum \u0026gt; oNum) { return false } return true } 复杂度 时间复杂度：$ O(N^2), N = len(board) $ 空间复杂度：$ O(1) $ ","date":"2021-12-09T10:16:48+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-794.-%E6%9C%89%E6%95%88%E7%9A%84%E4%BA%95%E5%AD%97%E6%B8%B8%E6%88%8F/","title":"Leetcode 794. 有效的井字游戏"},{"content":"链接： https://leetcode-cn.com/problems/coloring-a-border/\n难度： 中等\n题目描述 给你一个大小为 m x n 的整数矩阵 grid ，表示一个网格。另给你三个整数 row、col 和 color 。网格中的每个值表示该位置处的网格块的颜色。\n当两个网格块的颜色相同，而且在四个方向中任意一个方向上相邻时，它们属于同一 连通分量 。\n连通分量的边界 是指连通分量中的所有与不在分量中的网格块相邻（四个方向上）的所有网格块，或者在网格的边界上（第一行/列或最后一行/列）的所有网格块。\n请你使用指定颜色 color 为所有包含网格块 grid[row][col] 的 连通分量的边界 进行着色，并返回最终的网格 grid 。\n示例 1： 输入： grid = [[1,1],[1,2]], row = 0, col = 0, color = 3\n输出： [[3,3],[3,2]]\n示例 2： 输入： grid = [[1,2,2],[2,3,2]], row = 0, col = 1, color = 3\n输出： [[1,3,3],[2,3,3]]\n示例 3： 输入： grid = [[1,1,1],[1,1,1],[1,1,1]], row = 1, col = 1, color = 2\n输出： [[2,2,2],[2,1,2],[2,2,2]]\n提示： m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 50 1 \u0026lt;= grid[i][j], color \u0026lt;= 1000 0 \u0026lt;= row \u0026lt; m 0 \u0026lt;= col \u0026lt; n 解题思路 深度优先搜索 从 grid[row][col] 开始进行深度优先搜索，需要使用 visit 矩阵来记录已经搜索过的网格。\n对于搜索到的每个网格，标记已访问，依次判定与之相邻的网格，当存在超出边界或者不属于同一个连通分量时，标记该网格需要着色（由于直接着色可能会影响后续相邻网格的着色判定，需要后续统一着色），之后继续搜索在同一个连通分量的相邻网格。\n搜索结束，得到标记需着色的网格坐标，对应地将其着色，并返回该矩阵。\nfunc colorBorder(grid [][]int, row int, col int, color int) [][]int { border := make([][2]int, 0, len(grid)*len(grid[0])) directions := [][2]int{{0, -1}, {0, 1}, {-1, 0}, {1, 0}} originColor := grid[row][col] // 访问标记 visit := make([][]bool, 0, len(grid)) for range grid { visit = append(visit, make([]bool, len(grid[0]))) } var dfs func(row, col int) dfs = func(row, col int) { visit[row][col] = true painting := false for _, direction := range directions { newRow := row + direction[0] newCol := col + direction[1] // 着色判定 if newRow \u0026lt; 0 || newRow \u0026gt;= len(grid) || newCol \u0026lt; 0 || newCol \u0026gt;= len(grid[0]) || grid[newRow][newCol] != originColor { painting = true } else if !visit[newRow][newCol] { dfs(newRow, newCol) } } // 标记着色 if painting { border = append(border, [2]int{row, col}) } } dfs(row, col) // 着色 for _, b := range border { grid[b[0]][b[1]] = color } return grid } 复杂度 时间复杂度：$ O(mn) $ 空间复杂度：$ O(mn) $ 广度优先搜索 思路如上述深度优先搜索，用广度优先搜索实现。\nfunc colorBorder(grid [][]int, row int, col int, color int) [][]int { border := make([][2]int, 0, len(grid)*len(grid[0])) directions := [][2]int{{0, -1}, {0, 1}, {-1, 0}, {1, 0}} originColor := grid[row][col] // 访问标记 visit := make([][]bool, 0, len(grid)) for range grid { visit = append(visit, make([]bool, len(grid[0]))) } queue := list.New() queue.PushBack([2]int{row, col}) for queue.Len() \u0026gt; 0 { cell := queue.Remove(queue.Front()).([2]int) row, col := cell[0], cell[1] visit[row][col] = true painting := false for _, direction := range directions { newRow := row + direction[0] newCol := col + direction[1] // 着色判定 if newRow \u0026lt; 0 || newRow \u0026gt;= len(grid) || newCol \u0026lt; 0 || newCol \u0026gt;= len(grid[0]) || grid[newRow][newCol] != originColor { painting = true } else if !visit[newRow][newCol] { queue.PushBack([2]int{newRow, newCol}) } } // 标记着色 if painting { border = append(border, [2]int{row, col}) } } // 着色 for _, b := range border { grid[b[0]][b[1]] = color } return grid } 复杂度 时间复杂度：$ O(mn) $ 空间复杂度：$ O(mn) $ ","date":"2021-12-07T10:14:52+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1034.-%E8%BE%B9%E7%95%8C%E7%9D%80%E8%89%B2/","title":"Leetcode 1034. 边界着色"},{"content":"链接： https://leetcode-cn.com/problems/truncate-sentence/\n难度： 简单\n题目描述 句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。\n例如，\u0026quot;Hello World\u0026quot;、\u0026quot;HELLO\u0026quot; 和 \u0026quot;hello world hello world\u0026quot; 都是句子。 给你一个句子 s​​​​​​ 和一个整数 k​​​​​​ ，请你将 s​​ 截断 ​，​​​使截断后的句子仅含 前 k​​​​​​ 个单词。返回 截断 s​​​​​​ 后得到的句子。\n示例 1： 输入： s = \u0026ldquo;Hello how are you Contestant\u0026rdquo;, k = 4\n输出： \u0026ldquo;Hello how are you\u0026rdquo;\n解释：\ns 中的单词为 [\u0026ldquo;Hello\u0026rdquo;, \u0026ldquo;how\u0026rdquo; \u0026ldquo;are\u0026rdquo;, \u0026ldquo;you\u0026rdquo;, \u0026ldquo;Contestant\u0026rdquo;]\n前 4 个单词为 [\u0026ldquo;Hello\u0026rdquo;, \u0026ldquo;how\u0026rdquo;, \u0026ldquo;are\u0026rdquo;, \u0026ldquo;you\u0026rdquo;]\n因此，应当返回 \u0026ldquo;Hello how are you\u0026rdquo;\n示例 2： 输入： s = \u0026ldquo;What is the solution to this problem\u0026rdquo;, k = 4\n输出： \u0026ldquo;What is the solution\u0026rdquo;\n解释：\ns 中的单词为 [\u0026ldquo;What\u0026rdquo;, \u0026ldquo;is\u0026rdquo; \u0026ldquo;the\u0026rdquo;, \u0026ldquo;solution\u0026rdquo;, \u0026ldquo;to\u0026rdquo;, \u0026ldquo;this\u0026rdquo;, \u0026ldquo;problem\u0026rdquo;]\n前 4 个单词为 [\u0026ldquo;What\u0026rdquo;, \u0026ldquo;is\u0026rdquo;, \u0026ldquo;the\u0026rdquo;, \u0026ldquo;solution\u0026rdquo;]\n因此，应当返回 \u0026ldquo;What is the solution\u0026rdquo;\n示例 3： 输入： s = \u0026ldquo;chopper is not a tanuki\u0026rdquo;, k = 5\n输出： \u0026ldquo;chopper is not a tanuki\u0026rdquo;\n提示： 1 \u0026lt;= s.length \u0026lt;= 500 k 的取值范围是 [1, s 中单词的数目] s 仅由大小写英文字母和空格组成 s 中的单词之间由单个空格隔开 不存在前导或尾随空格 解题思路 计数 已知输入 s 是一个句子，则其两端不存在空格，并且每两个相邻单词之间仅存在一个空格将其分开。\n遍历这个句子，统计遍历到的空格的数量，也即是前缀中单词的数量。当空格的数量为 k 时，在此处截断直接返回；否则说明遍历到了结尾，直接返回原句子 s 即可。\nfunc truncateSentence(s string, k int) string { cnt := 0 for i := range s { if s[i] == \u0026#39; \u0026#39; { cnt++ if cnt == k { return s[:i] } } } return s } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-12-06T10:21:30+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1816.-%E6%88%AA%E6%96%AD%E5%8F%A5%E5%AD%90/","title":"Leetcode 1816. 截断句子"},{"content":"链接： https://leetcode-cn.com/problems/super-pow/\n难度： 中等\n题目描述 你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。\n示例 1： 输入： a = 2, b = [3]\n输出： 8\n示例 2： 输入： a = 2, b = [1,0]\n输出： 1024\n示例 3： 输入： a = 1, b = [4,3,3,8,5,2]\n输出： 1\n示例 4： 输入： a = 2147483647, b = [2,0,0]\n输出： 1198\n提示： 1 \u0026lt;= a \u0026lt;= 231 - 1 1 \u0026lt;= b.length \u0026lt;= 2000 0 \u0026lt;= b[i] \u0026lt;= 9 b 不含前导 0 解题思路 快速幂 两个因数相乘取模的值，与每个因数各自取模后相乘再取模的值一致。\n显而易见是一道快速幂的题目，但是指数是以十进制数组的方式给出的，故每次步进时，是 a, a10, a100, \u0026hellip;。同时，每一位上的数字可能的取值是 1~9，故用二进制快速幂求得每一位的计算结果和步进。\nfunc superPow(a int, b []int) int { const MOD = 1337 var fastPower = func(x, n int) int { ans := 1 for ; n \u0026gt; 0; n \u0026gt;\u0026gt;= 1 { if n\u0026amp;1 != 0 { ans = ans * x % MOD } x = x * x % MOD } return ans } ans := 1 a %= MOD for i := len(b) - 1; i \u0026gt;= 0; i-- { ans = ans * fastPower(a, b[i]) % MOD a = fastPower(a, 10) } return ans } 复杂度 时间复杂度：$ O(N), N = len(b) $ 空间复杂度：$ O(1) $ ","date":"2021-12-05T11:48:08+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-372.-%E8%B6%85%E7%BA%A7%E6%AC%A1%E6%96%B9/","title":"Leetcode 372. 超级次方"},{"content":"链接： https://leetcode-cn.com/problems/ransom-note/\n难度： 简单\n题目描述 为了不在赎金信中暴露字迹，从杂志上搜索各个需要的字母，组成单词来表达意思。\n给你一个赎金信 (ransomNote) 字符串和一个杂志(magazine)字符串，判断 ransomNote 能不能由 magazines 里面的字符构成。\n如果可以构成，返回 true ；否则返回 false 。\nmagazine 中的每个字符只能在 ransomNote 中使用一次。\n示例 1： 输入： ransomNote = \u0026ldquo;a\u0026rdquo;, magazine = \u0026ldquo;b\u0026rdquo;\n输出： false\n示例 2： 输入： ransomNote = \u0026ldquo;aa\u0026rdquo;, magazine = \u0026ldquo;ab\u0026rdquo;\n输出：false\n示例 3： 输入： ransomNote = \u0026ldquo;aa\u0026rdquo;, magazine = \u0026ldquo;aab\u0026rdquo;\n输出： true\n提示： 1 \u0026lt;= ransomNote.length, magazine.length \u0026lt;= 105 ransomNote 和 magazine 由小写英文字母组成 解题思路 哈希 遍历 magazine 字符串，使用哈希表统计每个字符出现的次数，然后尝试将 ransomNote 中的每个字符从哈希表中删除：\n当任意一个字符数量不足时，返回 false； 否则，返回 true func canConstruct(ransomNote string, magazine string) bool { cnt := [26]int{} for i := range magazine { cnt[magazine[i]-\u0026#39;a\u0026#39;]++ } for i := range ransomNote { if cnt[ransomNote[i]-\u0026#39;a\u0026#39;] == 0 { return false } cnt[ransomNote[i]-\u0026#39;a\u0026#39;]-- } return true } 复杂度 时间复杂度：$ O(N+M), N = len(ransomNote), M = len(maganize) $ 空间复杂度：$ O(\\Sigma), \\Sigma表示字符集，本题中为26 $ ","date":"2021-12-04T19:28:15+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-383.-%E8%B5%8E%E9%87%91%E4%BF%A1/","title":"Leetcode 383. 赎金信"},{"content":"链接： https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/\n难度： 简单\n题目描述 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：\n选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。\n以这种方式修改数组后，返回数组 可能的最大和 。\n示例 1： 输入： nums = [4,2,3], k = 1\n输出： 5\n解释： 选择下标 1 ，nums 变为 [4,-2,3] 。\n示例 2： 输入： nums = [3,-1,0,2], k = 3\n输出： 6\n解释： 选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。\n示例 3： 输入： nums = [2,-3,-1,5,-4], k = 2\n输出： 13\n解释： 选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。\n提示： 1 \u0026lt;= nums.length \u0026lt;= 104 -100 \u0026lt;= nums[i] \u0026lt;= 100 1 \u0026lt;= k \u0026lt;= 104 解题思路 排序 为使得数组之和尽可能大，应尽量让负数变为正，且优先选择更小的负数变换。\n当数组中的所有元素都不为负时，若还需要进行变换，则有两种情况：\n注意到两次变换即相当于没有操作，故当剩余变换次数为偶数时，勿需变换； 当剩余变换次数为奇数时，选择最小的元素将其变换为负数。 func largestSumAfterKNegations(nums []int, k int) int { sum := 0 // 数组和 min := math.MaxInt32 // 记录变换为非负数的最小值 nagative := make([]int, 0, len(nums)) // 记录所有负数 for _, num := range nums { sum += num // 求和 if num \u0026lt; 0 { nagative = append(nagative, num) num = -num } // 更新最小值 if min \u0026gt; num { min = num } } // 排序，优先选择的负数开始变换 sort.Ints(nagative) for _, num := range nagative { // k 次变换结束 if k \u0026lt;= 0 { break } sum += (-num) \u0026lt;\u0026lt; 1 // 已经加上负值，需要抵消，故加两倍 k-- } if k\u0026amp;1 != 0 { sum -= min \u0026lt;\u0026lt; 1 // 已经加上正值，需要抵消，故减两倍 } return sum } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2021-12-03T10:16:51+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1005.-k-%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C/","title":"Leetcode 1005. K 次取反后最大化的数组和"},{"content":"链接： https://leetcode-cn.com/problems/relative-ranks/\n难度： 简单\n题目描述 给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都 互不相同 。\n运动员将根据得分 决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：\n名次第 1 的运动员获金牌 \u0026quot;Gold Medal\u0026quot; 。 名次第 2 的运动员获银牌 \u0026quot;Silver Medal\u0026quot; 。 名次第 3 的运动员获铜牌 \u0026quot;Bronze Medal\u0026quot; 。 从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 \u0026quot;x\u0026quot;）。 使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况。\n示例 1： 输入： score = [5,4,3,2,1]\n输出： [\u0026ldquo;Gold Medal\u0026rdquo;,\u0026ldquo;Silver Medal\u0026rdquo;,\u0026ldquo;Bronze Medal\u0026rdquo;,\u0026ldquo;4\u0026rdquo;,\u0026ldquo;5\u0026rdquo;]\n解释： 名次为 [1st, 2nd, 3rd, 4th, 5th] 。\n示例 2： 输入： score = [10,3,8,9,4]\n输出： [\u0026ldquo;Gold Medal\u0026rdquo;,\u0026ldquo;5\u0026rdquo;,\u0026ldquo;Bronze Medal\u0026rdquo;,\u0026ldquo;Silver Medal\u0026rdquo;,\u0026ldquo;4\u0026rdquo;]\n解释： 名次为 [1st, 5th, 3rd, 2nd, 4th] 。\n提示： n == score.length 1 \u0026lt;= n \u0026lt;= 104 0 \u0026lt;= score[i] \u0026lt;= 106 score 中的所有值 互不相同 解题思路 排序 + 哈希 按照分数进行排序，得到每个分数对应的排名并记录到哈希表中，按照原来的顺序查找哈希表返回排名。\nfunc findRelativeRanks(score []int) []string { t := make([]int, 0, len(score)) for _, s := range score { t = append(t, s) } copy(t, score) sort.Ints(t) rank := make(map[int]int) for i := len(t) - 1; i \u0026gt;= 0; i-- { rank[t[i]] = len(t) - i } ans := make([]string, 0, len(score)) for _, s := range score { r := \u0026#34;\u0026#34; switch rank[s] { case 1: r = \u0026#34;Gold Medal\u0026#34; case 2: r = \u0026#34;Silver Medal\u0026#34; case 3: r = \u0026#34;Bronze Medal\u0026#34; default: r = strconv.FormatInt(int64(rank[s]), 10) } ans = append(ans, r) } return ans } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(score) $ 空间复杂度：$ O(N) $ ","date":"2021-12-02T19:55:32+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-506.-%E7%9B%B8%E5%AF%B9%E5%90%8D%E6%AC%A1/","title":"Leetcode 506. 相对名次"},{"content":"链接： https://leetcode-cn.com/problems/consecutive-characters/\n难度： 简单\n题目描述 给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。\n请你返回字符串的能量。\n示例 1： 输入： s = \u0026ldquo;leetcode\u0026rdquo;\n输出： 2\n解释： 子字符串 \u0026ldquo;ee\u0026rdquo; 长度为 2 ，只包含字符 \u0026rsquo;e\u0026rsquo; 。\n示例 2： 输入： s = \u0026ldquo;abbcccddddeeeeedcba\u0026rdquo;\n输出： 5\n解释： 子字符串 \u0026ldquo;eeeee\u0026rdquo; 长度为 5 ，只包含字符 \u0026rsquo;e\u0026rsquo; 。\n示例 3： 输入： s = \u0026ldquo;triplepillooooow\u0026rdquo;\n输出： 5\n示例 4： 输入： s = \u0026ldquo;hooraaaaaaaaaaay\u0026rdquo;\n输出： 11\n示例 5： 输入： s = \u0026ldquo;tourist\u0026rdquo;\n输出： 1\n提示： 1 \u0026lt;= s.length \u0026lt;= 500 s 只包含小写英文字母。 解题思路 模拟 从头到尾遍历整个字符串，当与前面的字符相同时，当前连续相同该字符的长度加一；否则，将其长度置为 1。\n遍历过程中记录最大值。\nfunc maxPower(s string) int { max := 1 cur := 1 last := byte(0) for i := range s { if s[i] == last { cur++ if max \u0026lt; cur { max = cur } } else { cur = 1 last = s[i] } } return max } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-12-01T10:19:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1446.-%E8%BF%9E%E7%BB%AD%E5%AD%97%E7%AC%A6/","title":"Leetcode 1446. 连续字符"},{"content":"链接： https://leetcode-cn.com/problems/nth-digit/\n难度： 中等\n题目描述 给你一个整数 n ，请你在无限的整数序列 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...] 中找出并返回第 n 位数字。\n示例 1： 输入： n = 3\n输出： 3\n示例 2： 输入： n = 11\n输出： 0\n解释： 第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, \u0026hellip; 里是 0 ，它是 10 的一部分。\n提示： 1 \u0026lt;= n \u0026lt;= 231 - 1 解题思路 模拟 字符串按照数字顺序排列，其按照数字长度为 1、2、3、... 进行排列，可以利用这个规则求得 n 所在的那个数，进而求的该位对应的数字。\n排除 0，则相同长度的数字所占的字符串长度为 9*基数*数字长度，（即9=9*1*1、90=9*10*2、900=9*100*3、...），通过覆盖范围的查找确定到 n 对应的数字长度和基数。\n之后获取到 n 所在数字的偏移量，并求得该数，之后返回 n 对应位的数字即可。对输入 0 需要验证。\nfunc findNthDigit(n int) int { base := 1 // 基数 10^N digit := 1 // 位数 10进制 // 确定位数 for ; n \u0026gt; base*9*digit; base, digit = 10*base, digit+1 { n -= base * 9 * digit } offset := (n - 1) / digit // 偏移量 // 获取指定位数字 ans := base + offset for i := digit - (n-1)%digit; i \u0026gt; 1; i-- { ans /= 10 } return ans % 10 } 复杂度 时间复杂度：$ O(\\log{n}) $ 空间复杂度：$ O(1) $ ","date":"2021-11-30T10:30:37+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-400.-%E7%AC%AC-n-%E4%BD%8D%E6%95%B0%E5%AD%97/","title":"Leetcode 400. 第 N 位数字"},{"content":"链接： https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/\n难度： 困难\n题目描述 给你一个按递增顺序排序的数组 arr 和一个整数 k 。数组 arr 由 1 和若干 素数 组成，且其中所有整数互不相同。\n对于每对满足 0 \u0026lt; i \u0026lt; j \u0026lt; arr.length 的 i 和 j ，可以得到分数 arr[i] / arr[j] 。\n那么第 k 个最小的分数是多少呢? 以长度为 2 的整数数组返回你的答案, 这里 answer[0] == arr[i] 且 answer[1] == arr[j] 。\n示例 1： 输入： arr = [1,2,3,5], k = 3\n输出： [2,5]\n解释： 已构造好的分数,排序后如下所示:\n1/5, 1/3, 2/5, 1/2, 3/5, 2/3\n很明显第三个最小的分数是 2/5\n示例 2： 输入： arr = [1,7], k = 1\n输出： [1,7]\n提示： 2 \u0026lt;= arr.length \u0026lt;= 1000 1 \u0026lt;= arr[i] \u0026lt;= 3 * 104 arr[0] == 1 arr[i] 是一个 素数 ，i \u0026gt; 0 arr 中的所有数字 互不相同 ，且按 严格递增 排序 1 \u0026lt;= k \u0026lt;= arr.length * (arr.length - 1) / 2 解题思路 排序 整个数组中的素数两两组成分数，构成一个列表，对整个列表进行排序，便可直接得到第 k 小的分数。\nfunc kthSmallestPrimeFraction(arr []int, k int) []int { type Pair struct { nums []int fraction float64 } fractions := make([]*Pair, 0, len(arr)*(len(arr)-1)/2) for i, numerator := range arr { for _, denominator := range arr[i+1:] { fractions = append(fractions, \u0026amp;Pair{ nums: []int{numerator, denominator}, fraction: float64(numerator) / float64(denominator), }) } } sort.Slice(fractions, func(i, j int) bool { return fractions[i].fraction \u0026lt; fractions[j].fraction }) return fractions[k-1].nums } 复杂度 时间复杂度：$ O(N^2\\log{N}), N = len(arr) $ 空间复杂度：$ O(N^2) $ 堆 使用大顶堆存放前 k 小的所有分数。从头到尾遍历分子，并在分子确定的情况下，分母从尾到头遍历：\n当当前堆中元素不足 k 个时，新生成分数直接入堆； 否则，和堆顶分数比较： 若小于堆顶元素，则将堆顶元素置换出去； 否则，忽略该分数，并且后续生成的分数不会比堆中的分数小，勿需遍历，直接从下一个分子开始遍历。 遍历完成后，堆中所有元素即位前 k 小的分数，堆定元素即位第 k 小的元素。\ntype Pair struct { nums []int fraction float64 } type MaxHeap struct { elems []*Pair } func (this *MaxHeap) Len() int { return len(this.elems) } func (this *MaxHeap) Swap(i, j int) { this.elems[i], this.elems[j] = this.elems[j], this.elems[i] } func (this *MaxHeap) Less(i, j int) bool { return this.elems[i].fraction \u0026gt;= this.elems[j].fraction } func (this *MaxHeap) Push(elem interface{}) { this.elems = append(this.elems, elem.(*Pair)) } func (this *MaxHeap) Pop() interface{} { max := this.elems[len(this.elems)-1] this.elems = this.elems[:len(this.elems)-1] return max } func kthSmallestPrimeFraction(arr []int, k int) []int { h := \u0026amp;MaxHeap{ elems: make([]*Pair, 0, k), } for i, numerator := range arr { for j := len(arr) - 1; j \u0026gt; i; j-- { pair := \u0026amp;Pair{ nums: []int{numerator, arr[j]}, fraction: float64(numerator) / float64(arr[j]), } if h.Len() == k { if pair.fraction \u0026gt; h.elems[0].fraction { break } heap.Pop(h) } heap.Push(h, pair) } } return h.elems[0].nums } 复杂度 时间复杂度：$ O(N^2\\log{k}), N = len(arr) $ 空间复杂度：$ O(k) $ ","date":"2021-11-29T10:26:07+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-786.-%E7%AC%AC-k-%E4%B8%AA%E6%9C%80%E5%B0%8F%E7%9A%84%E7%B4%A0%E6%95%B0%E5%88%86%E6%95%B0/","title":"Leetcode 786. 第 K 个最小的素数分数"},{"content":"链接： https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/\n难度： 中等\n题目描述 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。\n示例 1： 输入： s = \u0026ldquo;cbaebabacd\u0026rdquo;, p = \u0026ldquo;abc\u0026rdquo;\n输出： [0,6]\n解释：\n起始索引等于 0 的子串是 \u0026ldquo;cba\u0026rdquo;, 它是 \u0026ldquo;abc\u0026rdquo; 的异位词。\n起始索引等于 6 的子串是 \u0026ldquo;bac\u0026rdquo;, 它是 \u0026ldquo;abc\u0026rdquo; 的异位词。\n示例 2： 输入： s = \u0026ldquo;abab\u0026rdquo;, p = \u0026ldquo;ab\u0026rdquo;\n输出： [0,1,2]\n解释：\n起始索引等于 0 的子串是 \u0026ldquo;ab\u0026rdquo;, 它是 \u0026ldquo;ab\u0026rdquo; 的异位词。\n起始索引等于 1 的子串是 \u0026ldquo;ba\u0026rdquo;, 它是 \u0026ldquo;ab\u0026rdquo; 的异位词。\n起始索引等于 2 的子串是 \u0026ldquo;ab\u0026rdquo;, 它是 \u0026ldquo;ab\u0026rdquo; 的异位词。\n提示： 1 \u0026lt;= s.length, p.length \u0026lt;= 3 * 104 s 和 p 仅包含小写字母 解题思路 滑动窗口 + 哈希 异位词要求两个字符串长度相同，并且出现的字符的数量一致，所以选择在 s 上使用长度为 len(p) 的滑动窗口。\n对于字符数量，使用哈希表进行统计，每次遍历一遍哈希表比较即可。\nfunc findAnagrams(s string, p string) []int { if len(s) \u0026lt; len(p) { return make([]int, 0) } // 比较两个哈希表 isAnagrams := func(m1, m2 map[byte]int) bool { for char, cnt := range m1 { if cnt != m2[char] { return false } } return true } // 初始化 idxes := make([]int, 0, len(s)-len(p)+1) pCnt := make(map[byte]int, 26) sCnt := make(map[byte]int, 26) // 滑动窗口内的字符数量 for i := range p { pCnt[p[i]]++ sCnt[s[i]]++ } // 首次比较 if isAnagrams(pCnt, sCnt) { idxes = append(idxes, 0) } // 后续比较 for i := len(p); i \u0026lt; len(s); i++ { sCnt[s[i-len(p)]]-- sCnt[s[i]]++ if isAnagrams(pCnt, sCnt) { idxes = append(idxes, i-len(p)+1) } } return idxes } 复杂度 时间复杂度：$ O(M + (N-M)\\Sigma), N = len(s), M = len(p), \\Sigma表示字符集，本题中为26 $ 空间复杂度：$ O(\\Sigma) $ 优化 在上述题解中，每次比较需要遍历整个哈希表，但是每次窗口滑动时，仅有两个字符的数量发生了变化，其他的比较是不必要的。\n引入一个变量 diff 记录滑动窗口中的字串和 p 中字符数量不同的字符个数，则当 diff 变为 0 时，表示所有的字符数量均相同，即两个哈希表相同，即找到了一个异位词。仅需要在窗口滑动时维护该变量即可。\n同时，可以仅使用一个哈希表记录两个串字符的差值，进一步优化空间。\nfunc findAnagrams(s string, p string) []int { if len(s) \u0026lt; len(p) { return make([]int, 0) } // 初始化 idxes := make([]int, 0, len(s)-len(p)+1) cnt := make(map[byte]int, 26) diff := 0 for i := range p { cnt[p[i]]-- cnt[s[i]]++ } // 统计字符数量不同的数量 for _, cnt := range cnt { if cnt != 0 { diff++ } } // 首次比较 if diff == 0 { idxes = append(idxes, 0) } // 滑动比较 for i := len(p); i \u0026lt; len(s); i++ { switch cnt[s[i-len(p)]] { case 1: diff-- // 变为相同 case 0: diff++ // 变为不同 } // 删除字符，差值-1 cnt[s[i-len(p)]]-- switch cnt[s[i]] { case -1: // 变为相同 diff-- case 0: // 变为不同 diff++ } // 增加字符，差值+1 cnt[s[i]]++ if diff == 0 { idxes = append(idxes, i-len(p)+1) } } return idxes } 复杂度 时间复杂度：$ O(N + \\Sigma), N = len(s), M = len(p), \\Sigma表示字符集，本题中为26 $ 空间复杂度：$ O(\\Sigma) $ ","date":"2021-11-28T10:03:54+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-438.-%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","title":"Leetcode 438. 找到字符串中所有字母异位词"},{"content":"链接： https://leetcode-cn.com/problems/random-flip-matrix/\n难度： 中等\n题目描述 给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足 matrix[i][j] == 0 的下标 (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] == 0 的下标 (i, j) 被选取的概率应当均等。\n尽量最少调用内置的随机函数，并且优化时间和空间复杂度。\n实现 Solution 类：\nSolution(int m, int n) 使用二元矩阵的大小 m 和 n 初始化该对象 int[] flip() 返回一个满足 matrix[i][j] == 0 的随机下标 [i, j] ，并将其对应格子中的值变为 1 void reset() 将矩阵中所有的值重置为 0 示例： 输入：\n[\u0026ldquo;Solution\u0026rdquo;, \u0026ldquo;flip\u0026rdquo;, \u0026ldquo;flip\u0026rdquo;, \u0026ldquo;flip\u0026rdquo;, \u0026ldquo;reset\u0026rdquo;, \u0026ldquo;flip\u0026rdquo;]\n[[3, 1], [], [], [], [], []]\n输出：\n[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]\n解释：\nSolution solution = new Solution(3, 1);\nsolution.flip(); // 返回 [1, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同\nsolution.flip(); // 返回 [2, 0]，因为 [1,0] 已经返回过了，此时返回 [2,0] 和 [0,0] 的概率应当相同\nsolution.flip(); // 返回 [0, 0]，根据前面已经返回过的下标，此时只能返回 [0,0]\nsolution.reset(); // 所有值都重置为 0 ，并可以再次选择下标返回\nsolution.flip(); // 返回 [2, 0]，此时返回 [0,0]、[1,0] 和 [2,0] 的概率应当相同\n提示： 1 \u0026lt;= m, n \u0026lt;= 104 每次调用 flip 时，矩阵中至少存在一个值为 0 的格子。 最多调用 1000 次 flip 和 reset 方法。 解题思路 哈希 对于已经变为 1 的格子，需要在随机选择时候将其排除在外，故需要维护一个池子，该池子中的元素均为当前可选的格子坐标，每次从中随机选取一个即可。\n随机函数生成的数字是连续整数，可以采用数组维护这个池子，随机的生成一个下标。之后需要将该元素从池子中排除，可以将此处的格子与最后一个交换，则以最后一个格子为分界线，前面的元素可用，此后的被排除。之后选出的元素依次与倒数第 2、3、4 个元素交换，即以较低的复杂度实现了排除操作。\n每个格子的坐标按照逐行的顺序编号，则有映射关系：编号 = 行号 * 列数 + 列号，并且可以通过编号反推得出坐标：\n行号 = 编号 / 列数 列号 = 编号 % 列数 在数组中，初始数组下标和数组中保存的编号是一致的。当执行交换后，才会有两个元素下标和编号不一致。而操作次数远小于矩阵元素数量，故使用哈希表记录不一致的这些元素即可。\n对于 flip 操作，从可用区间内随机选取一个下标，将其置到可用区间尾部，可用区间缩短 1。每次的交换操作均需要去哈希表中查找确认操作数，若不存在则操作数即和下标相同，否则操作数为哈希表中的数。\n对于 reset 操作，直接将可用区间扩展为整个数组即可。\ntype Solution struct { hash map[int]int valid int rows int cols int random *rand.Rand } func Constructor(m int, n int) Solution { return Solution{ hash: make(map[int]int), valid: m * n, rows: m, cols: n, random: rand.New(rand.NewSource(time.Now().UnixNano())), } } func (this *Solution) Flip() []int { idx := this.random.Intn(this.valid) this.valid-- num := idx if _, ok := this.hash[idx]; ok { num = this.hash[idx] } swapNum := this.valid if _, ok := this.hash[this.valid]; ok { swapNum = this.hash[this.valid] } this.hash[idx], this.hash[this.valid] = swapNum, num return []int{num / this.cols, num % this.cols} } func (this *Solution) Reset() { this.valid = this.rows * this.cols } 复杂度 时间复杂度： flip：$ O(1) $ reset：$ O(1) $ 空间复杂度：$ O(operations) $ ","date":"2021-11-27T13:18:35+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-519.-%E9%9A%8F%E6%9C%BA%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5/","title":"Leetcode 519. 随机翻转矩阵"},{"content":"链接： https://leetcode-cn.com/problems/search-in-a-binary-search-tree/\n难度： 简单\n题目描述 给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL 。\n例如，\n给定二叉搜索树:\n4 / \\ 2 7 / \\ 1 3 和值: 2 你应该返回如下子树:\n2 / \\ 1 3 在上述示例中，如果要找的值是 5 ，但因为没有节点值为 5 ，我们应该返回 NULL 。\n解题思路 二分查找 题设中给出的树是一颗二叉搜索树，则对于其中任意一个结点，其左子树所有结点值均小于当前结点，右子树所有结点值均大于当前结点，故采用二分查找的方式：\n当当前结点值 = val 时，直接返回该结点； 当当前结点值 \u0026lt; val 时，去做左子树中查找； 当当前结点值 \u0026gt; val 时，去做右子树中查找； 当当前结点为空时，说明找不到，直接返回 NULL 。 func searchBST(root *TreeNode, val int) *TreeNode { for node := root; node != nil; { if val == node.Val { return node } else if val \u0026lt; node.Val { node = node.Left } else { node = node.Right } } return nil } 复杂度 时间复杂度：$ O(\\log{N}) $ 空间复杂度：$ O(1) $ ","date":"2021-11-26T10:15:50+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-700.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/","title":"Leetcode 700. 二叉搜索树中的搜索"},{"content":"链接： https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/\n难度： 中等\n题目描述 给你一个字符串 s ，其中包含字母顺序打乱的用英文单词表示的若干数字（0-9）。按 升序 返回原始的数字。\n示例 1： 输入： s = \u0026ldquo;owoztneoer\u0026rdquo;\n输出： \u0026ldquo;012\u0026rdquo;\n示例 2： 输入： s = \u0026ldquo;fviefuro\u0026rdquo;\n输出： \u0026ldquo;45\u0026rdquo;\n提示： 1 \u0026lt;= s.length \u0026lt;= 105 s[i] 为 [\u0026quot;e\u0026quot;,\u0026quot;g\u0026quot;,\u0026quot;f\u0026quot;,\u0026quot;i\u0026quot;,\u0026quot;h\u0026quot;,\u0026quot;o\u0026quot;,\u0026quot;n\u0026quot;,\u0026quot;s\u0026quot;,\u0026quot;r\u0026quot;,\u0026quot;u\u0026quot;,\u0026quot;t\u0026quot;,\u0026quot;w\u0026quot;,\u0026quot;v\u0026quot;,\u0026quot;x\u0026quot;,\u0026quot;z\u0026quot;]这些字符之一 s 保证是一个符合题目要求的字符串 解题思路 哈希 使用哈希表记录每个字母出现时次数，其中 [\u0026quot;z\u0026quot;，\u0026quot;w\u0026quot;, \u0026quot;u\u0026quot;, \u0026quot;x\u0026quot;, \u0026quot;g\u0026quot;] 可以唯一的确定包含的数字 [0, 2, 4, 6, 8]，仍然使用哈希表记录每个数字出现的次数，并将数字对应的字母从哈希表中减去。\n在剩余的字母中，[\u0026quot;o\u0026quot;, \u0026quot;t\u0026quot;, \u0026quot;f\u0026quot;, \u0026quot;s\u0026quot;] 可以唯一的确定包含的数字 [1, 3, 5, 7]，最后只剩构成 9 的字符，使用 i 代表即可。\n故按照 [\u0026quot;z\u0026quot;，\u0026quot;w\u0026quot;, \u0026quot;u\u0026quot;, \u0026quot;x\u0026quot;, \u0026quot;g\u0026quot;, \u0026quot;o\u0026quot;, \u0026quot;t\u0026quot;, \u0026quot;f\u0026quot;, \u0026quot;s\u0026quot;, \u0026quot;i\u0026quot;] 的顺序，确定数字 [0, 2, 4, 6, 8, 1, 3, 5, 7, 9] 的数量，每次将确定数字对应的字母删除掉。\nfunc originalDigits(s string) string { mapping := map[byte]struct { en string num byte }{ \u0026#39;z\u0026#39;: {en: \u0026#34;zero\u0026#34;, num: \u0026#39;0\u0026#39;}, \u0026#39;o\u0026#39;: {en: \u0026#34;one\u0026#34;, num: \u0026#39;1\u0026#39;}, \u0026#39;w\u0026#39;: {en: \u0026#34;two\u0026#34;, num: \u0026#39;2\u0026#39;}, \u0026#39;t\u0026#39;: {en: \u0026#34;three\u0026#34;, num: \u0026#39;3\u0026#39;}, \u0026#39;u\u0026#39;: {en: \u0026#34;four\u0026#34;, num: \u0026#39;4\u0026#39;}, \u0026#39;f\u0026#39;: {en: \u0026#34;five\u0026#34;, num: \u0026#39;5\u0026#39;}, \u0026#39;x\u0026#39;: {en: \u0026#34;six\u0026#34;, num: \u0026#39;6\u0026#39;}, \u0026#39;s\u0026#39;: {en: \u0026#34;seven\u0026#34;, num: \u0026#39;7\u0026#39;}, \u0026#39;g\u0026#39;: {en: \u0026#34;eight\u0026#34;, num: \u0026#39;8\u0026#39;}, \u0026#39;e\u0026#39;: {en: \u0026#34;nine\u0026#34;, num: \u0026#39;9\u0026#39;}, } // 统计字符数量 charCnt := make(map[byte]int) for i := range s { charCnt[s[i]]++ } numCnt := make(map[byte]int) length := 0 for _, char := range []byte(\u0026#34;zwuxgotfse\u0026#34;) { if charCnt[char] \u0026lt;= 0 { continue } numCnt[mapping[char].num] = charCnt[char] length += charCnt[char] // 删除已知数字字符 for i := range mapping[char].en { charCnt[mapping[char].en[i]] -= numCnt[mapping[char].num] } } // 构造结果 ans := make([]byte, 0, length) for char := byte(\u0026#39;0\u0026#39;); char \u0026lt;= \u0026#39;9\u0026#39;; char++ { for j := numCnt[char]; j \u0026gt; 0; j-- { ans = append(ans, char) } } return string(ans) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(\\Sigma), \\Sigma是字符和数字构成的集合，本题目中为 15 + 10 = 25 $ ","date":"2021-11-24T10:12:51+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-423.-%E4%BB%8E%E8%8B%B1%E6%96%87%E4%B8%AD%E9%87%8D%E5%BB%BA%E6%95%B0%E5%AD%97/","title":"Leetcode 423. 从英文中重建数字"},{"content":"链接： https://leetcode-cn.com/problems/shuffle-an-array/\n难度： 中等\n题目描述 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。\n实现 Solution class:\nSolution(int[] nums) 使用整数数组 nums 初始化对象 int[] reset() 重设数组到它的初始状态并返回 int[] shuffle() 返回数组随机打乱后的结果 示例 1： 输入：\n[\u0026ldquo;Solution\u0026rdquo;, \u0026ldquo;shuffle\u0026rdquo;, \u0026ldquo;reset\u0026rdquo;, \u0026ldquo;shuffle\u0026rdquo;]\n[[[1, 2, 3]], [], [], []]\n输出：\n[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n解释：\nSolution solution = new Solution([1, 2, 3]);\nsolution.shuffle(); // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]\nsolution.reset(); // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]\nsolution.shuffle(); // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]\n提示： 1 \u0026lt;= nums.length \u0026lt;= 200 -106 \u0026lt;= nums[i] \u0026lt;= 106 nums 中的所有元素都是 唯一的 最多可以调用 5 * 104 次 reset 和 shuffle 解题思路 暴力求解 reset 要返回数组初始的状态，故 Solution 中需要一个成员数组来记录初始的状态。\n对于 shuffle 操作，每次从可选元素中随机选择一个加入到结果队列中，并将此元素删除，直到所有元素被选择完毕。\ntype Solution struct { origin []int rand *rand.Rand } func Constructor(nums []int) Solution { return Solution{ origin: nums, rand: rand.New(rand.NewSource(time.Now().UnixNano())), } } func (this *Solution) Reset() []int { return this.origin } func (this *Solution) Shuffle() []int { shuffle := make([]int, len(this.origin)) bak := make([]int, len(this.origin)) copy(bak, this.origin) for i := range this.origin { idx := this.rand.Intn(len(bak)) shuffle[i] = bak[idx] bak = append(bak[:idx], bak[idx+1:]...) } return shuffle } 复杂度 时间复杂度： reset：$ O(1) $ shuffle：$ (N^2) $ 空间复杂度：$ O(N), N = len(nums) $ reset：$ O(1) $ shuffle：$ (N) $ 优化 在上述 shuffle 操作中，将随机选择出来的元素直接交换到末尾，即完成了元素的删除和添加操作，降低时间复杂度。\ntype Solution struct { origin []int rand *rand.Rand } func Constructor(nums []int) Solution { return Solution{ origin: nums, rand: rand.New(rand.NewSource(time.Now().UnixNano())), } } func (this *Solution) Reset() []int { return this.origin } func (this *Solution) Shuffle() []int { shuffle := make([]int, len(this.origin)) copy(shuffle, this.origin) for i := range shuffle { idx := this.rand.Intn(len(shuffle) - i) shuffle[idx], shuffle[len(shuffle)-1-i] = shuffle[len(shuffle)-1-i], shuffle[idx] } return shuffle } 复杂度 时间复杂度： reset：$ O(1) $ shuffle：$ (N) $ 空间复杂度：$ O(N), N = len(nums) $ reset：$ O(1) $ shuffle：$ (N) $ ","date":"2021-11-22T10:15:12+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-384.-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/","title":"Leetcode 384. 打乱数组"},{"content":"链接： https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/\n难度： 简单\n题目描述 给定一个 N 叉树，找到其最大深度。\n最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。\nN 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。\n示例 1： 输入： root = [1,null,3,2,4,null,5,6]\n输出： 3\n示例 2： 输入： root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\n输出： 5\n提示： 树的深度不会超过 1000 。 树的节点数目位于 [0, 104] 之间。 解题思路 后序遍历 一颗树的最大深度是其所有子树的最大深度加一。递归的求解某个结点各个子树的深度，即可比较求得以当前结点为根结点的子树的最大深度。\nfunc maxDepth(root *Node) int { if root == nil { return 0 } _maxDepth := 0 for _, node := range root.Children { depth := maxDepth(node) if _maxDepth \u0026lt; depth { _maxDepth = depth } } return _maxDepth + 1 } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-11-21T10:32:51+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-559.-n-%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","title":"Leetcode 559. N 叉树的最大深度"},{"content":"链接： https://leetcode-cn.com/problems/longest-harmonious-subsequence/\n难度： 简单\n题目描述 和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。\n现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。\n数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。\n示例 1： 输入： nums = [1,3,2,2,5,2,3,7]\n输出： 5\n解释： 最长的和谐子序列是 [3,2,2,2,3]\n示例 2： 输入： nums = [1,2,3,4]\n输出： 2\n示例 3： 输入： nums = [1,1,1,1]\n输出： 0\n提示： 1 \u0026lt;= nums.length \u0026lt;= 2 * 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 解题思路 排序 + 滑动窗口 将整个数组排序，两段相邻的元素相同的子数组，并且差值为 1 时，在原数组中可以构成和谐数组，记录最大值。\nfunc findLHS(nums []int) int { sort.Ints(nums) max := 0 begin := 0 for i, num := range nums { // 无法构成和谐数组，当前窗口向右滑动 if num-nums[begin] \u0026gt; 1 { begin++ } if num-nums[begin] == 1 \u0026amp;\u0026amp; max \u0026lt; i-begin+1 { max = i - begin + 1 } } return max } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(nums) $ 空间复杂度：$ O(\\log{N}) $ 哈希 使用哈希表记录每个数字出现的次数。\n对于数组中的一个数字 num ，当 num + 1 在数组中出现过时，能够构成和谐数组，该子序列的长度为 num 出现的次数加上 num + 1 出现的次数。\n枚举每个出现过的数字，找出最大值。\nfunc findLHS(nums []int) int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ } max := 0 for num := range cnt { if cnt[num+1] == 0 { continue } if max \u0026lt; cnt[num]+cnt[num+1] { max = cnt[num] + cnt[num+1] } } return max } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2021-11-20T23:59:35+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-594.-%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/","title":"Leetcode 594. 最长和谐子序列"},{"content":"链接： https://leetcode-cn.com/problems/integer-replacement/\n难度： 中等\n题目描述 给定一个正整数 n ，你可以做如下操作：\n如果 n 是偶数，则用 n / 2 替换 n 。 如果 n 是奇数，则可以用 n + 1 或 n - 1 替换 n 。 n 变为 1 所需的最小替换次数是多少？\n示例 1： 输入： n = 8\n输出： 3\n解释： 8 -\u0026gt; 4 -\u0026gt; 2 -\u0026gt; 1\n示例 2： 输入： n = 7\n输出： 4\n解释： 7 -\u0026gt; 8 -\u0026gt; 4 -\u0026gt; 2 -\u0026gt; 1\n或 7 -\u0026gt; 6 -\u0026gt; 3 -\u0026gt; 2 -\u0026gt; 1\n示例 3： 输入： n = 4\n输出： 2\n提示： 1 \u0026lt;= n \u0026lt;= 231 - 1 解题思路 深度优先搜索 从 n 开始进行搜索：\n当为偶数时，搜索 n / 2 的最小替换次数，并加一； 当为奇数时，则有两种情况，分别搜索 n+1 和 n-1，选择更小的替换次数并加一。 func integerReplacement(n int) int { if n == 1 { return 0 } if n\u0026amp;1 == 0 { return integerReplacement(n/2) + 1 } else { min1 := integerReplacement(n + 1) min2 := integerReplacement(n - 1) if min1 \u0026lt; min2 { return min1 + 1 } else { return min2 + 1 } } } 复杂度 时间复杂度：$ O(F(\\log{n})), F(n)为斐波那契数列的前 n 项和，（对于一个奇数，其加减一以后的其中一个值必定可以连续减半两次，故递归树每层的数量构成斐波那契数列） $ 空间复杂度：$ O(\\log{n}) $ ","date":"2021-11-19T10:07:59+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-397.-%E6%95%B4%E6%95%B0%E6%9B%BF%E6%8D%A2/","title":"Leetcode 397. 整数替换"},{"content":"链接： https://leetcode-cn.com/problems/binary-tree-tilt/\n难度： 简单\n题目描述 给定一个二叉树，计算 整个树 的坡度 。\n一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。\n整个树 的坡度就是其所有节点的坡度之和。\n示例 1： 输入： root = [1,2,3]\n输出： 1\n解释：\n节点 2 的坡度：|0-0| = 0（没有子节点）\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）\n坡度总和：0 + 0 + 1 = 1\n示例 2： 输入： root = [4,2,9,3,5,null,7]\n输出： 15\n解释：\n节点 3 的坡度：|0-0| = 0（没有子节点）\n节点 5 的坡度：|0-0| = 0（没有子节点）\n节点 7 的坡度：|0-0| = 0（没有子节点）\n节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）\n节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）\n节点 4 的坡度：|(3+5+2)-(9+7)| = |10-16| = 6（左子树值为 3、5 和 2 ，和是 10 ；右子树值为 9 和 7 ，和是 16 ）\n坡度总和：0 + 0 + 0 + 2 + 7 + 6 = 15\n示例 3： 输入： root = [21,7,14,1,1,2,2,3,3]\n输出： 9\n提示： 树中节点数目的范围在 [0, 104] 内 -1000 \u0026lt;= Node.val \u0026lt;= 1000 解题思路 后序遍历 计算某个结点的坡度需要知道左右子树的所有结点之和，可以用后序遍历求得，进而得到结点的坡度。\n某棵树的坡度求解也分为当前结点的坡度加上左右子树的坡度，仍可以采用后序遍历的方式求解。\n需要每次后序遍历返回以当前结点为根结点的子树的坡度以及所有结点之和。\nfunc findTilt(root *TreeNode) int { var dfs func(node *TreeNode) (int, int) dfs = func(node *TreeNode) (int, int) { if node == nil { return 0, 0 } lSum, lTilt := dfs(node.Left) RSum, rTilt := dfs(node.Right) tilt := lSum - RSum if tilt \u0026lt; 0 { tilt = -tilt } tilt += lTilt + rTilt return node.Val + lSum + RSum, tilt } _, tilt := dfs(root) return tilt } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-11-18T10:13:03+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-563.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9D%A1%E5%BA%A6/","title":"Leetcode 563. 二叉树的坡度"},{"content":"链接： https://leetcode-cn.com/problems/maximum-product-of-word-lengths/\n难度： 中等\n题目描述 给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。\n示例 1： 输入: [\u0026ldquo;abcw\u0026rdquo;,\u0026ldquo;baz\u0026rdquo;,\u0026ldquo;foo\u0026rdquo;,\u0026ldquo;bar\u0026rdquo;,\u0026ldquo;xtfn\u0026rdquo;,\u0026ldquo;abcdef\u0026rdquo;]\n输出: 16\n解释: 这两个单词为 \u0026ldquo;abcw\u0026rdquo;, \u0026ldquo;xtfn\u0026rdquo;。\n示例 2： 输入: [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;ab\u0026rdquo;,\u0026ldquo;abc\u0026rdquo;,\u0026ldquo;d\u0026rdquo;,\u0026ldquo;cd\u0026rdquo;,\u0026ldquo;bcd\u0026rdquo;,\u0026ldquo;abcd\u0026rdquo;]\n输出: 4\n解释: 这两个单词为 \u0026ldquo;ab\u0026rdquo;, \u0026ldquo;cd\u0026rdquo;。\n示例 3: 输入: [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;aa\u0026rdquo;,\u0026ldquo;aaa\u0026rdquo;,\u0026ldquo;aaaa\u0026rdquo;]\n输出: 0\n解释: 不存在这样的两个单词。\n提示： 2 \u0026lt;= words.length \u0026lt;= 1000 1 \u0026lt;= words[i].length \u0026lt;= 1000 words[i] 仅包含小写字母 解题思路 暴力求解 将字符串两两比较判定，使用哈希表确定是否有公共字符，有则跳过，没有将两个字符串长度相乘并更新最大值。\nfunc maxProduct(words []string) int { max := 0 for i := len(words) - 1; i \u0026gt; 0; i-- { exist := make([]bool, 26) for k := range words[i] { exist[words[i][k]-\u0026#39;a\u0026#39;] = true } Other: for j := i - 1; j \u0026gt;= 0; j-- { for k := range words[j] { if exist[words[j][k]-\u0026#39;a\u0026#39;] { continue Other } } if max \u0026lt; len(words[i])*len(words[j]) { max = len(words[i]) * len(words[j]) } } } return max } 复杂度 时间复杂度：$ O(N^2L), N = len(words), L = len(words[i]) $ 空间复杂度：$ O(L) $ 排序 在暴力的基础上优化，将 words 按照长度排序，从最长的字符串 word[i] 开始遍历，寻找下一个与 words[i] 没有公共字符的字符串 word[j]，找到即求得 word[i] 关联的最大值，无需继续遍历；当 len(word[i]) * len(word[j]) 小于最大值的时候，也无需继续遍历。\n当 len(word[i]) 的平方小于最长单词的时候，即完成遍历。\n比较两个单词是否有公共字符时，使用哈希表，将 word[i] 以字符的维度记录到哈希表中，遍历 word[j] ，确认其字符是否在哈希表中。\nfunc maxProduct(words []string) int { sort.Slice(words, func(i, j int) bool { return len(words[i]) \u0026lt; len(words[j]) }) max := 0 for i := len(words) - 1; i \u0026gt; 0; i-- { if len(words[i])*len(words[i]) \u0026lt; len(words[len(words)-1]) { break } exist := make([]bool, 26) for k := range words[i] { exist[words[i][k]-\u0026#39;a\u0026#39;] = true } Other: for j := i - 1; j \u0026gt;= 0; j-- { if len(words[i])*len(words[j]) \u0026lt; max { break } for k := range words[j] { if exist[words[j][k]-\u0026#39;a\u0026#39;] { continue Other } } if max \u0026lt; len(words[i])*len(words[j]) { max = len(words[i]) * len(words[j]) break } } } return max } 复杂度 时间复杂度：$ O(N^2L), N = len(words), L = len(words[i]) $ 空间复杂度：$ O(\\log{N}+L) $ 位运算 当使用哈希表确定是否有公共字符时，需要进行遍历，效率比较低。而因为字符空间为小写字母集合，可以用整数中的位代替哈希表的作用，这样可以使用与运算 $O(1)$ 的计算出是否有公共字符。\nfunc maxProduct(words []string) int { chars := make([]int32, len(words)) max := 0 for i, word := range words { for j := range word { chars[i] |= 1 \u0026lt;\u0026lt; (word[j] - \u0026#39;a\u0026#39;) } } for i := len(words) - 1; i \u0026gt; 0; i-- { for j := i - 1; j \u0026gt;= 0; j-- { if chars[i]\u0026amp;chars[j] == 0 \u0026amp;\u0026amp; max \u0026lt; len(words[i])*len(words[j]) { max = len(words[i]) * len(words[j]) } } } return max } 复杂度 时间复杂度：$ O(N^2+NL), N = len(words), L = len(words[i]) $ 空间复杂度：$ O(N) $ ","date":"2021-11-17T10:19:33+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-318.-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF/","title":"Leetcode 318. 最大单词长度乘积"},{"content":"链接： https://leetcode-cn.com/problems/bulb-switcher/\n难度： 中等\n题目描述 初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。\n第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。\n找出并返回 n 轮后有多少个亮着的灯泡。\n示例 1： 输入： n = 3\n输出： 1\n解释：\n初始时, 灯泡状态 [关闭, 关闭, 关闭].\n第一轮后, 灯泡状态 [开启, 开启, 开启].\n第二轮后, 灯泡状态 [开启, 关闭, 开启].\n第三轮后, 灯泡状态 [开启, 关闭, 关闭].\n你应该返回 1，因为只有一个灯泡还亮着。\n示例 2： 输入： n = 0\n输出： 0\n示例 3： 输入： n = 1\n输出： 1\n提示： 0 \u0026lt;= n \u0026lt;= 109 解题思路 数学 对于第 x 个灯泡来说，当进行第 i 轮切换时，只有满足 i 是 x 的约数时，其灯泡状态才会发生变化。\n而灯泡要亮则其约数数量必须要为奇数，需要满足该数是一个完全平方数。\n题目转换为寻找区间 [1,n] 内完全平方数的个数，使用内置开方函数即可。\nfunc bulbSwitch(n int) int { return int(math.Sqrt(float64(n))) } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-11-15T10:15:49+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-319.-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3/","title":"Leetcode 319. 灯泡开关"},{"content":"链接： https://leetcode-cn.com/problems/map-sum-pairs/\n难度： 中等\n题目描述 实现一个 MapSum 类，支持两个方法，insert 和 sum：\nMapSum() 初始化 MapSum 对象 void insert(String key, int val) 插入 key-val 键值对，字符串表示键 key ，整数表示值 val 。如果键 key 已经存在，那么原来的键值对将被替代成新的键值对。 int sum(string prefix) 返回所有以该前缀 prefix 开头的键 key 的值的总和。 示例： 输入：\n[\u0026ldquo;MapSum\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;sum\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;sum\u0026rdquo;]\n[[], [\u0026ldquo;apple\u0026rdquo;, 3], [\u0026ldquo;ap\u0026rdquo;], [\u0026ldquo;app\u0026rdquo;, 2], [\u0026ldquo;ap\u0026rdquo;]]\n输出：\n[null, null, 3, null, 5]\n解释：\nMapSum mapSum = new MapSum();\nmapSum.insert(\u0026ldquo;apple\u0026rdquo;, 3);\nmapSum.sum(\u0026ldquo;ap\u0026rdquo;); // return 3 (apple = 3)\nmapSum.insert(\u0026ldquo;app\u0026rdquo;, 2); mapSum.sum(\u0026ldquo;ap\u0026rdquo;); // return 5 (apple + app = 3 + 2 = 5)\n提示： 1 \u0026lt;= key.length, prefix.length \u0026lt;= 50 key 和 prefix 仅由小写英文字母组成 1 \u0026lt;= val \u0026lt;= 1000 最多调用 50 次 insert 和 sum 解题思路 暴力求解 使用哈希表记录字符串和整数的对象的映射。每次求和时，遍历哈希表找到满足条件的 key 然后对 val 求和。\ntype MapSum struct { hash map[string]int } func Constructor() MapSum { return MapSum{ hash: make(map[string]int), } } func (this *MapSum) Insert(key string, val int) { this.hash[key] = val } func (this *MapSum) Sum(prefix string) int { sum := 0 for key, val := range this.hash { if strings.HasPrefix(key, prefix) { sum += val } } return sum } 复杂度 时间复杂度： insert：$ O(1) $ sum：$ O(NL), N = size(hash), L = len(key) $ 空间复杂度：$ O(NL) $ Trie树 使用 Trie树 记录字符串和整数的对象的映射。每次求和时，遍历 Trie树 的前缀部分，然后使用深度优先搜索找到所有满足前缀的 key ，并对 val 求和。\ntype Node struct { val int child map[byte]*Node } type MapSum struct { head *Node } func Constructor() MapSum { return MapSum{ head: \u0026amp;Node{ child: make(map[byte]*Node), }, } } func (this *MapSum) Insert(key string, val int) { node := this.head for i := 0; i \u0026lt; len(key); i, node = i+1, node.child[key[i]] { if _, ok := node.child[key[i]]; !ok { node.child[key[i]] = \u0026amp;Node{ val: 0, child: make(map[byte]*Node), } } } node.val = val } func (this *MapSum) Sum(prefix string) int { node := this.head for i := 0; i \u0026lt; len(prefix); i++ { var ok bool if node, ok = node.child[prefix[i]]; !ok { return 0 } } var dfs func(node *Node) int dfs = func(node *Node) int { sum := node.val for _, node := range node.child { sum += dfs(node) } return sum } return dfs(node) } 复杂度 时间复杂度： insert：$ O(L), L = len(val) $ sum：$ O(NL), N = count(key) $ 空间复杂度：$ O(NL) $ ","date":"2021-11-14T10:55:35+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-677.-%E9%94%AE%E5%80%BC%E6%98%A0%E5%B0%84/","title":"Leetcode 677. 键值映射"},{"content":"链接： https://leetcode-cn.com/problems/detect-capital/\n难度： 简单\n题目描述 我们定义，在以下情况时，单词的大写用法是正确的：\n全部字母都是大写，比如 \u0026quot;USA\u0026quot; 。 单词中所有字母都不是大写，比如 \u0026quot;leetcode\u0026quot; 。 如果单词不只含有一个字母，只有首字母大写， 比如 \u0026quot;Google\u0026quot; 。 给你一个字符串 word 。如果大写用法正确，返回 true ；否则，返回 false 。\n示例 1： 输入： word = \u0026ldquo;USA\u0026rdquo;\n输出： true\n示例 2： 输入： word = \u0026ldquo;FlaG\u0026rdquo;\n输出： false\n提示： 1 \u0026lt;= word.length \u0026lt;= 100 word 由小写和大写英文字母组成 解题思路 分类讨论 满足条件的字符串或者全部为小写字母，或者首字母为大写字母，其余字母的大小写一致。根据这个进行分类讨论：\n当 word 长度小于 2 时，返回 true； 当首字母为小写字母时，需要判定后续字母必须全部小写； 当首字母是大写时，后续的字母均需要和第二个字母大小写相同。 func detectCapitalUse(word string) bool { if len(word) \u0026lt;= 1 { return true } i := 1 isCapital := false // 剩余字母的大小写 if word[0] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; word[0] \u0026lt;= \u0026#39;Z\u0026#39; { // 当首字母是大写时，确定第二个字母的大小写，并从第三个字母开始判断 if word[1] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; word[1] \u0026lt;= \u0026#39;Z\u0026#39; { isCapital = true } i = 2 } // 判断后续字母的大小写 for ; i \u0026lt; len(word); i++ { if (word[i] \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; word[i] \u0026lt;= \u0026#39;Z\u0026#39;) != isCapital { return false } } return true } 复杂度 时间复杂度：$ O(N), N = len(word) $ 空间复杂度：$ O(1) $ ","date":"2021-11-13T20:49:36+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-520.-%E6%A3%80%E6%B5%8B%E5%A4%A7%E5%86%99%E5%AD%97%E6%AF%8D/","title":"Leetcode 520. 检测大写字母"},{"content":"链接： https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/\n难度： 中等\n题目描述 我们正在玩一个猜数游戏，游戏规则如下：\n我从 1 到 n 之间选择一个数字。 你来猜我选了哪个数字。 如果你猜到正确的数字，就会 赢得游戏 。 如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。 每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。 给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。\n示例 1： 输入： n = 10\n输出： 16\n解释： 制胜策略如下：\n数字范围是 [1,10] 。你先猜测数字为 7 。 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。 在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。\n示例 2： 输入： n = 1\n输出： 0\n解释： 只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用\n示例 3： 输入： n = 2\n输出： 1\n解释： 有两个可能的数字 1 和 2 。\n你可以先猜 1 。 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。 最糟糕的情况下，你需要支付 $1 。\n提示： 1 \u0026lt;= n \u0026lt;= 200 解题思路 动态规划 由于无法得知每一步要选择哪个数字，故需要递归的寻找最优选择，但这样会产生很多重复的子问题，考虑转换为动态规划进行优化。\n使用 dp[i][j] 表示在连续区间 [i, j] 中猜数能获胜的最小现金数，则可以得到状态转移方程：\ndp[i][i] = 0； dp[i][j] = min(k + max(dp[i][k-1], dp[k+1][j])), k ∈ [i, j]。 最终结果为 dp[1][n]。\nfunc getMoneyAmount(n int) int { dp := make([][]int, 0, n) for i := 0; i \u0026lt; n; i++ { dp = append(dp, make([]int, n)) } // 求解区间长度 for length := 2; length \u0026lt;= n; length++ { // 区间开始下标 for i := n - length; i \u0026gt;= 0; i-- { dp[i][i+length-1] = math.MaxInt32 // 遍历可能选择 for k := i + length - 1; k \u0026gt;= i; k-- { pay := k + 1 // 下标从零开始，转换为 [1,n] // 两端判定 if k == i { pay += dp[k+1][i+length-1] } else if k == i+length-1 { pay += dp[i][k-1] } else { // 中间取大值 if dp[i][k-1] \u0026gt; dp[k+1][i+length-1] { pay += dp[i][k-1] } else { pay += dp[k+1][i+length-1] } } // 取最小选择点 if dp[i][i+length-1] \u0026gt; pay { dp[i][i+length-1] = pay } } } } return dp[0][n-1] } 复杂度 时间复杂度：$ O(n^3) $ 空间复杂度：$ O(n^2) $ ","date":"2021-11-12T11:30:47+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-375.-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F-ii/","title":"Leetcode 375. 猜数字大小 II"},{"content":"链接： https://leetcode-cn.com/problems/valid-triangle-number/\n难度： 困难\n题目描述 给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。\n逆序对的定义如下：对于数组的第 i 个和第 j 个元素，如果满足 i \u0026lt; j 且 a[i] \u0026gt; a[j]，则其为一个逆序对；否则不是。\n由于答案可能很大，只需要返回 答案 mod 109 + 7 的值。\n示例 1： 输入: n = 3, k = 0\n输出: 1\n解释: 只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。\n示例 2： 输入: n = 3, k = 1\n输出: 2\n解释: 数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。\n说明： n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。 解题思路 动态规划 对于由前 i 个自然数构成的任意排列，不妨假设逆序对个数为 x ，则将 i + 1 加入到排列中，由于 i + 1 是最大值，则其加入后对应逆序对的个数区间为 [x, x + i]，故可以用动态规划求解。\n用 dp[i][j] 表示前 i 个自然数的排列中，逆序对的个数为 j 的排列个数。则容易得到状态转移方程：\n初始时，dp[1][0] = 1, dp[1][...] = 0； 之后，dp[i][j] = dp[i-1][j-i+1] + dp[i-1][j-i+2] + ... + dp[i-1][j]。 最后的结果即为 dp[n][k] ，选择使用滚动数组降低空间复杂度。\n可以看到上述每次转移时，时间复杂度为 i，需要优化。注意到：\ndp[i][j-1] = dp[i-1][j-i] + dp[i-1][j-i+1] + ... + dp[i-1][j-1],\n则 dp[i][j] = dp[i-1][j-i+1] + dp[i-1][j-i+2] + ... + dp[i-1][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-i]。\nfunc kInversePairs(n int, k int) int { const MOD int = 1e9 + 7 dp0 := make([]int, k+1) dp1 := make([]int, k+1) dp0[0] = 1 for i := 2; i \u0026lt;= n; i++ { dp1[0] = dp0[0] for j := 1; j \u0026lt;= k; j++ { // 越界检查 if j \u0026lt; i { dp1[j] = (dp1[j-1] + dp0[j]) % MOD } else { dp1[j] = (dp1[j-1] + dp0[j] - dp0[j-i]) % MOD if dp1[j] \u0026lt; 0 { dp1[j] += MOD } } } dp1, dp0 = dp0, dp1 } return dp0[k] } 复杂度 时间复杂度：$ O(nk) $ 空间复杂度：$ O(k) $ ","date":"2021-11-11T10:32:02+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-629.-k%E4%B8%AA%E9%80%86%E5%BA%8F%E5%AF%B9%E6%95%B0%E7%BB%84/","title":"Leetcode 629. K个逆序对数组"},{"content":"链接： https://leetcode-cn.com/problems/teemo-attacking/\n难度： 简单\n题目描述 在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄。他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。\n当提莫攻击艾希，艾希的中毒状态正好持续 duration 秒。\n正式地讲，提莫在 t 发起发起攻击意味着艾希在时间区间 [t, t + duration - 1]（含 t 和 t + duration - 1）处于中毒状态。如果提莫在中毒影响结束 前 再次攻击，中毒状态计时器将会 重置 ，在新的攻击之后，中毒影响将会在 duration 秒后结束。\n给你一个 非递减 的整数数组 timeSeries ，其中 timeSeries[i] 表示提莫在 timeSeries[i] 秒时对艾希发起攻击，以及一个表示中毒持续时间的整数 duration 。\n返回艾希处于中毒状态的 总 秒数。\n示例 1： 输入： timeSeries = [1,4], duration = 2\n输出： 4\n解释： 提莫攻击对艾希的影响如下：\n第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。 第 4 秒，提莫再次攻击艾希，艾希中毒状态又持续 2 秒，即第 4 秒和第 5 秒。\n艾希在第 1、2、4、5 秒处于中毒状态，所以总中毒秒数是 4 。 示例 2： 输入： timeSeries = [1,2], duration = 2\n输出： 3\n解释： 提莫攻击对艾希的影响如下：\n第 1 秒，提莫攻击艾希并使其立即中毒。中毒状态会维持 2 秒，即第 1 秒和第 2 秒。 第 2 秒，提莫再次攻击艾希，并重置中毒计时器，艾希中毒状态需要持续 2 秒，即第 2 秒和第 3 秒。\n艾希在第 1、2、3 秒处于中毒状态，所以总中毒秒数是 3 。 提示： 1 \u0026lt;= timeSeries.length \u0026lt;= 104 0 \u0026lt;= timeSeries[i], duration \u0026lt;= 107 timeSeries 按 非递减 顺序排列 解题思路 模拟 对于每次攻击 timeSeries[i] ，判定与下一次攻击 timeSeries[i+1] 之间的时间间隔：\n当距离下一次攻击的时间间隔 ≥ duration 时，中毒计数器不会重置，中毒时间为 duration； 否则，说明中毒计数器重置了，中毒时间为 timeSeries[i+1] - timeSeries[i]； 最后一次攻击后，其中毒时间为 duration。 将每次计算的中毒时间累加即可。\nfunc findPoisonedDuration(timeSeries []int, duration int) int { time := duration for i := 1; i \u0026lt; len(timeSeries); i++ { if timeSeries[i]-timeSeries[i-1] \u0026gt;= duration { time += duration } else { time += timeSeries[i] - timeSeries[i-1] } } return time } 复杂度 时间复杂度：$ O(N), N = len(timeSeries) $ 空间复杂度：$ O(1) $ ","date":"2021-11-10T10:21:09+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-495.-%E6%8F%90%E8%8E%AB%E6%94%BB%E5%87%BB/","title":"Leetcode 495. 提莫攻击"},{"content":"链接： https://leetcode-cn.com/problems/buddy-strings/\n难度： 简单\n题目描述 给你两个字符串 s 和 goal ，只要我们可以通过交换 s 中的两个字母得到与 goal 相等的结果，就返回 true ；否则返回 false 。\n交换字母的定义是：取两个下标 i 和 j （下标从 0 开始）且满足 i != j ，接着交换 s[i] 和 s[j] 处的字符。\n例如，在 \u0026quot;abcd\u0026quot; 中交换下标 0 和下标 2 的元素可以生成 \u0026quot;cbad\u0026quot; 。\n示例 1： 输入： s = \u0026ldquo;ab\u0026rdquo;, goal = \u0026ldquo;ba\u0026rdquo;\n输出： true\n解释： 你可以交换 s[0] = \u0026lsquo;a\u0026rsquo; 和 s[1] = \u0026lsquo;b\u0026rsquo; 生成 \u0026ldquo;ba\u0026rdquo;，此时 s 和 goal 相等。\n示例 2： 输入： s = \u0026ldquo;ab\u0026rdquo;, goal = \u0026ldquo;ab\u0026rdquo;\n输出： false\n解释： 你只能交换 s[0] = \u0026lsquo;a\u0026rsquo; 和 s[1] = \u0026lsquo;b\u0026rsquo; 生成 \u0026ldquo;ba\u0026rdquo;，此时 s 和 goal 不相等。\n示例 3： 输入： s = \u0026ldquo;aa\u0026rdquo;, goal = \u0026ldquo;aa\u0026rdquo;\n输出： true\n解释： 你可以交换 s[0] = \u0026lsquo;a\u0026rsquo; 和 s[1] = \u0026lsquo;a\u0026rsquo; 生成 \u0026ldquo;aa\u0026rdquo;，此时 s 和 goal 相等。\n示例 4： 输入： s = \u0026ldquo;aaaaaaabc\u0026rdquo;, goal = \u0026ldquo;aaaaaaacb\u0026rdquo;\n输出： true\n提示： 1 \u0026lt;= s.length, goal.length \u0026lt;= 2 * 104 s 和 goal 由小写英文字母组成 解题思路 暴力求解 满足条件的字符串有两种情况：\n字符串 s 和 goal 有且仅有两个下标处的字符不同，并且这两个下标处的字符位置相反的； 字符串 s 和 goal 完全相同，而且 s 中至少有一个字符出现两次。 其余情况均不满足条件。\n针对上述情况，首先比较字符串长度，不相同直接返回 false 。相同则逐一地遍历比较每个字符，记录不同字符的下标位置，对于相同的字符，使用哈希表来判断是否有出现相同的字符。当仅有两个字符不相同时，返回是否位置相反；当全部都相同时，返回是否有重复字符；其余返回 false 。\nfunc buddyStrings(s string, goal string) bool { if len(s) != len(goal) { return false } diff := make([]int, 0, 2) repeat := false exist := make(map[byte]struct{}) for i := range s { if s[i] == goal[i] { if !repeat { if _, ok := exist[s[i]]; ok { repeat = true } exist[s[i]] = struct{}{} } continue } if len(diff) == 2 { return false } diff = append(diff, i) } switch len(diff) { case 0: return repeat case 2: return s[diff[0]] == goal[diff[1]] \u0026amp;\u0026amp; s[diff[1]] == goal[diff[0]] } return false } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(\\Sigma), \\Sigma表示字符集字符总数量，本题为26$ ","date":"2021-11-09T10:50:05+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-859.-%E4%BA%B2%E5%AF%86%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 859. 亲密字符串"},{"content":"链接： https://leetcode-cn.com/problems/bulls-and-cows/\n难度： 中等\n题目描述 你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下：\n写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：\n猜测数字中有多少位属于数字和确切位置都猜对了（称为 \u0026ldquo;Bulls\u0026rdquo;, 公牛）， 有多少位属于数字猜对了但是位置不对（称为 \u0026ldquo;Cows\u0026rdquo;, 奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。 给你一个秘密数字 secret 和朋友猜测的数字 guess ，请你返回对朋友这次猜测的提示。\n提示的格式为 \u0026quot;xAyB\u0026quot; ，x 是公牛个数， y 是奶牛个数，A 表示公牛，B 表示奶牛。\n请注意秘密数字和朋友猜测的数字都可能含有重复数字。\n示例 1： 输入: secret = \u0026ldquo;1807\u0026rdquo;, guess = \u0026ldquo;7810\u0026rdquo;\n输出: \u0026ldquo;1A3B\u0026rdquo;\n解释: 数字和位置都对（公牛）用 \u0026lsquo;|\u0026rsquo; 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\u0026ldquo;1807\u0026rdquo;\n|\n\u0026ldquo;7810\u0026rdquo;\n示例 2： 输入: secret = \u0026ldquo;1123\u0026rdquo;, guess = \u0026ldquo;0111\u0026rdquo;\n输出: \u0026ldquo;1A1B\u0026rdquo;\n解释: 数字和位置都对（公牛）用 \u0026lsquo;|\u0026rsquo; 连接，数字猜对位置不对（奶牛）的采用斜体加粗标识。\n\u0026ldquo;1123\u0026rdquo; \u0026ldquo;1123\u0026rdquo;\n| or |\n\u0026ldquo;0111\u0026rdquo; \u0026ldquo;0111\u0026rdquo;\n注意，两个不匹配的 1 中，只有一个会算作奶牛（数字猜对位置不对）。通过重新排列非公牛数字，其中仅有一个 1 可以成为公牛数字。\n示例 3： 输入： secret = \u0026ldquo;1\u0026rdquo;, guess = \u0026ldquo;0\u0026rdquo;\n输出： \u0026ldquo;0A0B\u0026rdquo;\n示例 4： 输入： secret = \u0026ldquo;1\u0026rdquo;, guess = \u0026ldquo;1\u0026rdquo;\n输出： \u0026ldquo;1A0B\u0026rdquo;\n提示： 1 \u0026lt;= secret.length, guess.length \u0026lt;= 1000 secret.length == guess.length secret 和 guess 仅由数字组成 解题思路 哈希 数字和确切位置都相同的字符经过一次遍历比较即可得出 \u0026quot;Bulls\u0026quot; ，现需要求解数字对但位置不对的字符数量。\n使用两个哈希表分别记录 secret 和 guess 中，数字和位置不都相同的数字数量，然后比较两个哈希表，每个字符选取小的那个累加到 \u0026quot;Cows\u0026quot; 中。算法如下：\n遍历并比较 secret 和 guess 中的每一位字符：\n若不同，则将其记录到分别记录到两个哈希表中； 若相同，则 \u0026quot;Bulls\u0026quot; 的数量 +1，同时记录这些位置。 然后遍历 guess 对应的哈希表，选择数量小的求和。\nfunc getHint(secret string, guess string) string { secretCnt := make(map[byte]int) guessCnt := make(map[byte]int) bulls := 0 for i := range secret { if secret[i] == guess[i] { bulls++ } else { secretCnt[secret[i]]++ guessCnt[guess[i]]++ } } cows := 0 for char := range guessCnt { if guessCnt[char] \u0026lt; secretCnt[char] { cows += guessCnt[char] } else { cows += secretCnt[char] } } return fmt.Sprintf(\u0026#34;%dA%dB\u0026#34;, bulls, cows) } 复杂度 时间复杂度：$ O(N), N = len(secret) $ 空间复杂度：$ O(\\Sigma), \\Sigma表示字符集字符总数量，本题为10 $ ","date":"2021-11-08T22:46:13+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-299.-%E7%8C%9C%E6%95%B0%E5%AD%97%E6%B8%B8%E6%88%8F/","title":"Leetcode 299. 猜数字游戏"},{"content":"链接： https://leetcode-cn.com/problems/range-addition-ii/\n难度： 简单\n题目描述 给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。\n操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，含义是将所有符合 0 \u0026lt;= i \u0026lt; a 以及 0 \u0026lt;= j \u0026lt; b 的元素 M[i][j] 的值都增加 1。\n在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。\n示例： 输入:\nm = 3, n = 3 operations = [[2,2],[3,3]] 输出: 4\n解释:\n初始状态, M =\n[[0, 0, 0],\n[0, 0, 0],\n[0, 0, 0]]\n执行完操作 [2,2] 后, M =\n[[1, 1, 0],\n[1, 1, 0],\n[0, 0, 0]]\n执行完操作 [3,3] 后, M =\n[[2, 2, 1],\n[2, 2, 1],\n[1, 1, 1]]\nM 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。\n注意： m 和 n 的范围是 [1,40000]。 a 的范围是 [1,m]，b 的范围是 [1,n]。 操作数目不超过 10000。 解题思路 模拟 每次的操作都是左上角的元素增加 1，所有操作的交集范围即为最大整数的元素个数，每次记录 a 和 b 的最小值即可。\nfunc maxCount(m int, n int, ops [][]int) int { a, b := m, n for _, op := range ops { if a \u0026gt; op[0] { a = op[0] } if b \u0026gt; op[1] { b = op[1] } } return a * b } 复杂度 时间复杂度：$ O(N), N = len(ops) $ 空间复杂度：$ O(1) $ ","date":"2021-11-07T10:14:48+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-598.-%E8%8C%83%E5%9B%B4%E6%B1%82%E5%92%8C-ii/","title":"Leetcode 598. 范围求和 II"},{"content":"链接： https://leetcode-cn.com/problems/missing-number/\n难度： 简单\n题目描述 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。\n示例 1： 输入： nums = [3,0,1]\n输出： 2\n解释： n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。\n示例 2： 输入： nums = [0,1]\n输出： 2\n解释： n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。\n示例 3： 输入： nums = [9,6,4,2,3,5,7,0,1]\n输出： 8\n解释： n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。\n示例 4： 输入： nums = [0]\n输出： 1\n解释： n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。\n提示： n == nums.length 1 \u0026lt;= n \u0026lt;= 104 0 \u0026lt;= nums[i] \u0026lt;= n nums 中的所有数字都 独一无二 解题思路 哈希 使用哈希表记录出现过的数字，然后从 1 开始向后遍历，返回没有在哈希表中的数字。\nfunc missingNumber(nums []int) int { exists := make(map[int]struct{}) for _, num := range nums { exists[num] = struct{}{} } for i := 0; ; i++ { if _, ok := exists[i]; !ok { return i } } } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ 排序 对整个数组排序，然后遍历数组，当遇到元素值和下标不一样时，返回下标；若都一样，则返回 len(nums)。\nfunc missingNumber(nums []int) int { sort.Ints(nums) for i, num := range nums { if i != num { return i } } return len(nums) } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(nums) $ 空间复杂度：$ O(\\log{N}) $ 排序优化 由于数组中的数字位于区间 [0, n]，对于除了 n 的每个数字，可以知道其对应的正确位置，直接将其放置在对应的位置上，降低排序的时空间复杂度。\n则在排序完成后，有两种情况：\n当缺少的元素为 n 时，整个数组中元素和下标一一对应； 当缺少的元素不为 n 时，缺少的元素下表处放置的数字为 n。 与排序后的处理方案一致：遍历数组，当遇到元素值和下标不一样时，返回下标；若都一样，则返回 len(nums)。\nfunc missingNumber(nums []int) int { for i := 0; i \u0026lt; len(nums); { if nums[i] \u0026lt; len(nums) \u0026amp;\u0026amp; nums[i] != i { nums[i], nums[nums[i]] = nums[nums[i]], nums[i] } else { i++ } } for i, num := range nums { if i != num { return i } } return len(nums) } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ 位运算 将原数组拼接区间 [0, n] 形成一个新的数组，在这个数组中，除了结果项外，其他元素均出现了两次，通过异或运算消除相同的数字即可求得结果项。\nfunc missingNumber(nums []int) int { xor := 0 for _, num := range nums { xor ^= num } for i := len(nums); i \u0026gt;= 0; i-- { xor ^= i } return xor } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ 数学 数组中的所有数字和结果需要返回的数字一起构成了首项为 0，公差为 1 的等差数列，现在需要求解其中一项，可以通过做差求得。\n等差数列的和为 $\\frac{n(n+1)}{2}$，遍历数组求得已知项的和为 sum ，则未知项即为 $\\frac{n(n+1)}{2} - sum$。\nfunc missingNumber(nums []int) int { sum := 0 for _, num := range nums { sum += num } return len(nums)*(len(nums)+1)/2 - sum } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-11-06T12:14:29+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-268.-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","title":"Leetcode 268. 丢失的数字"},{"content":"链接： https://leetcode-cn.com/problems/longest-arithmetic-subsequence-of-given-difference/\n难度： 中等\n题目描述 给你一个整数数组 arr 和一个整数 difference，请你找出并返回 arr 中最长等差子序列的长度，该子序列中相邻元素之间的差等于 difference 。\n子序列 是指在不改变其余元素顺序的情况下，通过删除一些元素或不删除任何元素而从 arr 派生出来的序列。\n示例1： 输入： arr = [1,2,3,4], difference = 1\n输出： 4\n解释： 最长的等差子序列是 [1,2,3,4]。\n示例 2： 输入： arr = [1,3,5,7], difference = 1\n输出： 1\n解释： 最长的等差子序列是任意单个元素。\n示例 3： 输入： arr = [1,5,7,8,5,3,4,2,1], difference = -2\n输出： 4\n解释： 最长的等差子序列是 [7,5,3,1]。\n提示： 1 \u0026lt;= arr.length \u0026lt;= 105 -104 \u0026lt;= arr[i], difference \u0026lt;= 104 解题思路 动态规划 对于 arr 中的某个元素 num ，其能否和之前的元素构成等差数列，取决于在其前面是否出现了 num - difference 这个元素，并可以不断向前追溯从而求得队列长度。所以要记录当前出现过的元素，同时为优化追溯过程，需要记录数列长度，故可以使用动态规划求解。\n使用 dp[i] 表示以 i 结尾的当前满足条件的等差数列的长度，由于记录的是数据值，存储结构选用哈希表，则有状态转移方程：\n初始时，dp[i] = 0 之后，dp[i] = dp[i-difference] + 1 在遍历的过程中，比较并记录等差数列的最大值。\nfunc longestSubsequence(arr []int, difference int) int { max := 0 dp := make(map[int]int) for _, num := range arr { dp[num] = dp[num-difference] + 1 if max \u0026lt; dp[num] { max = dp[num] } } return max } 复杂度 时间复杂度：$ O(N), N = len(arr) $ 空间复杂度：$ O(N) $ ","date":"2021-11-05T22:33:00+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1218.-%E6%9C%80%E9%95%BF%E5%AE%9A%E5%B7%AE%E5%AD%90%E5%BA%8F%E5%88%97/","title":"Leetcode 1218. 最长定差子序列"},{"content":"链接： https://leetcode-cn.com/problems/valid-perfect-square/\n难度： 简单\n题目描述 给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。\n进阶： 不要 使用任何内置的库函数，如 sqrt 。\n示例 1： 输入： num = 16\n输出： true\n示例 2： 输入： num = 14\n输出： false\n提示： 1 \u0026lt;= num \u0026lt;= 231 - 1 解题思路 暴力求解 从 i = 1 开始每次累加 1，直到 i * i \u0026gt;= num 时为止。\n若此时 i * i = num ，则返回 true；否则，返回 false 。\nfunc isPerfectSquare(num int) bool { i := 1 for ; i*i \u0026lt; num; i++ { } if i*i == num { return true } return false } 复杂度 时间复杂度：$ O(\\sqrt{num}) $ 空间复杂度：$ O(1) $ 二分查找 若 num 是一个完全平方数，则其平方根位于区间 [1, num] 中，可以使用二分查找求解，设区间中间为 mid，左右端点为 l 和 r ：\n当 mid * mid = num，返回 true 当 mid * mid \u0026lt; num，在区间 [mid+1, r] 中查找； 当 mid * mid \u0026gt; num，在区间 [l, mid-1] 中查找； 直到区间为空时，说明 num 不是完全平方数，返回 false。\nfunc isPerfectSquare(num int) bool { for l, r := 1, num; l \u0026lt;= r; { mid := (l + r) / 2 if mid*mid == num { return true } else if mid*mid \u0026lt; num { l = mid + 1 } else { r = mid - 1 } } return false } 复杂度 时间复杂度：$ O(\\log{num}) $ 空间复杂度：$ O(1) $ ","date":"2021-11-04T21:44:09+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-367.-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/","title":"Leetcode 367. 有效的完全平方数"},{"content":"链接： https://leetcode-cn.com/problems/delete-node-in-a-linked-list/\n难度： 简单\n题目描述 请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。\n题目数据保证需要删除的节点 不是末尾节点 。\n示例 1： 输入： head = [4,5,1,9], node = 5\n输出： [4,1,9]\n解释： 指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -\u0026gt; 1 -\u0026gt; 9\n示例 2： 输入： head = [4,5,1,9], node = 1\n输出： [4,5,9]\n解释： 指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -\u0026gt; 5 -\u0026gt; 9\n示例 3： 输入： head = [1,2,3,4], node = 3\n输出： [1,2,4]\n示例 4： 输入： head = [0,1], node = 0\n输出： [1]\n示例 5： 输入： head = [-3,5,-99], node = -3\n输出： [5,-99]\n提示： 链表中节点的数目范围是 [2, 1000] -1000 \u0026lt;= Node.val \u0026lt;= 1000 链表中每个节点的值都是唯一的 需要删除的节点 node 是 链表中的一个有效节点 ，且 不是末尾节点 解题思路 值交换 由于无法修改上一个结点的 Next 指针，故可以将下一个结点的值赋给当前结点，然后删除下一个结点。\nfunc deleteNode(node *ListNode) { node.Val = node.Next.Val node.Next = node.Next.Next } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-11-02T22:55:00+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-237.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","title":"Leetcode 237. 删除链表中的节点"},{"content":"链接： https://leetcode-cn.com/problems/distribute-candies/\n难度： 简单\n题目描述 Alice 有 n 枚糖，其中第 i 枚糖的类型为 candyType[i] 。Alice 注意到她的体重正在增长，所以前去拜访了一位医生。\n医生建议 Alice 要少摄入糖分，只吃掉她所有糖的 n / 2 即可（n 是一个偶数）。Alice 非常喜欢这些糖，她想要在遵循医生建议的情况下，尽可能吃到最多不同种类的糖。\n给你一个长度为 n 的整数数组 candyType ，返回： Alice 在仅吃掉 n / 2 枚糖的情况下，可以吃到糖的最多种类数。\n示例 1： 输入： candyType = [1,1,2,2,3,3]\n输出： 3\n解释： Alice 只能吃 6 / 2 = 3 枚糖，由于只有 3 种糖，她可以每种吃一枚。\n示例 2： 输入： candyType = [1,1,2,3]\n输出： 2\n解释： Alice 只能吃 4 / 2 = 2 枚糖，不管她选择吃的种类是 [1,2]、[1,3] 还是 [2,3]，她只能吃到两种不同类的糖。\n\u0008示例 3： 输入： candyType = [6,6,6,6]\n输出： 1\n解释： Alice 只能吃 4 / 2 = 2 枚糖，尽管她能吃 2 枚，但只能吃到 1 种糖。\n提示： n == candyType.length 2 \u0026lt;= n \u0026lt;= 104 n 是一个偶数 -105 \u0026lt;= candyType[i] \u0026lt;= 105 解题思路 哈希 使用哈希表记录糖果的种类，记为 types, 则其能吃到糖的最多种类数即为 min(n/2, size(types))\nfunc distributeCandies(candyType []int) int { types := make(map[int]struct{}) for _, t := range candyType { types[t] = struct{}{} } if len(candyType)/2 \u0026lt; len(types) { return len(candyType) / 2 } else { return len(types) } } 复杂度 时间复杂度：$ O(N), N = len(candyType) $ 空间复杂度：$ O(N) $ ","date":"2021-11-01T23:18:01+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-575.-%E5%88%86%E7%B3%96%E6%9E%9C/","title":"Leetcode 575. 分糖果"},{"content":"链接： https://leetcode-cn.com/problems/keyboard-row/\n难度： 简单\n题目描述 给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。键盘如下图所示。\n美式键盘 中：\n第一行由字符 \u0026quot;qwertyuiop\u0026quot; 组成。 第二行由字符 \u0026quot;asdfghjkl\u0026quot; 组成。 第三行由字符 \u0026quot;zxcvbnm\u0026quot; 组成。 示例 1： 输入： words = [\u0026ldquo;Hello\u0026rdquo;,\u0026ldquo;Alaska\u0026rdquo;,\u0026ldquo;Dad\u0026rdquo;,\u0026ldquo;Peace\u0026rdquo;]\n输出： [\u0026ldquo;Alaska\u0026rdquo;,\u0026ldquo;Dad\u0026rdquo;]\n示例 2： 输入： words = [\u0026ldquo;omk\u0026rdquo;]\n输出： []\n\u0008示例 3： 输入： words = [\u0026ldquo;adsdf\u0026rdquo;,\u0026ldquo;sfd\u0026rdquo;]\n输出： [\u0026ldquo;adsdf\u0026rdquo;,\u0026ldquo;sfd\u0026rdquo;]\n提示： 1 \u0026lt;= words.length \u0026lt;= 20 1 \u0026lt;= words[i].length \u0026lt;= 100 words[i] 由英文字母（小写和大写字母）组成 解题思路 哈希 使用哈希表记录每个字母对应的行号。之后遍历每个字符串，判断每个字母行号是否相同。\nfunc findWords(words []string) []string { row := make(map[byte]int) for line, chars := range []string{\u0026#34;qwertyuiop\u0026#34;, \u0026#34;asdfghjkl\u0026#34;, \u0026#34;zxcvbnm\u0026#34;} { for i := range chars { row[chars[i]] = line row[chars[i]-\u0026#39;a\u0026#39;+\u0026#39;A\u0026#39;] = line } } ans := make([]string, 0, len(words)) Outer: for _, word := range words { line := row[word[0]] for i := 1; i \u0026lt; len(word); i++ { if row[word[i]] != line { continue Outer } } ans = append(ans, word) } return ans } 复杂度 时间复杂度：$ O(N*L), N = len(words), L = avg(len(word[i])) $ 空间复杂度：$ O(\\Sigma), \\Sigma 表示字符集，此题为26 $ ","date":"2021-10-31T13:42:17+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-500.-%E9%94%AE%E7%9B%98%E8%A1%8C/","title":"Leetcode 500. 键盘行"},{"content":"链接： https://leetcode-cn.com/problems/single-number-iii/\n难度： 中等\n题目描述 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。\n进阶： 你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？\n示例 1： 输入： nums = [1,2,1,3,2,5]\n输出： [3,5]\n解释： [5, 3] 也是有效的答案。\n示例 2： 输入： nums = [-1,0]\n输出： [-1,0]\n示例 3： 输入： nums = [0,1]\n输出： [1,0]\n提示： 2 \u0026lt;= nums.length \u0026lt;= 3 * 104 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 除两个只出现一次的整数外，nums 中的其他数字都出现两次 解题思路 哈希 使用哈希表统计数字的出现次数，将出现次数为 1 的加入到结果中。\nfunc singleNumber(nums []int) []int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ } ans := make([]int, 0, 2) for num, c := range cnt { if c == 1 { ans = append(ans, num) } } return ans } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ 异或 + 拆分 将整个数组进行异或操作，得到最后的两个数字的异或值。从其中找出为 1 的位，按照此位将数组中的数字分为两组，则同一对数字必然在同一组，不同的两个数在不同组，对两组分别求异或即可得出结果。\nfunc singleNumber(nums []int) []int { xor := 0 for _, num := range nums { xor ^= num } bit := 1 for ; xor\u0026amp;bit == 0; bit \u0026lt;\u0026lt;= 1 { } ans0 := 0 ans1 := 0 for _, num := range nums { if num\u0026amp;bit == 0 { ans0 ^= num } else { ans1 ^= num } } return []int{ans0, ans1} } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-10-30T11:40:06+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-260.-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-iii/","title":"Leetcode 260. 只出现一次的数字 III"},{"content":"链接： https://leetcode-cn.com/problems/reordered-power-of-2/\n难度： 中等\n题目描述 给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。\n如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。\n示例 1： 输入： 1\n输出： true\n示例 2： 输入： 10\n输出： false\n示例 3： 输入： 16\n输出： true\n示例 4： 输入： 24\n输出： false\n示例 5： 输入： 46\n输出： true\n提示： 1 \u0026lt;= N \u0026lt;= 109 解题思路 排序 + 哈希表 遍历范围内所有 2 的幂，按照每一位数字顺序进行排序形成字符串并构成一个哈希表。\n对于每个数字，按照每一位数字顺序进行排序形成字符串，查表即可。\nfunc reorderedPowerOf2(n int) bool { proc := func(num int) string { t := make([]byte, 0, 10) for ; num \u0026gt; 0; num /= 10 { t = append(t, byte(num%10)+\u0026#39;0\u0026#39;) } sort.Slice(t, func(i, j int) bool { return t[i] \u0026lt; t[j] }) return string(t) } exist := make(map[string]struct{}) for i := 1; i \u0026lt; n*10; i \u0026lt;\u0026lt;= 1 { exist[proc(i)] = struct{}{} } _, ok := exist[proc(n)] return ok } 复杂度 时间复杂度：$ O(\\log{n}) $ 空间复杂度：$ O(\\log{n}) $ ","date":"2021-10-28T12:49:06+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-869.-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B0-2-%E7%9A%84%E5%B9%82/","title":"Leetcode 869. 重新排序得到 2 的幂"},{"content":"链接： https://leetcode-cn.com/problems/next-greater-element-i/\n难度： 简单\n题目描述 给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中 nums1 是 nums2 的子集。\n请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。\nnums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。\n示例 1： 输入: nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出: [-1,3,-1]\n解释:\n对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。\n对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。\n对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。\n示例 2： 输入: nums1 = [2,4], nums2 = [1,2,3,4].\n输出: [3,-1]\n解释:\n对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。\n对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。\n提示： 1 \u0026lt;= nums1.length \u0026lt;= nums2.length \u0026lt;= 1000 0 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 104 nums1 和 nums2 中所有整数 互不相同 nums1 中的所有整数同样出现在 nums2 中 进阶： 你可以设计一个时间复杂度为 $O(nums1.length + nums2.length)$ 的解决方案吗？\n解题思路 暴力求解 对于 nums1 中的每个数字，在 nums2 中进行寻找。\nfunc nextGreaterElement(nums1 []int, nums2 []int) []int { stack := make([]int, 0, len(nums2)) for _, num2 := range nums2 { if len(sta) } return ans } 复杂度 时间复杂度：$ O(N*M), N = len(nums1), M = len(nums2) $ 空间复杂度：$ O(1) $ 栈 + 哈希 使用哈希表记录 nums2 中每个元素的下一个比其大的值，对于 nums1 中的元素，查表即可。\n从左往右遍历 nums2 中的元素，使用栈 stack 来记录当前没有找到下一个比其大的值的元素，则 stack 存储的是非严格单调递减的序列：\n对于每个元素 num2，首先从栈顶开始将所有小于 num2 的元素弹出栈，这些元素的下一个比其大的值即为 num2，记录到哈希表中； 然后将当前元素加入到栈中。 处理结束，不在哈希表中的元素即没有找到，之后遍历 nums1 依次查找哈希表即可。\nfunc nextGreaterElement(nums1 []int, nums2 []int) []int { hash := make(map[int]int) stack := make([]int, 0, len(nums2)) for _, num2 := range nums2 { for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; stack[len(stack)-1] \u0026lt; num2 { hash[stack[len(stack)-1]] = num2 stack = stack[:len(stack)-1] } stack = append(stack, num2) } ans := make([]int, 0, len(nums1)) for _, num1 := range nums1 { t, ok := hash[num1] if !ok { ans = append(ans, -1) } else { ans = append(ans, t) } } return ans } 复杂度 时间复杂度：$ O(N+M), N = len(nums1), M = len(nums2) $ 空间复杂度：$ O(M) $ ","date":"2021-10-26T11:32:45+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-496.-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0-i/","title":"Leetcode 496. 下一个更大元素 I"},{"content":"链接： https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\n难度： 中等\n题目描述 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：\n每行的元素从左到右升序排列。 每列的元素从上到下升序排列。 示例 1： 输入： matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n输出： true\n示例 2： 输入： matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n输出： false\n提示： m == matrix.length n == matrix[i].length 1 \u0026lt;= n, m \u0026lt;= 300 -109 \u0026lt;= matrix[i][j] \u0026lt;= 109 每行的所有元素从左到右升序排列 每列的所有元素从上到下升序排列 -109 \u0026lt;= target \u0026lt;= 109 解题思路 暴力求解 遍历整个矩阵，寻找 target。\nfunc searchMatrix(matrix [][]int, target int) bool { for _, line := range matrix { for _, cell := range line { if cell == target { return true } } } return false } 复杂度 时间复杂度：$ O(mn)$ 空间复杂度：$ O(1) $ 二分查找 由于矩阵每一行是有序的，针对每一行二分查找 target。\nfunc searchMatrix(matrix [][]int, target int) bool { for _, line := range matrix { idx := sort.SearchInts(line, target) if idx \u0026lt; len(matrix[0]) \u0026amp;\u0026amp; line[idx] == target { return true } } return false } 复杂度 时间复杂度：$ O(m\\log{n}) $ 空间复杂度：$ O(1) $ 双指针 因为整个矩阵从左到右，从上到下升序排列，所以：\n当某个元素 \u0026gt; target，则其右下范围内的所有元素均 \u0026gt; target，也即 target 不在该范围内。 当某个元素 \u0026lt; target，则其左上范围内的所有元素均 \u0026lt; target，也即 target 不在该范围内。 故利用上述特性，从右上角开始查找：\n若当前元素 = target，则直接返回 true ; 若当前元素 \u0026gt; target，则向左查找。 若当前元素 \u0026lt; target，则向下查找。 当超出矩阵范围时，查找失败，返回 false。\nfunc searchMatrix(matrix [][]int, target int) bool { row, col := 0, len(matrix[0])-1 for row \u0026lt; len(matrix) \u0026amp;\u0026amp; col \u0026gt;= 0 { if matrix[row][col] == target { return true } else if matrix[row][col] \u0026gt; target { col-- } else { row++ } } return false } 复杂度 时间复杂度：$ O(m+n) $ 空间复杂度：$ O(1) $ ","date":"2021-10-25T11:40:02+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-240.-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-ii/","title":"Leetcode 240. 搜索二维矩阵 II"},{"content":"链接： https://leetcode-cn.com/problems/construct-the-rectangle/\n难度： 简单\n题目描述 作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：\n你设计的矩形页面必须等于给定的目标面积。 宽度 W 不应大于长度 L，换言之，要求 L \u0026gt;= W 。 长度 L 和宽度 W 之间的差距应当尽可能小。 你需要按顺序输出你设计的页面的长度 L 和宽度 W。\n示例 ： 输入: 4\n输出: [2, 2]\n解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。\n但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。\n提示： 给定的面积不大于 10,000,000 且为正整数。 你设计的页面的长度和宽度必须都是正整数。 解题思路 模拟 令 W 从 $ \\sqrt{area} $ 开始，找到符合条件的首个 L 的即返回。\nfunc constructRectangle(area int) []int { for w := int(math.Sqrt(float64(area))); w \u0026gt; 1; w-- { if area % w == 0 { return []int{area/w, w} } } return []int{area, 1} } 复杂度 时间复杂度：$ O(\\sqrt{area}) $ 空间复杂度：$ O(1) $ ","date":"2021-10-23T12:04:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-492.-%E6%9E%84%E9%80%A0%E7%9F%A9%E5%BD%A2/","title":"Leetcode 492. 构造矩形"},{"content":"链接： https://leetcode-cn.com/problems/majority-element-ii/\n难度： 中等\n题目描述 给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。\n示例 1： 输入： [3,2,3]\n输出： [3]\n示例 2： 输入： nums = [1]\n输出： [1]\n示例 3： 输入： [1,1,1,3,3,2,2,2]\n输出： [1,2]\n提示： 1 \u0026lt;= nums.length \u0026lt;= 5 * 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 解题思路 哈希 使用哈希表统计每个数字出现的数量，当其首次超过 ⌊ n/3 ⌋ 次时候，加入到结果集合中。\nfunc majorityElement(nums []int) []int { major := make([]int, 0, 2) minCnt := len(nums)/3 + 1 cnt := make(map[int]int) for _, num := range nums { cnt[num]++ if cnt[num] == minCnt { major = append(major, num) } } return major } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2021-10-22T10:50:56+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-229.-%E6%B1%82%E4%BC%97%E6%95%B0-ii/","title":"Leetcode 229. 求众数 II"},{"content":"链接： https://leetcode-cn.com/problems/plus-one/\n难度： 简单\n题目描述 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。\n最高位数字存放在数组的首位， 数组中每个元素只存储 单个 数字。\n你可以假设除了整数 0 之外，这个整数不会以零开头。\n示例 1： 输入： digits = [1,2,3]\n输出： [1,2,4]\n解释： 输入数组表示数字 123。\n示例 2： 输入： digits = [4,3,2,1]\n输出： [4,3,2,2]\n解释： 输入数组表示数字 4321。\n示例 3： 输入： digits = [0]\n输出： [1]\n提示： 1 \u0026lt;= digits.length \u0026lt;= 100 0 \u0026lt;= digits[i] \u0026lt;= 9 解题思路 模拟 从尾部开始计算，使用进位标识 c 记录是否需要进位，初始 c 为 1。\n当当前数字加上进位 c 后，若为 10 则当前位置为 0，c 为 1，继续运算； 否则，c 置为 0，求解结束，直接返回。 正常循环结束时，说明最高位还有进位，新开数组首个元素置为 1，其余元素拷贝过去返回。\nfunc plusOne(digits []int) []int { c := 1 for i := len(digits) - 1; i \u0026gt;= 0; i-- { digits[i] += c if digits[i] == 10 { digits[i] = 0 } else { return digits } } ans := make([]int, 0, len(digits)+1) ans = append(ans, 1) return append(ans, digits...) } 复杂度 时间复杂度：$ O(N), N = len(digits) $ 空间复杂度：$ O(1) $ ","date":"2021-10-21T11:53:08+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-66.-%E5%8A%A0%E4%B8%80/","title":"Leetcode 66. 加一"},{"content":"链接： https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/\n难度： 简单\n题目描述 给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。\n示例 1： 输入： nums = [1,2,3]\n输出： 3\n解释：\n只需要3次操作（注意每次操作会增加两个元素的值）：\n[1,2,3] =\u0026gt; [2,3,3] =\u0026gt; [3,4,3] =\u0026gt; [4,4,4]\n示例 2： 输入： nums = [1,1,1]\n输出： 0\n提示： n == nums.length 1 \u0026lt;= nums.length \u0026lt;= 105 -109 \u0026lt;= nums[i] \u0026lt;= 109 答案保证符合 32-bit 整数 解题思路 数学 因为最终目标是使得所有元素数字相等，则每次操作使 n - 1 个元素增加 1，可以变换为操作使其中一个元素减 1，则只需求解将所有元素变为最小值的操作步骤次数。\nfunc minMoves(nums []int) int { ans := 0 min := math.MaxInt32 for i, num := range nums { if min \u0026gt; num { ans += (min - num) * i // 最小值变化，差值补充 min = num } ans += num - min } return ans } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-10-20T10:14:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-453.-%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9B%B8%E7%AD%89/","title":"Leetcode 453. 最小操作次数使数组元素相等"},{"content":"链接： https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/\n难度： 中等\n题目描述 请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。\n实现词典类 WordDictionary ：\nWordDictionary() 初始化词典对象 void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配 bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回 false 。word 中可能包含一些 '.' ，每个 . 都可以表示任何一个字母。 示例： 输入：\n[\u0026ldquo;WordDictionary\u0026rdquo;,\u0026ldquo;addWord\u0026rdquo;,\u0026ldquo;addWord\u0026rdquo;,\u0026ldquo;addWord\u0026rdquo;,\u0026ldquo;search\u0026rdquo;,\u0026ldquo;search\u0026rdquo;,\u0026ldquo;search\u0026rdquo;,\u0026ldquo;search\u0026rdquo;]\n[[],[\u0026ldquo;bad\u0026rdquo;],[\u0026ldquo;dad\u0026rdquo;],[\u0026ldquo;mad\u0026rdquo;],[\u0026ldquo;pad\u0026rdquo;],[\u0026ldquo;bad\u0026rdquo;],[\u0026quot;.ad\u0026quot;],[\u0026ldquo;b..\u0026rdquo;]]\n输出：\n[null,null,null,null,false,true,true,true]\n解释：\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\u0026ldquo;bad\u0026rdquo;);\nwordDictionary.addWord(\u0026ldquo;dad\u0026rdquo;);\nwordDictionary.addWord(\u0026ldquo;mad\u0026rdquo;);\nwordDictionary.search(\u0026ldquo;pad\u0026rdquo;); // return False\nwordDictionary.search(\u0026ldquo;bad\u0026rdquo;); // return True\nwordDictionary.search(\u0026quot;.ad\u0026quot;); // return True\nwordDictionary.search(\u0026ldquo;b..\u0026rdquo;); // return True\n提示： 1 \u0026lt;= word.length \u0026lt;= 500 addWord 中的 word 由小写英文字母组成 search 中的 word 由 '.' 或小写英文字母组成 最多调用 50000 次 addWord 和 search 解题思路 Trie树 使用 Trie树 来存储单词。\n当查找的时候，因为存在的 '.' 可以匹配任意字符，故所有的情况都需要判断。\ntype Node struct { end bool char map[byte]*Node } type WordDictionary struct { head *Node } func Constructor() WordDictionary { return WordDictionary{ head: \u0026amp;Node{ end: false, char: make(map[byte]*Node), }, } } func (this *WordDictionary) AddWord(word string) { node := this.head for i := range word { if _, ok := node.char[word[i]]; !ok { node.char[word[i]] = \u0026amp;Node{ end: false, char: make(map[byte]*Node), } } node = node.char[word[i]] } node.end = true } func (this *WordDictionary) Search(word string) bool { var search func(node *Node, suffix []byte) bool search = func(node *Node, suffix []byte) bool { for i, c := range suffix { if c == \u0026#39;.\u0026#39; { // 尝试递归匹配所有项 for _, n := range node.char { if search(n, suffix[i+1:]) { return true } } return false } // 继续匹配下一项 if nextNode, ok := node.char[c]; !ok { return false } else { node = nextNode } } return node.end } return search(this.head, []byte(word)) } 复杂度 时间复杂度： AddWord：$ O(N), N = len(word) $ Search：$ O(\\Sigma^N), \\Sigma表示字符集字符总数量 $ 空间复杂度：$ O(\\Sigma*\\sum{len(word_i)}) $ ","date":"2021-10-19T12:58:00+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-211.-%E6%B7%BB%E5%8A%A0%E4%B8%8E%E6%90%9C%E7%B4%A2%E5%8D%95%E8%AF%8D-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/","title":"Leetcode 211. 添加与搜索单词 - 数据结构设计"},{"content":"链接： https://leetcode-cn.com/problems/number-complement/\n难度： 简单\n题目描述 给你一个 正 整数 num ，输出它的补数。补数是对该数的二进制表示取反。\n示例 1： 输入： num = 5\n输出： 2\n解释： 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。\n示例 2： 输入： num = 1\n输出： 0\n解释： 1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。\n提示： 给定的整数 num 保证在 32 位带符号整数的范围内。 num \u0026gt;= 1 你可以假定二进制数不包含前导零位。 解题思路 位运算 从二进制的最后一位开始，直到首个 1 为止，当遇到 0 时，将结果对应位置为 1。\nfunc findComplement(num int) int { ans := 0 for bit := 1; bit \u0026lt;= num; bit \u0026lt;\u0026lt;= 1 { if num \u0026amp; bit == 0 { ans |= bit } } return ans } 复杂度 时间复杂度：$ O(\\log{num}) $ 空间复杂度：$ O(1) $ ","date":"2021-10-18T09:44:53+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-476.-%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/","title":"Leetcode 476. 数字的补数"},{"content":"链接： https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/\n难度： 中等\n题目描述 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。\n示例 1： 输入： root = [3,1,4,null,2], k = 1\n输出： 1\n示例 2： 输入： root = [5,3,6,2,4,null,null,1], k = 3\n输出： 3\n提示： 树中的节点数为 n 。 1 \u0026lt;= k \u0026lt;= n \u0026lt;= 104 0 \u0026lt;= Node.val \u0026lt;= 104 进阶： 如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？\n解题思路 中序遍历 中序遍历，每遇到一个结点， k = k - 1，当 k 减为 0 时，返回当前结点的值。\nfunc kthSmallest(root *TreeNode, k int) int { var dfs func(node *TreeNode) int dfs = func(node *TreeNode) int { if node == nil { return -1 } ans := dfs(node.Left) if ans != -1 { return ans } k-- if k == 0 { return node.Val } return dfs(node.Right) } return dfs(root) } 复杂度 时间复杂度：$ O(\\log{N} + k), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ 哈希 + 中序遍历 遍历二叉树，使用哈希表记录每个结点左子树中的结点数量，这样每次查找时就可以判断从哪个子树中去寻找了，时间复杂度降低。从根结点开始遍历：\n若当前结点左子树结点数量 \u0026gt; k-1，则从左子树中寻找第 k 小结点； 若当前结点左子树结点数量 = k-1，则当前结点即为第 k 小结点，返回； 若当前结点左子树结点数量 cnt \u0026lt; k-1，则从右子树中寻找第 k - cnt - 1 小结点； type Tree struct { root *TreeNode leftCnt map[*TreeNode]int } func (this *Tree) build(node *TreeNode) int { if node == nil { return 0 } l := this.build(node.Left) this.leftCnt[node] = l r := this.build(node.Right) return l + r + 1 } func Constractor(root *TreeNode) *Tree { tree := \u0026amp;Tree{ root: root, leftCnt: make(map[*TreeNode]int), } tree.build(root) return tree } func (this *Tree) kthSmallest(k int) int { for node := this.root; node != nil; { switch { case this.leftCnt[node] \u0026gt; k-1: node = node.Left case this.leftCnt[node] == k-1: return node.Val default: k -= this.leftCnt[node] + 1 node = node.Right } } return -1 } func kthSmallest(root *TreeNode, k int) int { return Constractor(root).kthSmallest(k) } 复杂度 时间复杂度： build：$ O(N), N = size(Tree) $ kthSmallest：$ O(\\log{N}) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-10-17T10:43:50+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-230.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/","title":"Leetcode 230. 二叉搜索树中第K小的元素"},{"content":"链接： https://leetcode-cn.com/problems/expression-add-operators/\n难度： 中等\n题目描述 给定一个仅包含数字 0-9 的字符串 num 和一个目标值整数 target ，在 num 的数字之间添加 二元 运算符（不是一元）+、- 或 * ，返回所有能够得到目标值的表达式。\n示例 1： 输入: num = \u0026ldquo;123\u0026rdquo;, target = 6\n输出: [\u0026ldquo;1+2+3\u0026rdquo;, \u0026ldquo;123\u0026rdquo;]\n示例 2： 输入: num = \u0026ldquo;232\u0026rdquo;, target = 8\n输出: [\u0026ldquo;23+2\u0026rdquo;, \u0026ldquo;2+32\u0026rdquo;]\n示例 3： 输入: num = \u0026ldquo;105\u0026rdquo;, target = 5\n输出: [\u0026ldquo;1*0+5\u0026rdquo;,\u0026ldquo;10-5\u0026rdquo;]\n示例 4： 输入: num = \u0026ldquo;00\u0026rdquo;, target = 0\n输出: [\u0026ldquo;0+0\u0026rdquo;, \u0026ldquo;0-0\u0026rdquo;, \u0026ldquo;0*0\u0026rdquo;]\n示例 5： 输入: num = \u0026ldquo;3456237490\u0026rdquo;, target = 9191\n输出: []\n提示： 1 \u0026lt;= num.length \u0026lt;= 10 num 仅含数字 -231 \u0026lt;= target \u0026lt;= 231 - 1 解题思路 回溯 使用回溯法，在所有可能的地方添加运算符号。\n由于乘法的优先级比较高，在传递时需要记录最后几项的积 product，以及除该积外剩余部分的结果 result。\n每次回溯时，向后遍历产生多个项，注意当出现前导 0 时，表达式无效，直接回溯。对于每一项 item ，采取如下操作：\n若表达式为空，则将该项加入表达式中，将 product 置为该项； 表达式非空，需要加入对应的运算符，循环尝试： 当运算符为 '*' 时，将 item 乘到 product 中； 当运算符为 '+' 时，将 product 加到 result 中，product 变为 item； 当运算符为 '-' 时，将 product 加到 result 中，product 变为 - item。 然后继续递归的寻找下一项并按上述处理，直到遍历到 num 结尾，此时需要判定表达式的有效性：当 result + product = target 时，该表达式有效，将其加入到结果中。\nfunc addOperators(num string, target int) []string { ops := []byte(\u0026#34;+-*\u0026#34;) expressions := make([]string, 0, 1) var backtracking func(idx int, expression []byte, result int, product int) backtracking = func(idx int, expression []byte, result int, product int) { // 结尾 if idx == len(num) { // 有效性判定 if result+product == target { expressions = append(expressions, string(expression)) } return } // 生成当前项，前导 0 判定 for end := idx + 1; end \u0026lt;= len(num) \u0026amp;\u0026amp; (end-idx \u0026lt;= 1 || num[idx] != \u0026#39;0\u0026#39;); end++ { t, _ := strconv.ParseInt(num[idx:end], 10, 64) elem := int(t) // 首项判定 if len(expression) == 0 { expression = append(expression, num[idx:end]...) backtracking(end, expression, 0, elem) expression = expression[:0] // 回溯 continue } // 三种运算符 for _, op := range ops { expression = append(expression, op) expression = append(expression, num[idx:end]...) switch op { case \u0026#39;*\u0026#39;: backtracking(end, expression, result, product*elem) case \u0026#39;-\u0026#39;: backtracking(end, expression, result+product, -elem) case \u0026#39;+\u0026#39;: backtracking(end, expression, result+product, elem) } expression = expression[:len(expression)-1-end+idx] // 回溯 } } } backtracking(0, make([]byte, 0, len(num)\u0026lt;\u0026lt;2), 0, 0) return expressions } 复杂度 时间复杂度：$ O(4^N), N = len(num) $ 空间复杂度：$ O(N) $ ","date":"2021-10-16T12:14:42+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-282.-%E7%BB%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B7%BB%E5%8A%A0%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"Leetcode 282. 给表达式添加运算符"},{"content":"链接： https://leetcode-cn.com/problems/count-and-say/\n难度： 中等\n题目描述 给定一个正整数 n ，输出外观数列的第 n 项。\n「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。\n你可以将其视作是由递归公式定义的数字字符串序列：\ncountAndSay(1) = \u0026quot;1\u0026quot; countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。 前五项如下： 1. 1 2. 11 3. 21 4. 1211 5. 111221 第一项是数字 1 描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 \u0026#34;11\u0026#34; 描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 \u0026#34;21\u0026#34; 描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 \u0026#34;1211\u0026#34; 描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 \u0026#34;111221\u0026#34; 要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。\n例如，数字字符串 \u0026quot;3322251\u0026quot; 的描述如下图： 示例 1： 输入： n = 1\n输出： \u0026ldquo;1\u0026rdquo;\n解释： 这是一个基本样例。\n示例 2： 输入： n = 4\n输出： \u0026ldquo;1211\u0026rdquo;\n解释：\ncountAndSay(1) = \u0026ldquo;1\u0026rdquo;\ncountAndSay(2) = 读 \u0026ldquo;1\u0026rdquo; = 一 个 1 = \u0026ldquo;11\u0026rdquo;\ncountAndSay(3) = 读 \u0026ldquo;11\u0026rdquo; = 二 个 1 = \u0026ldquo;21\u0026rdquo;\ncountAndSay(4) = 读 \u0026ldquo;21\u0026rdquo; = 一 个 2 + 一 个 1 = \u0026ldquo;12\u0026rdquo; + \u0026ldquo;11\u0026rdquo; = \u0026ldquo;1211\u0026rdquo;\n提示： 1 \u0026lt;= n \u0026lt;= 30 解题思路 模拟 模拟题设，从第 1 项开始，依次生成直到第 n 项。\nfunc countAndSay(n int) string { item := []byte{\u0026#39;1\u0026#39;} for i := 2; i \u0026lt;= n; i++ { t := make([]byte, 0, len(item)\u0026lt;\u0026lt;1) char := item[0] cnt := 1 for j := 1; j \u0026lt; len(item); j++ { if item[j] != char { t = append(t, strconv.FormatInt(int64(cnt), 10)...) t = append(t, char) char = item[j] cnt = 1 continue } cnt++ } t = append(t, strconv.FormatInt(int64(cnt), 10)...) t = append(t, char) item = t } return string(item) } 复杂度 时间复杂度：$ O(n*\\overline{len(item)}) $ 空间复杂度：$ O(max(item)) $ ","date":"2021-10-15T14:55:19+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-38.-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/","title":"Leetcode 38. 外观数列"},{"content":"链接： https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\n难度： 简单\n题目描述 给定一个二叉树的根节点 root ，返回它的 中序 遍历。\n示例 1： 输入： root = [1,null,2,3]\n输出： [1,3,2]\n示例 2： 输入： root = []\n输出： []\n示例 3： 输入： root = [1]\n输出： [1]\n示例 4： 输入： root = [1,2]\n输出： [2,1]\n示例 5： 输入： root = [1,null,2]\n输出： [1,2]\n提示： 树中节点数目在范围 [0, 100] 内 100 \u0026lt;= Node.val \u0026lt;= 100 **进阶: ** 递归算法很简单，你可以通过迭代算法完成吗？\n解题思路 递归 func inorderTraversal(root *TreeNode) []int { if root == nil { return nil } ans := inorderTraversal(root.Left) ans = append(ans, root.Val) return append(ans, inorderTraversal(root.Right)...) } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ 迭代 func inorderTraversal(root *TreeNode) []int { ans := make([]int, 0, 101) stack := make([]*TreeNode, 0, 100) stack = append(stack, \u0026amp;TreeNode{ Right: root, }) for len(stack) \u0026gt; 0 { top := stack[len(stack)-1] stack = stack[:len(stack)-1] ans = append(ans, top.Val) for node := top.Right; node != nil; node = node.Left { stack = append(stack, node) } } return ans[1:] } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-10-14T14:53:52+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-94.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","title":"Leetcode 94. 二叉树的中序遍历"},{"content":"链接： https://leetcode-cn.com/problems/maximum-subarray/\n难度： 简单\n题目描述 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n示例 1： 输入： nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出： 6\n解释： 连续子数组 [4,-1,2,1] 的和最大，为 6 。\n示例 2： 输入： nums = [1]\n输出： 1\n示例 3： 输入： nums = [0]\n输出： 0\n示例 4： 输入： nums = [-1]\n输出： -1\n示例 5： 输入： nums = [-100000]\n输出： -100000\n提示： 1 \u0026lt;= nums.length \u0026lt;= 105 -104 \u0026lt;= nums[i] \u0026lt;= 104 进阶： 如果你已经实现复杂度为 $O(n)$ 的解法，尝试使用更为精妙的 分治法 求解。\n解题思路 动态规划 由于题设要求是连续子数组，使用 dp[i] 记录以下标 i 为连续子数组末尾元素的最大值，则：\ndp[0] = nums[1] dp[i] = make(nums[i], dp[i-1]+nums[i]) 在遍历的过程中找出最大值即可。\n由于状态转移时，其仅依赖上一个值，使用滚动变量降低空间复杂度。\nfunc maxSubArray(nums []int) int { dp := nums[0] max := dp for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026lt; dp+nums[i] { dp += nums[i] } else { dp = nums[i] } if max \u0026lt; dp { max = dp } } return max } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ 分治 对于一个区间，最长连续字序列，要么在左半区间，要么在右半区间，要么跨越左右区间，。\n采用分治法，每个区间维护四个变量，区间内的最大值 max，以最左侧元素开始的连续子数组的最大值 lMax，以最右侧元素开始的连续子数组的最大值 rMax，整个区间的最大值 sum， 每次求得左右两个区间的结果，当前区间的四个变量即为:\nmax = max(左区间max, 右区间max, 左区间rMax + 右区间lMax) lMax = max(左区间lMax, 左区间sum + 右区间lMax) rMax = max(左区间lMax, 左区间rMax + 右区sum) sum = 左区间sum + 右区间sum func maxSubArray(nums []int) int { getMax := func(nums ...int) int { max := nums[0] for i := 1; i \u0026lt; len(nums); i++ { if max \u0026lt; nums[i] { max = nums[i] } } return max } var divideAndConquer func(nums []int) (max, lMax, rMax, sum int) divideAndConquer = func(nums []int) (max, lMax, rMax, sum int) { if len(nums) == 1 { return nums[0], nums[0], nums[0], nums[0] } leftMax, leftLMax, leftRMax, leftSum := divideAndConquer(nums[:len(nums)/2]) rightMax, rightLMax, rightRMax, rightSum := divideAndConquer(nums[len(nums)/2:]) max = getMax(leftMax, rightMax, leftRMax+rightLMax) lMax = getMax(leftLMax, leftSum+rightLMax) rMax = getMax(rightRMax, rightSum+leftRMax) sum = leftSum + rightSum return } max, _, _, _ := divideAndConquer(nums) return max } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-10-14T13:28:41+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-53.-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/","title":"Leetcode 53. 最大子序和"},{"content":"链接： https://leetcode-cn.com/problems/palindrome-linked-list/\n难度： 简单\n题目描述 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。\n示例 1： 输入： head = [1,2,2,1]\n输出： true\n示例 2： 输入： head = [1,2]\n输出： false\n提示： 链表中节点数目在范围 [1, 105] 内 0 \u0026lt;= Node.val \u0026lt;= 9 进阶： 你能否用 $O(n)$ 时间复杂度和 $O(1)$ 空间复杂度解决此题？\n解题思路 顺序表 将链表中的元素记录到数组中，判定其是否回文。\nfunc isPalindrome(head *ListNode) bool { str := make([]int, 0, 1e5) for ; head != nil; head = head.Next { str = append(str, head.Val) } for i := len(str)/2 - 1; i \u0026gt;= 0; i-- { if str[i] != str[len(str)-1-i] { return false } } return true } 复杂度 时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(N) $ 快慢指针 + 反转链表 使用快慢指针找到链表中间的结点，将其后的链表反转，比较两个链表的元素值是否相同。\nfunc isPalindrome(head *ListNode) bool { // 寻找中间结点 head = \u0026amp;ListNode{ Next: head, } slow := head for fast := head; fast != nil \u0026amp;\u0026amp; fast.Next != nil; slow, fast = slow.Next, fast.Next.Next { } // 反转 last := (*ListNode)(nil) for cur := slow.Next; cur != nil; { cur.Next, cur, last = last, cur.Next, cur } // 比较 head = head.Next for ; head != nil \u0026amp;\u0026amp; last != nil; head, last = head.Next, last.Next { if head.Val != last.Val { return false } } return true } 复杂度 时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(1) $ ","date":"2021-10-14T12:56:45+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-234.-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","title":"Leetcode 234. 回文链表"},{"content":"链接： https://leetcode-cn.com/problems/B1IidL/\n难度： 简单\n题目描述 符合下列属性的数组 arr 称为 山峰数组（山脉数组） ：\narr.length \u0026gt;= 3 存在 i（0 \u0026lt; i \u0026lt; arr.length - 1）使得： arr[0] \u0026lt; arr[1] \u0026lt; ... arr[i-1] \u0026lt; arr[i] arr[i] \u0026gt; arr[i+1] \u0026gt; ... \u0026gt; arr[arr.length - 1] 给定由整数组成的山峰数组 arr ，返回任何满足 arr[0] \u0026lt; arr[1] \u0026lt; ... arr[i - 1] \u0026lt; arr[i] \u0026gt; arr[i + 1] \u0026gt; ... \u0026gt; arr[arr.length - 1] 的下标 i ，即山峰顶部。\n示例 1： 输入： arr = [0,1,0]\n输出： 1\n示例 2： 输入： arr = [1,3,5,4,2]\n输出： 2\n示例 3： 输入： arr = [0,10,5,2]\n输出： 1\n示例 4： 输入： arr = [3,4,5,1]\n输出： 2\n示例 5： 输入： arr = [24,69,100,99,79,78,67,36,26,19]\n输出： 2\n提示 3 \u0026lt;= arr.length \u0026lt;= 104 0 \u0026lt;= arr[i] \u0026lt;= 106 题目数据保证 arr 是一个山脉数组 解题思路 暴力求解 遍历整个数组，找到最大值，返回其下标。\nfunc peakIndexInMountainArray(arr []int) int { idx := 0 for i, num := range arr { if arr[idx] \u0026lt; num { idx = i } } return idx } 复杂度 时间复杂度：$ O(N), N = len(arr) $ 空间复杂度：$ O(1) $ 二分查找 每次获取区间中点 mid，将其与后一个比较：\n若 mid 大于 后一个元素，则在左半区间查找； 否则，在右半区间查找。 func peakIndexInMountainArray(arr []int) int { l, r := 0, len(arr) for l != r { mid := (l+r)/2 if arr[mid] \u0026gt; arr[mid+1] { r = mid } else { l = mid + 1 } } return l } 复杂度 时间复杂度：$ O(\\log{N}), N = len(arr) $ 空间复杂度：$ O(1) $ ","date":"2021-10-14T10:43:54+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-ii-069.-%E5%B1%B1%E5%B3%B0%E6%95%B0%E7%BB%84%E7%9A%84%E9%A1%B6%E9%83%A8/","title":"剑指 Offer II 069. 山峰数组的顶部"},{"content":"链接： https://leetcode-cn.com/problems/fizz-buzz/\n难度： 简单\n题目描述 写一个程序，输出从 1 到 n 数字的字符串表示。\n如果 n 是3的倍数，输出“Fizz”； 如果 n 是5的倍数，输出“Buzz”； 如果 n 同时是3和5的倍数，输出 “FizzBuzz”。 示例： n = 15, 返回: [ \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;Fizz\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;Buzz\u0026#34;, \u0026#34;Fizz\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;8\u0026#34;, \u0026#34;Fizz\u0026#34;, \u0026#34;Buzz\u0026#34;, \u0026#34;11\u0026#34;, \u0026#34;Fizz\u0026#34;, \u0026#34;13\u0026#34;, \u0026#34;14\u0026#34;, \u0026#34;FizzBuzz\u0026#34; ] 解题思路 模拟 从 1 到 n 对每个数进行判定，将其转换为正确的字符串添加进结果中。\nfunc fizzBuzz(n int) []string { ans := make([]string, 0, n) for i := 1; i \u0026lt;= n; i++ { if i % 3 == 0 \u0026amp;\u0026amp; i % 5 == 0 { ans = append(ans, \u0026#34;FizzBuzz\u0026#34;) } else if i % 3 == 0 { ans = append(ans, \u0026#34;Fizz\u0026#34;) } else if i % 5 == 0 { ans = append(ans, \u0026#34;Buzz\u0026#34;) } else { ans = append(ans, strconv.FormatInt(int64(i), 10)) } } return ans } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ (1) $ ","date":"2021-10-13T10:46:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-412.-fizz-buzz/","title":"Leetcode 412. Fizz Buzz"},{"content":"链接： https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/\n难度： 困难\n题目描述 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。\n路径和 是路径中各节点值的总和。\n给你一个二叉树的根节点 root ，返回其 最大路径和 。\n示例 1： 输入： root = [1,2,3]\n输出： 6\n解释： 最优路径是 2 -\u0026gt; 1 -\u0026gt; 3 ，路径和为 2 + 1 + 3 = 6\n示例 2： 输入： root = [-10,9,20,null,null,15,7]\n输出： 42\n解释： 最优路径是 15 -\u0026gt; 20 -\u0026gt; 7 ，路径和为 15 + 20 + 7 = 42\n提示： 树中节点数目范围是 [1, 3 * 104] -1000 \u0026lt;= Node.val \u0026lt;= 1000 解题思路 递归 + 前缀和 最大路径和或者跨越当前结点，或者在左子树，或者在右子树。\n每次获得从根节点到左右子树的最大前缀和，以及左子树和右子树的最大路径和，然后将三者做比较，返回最大路径和以及最大前缀和。\nfunc maxPathSum(root *TreeNode) int { var dfs func(node *TreeNode, prefixSum int) (maxPath, maxPrefixSum int) dfs = func(node *TreeNode, prefixSum int) (maxPath, maxPrefixSum int) { if node == nil { return -math.MaxInt32, prefixSum } // 子树的最大前缀和、最大路径和 maxPath, maxPrefixSum = dfs(node.Left, prefixSum+node.Val) rMaxPath, rMaxPrefixSum := dfs(node.Right, prefixSum+node.Val) // 当前树的大路径和 curMaxPath := maxPrefixSum + rMaxPrefixSum - (prefixSum \u0026lt;\u0026lt; 1) - node.Val if maxPath \u0026lt; curMaxPath { maxPath = curMaxPath } if maxPath \u0026lt; rMaxPath { maxPath = rMaxPath } // 最大前缀和 if maxPrefixSum \u0026lt; rMaxPrefixSum { maxPrefixSum = rMaxPrefixSum } if maxPrefixSum \u0026lt; prefixSum { maxPrefixSum = prefixSum } return } maxPath, _ := dfs(root, 0) return maxPath } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-10-12T18:59:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-124.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/","title":"Leetcode 124. 二叉树中的最大路径和"},{"content":"链接： https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/\n难度： 中等\n题目描述 给你二叉树的根结点 root ，请你将它展开为一个单链表：\n展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 展开后的单链表应该与二叉树 先序遍历 顺序相同。 示例 1： 输入： root = [1,2,5,3,4,null,6]\n输出： [1,null,2,null,3,null,4,null,5,null,6]\n示例 2： 输入： root = []\n输出： []\n示例 3： 输入： root = [0]\n输出： [0]\n提示： 树中结点数在范围 [0, 2000] 内 -100 \u0026lt;= Node.val \u0026lt;= 100 进阶： 你可以使用原地算法（$O(1)$ 额外空间）展开这棵树吗？\n解题思路 先序遍历 使用一个记录目前展开链表的尾部，先序遍历二叉树，每遇到一个新结点，将其加入到尾部。\nfunc flatten(root *TreeNode) { head := new(TreeNode) tail := head var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } left := node.Left right := node.Right tail.Right = node tail = tail.Right tail.Left = nil dfs(left) dfs(right) } dfs(root) } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-10-12T18:29:58+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-114.-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/","title":"Leetcode 114. 二叉树展开为链表"},{"content":"链接： https://leetcode-cn.com/problems/reverse-linked-list-ii/\n难度： 中等\n题目描述 给你单链表的头指针 head 和两个整数 left 和 right ，其中 left \u0026lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。\n示例 1： 输入： head = [1,2,3,4,5], left = 2, right = 4\n输出： [1,4,3,2,5]\n示例 2： 输入： head = [5], left = 1, right = 1\n输出： [5]\n提示： 链表中节点数目为 n 1 \u0026lt;= n \u0026lt;= 500 -500 \u0026lt;= Node.val \u0026lt;= 500 1 \u0026lt;= left \u0026lt;= right \u0026lt;= n 进阶： 你可以使用一趟扫描完成反转吗？\n解题思路 就地反转 使用虚拟的头结点，遍历找到待反转区域的上一个结点 prev，反转该区域，将 prev.Next 指向反转后的头部， 和尾部区域，\nfunc reverseBetween(head *ListNode, left int, right int) *ListNode { newHead := \u0026amp;ListNode{ Next: head, } // 跳过头 prev := newHead for i := 1; i \u0026lt; left; i++ { prev = prev.Next } // 反转中间 tail := (*ListNode)(nil) node := prev.Next for i := left; i \u0026lt;= right; i++ { node.Next, node, tail = tail, node.Next, node } // 连接头尾 prev.Next.Next = node prev.Next = tail return newHead.Next } 复杂度 时间复杂度：$ O(right) $ 空间复杂度：$ O(1) $ ","date":"2021-10-12T16:28:21+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-92.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-ii/","title":"Leetcode 92. 反转链表 II"},{"content":"链接： https://leetcode-cn.com/problems/lru-cache/\n难度： 中等\n题目描述 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。\n实现 LRUCache 类：\nLRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶： 你是否可以在 O(1) 时间复杂度内完成这两种操作？\n示例： 输入:\n[\u0026ldquo;LRUCache\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;get\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;get\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;get\u0026rdquo;, \u0026ldquo;get\u0026rdquo;, \u0026ldquo;get\u0026rdquo;]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\n输出:\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n解释:\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // 缓存是 {1=1}\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\nlRUCache.get(1); // 返回 1\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\nlRUCache.get(2); // 返回 -1 (未找到)\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\nlRUCache.get(1); // 返回 -1 (未找到)\nlRUCache.get(3); // 返回 3\nlRUCache.get(4); // 返回 4\n提示： 1 \u0026lt;= capacity \u0026lt;= 3000 0 \u0026lt;= key \u0026lt;= 10000 0 \u0026lt;= value \u0026lt;= 105 最多调用 2 * 105 次 get 和 put 解题思路 双向链表 + 哈希 使用一个双向链表和哈希表，哈希表负责 $ O(1) $ 的查找某个节点，链表按照访问时间组织节点，最近使用过在头部，未使用过的在尾部。\ntype pair struct { key int val int } type LRUCache struct { hash map[int]*list.Element deque *list.List capacity int } func Constructor(capacity int) LRUCache { return LRUCache{ hash: make(map[int]*list.Element), deque: list.New(), capacity: capacity, } } func (this *LRUCache) Get(key int) int { elem, ok := this.hash[key] if !ok { return -1 } this.deque.MoveToFront(elem) return elem.Value.(*pair).val } func (this *LRUCache) Put(key int, value int) { if elem, ok := this.hash[key]; ok { elem.Value.(*pair).val = value this.deque.MoveToFront(elem) return } if this.deque.Len() == this.capacity { delete(this.hash, this.deque.Remove(this.deque.Back()).(*pair).key) } this.hash[key] = this.deque.PushFront(\u0026amp;pair{ key: key, val: value, }) } 复杂度 时间复杂度： Get：$ O(1) $ Put：$ O(1) $ 空间复杂度：$ O(capacity) $ ","date":"2021-10-12T14:06:10+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-146.-lru-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","title":"Leetcode 146. LRU 缓存机制"},{"content":"链接： https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/\n难度： 中等\n题目描述 给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。\n设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。\n注意： 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。\n示例 1： 输入: prices = [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。\n示例 2： 输入: prices = [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。\n示例 3： 输入: prices = [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n提示： 1 \u0026lt;= prices.length \u0026lt;= 3 * 104 0 \u0026lt;= prices[i] \u0026lt;= 104 解题思路 贪心 股票的走势有上升区间和下降区间，每次均在上升区间的底部买入，顶部卖出，即可获得最大利润，即将所有的上升区间差值求和即可。\nfunc maxProfit(prices []int) int { profit := 0 for i := 1; i \u0026lt; len(prices); i++ { if prices[i-1] \u0026lt; prices[i] { profit += prices[i] - prices[i-1] } } return profit } 复杂度 时间复杂度：$ O(N), N = len(prices) $ 空间复杂度：$ O(1) $ ","date":"2021-10-12T13:45:49+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-122.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii/","title":"Leetcode 122. 买卖股票的最佳时机 II"},{"content":"链接： https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\n难度： 简单\n题目描述 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n示例 1： 输入： [7,1,5,3,6,4]\n输出： 5\n解释： 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n示例 2： 输入： prices = [7,6,4,3,1]\n输出： 0\n解释： 在这种情况下, 没有交易完成, 所以最大利润为 0。\n提示： 1 \u0026lt;= prices.length \u0026lt;= 105 0 \u0026lt;= prices[i] \u0026lt;= 104 解题思路 遍历 使用 min 记录到目前为止股票的最小值，每次使用当前股票价格减去 min ，更新最大利润。\nfunc maxProfit(prices []int) int { profit := 0 min := prices[0] for i := 1; i \u0026lt; len(prices); i++ { if min \u0026gt; prices[i] { min = prices[i] } if profit \u0026lt; prices[i]-min { profit = prices[i] - min } } return profit } 复杂度 时间复杂度：$ O(N), N = len(prices) $ 空间复杂度：$ O(1) $ ","date":"2021-10-12T13:34:34+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-121.-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/","title":"Leetcode 121. 买卖股票的最佳时机"},{"content":"链接： https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/\n难度： 中等\n题目描述 给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。\n例如： 给定二叉树 [3,9,20,null,null,15,7],\n3 / \\ 9 20 / \\ 15 7 返回锯齿形层序遍历如下：\n[ [3], [20,9], [15,7] ] 解题思路 层序遍历 使用一个双端队列记录遍历到的结点，初始时根结点入队。\n奇偶分离，偶数层从头至尾遍历完当前整层的所有元素，子结点先左后右从队尾入队；奇数层从尾至头遍历整层所有元素，子结点先右后左从队头入队。\n每次遍历到的结点值加入到结果队列中，直至队列为空为止。\nfunc zigzagLevelOrder(root *TreeNode) [][]int { if root == nil { return make([][]int, 0) } ans := make([][]int, 0, 1) deque := list.New() deque.PushBack(root) for deque.Len() \u0026gt; 0 { t := make([]int, 0, deque.Len()) for i := deque.Len(); i \u0026gt; 0; i-- { node := deque.Remove(deque.Front()).(*TreeNode) t = append(t, node.Val) if node.Left != nil { deque.PushBack(node.Left) } if node.Right != nil { deque.PushBack(node.Right) } } ans = append(ans, t) if deque.Len() == 0 { break } t = make([]int, 0, deque.Len()) for i := deque.Len(); i \u0026gt; 0; i-- { node := deque.Remove(deque.Back()).(*TreeNode) t = append(t, node.Val) if node.Right != nil { deque.PushFront(node.Right) } if node.Left != nil { deque.PushFront(node.Left) } } ans = append(ans, t) } return ans } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(N) $ ","date":"2021-10-12T13:08:58+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-103.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","title":"Leetcode 103. 二叉树的锯齿形层序遍历"},{"content":"链接： https://leetcode-cn.com/problems/divide-two-integers/\n难度： 中等\n题目描述 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。\n返回被除数 dividend 除以除数 divisor 得到的商。\n整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2\n示例1： 输入: dividend = 10, divisor = 3\n输出: 3\n解释: 10/3 = truncate(3.33333..) = truncate(3) = 3\n示例2： 输入: dividend = 7, divisor = -3\n输出: -2\n解释: 7/-3 = truncate(-2.33333..) = -2\n提示： 被除数和除数均为 32 位有符号整数。 除数不为 0。 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1 解题思路 减法模拟 + 位运算 使用多次的减法来计算，由于负数的取值范围更大，将正数变换为负数求解。\n首先初始化除数 divisor ，使用位运算，使其在不越界的情况下，乘以2的整数方次倍达到最大值，同时记录原除数 b 和倍数 quotient，也即可以累加进结果的商。\n然后求解，当 a ≤ divisor 时，用 a 减去 divisor，结果加上对应的除数倍数 quotient；每次循环结束，divisor 和 quotient 均向右移动一位。\n重复计算，知道无法进行除法运算为止，进行越界判断和符号修正，返回结果。\nfunc divide(a int, b int) int { // 负数取值范围更大，变换为负数求值，记录符号位 positive := true if a \u0026gt; 0 { a = -a } else { positive = !positive } if b \u0026gt; 0 { b = -b } else { positive = !positive } // 除数初始化 divisor := b quotient := 1 for ; divisor \u0026gt;= (-1 \u0026lt;\u0026lt; 30); divisor, quotient = divisor\u0026lt;\u0026lt;1, quotient\u0026lt;\u0026lt;1 { } // 减法求商 ans := 0 for a \u0026lt;= b \u0026amp;\u0026amp; divisor \u0026lt;= b { if a \u0026lt;= divisor { a -= divisor ans -= quotient } divisor \u0026gt;\u0026gt;= 1 quotient \u0026gt;\u0026gt;= 1 } if positive { // 溢出判定 if ans == math.MinInt32 { ans++ } ans = -ans } return ans } 复杂度 时间复杂度：$ O(\\log{MaxInt32}) $ 空间复杂度：$ O(1) $ ","date":"2021-10-12T11:13:55+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-29.-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/","title":"Leetcode 29. 两数相除"},{"content":"链接： https://leetcode-cn.com/problems/integer-to-english-words/\n难度： 困难\n题目描述 将非负整数 num 转换为其对应的英文表示。\n示例 1： 输入： num = 123\n输出： \u0026ldquo;One Hundred Twenty Three\u0026rdquo;\n示例 2： 输入： num = 12345\n输出： \u0026ldquo;Twelve Thousand Three Hundred Forty Five\u0026rdquo;\n示例 3： 输入： num = 1234567\n输出： \u0026ldquo;One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\u0026rdquo;\n示例 4： 输入： num = 1234567891\n输出： \u0026ldquo;One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One\u0026rdquo;\n提示： 0 \u0026lt;= num \u0026lt;= 231 - 1 解题思路 模拟 将数字分为三个一组，将每一部分的三位数转换为对应的英文表示，然后添加对应组的单位。\nfunc numberToWords(num int) string { en := map[int]string{ 0: \u0026#34;Zero\u0026#34;, 1: \u0026#34;One\u0026#34;, 2: \u0026#34;Two\u0026#34;, 3: \u0026#34;Three\u0026#34;, 4: \u0026#34;Four\u0026#34;, 5: \u0026#34;Five\u0026#34;, 6: \u0026#34;Six\u0026#34;, 7: \u0026#34;Seven\u0026#34;, 8: \u0026#34;Eight\u0026#34;, 9: \u0026#34;Nine\u0026#34;, 10: \u0026#34;Ten\u0026#34;, 11: \u0026#34;Eleven\u0026#34;, 12: \u0026#34;Twelve\u0026#34;, 13: \u0026#34;Thirteen\u0026#34;, 14: \u0026#34;Fourteen\u0026#34;, 15: \u0026#34;Fifteen\u0026#34;, 16: \u0026#34;Sixteen\u0026#34;, 17: \u0026#34;Seventeen\u0026#34;, 18: \u0026#34;Eighteen\u0026#34;, 19: \u0026#34;Nineteen\u0026#34;, 20: \u0026#34;Twenty\u0026#34;, 30: \u0026#34;Thirty\u0026#34;, 40: \u0026#34;Forty\u0026#34;, 50: \u0026#34;Fifty\u0026#34;, 60: \u0026#34;Sixty\u0026#34;, 70: \u0026#34;Seventy\u0026#34;, 80: \u0026#34;Eighty\u0026#34;, 90: \u0026#34;Ninety\u0026#34;, 100: \u0026#34;Hundred\u0026#34;, 1000: \u0026#34;Thousand\u0026#34;, 1e6: \u0026#34;Million\u0026#34;, 1e9: \u0026#34;Billion\u0026#34;, } if num == 0 { return en[0] } ans := make([]string, 0, 10) for mod := int(1e9); num \u0026gt; 0; mod /= 1000 { t := num / mod if t == 0 { continue } if t \u0026gt;= 100 { ans = append(ans, en[t/100], en[100]) } t %= 100 if t != 0 { if (t \u0026gt; 0 \u0026amp;\u0026amp; t \u0026lt; 20) || t%10 == 0 { ans = append(ans, en[t]) } else { ans = append(ans, en[t/10*10], en[t%10]) } } if mod != 1 { ans = append(ans, en[mod]) } num %= mod } return strings.Join(ans, \u0026#34; \u0026#34;) } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-10-11T21:29:00+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-273.-%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E8%8B%B1%E6%96%87%E8%A1%A8%E7%A4%BA/","title":"Leetcode 273. 整数转换英文表示"},{"content":"链接： https://leetcode-cn.com/problems/arranging-coins/\n难度： 简单\n题目描述 你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。\n给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。\n示例 1： 输入： n = 5\n输出： 2\n解释： 因为第三行不完整，所以返回 2 。\n示例 2： 输入： n = 8\n输出： 3\n解释： 因为第四行不完整，所以返回 3 。\n提示： 1 \u0026lt;= n \u0026lt;= 231 - 1 解题思路 模拟 按照题设排列，直到不够排成一行为止，返回排列完成的行数。\nfunc arrangeCoins(n int) int { ans := 0 for i := 1; n \u0026gt;= i; i++ { ans++ n -= i } return ans } 复杂度 时间复杂度：$ O(\\sqrt{n}) $ 空间复杂度：$ O(1) $ 数学 每一行到排列构成等差数列，根据等差数列求和公式可得： $$ \\begin{aligned} \\frac{x(x+1)}{2} \u0026amp;= n \\\\ x^2 + x - 2n \u0026amp;= 0 \\end{aligned} $$ 求得： $$ x = \\frac{-1\\pm\\sqrt{1+8n}}{2} $$ 得到排列完成的行数为：$\\lfloor\\frac{\\sqrt{8n+1}-1}{2}\\rfloor$\nfunc arrangeCoins(n int) int { return int(math.Sqrt(8*float64(n)+1)-1) / 2 } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-10-10T13:25:15+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-441.-%E6%8E%92%E5%88%97%E7%A1%AC%E5%B8%81/","title":"Leetcode 441. 排列硬币"},{"content":"链接： https://leetcode-cn.com/problems/repeated-dna-sequences/\n难度： 中等\n题目描述 所有 DNA 都由一系列缩写为 'A'，'C'，'G' 和 'T' 的核苷酸组成，例如：\u0026quot;ACGAATTCCG\u0026quot;。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。\n编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。\n示例 1： 输入： s = \u0026ldquo;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\u0026rdquo;\n输出： [\u0026ldquo;AAAAACCCCC\u0026rdquo;,\u0026ldquo;CCCCCAAAAA\u0026rdquo;]\n示例 2： 输入： s = \u0026ldquo;AAAAAAAAAAAAA\u0026rdquo;\n输出： [\u0026ldquo;AAAAAAAAAA\u0026rdquo;]\n提示： 0 \u0026lt;= s.length \u0026lt;= 105 s[i] 为 \u0026lsquo;A\u0026rsquo;、\u0026lsquo;C\u0026rsquo;、\u0026lsquo;G\u0026rsquo; 或 \u0026lsquo;T\u0026rsquo; 解题思路 哈希 使用哈希表记录每个长度为 10 的字串的出现次数，出现次数大于 1 时，添加到结果队列中。\nfunc findRepeatedDnaSequences(s string) []string { ans := make([]string, 0) cnt := make(map[string]int) for i := 10; i \u0026lt;= len(s); i++ { cnt[s[i-10:i]]++ if cnt[s[i-10:i]] == 2 { ans = append(ans, s[i-10:i]) } } return ans } 复杂度 时间复杂度：$ O(N) , N = len(s) $ 空间复杂度：$ O(N) $ ","date":"2021-10-08T10:51:30+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-187.-%E9%87%8D%E5%A4%8D%E7%9A%84dna%E5%BA%8F%E5%88%97/","title":"Leetcode 187. 重复的DNA序列"},{"content":"链接： https://leetcode-cn.com/problems/next-permutation/\n难度： 中等\n题目描述 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列（即，组合出下一个更大的整数）。\n如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n必须 原地 修改，只允许使用额外常数空间。\n示例 1： 输入： nums = [1,2,3]\n输出： [1,3,2]\n示例 2： 输入： nums = [3,2,1]\n输出： [1,2,3]\n示例 3： 输入： nums = [1,1,5]\n输出： [1,5,1]\n示例 4： 输入： nums = [1]\n输出： [1]\n提示： 1 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 100 解题思路 模拟 寻找下一个排列，其必然比当前排列要大，需要改变部分元素的顺序来获得。则其中一个较小的元素必然被其他更大的元素所替换，且其应该尽量的靠右。\n为找到这个元素 i ，从尾部开始遍历，找到其后存在比当前元素大的元素，即找到使得后半部分不满足非严格降序的首个元素，则该元素需要被比他大的元素替换。当找不到时，说明这是最大排列，反转后变为最小排列。\n然后找替换元素 j ，其要大于 i ，且尽量小。由于 i 素其后的元素非严格降序排序，可以倒序遍历，找到首个大于 i 的元素即为 j ，将 i 和 j 交换。\n之后需要将 i 后面的元素排序；i 和 j 交换后，其后仍遵循非严格降序，只需要反转这一部分即可。\nfunc nextPermutation(nums []int) { if len(nums) == 1 { return } // 寻找待替换元素 i := len(nums) - 2 for ; i \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[i+1]; i-- { } reverse := func(i, j int) { for ; i \u0026lt; j; i, j = i+1, j-1 { nums[i], nums[j] = nums[j], nums[i] } } // 没找到，排列最大，反转整个排列，返回最小值 if i == -1 { reverse(0, len(nums)-1) return } // 寻找替换元素 j := len(nums) - 1 for ; nums[j] \u0026lt;= nums[i]; j-- { } nums[i], nums[j] = nums[j], nums[i] // 排序 reverse(i+1, len(nums)-1) } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-10-07T16:16:34+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-31.-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/","title":"Leetcode 31. 下一个排列"},{"content":"链接： https://leetcode-cn.com/problems/sort-list/\n难度： 中等\n题目描述 给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。\n进阶：\n你可以在 $O(n\\log{n})$ 时间复杂度和常数级空间复杂度下，对链表进行排序吗？\n示例 1： 输入： head = [4,2,1,3]\n输出： [1,2,3,4]\n示例 2： 输入： head = [-1,5,3,4,0]\n输出： [-1,0,3,4,5]\n示例 3： 输入： head = []\n输出： []\n提示： 链表的长度范围为 [1, 5 * 104] 1 \u0026lt;= node.val \u0026lt;= 1000 解题思路 归并排序 从 i = 1 开始，每相邻的 2i个链表进行归并排序，直到 2i ≥ len(List) 为止。\n对于尾部不足 2i 的部分进行特殊处理，第一个链表长度为 2i-1，剩余部分为第二个链表。当剩余部分为空时，说明此部分已经排好序，进行下一轮归并即可。\nfunc sortList(head *ListNode) *ListNode { head = \u0026amp;ListNode{ Val: 0, Next: head, } length := 0 for node := head.Next; node != nil; node = node.Next { length++ } // 每 2^n 一组归并 for i := 2; i \u0026lt;= length\u0026lt;\u0026lt;1; i \u0026lt;\u0026lt;= 1 { node := head node1 := head.Next node2 := head.Next for node2 != nil { // 每组处理 node1 = node2 length1 := i \u0026gt;\u0026gt; 1 length2 := i \u0026gt;\u0026gt; 1 // 找到第二个链表开始位置 for j := i \u0026gt;\u0026gt; 1; j \u0026gt; 0 \u0026amp;\u0026amp; node2 != nil; j-- { node2 = node2.Next } // 尾部判定，直接推出 if node2 == nil { break } // 归并 for length1 \u0026gt; 0 || length2 \u0026gt; 0 { // 归并完毕退出 if length1 == 0 \u0026amp;\u0026amp; node2 == nil { break } // 选择较小的结点 if length1 == 0 || (length2 \u0026gt; 0 \u0026amp;\u0026amp; node2 != nil \u0026amp;\u0026amp; node2.Val \u0026lt; node1.Val) { node.Next = node2 node2 = node2.Next length2-- } else { node.Next = node1 node1 = node1.Next length1-- } node = node.Next } // 下一组 node.Next = node2 } } return head.Next } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(List) $ 空间复杂度：$ O(1) $ ","date":"2021-10-07T14:36:29+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-148.-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/","title":"Leetcode 148. 排序链表"},{"content":"链接： https://leetcode-cn.com/problems/reorder-list/\n难度： 中等\n题目描述 给定一个单链表 L 的头节点 head ，单链表 L 表示为：\nL0 → L1 → … → Ln-1 → Ln\n请将其重新排列后变为：\nL0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …\n不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\n示例 1： 输入: head = [1,2,3,4]\n输出: [1,4,2,3]\n示例 2： 输入: head = [1,2,3,4,5]\n输出: [1,5,2,4,3]\n提示： 链表的长度范围为 [1, 5 * 104] 1 \u0026lt;= node.val \u0026lt;= 1000 解题思路 顺序表 使用一个数组记录链表中的所有结点，按照顺序选出结点组成新的链表。\nfunc reorderList(head *ListNode) { length := 0 for node := head; node != nil; node = node.Next { length++ } list := make([]*ListNode, 0, length) for node := head; node != nil; node = node.Next { list = append(list, node) } ans := new(ListNode) node := ans i := 0 for ; i \u0026lt; length/2; i++ { node.Next = list[i] node = node.Next node.Next = list[length-1-i] node = node.Next } if length\u0026amp;1 == 1 { node.Next = list[i] node = node.Next } node.Next = nil head = ans.Next } 复杂度 时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(N) $ 拆分 + 反转链表 将原链表从中间拆分为两个链表，后半段反转，然后按照从前半段取一个结点，后半段取一个结点的顺序，重新排列链表。\nfunc reorderList(head *ListNode) { length := 0 for node := head; node != nil; node = node.Next { length++ } if length \u0026lt;= 1 { return } // 前半部分跳过 node := head for i := length/2 - 1; i \u0026gt; 0; i-- { node = node.Next } node.Next, node = nil, node.Next // 截断 // 后半部分反转 last := (*ListNode)(nil) for node != nil { node.Next, node, last = last, node.Next, node } tail := new(ListNode) for node = head; node != nil; { tail.Next = node tail = tail.Next node = node.Next tail.Next = last tail = tail.Next last = last.Next } if last != nil { tail.Next = last } } 复杂度 时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(1) $ ","date":"2021-10-07T13:23:22+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-143.-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/","title":"Leetcode 143. 重排链表"},{"content":"链接： https://leetcode-cn.com/problems/number-of-segments-in-a-string/\n难度： 简单\n题目描述 统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。\n请注意，你可以假定字符串里不包括任何不可打印的字符。\n示例： 输入: \u0026ldquo;Hello, my name is John\u0026rdquo;\n输出: 5\n解释: 这里的单词是指连续的不是空格的字符，所以 \u0026ldquo;Hello,\u0026rdquo; 算作 1 个单词。\n解题思路 遍历计数 遍历字符串，使用一个 hasWord 布尔值记录是否有单词：\n当遇到空格时，可能是单词结尾，若 hasWord = true ，单词数量加一，hasWord 置为 false； 当遇到非空格时，表示有新单词，hasWord 置为 true。 func countSegments(s string) int { ans := 0 hasWord := false for i := range s { if s[i] == \u0026#39; \u0026#39; { if hasWord { ans++ hasWord = false } } else { hasWord = true } } if hasWord { ans++ } return ans } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-10-07T13:05:49+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-434.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D%E6%95%B0/","title":"Leetcode 434. 字符串中的单词数"},{"content":"链接： https://leetcode-cn.com/problems/reverse-nodes-in-k-group/\n难度： 困难\n题目描述 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。\nk 是一个正整数，它的值小于或等于链表的长度。\n如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。\n进阶：\n你可以设计一个只使用常数额外空间的算法来解决此问题吗？ 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 示例 1： 输入： head = [1,2,3,4,5], k = 2\n输出： [2,1,4,3,5]\n示例 2： 输入： head = [1,2,3,4,5], k = 3\n输出： [3,2,1,4,5]\n示例 3： 输入： head = [1,2,3,4,5], k = 1\n输出： [1,2,3,4,5]\n示例 4： 输入： head = [1], k = 1\n输出： [1]\n提示： 列表中节点的数量在范围 sz 内 1 \u0026lt;= sz \u0026lt;= 5000 0 \u0026lt;= Node.val \u0026lt;= 1000 1 \u0026lt;= k \u0026lt;= sz 解题思路 顺序表 使用一个数组记录链表中的所有结点，按照顺序选出结点组成新的链表。\nfunc reverseKGroup(head *ListNode, k int) *ListNode { length := 0 for node := head; node != nil; node = node.Next { length++ } list := make([]*ListNode, 0, length) for node := head; node != nil; node = node.Next { list = append(list, node) } ans := new(ListNode) node := ans pos := 0 for ; pos \u0026lt; length; pos += k { // 反转判定 if pos+k \u0026gt; length { node.Next = list[pos] node == nil break } // 反转 for i := pos + k - 1; i \u0026gt;= pos \u0026amp;\u0026amp; i \u0026lt; length; i-- { node.Next = list[i] node = node.Next } } // 尾结点 Next 置空 if node != nil { node.Next = nil } return ans.Next } 复杂度 时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(N) $ 模拟 使用 tail 指针记录已经反转完成部分的链表的尾部，每次反转前进行反转判定：\n当剩余结点数量不足 k 个时，修改 tail.Next 指向该部分的头部，并返回； 否则反转该部分，修改 tail.Next 指向该反转部分的头部，tail 指向反转部分的尾部，并继续向后遍历。 由于 tail 指向的是上一部分的尾部，初始时使用一个结点模拟上一部分，则其新链表的头结点即为该结点 Next 指针所指向的结点。\nfunc reverseKGroup(head *ListNode, k int) *ListNode { ans := new(ListNode) // 头 tail := ans // 尾 for head != nil { cur := head // 反转判定 for i := 0; i \u0026lt; k; i++ { if cur == nil { tail.Next = head return ans.Next } cur = cur.Next } // 反转 k 个 last := (*ListNode)(nil) cur = head for i := 0; i \u0026lt; k; i++ { cur.Next, cur, last = last, cur.Next, cur } // 更新指针 tail.Next = last tail = head head = cur } return ans.Next } 复杂度 时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(1) $ ","date":"2021-10-07T11:51:45+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-25.-k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/","title":"Leetcode 25. K 个一组翻转链表"},{"content":"链接： https://leetcode-cn.com/problems/sqrtx/\n难度： 简单\n题目描述 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n注意： 不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n示例 1： 输入： x = 4\n输出： 2\n示例 2： 输入： x = 8\n输出： 2\n解释： 8 的算术平方根是 2.82842\u0026hellip;, 由于返回类型是整数，小数部分将被舍去。\n提示： 00 \u0026lt;= x \u0026lt;= 231 - 1 解题思路 枚举 从零开始枚举平方根 i ，直到 i*i \u0026gt; x 为止，返回最大的有效值 i-1。\nfunc mySqrt(x int) int { ans := 0 for ; ans*ans \u0026lt;= x; ans++ { } return ans-1 } 复杂度 时间复杂度：$ O(\\sqrt{x}) $ 空间复杂度：$ O(1) $ 位运算 从 215 开始，尝试将其累加到结果中，然后右移一位，直到为 0 为止。\nfunc mySqrt(x int) int { ans := 0 for bit := 1 \u0026lt;\u0026lt; 15; bit \u0026gt; 0; bit \u0026gt;\u0026gt;= 1 { t := ans + bit if t*t \u0026lt;= x { ans = t } } return ans } 复杂度 时间复杂度：$ O(\\log{MaxInt32}) $ 空间复杂度：$ O(1) $ ","date":"2021-10-06T23:00:54+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-69.-sqrtx/","title":"Leetcode 69. Sqrt(x)"},{"content":"链接： https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n难度： 中等\n题目描述 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。\n示例 1： 输入: \u0026ldquo;abcabcbb\u0026rdquo;\n输出: 3\n解释: 因为无重复字符的最长子串是 \u0026ldquo;abc\u0026rdquo;，所以其长度为 3。\n示例 2： 输入: \u0026ldquo;bbbbb\u0026rdquo;\n输出: 1\n解释: 因为无重复字符的最长子串是 \u0026ldquo;b\u0026rdquo;，所以其长度为 1。\n示例 3： 输入: \u0026ldquo;pwwkew\u0026rdquo;\n输出: 3\n解释: 因为无重复字符的最长子串是 \u0026ldquo;wke\u0026rdquo;，所以其长度为 3。\n请注意，你的答案必须是 子串 的长度，\u0026ldquo;pwke\u0026rdquo; 是一个子序列，不是子串。\n示例 4： 输入: s = \u0026quot;\u0026quot;\n输出: 0\n提示： 0 \u0026lt;= s.length \u0026lt;= 5 * 104 s 由英文字母、数字、符号和空格组成 解题思路 哈希 + 双指针 使用哈希表记录每个字符出现的下标，并记录有效字串开始的下标 start：当出现重复字符时，将 start 修正为重复字符出现的下一个位置。\nfunc lengthOfLongestSubstring(s string) int { ans := 0 pos := make(map[byte]int) start := 0 for i := 0; i \u0026lt; len(s); i++ { p, ok := pos[s[i]] if ok \u0026amp;\u0026amp; start \u0026lt;= p { start = p + 1 } pos[s[i]] = i if ans \u0026lt; i-start+1 { ans = i - start + 1 } } return ans } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-10-06T22:51:34+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-3.-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","title":"Leetcode 3. 无重复字符的最长子串"},{"content":"链接： https://leetcode-cn.com/problems/third-maximum-number/\n难度： 简单\n题目描述 给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。\n示例 1： 输入： [3, 2, 1]\n输出： 1\n解释： 第三大的数是 1 。\n示例 2： 输入： [1, 2]\n输出： 2\n解释： 第三大的数不存在, 所以返回最大的数 2 。\n示例 3： 输入： [2, 2, 3, 1]\n输出： 1\n解释： 注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。\n此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。\n提示： 1 \u0026lt;= nums.length \u0026lt;= 104 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 进阶： 你能设计一个时间复杂度 O(n) 的解决方案吗？\n解题思路 排序 对数组进行一轮排序，尝试从最大值开始寻找第三大的值，找到则返回；否则返回最大值。\nfunc thirdMax(nums []int) int { sort.Ints(nums) for i, rank, max := len(nums)-2, 0, nums[len(nums)-1]; i \u0026gt;= 0; i-- { if max != nums[i] { max = nums[i] rank++ if rank == 2 { return max } } } return nums[len(nums)-1] } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(nums) $ 空间复杂度：$ O(\\log{N}) $ 递减序列 使用三个变量记录遍历过的元素中最大的三个值，每遍历到一个元素时更新，若最后找到了第三大的值则返回，否则返回最大值。\nfunc thirdMax(nums []int) int { const Rank = 3 max := [Rank]int{} exist := [Rank]bool{} for _, num := range nums { for i := 0; i \u0026lt; len(max); i++ { if !exist[i] { max[i] = num exist[i] = true break } if num \u0026gt; max[i] { num, max[i] = max[i], num } else if num == max[i] { break } } } if exist[len(max)-1] { return max[len(max)-1] } return max[0] } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-10-06T14:16:55+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-414.-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/","title":"Leetcode 414. 第三大的数"},{"content":"链接： https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/\n难度： 困难\n题目描述 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。\n例如，\n[2,3,4] 的中位数是 3\n[2,3] 的中位数是 (2 + 3) / 2 = 2.5\n设计一个支持以下两种操作的数据结构：\nvoid addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 示例 1： 输入：\n[\u0026ldquo;MedianFinder\u0026rdquo;,\u0026ldquo;addNum\u0026rdquo;,\u0026ldquo;addNum\u0026rdquo;,\u0026ldquo;findMedian\u0026rdquo;,\u0026ldquo;addNum\u0026rdquo;,\u0026ldquo;findMedian\u0026rdquo;]\n[[],[1],[2],[],[3],[]]\n输出： [null,null,null,1.50000,null,2.00000]\n示例 2： 输入：\n[\u0026ldquo;MedianFinder\u0026rdquo;,\u0026ldquo;addNum\u0026rdquo;,\u0026ldquo;findMedian\u0026rdquo;,\u0026ldquo;addNum\u0026rdquo;,\u0026ldquo;findMedian\u0026rdquo;]\n[[],[2],[],[3],[]]\n输出： [null,null,2.00000,null,2.50000]\n限制： 最多会对 addNum、findMedian 进行 50000 次调用。 解题思路 双堆 分别使用大顶堆和小顶堆记录排序后的前半部分元素和后半部分元素，若元素数量不为偶数时，多余的一个元素记录到小顶堆中。\n则对于 findMedian 操作，当元素数量为奇数时，即两个堆元素数量不同时，返回小顶堆堆顶元素；为偶数时，即两个堆元素数量相同时，返回两个堆堆顶元素的平均值。\n对于 addNum 操作，需要修正两个堆的元素数量，保证小顶堆的元素数量不小于大顶堆，且差 ≤ 1：\n当两个堆的元素数量相同时，将该元素加入大顶堆中，并将大顶堆堆顶元素移动到小顶堆中； 当两个堆的元素数量不同时，将该元素加入小顶堆中，并将小顶堆堆顶元素移动到大顶堆中。 type Heap struct { sort.IntSlice reverse bool } func (this *Heap) Less(i, j int) bool { if this.reverse { return this.IntSlice.Less(j, i) } return this.IntSlice.Less(i, j) } func (this *Heap) Push(elem interface{}) { this.IntSlice = append(this.IntSlice, elem.(int)) } func (this *Heap) Pop() interface{} { elem := this.IntSlice[this.Len()-1] this.IntSlice = this.IntSlice[:this.Len()-1] return elem } type MedianFinder struct { minHeap *Heap maxHeap *Heap } func Constructor() MedianFinder { return MedianFinder{ minHeap: \u0026amp;Heap{ IntSlice: make([]int, 0, 1), reverse: false, }, maxHeap: \u0026amp;Heap{ IntSlice: make([]int, 0, 1), reverse: true, }, } } func (this *MedianFinder) AddNum(num int) { if this.maxHeap.Len() == this.minHeap.Len() { heap.Push(this.maxHeap, num) heap.Push(this.minHeap, heap.Pop(this.maxHeap)) } else { heap.Push(this.minHeap, num) heap.Push(this.maxHeap, heap.Pop(this.minHeap)) } } func (this *MedianFinder) FindMedian() float64 { if this.maxHeap.Len() == this.minHeap.Len() { return float64(this.maxHeap.IntSlice[0]+this.minHeap.IntSlice[0]) / 2 } return float64(this.minHeap.IntSlice[0]) } 复杂度 时间复杂度： AddNum：$ O(\\log{N}) $ FindMedian：$ O(1) $ 空间复杂度：$ O(N) $ ","date":"2021-10-05T20:42:26+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-41.-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","title":"剑指 Offer 41. 数据流中的中位数"},{"content":"链接： https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/\n难度： 困难\n题目描述 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。\n例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。\n示例 1： 输入： n = 12\n输出： 5\n示例 2： 输入： n = 13\n输出： 6\n限制： 1 \u0026lt;= n \u0026lt; 231 解题思路 逐位计数 按照个、十、百\u0026hellip;的顺序逐位统计。\n不妨设当前位的基数为 i，则对于前缀 0 ~ n/i-1，其必然可以取到 1，其后缀为 0 ~ i-1，故累加 n/i * i 次。\n对于前缀为 n/i 的部分，需要判别当前位：\n若当前位 \u0026gt; 1，则还可以取得后缀 0 ~ i-1，累加 i 次； 若当前位 = 1，则后缀可以取得 0 ~ n%i，累加 n%i + 1 次； 若当前位为 0，则无法取到。 func countDigitOne(n int) int { ans := 0 for i, x := 1, n; x \u0026gt; 0; x, i = x/10, i*10 { ans += x / 10 * i switch x % 10 { case 0: case 1: ans += n%i + 1 default: ans += i } } return ans } 复杂度 时间复杂度：$ O(\\log{n}) $ 空间复杂度：$ O(1) $ ","date":"2021-10-05T20:16:53+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-43.-1n-%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","title":"剑指 Offer 43. 1～n 整数中 1 出现的次数"},{"content":"链接： https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/\n难度： 困难\n题目描述 给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。\n示例： 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3\n输出: [3,3,5,5,6,7]\n解释:\n滑动窗口的位置 最大值\n[1 3 -1] -3 5 3 6 7 3\n1 [3 -1 -3] 5 3 6 7 3\n1 3 [-1 -3 5] 3 6 7 5\n1 3 -1 [-3 5 3] 6 7 5\n1 3 -1 -3 [5 3 6] 7 6\n1 3 -1 -3 5 [3 6 7] 7\n提示： 你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。 解题思路 暴力求解 对于每个窗口，遍历其中的元素，找到最大值。空数组需要特判。\nfunc maxSlidingWindow(nums []int, k int) []int { if len(nums) == 0 { return nil } ans := make([]int, 0, len(nums)-k+1) for i := k; i \u0026lt;= len(nums); i++ { max := math.MinInt32 for j := i - k; j \u0026lt; i; j++ { if max \u0026lt; nums[j] { max = nums[j] } } ans = append(ans, max) } return ans } 复杂度 时间复杂度：$ O(Nk), N = len(nums) $ 空间复杂度：$ O(1) $ 双端队列 使用一个队列维护窗口的最大值信息。\n可以发现，当窗口滑动后，在该值之前的位于窗口内的所有小于该值的元素对于最大值均无影响；仅当该值从窗口移出后，由此值后面的次大元素接任。\n所以这个队列的队列头记录当前队列的最大值，后续按值非严格递减的顺序记录其他值。当窗口移动时：\n对于新进入窗口的元素，需要从尾部开始将小于当前值的元素全部删除，然后该值入队； 对于离开窗口的元素，若队首元素是与其相等，则该值出队。 空数组需要特判。\nfunc maxSlidingWindow(nums []int, k int) []int { if len(nums) == 0 { return nil } // 初始化 deque := list.New() for i := 0; i \u0026lt; k; i++ { for deque.Len() \u0026gt; 0 \u0026amp;\u0026amp; deque.Back().Value.(int) \u0026lt; nums[i] { deque.Remove(deque.Back()) } deque.PushBack(nums[i]) } ans := make([]int, 0, len(nums)-k+1) ans = append(ans, deque.Front().Value.(int)) for i := k; i \u0026lt; len(nums); i++ { // 出队判定 if nums[i-k] == deque.Front().Value.(int) { deque.Remove(deque.Front()) } // 新元素入队 for deque.Len() \u0026gt; 0 \u0026amp;\u0026amp; deque.Back().Value.(int) \u0026lt; nums[i] { deque.Remove(deque.Back()) } deque.PushBack(nums[i]) ans = append(ans, deque.Front().Value.(int)) } return ans } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(k) $ 堆 + 哈希 使用大顶堆维护遍历到的最大值，当窗口滑动时，需要将新元素入堆，然后取出最大元素。\n为判定最大元素位于堆中，还需要记录元素的下标，可以使用哈希表，尝试不断的取出堆顶元素直到其位于滑动窗口中。\ntype MaxHeap struct { sort.IntSlice } func (this *MaxHeap) Less(i, j int) bool { return this.IntSlice.Less(j, i) } func (this *MaxHeap) Push(elem interface{}) { this.IntSlice = append(this.IntSlice, elem.(int)) } func (this *MaxHeap) Pop() interface{} { elem := this.IntSlice[0] this.IntSlice = this.IntSlice[:this.Len()-1] return elem } func maxSlidingWindow(nums []int, k int) []int { if len(nums) == 0 { return nil } // 初始化 h := \u0026amp;MaxHeap{ IntSlice: make([]int, 0, len(nums)), } pos := make(map[int]int) for i := 0; i \u0026lt; k; i++ { pos[nums[i]] = i heap.Push(h, nums[i]) } ans := make([]int, 0, len(nums)-k+1) ans = append(ans, h.IntSlice[0]) for i := k; i \u0026lt; len(nums); i++ { pos[nums[i]] = i // 入堆 heap.Push(h, nums[i]) for pos[h.IntSlice[0]] \u0026lt;= i-k { heap.Pop(h) } ans = append(ans, h.IntSlice[0]) } return ans } 时间复杂度：$ O(N\\log{N}), N = len(nums)$ 空间复杂度：$ O(N) $ ","date":"2021-10-05T18:12:15+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-59-i.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","title":"剑指 Offer 59 - I. 滑动窗口的最大值"},{"content":"链接： https://leetcode-cn.com/problems/peeking-iterator/\n难度： 中等\n题目描述 请你设计一个迭代器，除了支持 hasNext 和 next 操作外，还支持 peek 操作。\n实现 PeekingIterator 类：\nPeekingIterator(int[] nums) 使用指定整数数组 nums 初始化迭代器。 int next() 返回数组中的下一个元素，并将指针移动到下个元素处。 bool hasNext() 如果数组中存在下一个元素，返回 true ；否则，返回 false 。 int peek() 返回数组中的下一个元素，但 不 移动指针。 示例： 输入：\n[\u0026ldquo;PeekingIterator\u0026rdquo;, \u0026ldquo;next\u0026rdquo;, \u0026ldquo;peek\u0026rdquo;, \u0026ldquo;next\u0026rdquo;, \u0026ldquo;next\u0026rdquo;, \u0026ldquo;hasNext\u0026rdquo;]\n[[[1, 2, 3]], [], [], [], [], []]\n输出：\n[null, 1, 2, 2, 3, false]\n解释：\nPeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]\npeekingIterator.next(); // 返回 1 ，指针移动到下一个元素 [1,2,3]\npeekingIterator.peek(); // 返回 2 ，指针未发生移动 [1,2,3]\npeekingIterator.next(); // 返回 2 ，指针移动到下一个元素 [1,2,3]\npeekingIterator.next(); // 返回 3 ，指针移动到下一个元素 [1,2,3]\npeekingIterator.hasNext(); // 返回 False\n提示： 1 \u0026lt;= nums.length \u0026lt;= 1000 1 \u0026lt;= nums[i] \u0026lt;= 1000 对 next 和 peek 的调用均有效 next、hasNext 和 peek 最多调用 1000 次 进阶： 你将如何拓展你的设计？使之变得通用化，从而适应所有的类型，而不只是整数型？\n解题思路 动态规划 使用一个变量 current 记录顶端元素，原始迭代器的指针是指向下一个元素的，故另外需要使用一个 _hasNext 记录当前 current 是否存有有效值。\npeek 和 hasNext 操作，返回 current 和 _hasNext 即可； 初始化时，原始迭代器的实际指向的是下一个元素，将当前元素存入 current； next 操作，返回的是 current，并将下一个元素存入 current。 type PeekingIterator struct { iter *Iterator current int _hasNext bool } func Constructor(iter *Iterator) *PeekingIterator { p := \u0026amp;PeekingIterator{ iter: iter, current: 0, _hasNext: iter.hasNext(), } if iter.hasNext() { p.current = iter.next() } return p } func (this *PeekingIterator) hasNext() bool { return this._hasNext } func (this *PeekingIterator) next() int { ans := this.current this._hasNext = this.iter.hasNext() if this._hasNext { this.current = this.iter.next() } return ans } func (this *PeekingIterator) peek() int { return this.current } 复杂度 时间复杂度： hasNext：$ O(1) $ next：$ O(1) $ peek：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-10-05T13:38:07+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-284.-%E9%A1%B6%E7%AB%AF%E8%BF%AD%E4%BB%A3%E5%99%A8/","title":"Leetcode 284. 顶端迭代器"},{"content":"链接： https://leetcode-cn.com/problems/license-key-formatting/\n难度： 简单\n题目描述 有一个密钥字符串 S ，只包含字母，数字以及 \u0026lsquo;-\u0026rsquo;（破折号）。其中， N 个 \u0026lsquo;-\u0026rsquo; 将字符串分成了 N+1 组。\n给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 \u0026lsquo;-\u0026rsquo;（破折号）隔开，并且将所有的小写字母转换为大写字母。\n给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。\n示例 1： 输入： S = \u0026ldquo;5F3Z-2e-9-w\u0026rdquo;, K = 4\n输出： \u0026ldquo;5F3Z-2E9W\u0026rdquo;\n解释： 字符串 S 被分成了两个部分，每部分 4 个字符；\n注意，两个额外的破折号需要删掉。\n示例 2： 输入： S = \u0026ldquo;2-5g-3-J\u0026rdquo;, K = 2\n输出： \u0026ldquo;2-5G-3J\u0026rdquo;\n解释： 字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。\n提示： S 的长度可能很长，请按需分配大小。K 为正整数。 S 只包含字母数字（a-z，A-Z，0-9）以及破折号\u0026rsquo;-\u0026rsquo; S 非空 解题思路 计数 遍历一遍列表，统计所有字母的数量，若首个分组不足 k 个，需要额外处理，之后按 k 个一组进行分组。\nfunc licenseKeyFormatting(s string, k int) string { // 计数 cnt := 0 for i := range s { if s[i] != \u0026#39;-\u0026#39; { cnt++ } } ans := make([]byte, 0, cnt+cnt/k+1) i := 0 // 首个分组 处理 if cnt%k != 0 { for j := 0; j \u0026lt; cnt%k; i++ { if s[i] != \u0026#39;-\u0026#39; { t := s[i] if t \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; t \u0026lt;= \u0026#39;z\u0026#39; { t = t - \u0026#39;a\u0026#39; + \u0026#39;A\u0026#39; } ans = append(ans, t) j++ } } cnt -= cnt % k if cnt \u0026gt; 0 { ans = append(ans, \u0026#39;-\u0026#39;) } } // 剩余分组处理 for cnt \u0026gt; 0 { for j := 0; j \u0026lt; k; i++ { if s[i] != \u0026#39;-\u0026#39; { t := s[i] if t \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; t \u0026lt;= \u0026#39;z\u0026#39; { t = t - \u0026#39;a\u0026#39; + \u0026#39;A\u0026#39; } ans = append(ans, t) j++ } } cnt -= k if cnt \u0026gt; 0 { ans = append(ans, \u0026#39;-\u0026#39;) } } return string(ans) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ 倒序遍历 从尾至头遍历，k 个一组，最后剩余的不足 k 个字符也构成一组，然后反转整个字符串即可。\nfunc licenseKeyFormatting(s string, k int) string { ans := make([]byte, 0, len(s)\u0026lt;\u0026lt;1) for i, cnt := len(s)-1, 0; i \u0026gt;= 0; i-- { if s[i] == \u0026#39;-\u0026#39; { continue } t := s[i] if \u0026#39;a\u0026#39; \u0026lt;= t \u0026amp;\u0026amp; t \u0026lt;= \u0026#39;z\u0026#39; { t = t - \u0026#39;a\u0026#39; + \u0026#39;A\u0026#39; } ans = append(ans, t) cnt++ if cnt == k { ans = append(ans, \u0026#39;-\u0026#39;) cnt = 0 } } for i := len(ans)/2 - 1; i \u0026gt;= 0; i-- { ans[i], ans[len(ans)-1-i] = ans[len(ans)-1-i], ans[i] } if len(ans) \u0026gt; 0 \u0026amp;\u0026amp; ans[0] == \u0026#39;-\u0026#39; { ans = ans[1:] } return string(ans) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-10-04T11:44:14+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-482.-%E5%AF%86%E9%92%A5%E6%A0%BC%E5%BC%8F%E5%8C%96/","title":"Leetcode 482. 密钥格式化"},{"content":"链接： https://leetcode-cn.com/problems/fraction-to-recurring-decimal/\n难度： 中等\n题目描述 给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。\n如果小数部分为循环小数，则将循环的部分括在括号内。\n如果存在多个答案，只需返回 任意一个 。\n对于所有给定的输入，保证 答案字符串的长度小于 104 。\n示例 1： 输入： numerator = 1, denominator = 2\n输出： \u0026ldquo;0.5\u0026rdquo;\n示例 2： 输入： numerator = 2, denominator = 1\n输出： \u0026ldquo;2\u0026rdquo;\n示例 3： 输入： numerator = 2, denominator = 3\n输出： \u0026ldquo;0.(6)\u0026rdquo;\n示例 4： 输入： numerator = 4, denominator = 333\n输出： \u0026ldquo;0.(012)\u0026rdquo;\n示例 5： 输入： numerator = 1, denominator = 5\n输出： \u0026ldquo;0.2\u0026rdquo;\n提示： -231 \u0026lt;= numerator, denominator \u0026lt;= 231 - 1 denominator != 0 解题思路 数学 + 哈希表 判定符号位，然后将分子和分母全部转换为正数求商。\n首先求整数部分，然后进行除尽判定，能除尽则返回直接返回整数部分；\n对于小数部分，使用数学方法竖式求解，使用哈希表记录被除数除的位置：\n当被除数已经出现过时，说明出现了循环，在上次出现位置和当前位置前后加上括号并返回； 当被除数小于除数时，商为 0，被除数 * 10； 当被除数大于除数时，求得商和余数，将余数 * 10 作为下一次的被除数继续求解。 重复上述步骤知道直到被除数为 0 或者找到循环。\nfunc fractionToDecimal(numerator int, denominator int) string { ans := make([]byte, 0, 10) // 符号 if (numerator \u0026gt; 0 \u0026amp;\u0026amp; denominator \u0026lt; 0) || (numerator \u0026lt; 0 \u0026amp;\u0026amp; denominator \u0026gt; 0) { ans = append(ans, \u0026#39;-\u0026#39;) } // 全部转换正数运算 if numerator \u0026lt; 0 { numerator = -numerator } if denominator \u0026lt; 0 { denominator = -denominator } ans = append(ans, strconv.FormatInt(int64(numerator/denominator), 10)...) // 除尽判定 numerator %= denominator if numerator == 0 { return string(ans) } // 小数部分求解 ans = append(ans, \u0026#39;.\u0026#39;) appear := make(map[int]int) numerator *= 10 for i := len(ans); numerator != 0; i++ { // 出现循环，添加括号并跳出 if pos, ok := appear[numerator]; ok { ans = append(ans, \u0026#39;0\u0026#39;) copy(ans[pos+1:], ans[pos:len(ans)-1]) ans[pos] = \u0026#39;(\u0026#39; ans = append(ans, \u0026#39;)\u0026#39;) break } appear[numerator] = i if numerator \u0026gt; denominator { ans = append(ans, byte(numerator/denominator)+\u0026#39;0\u0026#39;) numerator %= denominator } else { ans = append(ans, \u0026#39;0\u0026#39;) } numerator *= 10 } return string(ans) } 复杂度 时间复杂度：$ O(N), N = len(ans) $ 空间复杂度：$ O(N) $ ","date":"2021-10-03T20:06:52+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-166.-%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/","title":"Leetcode 166. 分数到小数"},{"content":"链接： https://leetcode-cn.com/problems/xoh6Oh/\n难度： 简单\n题目描述 给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 '*'、除号 '/' 以及求余符号 '%' 。\n注意： 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231−1]。本题中，如果除法结果溢出，则返回 231 − 1 示例 1： 输入： a = 15, b = 2\n输出： 7\n解释： 15/2 = truncate(7.5) = 7\n示例 2： 输入： a = 7, b = -3\n输出： -2\n解释： 7/-3 = truncate(-2.33333..) = -2\n示例 3： 输入： a = 0, b = 1\n输出： 0\n示例 4： 输入： a = 1, b = 1\n输出： 1\n提示 -231 \u0026lt;= a, b \u0026lt;= 231 - 1 b != 0 解题思路 减法模拟 + 位运算 使用多次的减法来计算，由于负数的取值范围更大，将正数变换为负数求解。\n首先初始化除数 divisor ，使用位运算，使其在不越界的情况下，乘以2的整数方次倍达到最大值，同时记录和原除数 b 倍数 quotient，也即可以累加进结果的商。\n然后求解，当 a ≤ divisor 时，用 a 减去 divisor，结果加上对应的除数倍数 quotient；每次循环结束，divisor 和 quotient 均向右移动一位。\n重复计算，知道无法进行除法运算为止，进行越界判断和符号修正，返回结果。\nfunc divide(a int, b int) int { // 负数取值范围更大，变换为负数求值，记录符号位 positive := true if a \u0026gt; 0 { a = -a } else { positive = !positive } if b \u0026gt; 0 { b = -b } else { positive = !positive } // 除数初始化 divisor := b quotient := 1 for ; divisor \u0026gt;= (-1 \u0026lt;\u0026lt; 30); divisor, quotient = divisor\u0026lt;\u0026lt;1, quotient\u0026lt;\u0026lt;1 { } // 减法求商 ans := 0 for a \u0026lt;= b \u0026amp;\u0026amp; divisor \u0026lt;= b { if a \u0026lt;= divisor { a -= divisor ans -= quotient } divisor \u0026gt;\u0026gt;= 1 quotient \u0026gt;\u0026gt;= 1 } if positive { // 溢出判定 if ans == math.MinInt32 { ans++ } ans = -ans } return ans } 复杂度 时间复杂度：$ O(\\log{MaxInt32}) $ 空间复杂度：$ O(1) $ ","date":"2021-10-02T18:12:00+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-ii-001.-%E6%95%B4%E6%95%B0%E9%99%A4%E6%B3%95/","title":"剑指 Offer II 001. 整数除法"},{"content":"链接： https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/\n难度： 简单\n题目描述 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n例如，给定如下二叉搜索树: root = [3,5,1,6,2,0,8,null,null,7,4]\n示例 1： 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\n输出: 3\n解释: 节点 5 和节点 1 的最近公共祖先是节点 3。\n示例 2： 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\n输出: 5\n解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。\n说明： 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 解题思路 深度优先搜索 + 记录路径 利用深度优先搜索找出从根结点开始分别到 p 和 q 的路径，然后找出两条路径中最后一个相同的结点并返回。\nfunc lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { var dfs func(node *TreeNode, target *TreeNode, path []*TreeNode) []*TreeNode dfs = func(node *TreeNode, target *TreeNode, path []*TreeNode) []*TreeNode { if node == nil { return make([]*TreeNode, 0) } path = append(path, node) if node == target { return path } if path := dfs(node.Left, target, path); len(path) != 0 { return path } if path := dfs(node.Right, target, path); len(path) != 0 { return path } path = path[:len(path)-1] return make([]*TreeNode, 0) } pathP := dfs(root, p, make([]*TreeNode, 0, 2)) pathQ := dfs(root, q, make([]*TreeNode, 0, 2)) ans := (*TreeNode)(nil) for i := 0; i \u0026lt; len(pathP) \u0026amp;\u0026amp; i \u0026lt; len(pathQ) \u0026amp;\u0026amp; pathP[i] == pathQ[i]; i++ { ans = pathP[i] } return ans } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ 递归 最近公共结点有两种情况，或者 p 和 q 分别位于最近公共结点的左右子树，或者其中一个是另一个的祖先结点。\n使用递归求解，返回值为空，表示没有找到。\n当找到之中一个结点时，返回此结点，其囊括了情况2； 现在剩余了情况1，可以利用左右子树的搜索结果，若两个均非空，则说明两个节点分别位于左右子树，返回当前结点。 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root == p || root == q { return root } l := lowestCommonAncestor(root.Left, p, q) r := lowestCommonAncestor(root.Right, p, q) if l != nil \u0026amp;\u0026amp; r != nil { return root } if l == nil { return r } else { return l } } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-10-02T17:21:23+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-68-ii.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","title":"剑指 Offer 68 - II. 二叉树的最近公共祖先"},{"content":"链接： https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/\n难度： 简单\n题目描述 给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。\n注意: 十六进制中所有字母(a-f)都必须是小写。 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0\u0026rsquo;来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 给定的数确保在32位有符号整数范围内。 不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。 示例 1： 输入: 26\n输出: \u0026ldquo;1a\u0026rdquo;\n示例 2： 输入: -1\n输出: \u0026ldquo;ffffffff\u0026rdquo;\n解题思路 数学 将负数补码转换为正数，使用数学方法，除16取余，逆序排列。对0进行特判。\nfunc toHex(num int) string { if num == 0 { return \u0026#34;0\u0026#34; } digit := []byte(\u0026#34;0123456789abcdef\u0026#34;) ans := make([]byte, 0, 8) t := uint32(num) for ; t != 0; t /= 16 { ans = append(ans, digit[t%16]) } for i := len(ans)/2 - 1; i \u0026gt;= 0; i-- { ans[i], ans[len(ans)-1-i] = ans[len(ans)-1-i], ans[i] } return string(ans) } 复杂度 时间复杂度：O(\\log{num}) 空间复杂度：O(\\log{num}) 位运算 四个2进制位构成16进制，每次将末尾四个2进制位转换为16进制，并向右移动4位，直到 num 为0 或 转换次数到达上限。对0进行特判。\nfunc toHex(num int) string { if num == 0 { return \u0026#34;0\u0026#34; } digit := []byte(\u0026#34;0123456789abcdef\u0026#34;) ans := make([]byte, 0, 8) for i := 0; i \u0026lt; 8 \u0026amp;\u0026amp; num != 0; i, num = i+1, num\u0026gt;\u0026gt;4 { ans = append(ans, digit[num\u0026amp;15]) } for i := len(ans)/2 - 1; i \u0026gt;= 0; i-- { ans[i], ans[len(ans)-1-i] = ans[len(ans)-1-i], ans[i] } return string(ans) } 复杂度 时间复杂度：O(\\log{num}) 空间复杂度：O(\\log{num}) ","date":"2021-10-02T16:16:35+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-405.-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0/","title":"Leetcode 405. 数字转换为十六进制数"},{"content":"链接： https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/\n难度： 简单\n题目描述 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n示例 1： 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n输出: 6\n解释: 节点 2 和节点 8 的最近公共祖先是 6。\n示例 2： 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n输出: 2\n解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n说明： 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 解题思路 搜索 利用二叉树搜索数的性质：\n当 p 和 q 的值均小于当前结点时，去左子树搜索； 当 p 和 q 的值均大于当前结点时，去右子树搜索； 否则，有以下情况： 当前结点与其中一个结点相同，则另一个结点时候在此子树中，返回当前结点； 当前结点与两个结点都不相同，则 p 和 q 分别在左右子树中，仍返回当前结点。 class Solution { public: TreeNode *lowestCommonAncestor(TreeNode *root, TreeNode *p, TreeNode *q) { while (true) { if (p-\u0026gt;val \u0026lt; root-\u0026gt;val \u0026amp;\u0026amp; q-\u0026gt;val \u0026lt; root-\u0026gt;val) { root = root-\u0026gt;left; continue; } if (p-\u0026gt;val \u0026gt; root-\u0026gt;val \u0026amp;\u0026amp; q-\u0026gt;val \u0026gt; root-\u0026gt;val) { root = root-\u0026gt;right; continue; } return root; } } }; 复杂度 时间复杂度：$ O(\\log{N}), N = size(Tree) $ 空间复杂度：$ O(1) $ ","date":"2021-10-02T15:05:53+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-68-i.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","title":"剑指 Offer 68 - I. 二叉搜索树的最近公共祖先"},{"content":"链接： https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/\n难度： 中等\n题目描述 写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。\n首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。\n当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。\n该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。\n注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。\n在任何情况下，若函数不能进行有效的转换时，请返回 0。\n说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。\n示例 1： 输入: \u0026ldquo;42\u0026rdquo;\n输出: 42\n示例 2： 输入: \u0026quot; -42\u0026quot;\n输出: -42\n解释: 第一个非空白字符为 \u0026lsquo;-\u0026rsquo;, 它是一个负号。\n我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n示例 3： 输入: \u0026ldquo;4193 with words\u0026rdquo;\n输出: 4193\n解释: 转换截止于数字 \u0026lsquo;3\u0026rsquo; ，因为它的下一个字符不为数字。\n示例 4： 输入: \u0026ldquo;words and 987\u0026rdquo;\n输出: 0\n解释: 第一个非空字符是 \u0026lsquo;w\u0026rsquo;, 但它不是数字或正、负号。\n因此无法执行有效的转换。\n示例 5： 输入: \u0026ldquo;-91283472332\u0026rdquo;\n输出: -2147483648\n解释: 数字 \u0026ldquo;-91283472332\u0026rdquo; 超过 32 位有符号整数范围。\n因此返回 INT_MIN (−231) 。\n限制： 所有元素乘积之和不会溢出 32 位整数 a.length \u0026lt;= 100000 解题思路 模拟 去除开头空格，校验正负号，转换数字，注意要进行越界检查。\nfunc strToInt(str string) int { ans := 0 i := 0 for ; i \u0026lt; len(str) \u0026amp;\u0026amp; str[i] == \u0026#39; \u0026#39;; i++ { } if i == len(str) { return ans } plus := true if str[i] == \u0026#39;-\u0026#39; { i++ plus = false } else if str[i] == \u0026#39;+\u0026#39; { i++ } for ; i \u0026lt; len(str) \u0026amp;\u0026amp; str[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; str[i] \u0026lt;= \u0026#39;9\u0026#39;; i++ { if plus { if ans \u0026gt; math.MaxInt32/10 || (ans == math.MaxInt32/10 \u0026amp;\u0026amp; int(str[i]-\u0026#39;0\u0026#39;) \u0026gt; math.MaxInt32%10) { return math.MaxInt32 } ans = ans*10 + int(str[i]-\u0026#39;0\u0026#39;) } else { if ans \u0026lt; math.MinInt32/10 || (ans == math.MinInt32/10 \u0026amp;\u0026amp; -int(str[i]-\u0026#39;0\u0026#39;) \u0026lt; math.MinInt32%10) { return math.MinInt32 } ans = ans*10 - int(str[i]-\u0026#39;0\u0026#39;) } } return ans } 复杂度 时间复杂度：$ O(N), N = len(str) $ 空间复杂度：$ O(1) $ ","date":"2021-10-02T13:19:01+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-67.-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/","title":"剑指 Offer 67. 把字符串转换成整数"},{"content":"链接： https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/\n难度： 中等\n题目描述 给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。\n示例： 输入: [1,2,3,4,5]\n输出: [120,60,40,30,24]\n限制： 所有元素乘积之和不会溢出 32 位整数 a.length \u0026lt;= 100000 解题思路 前后缀积 计算前缀积 prefixProduct 和后缀积 suffixProduct，然后求得 B[i] = prefixProduct[i-1] * suffixProduct[i+1]。\nfunc constructArr(a []int) []int { if len(a) == 0 { return make([]int, 0) } ans := make([]int, len(a)) ans[0] = 1 for i, prefixProduct := 1, 1; i \u0026lt; len(a); i++ { prefixProduct *= a[i-1] ans[i] = prefixProduct } for i, suffixProduct := len(a)-2, 1; i \u0026gt;= 0; i-- { suffixProduct *= a[i+1] ans[i] *= suffixProduct } return ans } 复杂度 时间复杂度：$ O(N), N = len(a) $ 空间复杂度：$ O(1) $ ","date":"2021-10-01T22:53:59+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-66.-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/","title":"剑指 Offer 66. 构建乘积数组"},{"content":"链接： https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/\n难度： 简单\n题目描述 写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。\n示例： 输入: a = 1, b = 1\n输出: 2\n限制： a, b 均可能是负数或 0 结果不会溢出 32 位整数 解题思路 位运算 以二进制位为单位进行运算，从最低位开始，使用位操作符诸位运算。\n由于负数在计算机中存储的是补码，直接诸位求和即可，用 c 表示进位，利用 数字电路设计 得到计算方法如下：\n当前位计算结果为：$a\\oplus b\\oplus c$ 进位的计算结果为：$(a\\oplus b)c + ab$ func add(a int, b int) int { ans := 0 c := 0 for bit := 1; bit != 0; bit \u0026lt;\u0026lt;= 1 { ans |= (a ^ b ^ c) \u0026amp; bit c = (((a ^ b) \u0026amp; c) | (a \u0026amp; b)) \u0026amp; bit \u0026lt;\u0026lt; 1 } return ans } 复杂度 时间复杂度：$ O(\\log{MaxInt32}) $ 空间复杂度：$ O(1) $ ","date":"2021-10-01T22:35:56+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-65.-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/","title":"剑指 Offer 65. 不用加减乘除做加法"},{"content":"链接： https://leetcode-cn.com/problems/qiu-12n-lcof/\n难度： 中等\n题目描述 求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n示例 1： 输入: n = 3\n输出: 6\n示例 2： 输入: n = 9\n输出: 45\n限制： 1 \u0026lt;= n \u0026lt;= 10000 解题思路 递归 利用布尔表达式的短路返回，实现递归到终止条件。\nfunc sumNums(n int) int { ans := 0 var sum func(n int) bool sum = func(n int) bool { ans += n return n \u0026gt; 0 \u0026amp;\u0026amp; sum(n-1) } sum(n) return ans } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(n) $ ","date":"2021-10-01T20:44:05+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-64.-%E6%B1%821-2-n/","title":"剑指 Offer 64. 求1+2+…+n"},{"content":"链接： https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/\n难度： 中等\n题目描述 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？\n示例 1： 输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。\n示例 2： 输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。\n限制： 0 \u0026lt;= 数组长度 \u0026lt;= 105 解题思路 暴力求解 枚举买卖点，记录最大值。\nfunc maxProfit(prices []int) int { ans := 0 for i := range prices { for j := i + 1; j \u0026lt; len(prices); j++ { if ans \u0026lt; prices[j]-prices[i] { ans = prices[j] - prices[i] } } } return ans } 复杂度 时间复杂度：$ O(N^2), N = len(prices) $ 空间复杂度：$ O(1) $ 遍历 使用 min 记录到目前为止股票的最小值，每次使用当前股票价格减去 min ，更新最大利润。\nfunc maxProfit(prices []int) int { min := int(math.MaxInt32) ans := 0 for _, price := range prices { if min \u0026gt; price { min = price } if ans \u0026lt; price - min { ans = price - min } } return ans } 复杂度 时间复杂度：$ O(N), N = len(prices) $ 空间复杂度：$ O(1) $ ","date":"2021-10-01T20:29:26+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-63.-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/","title":"剑指 Offer 63. 股票的最大利润"},{"content":"链接： https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/\n难度： 简单\n题目描述 0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。\n例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。\n示例 1： 输入: n = 5, m = 3\n输出: 3\n示例 2： 输入: n = 10, m = 17\n输出: 2\n限制： 1 \u0026lt;= n \u0026lt;= 105 1 \u0026lt;= m \u0026lt;= 106 解题思路 递归 令 f(n, m) 表示从 n 个数字中不断删除第 m 个数字后剩余的数字， 则需要删除的数字为 (m-1) % n，然后变成了从 n-1 个数字中删除第 m 个数字。\nf(n-1, m) 可以得到从第 n-1 个数字中不断删除第 m 个数字后剩余的数字，该表达式是按照从第一个数字开始计数；然而在删除一个数字后，需要从 m % n 开始计数，故需要找到两者间的映射关系，即 f(n, m) = F(f(n-1, m))。\nf(n, m) m%n (m+1)%n \u0026hellip; n-1 0 1 \u0026hellip; (m-2)%n f(n-1, m) 0 1 \u0026hellip; (n-1-m)%n (0-m)%n (1-m)%n \u0026hellip; n-2 通过上表得到递归公式： f(n, m) = (f(n-1, m) + m) % n；\n当仅剩一个数字时，返回该数字，递归中止条件为 f(1, m) = 0。\nfunc lastRemaining(n int, m int) int { if n == 1 { return 0 } return (lastRemaining(n-1, m) + m) % n } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(n) $ 迭代 将上述递归修改为迭代，降低空间复杂度。\nfunc lastRemaining(n int, m int) int { ans := 0 for i := 2; i \u0026lt;= n; i++ { ans = (ans + m) % i } return ans } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2021-10-01T14:38:53+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-62.-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/","title":"剑指 Offer 62. 圆圈中最后剩下的数字"},{"content":"链接： https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/\n难度： 简单\n题目描述 从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。\n示例 1： 输入: [1,2,3,4,5]\n输出: True\n示例 2： 输入: [0,0,1,2,5]\n输出: True\n限制： 数组长度为 5 数组的数取值为 [0, 13] . 解题思路 排序 排序，统计大小王的数量，判断其余相邻牌的差值：\n当差值为 0 时，不构成顺子，返回 false； 当差值不为 0 时，使用大小王去补。 最后，当大小王数量不为负时，返回 true，否则返回 false 。 func isStraight(nums []int) bool { sort.Ints(nums) cnt := 0 for i := 0; i \u0026lt; len(nums); i++ { if nums[i] == 0 { cnt++ continue } if i-1 \u0026gt;= 0 \u0026amp;\u0026amp; nums[i-1] != 0 { diff := nums[i] - nums[i-1] if diff \u0026lt; 1 { return false } cnt -= diff - 1 } } return cnt \u0026gt;= 0 } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-10-01T14:17:17+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-61.-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/","title":"剑指 Offer 61. 扑克牌中的顺子"},{"content":"链接： https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/\n难度： 中等\n题目描述 请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是$O(1)$。\n若队列为空，pop_front 和 max_value 需要返回 -1 。\n示例 1： 输入:\n[\u0026ldquo;MaxQueue\u0026rdquo;,\u0026ldquo;push_back\u0026rdquo;,\u0026ldquo;push_back\u0026rdquo;,\u0026ldquo;max_value\u0026rdquo;,\u0026ldquo;pop_front\u0026rdquo;,\u0026ldquo;max_value\u0026rdquo;]\n[[],[1],[2],[],[],[]]\n输出: [null,null,null,2,1,2]\n示例 2： 输入:\n[\u0026ldquo;MaxQueue\u0026rdquo;,\u0026ldquo;pop_front\u0026rdquo;,\u0026ldquo;max_value\u0026rdquo;]\n[[],[],[]]\n输出: [null,-1,-1]\n限制： 1 \u0026lt;= push_back,pop_front,max_value的总操作数 \u0026lt;= 10000 1 \u0026lt;= value \u0026lt;= 105 解题思路 双队列 除正常存储数据的队列外，需要额外使用一个队列维护最大值信息。\n可以发现，当某一个值入队后，之前入队的所有小于该值的元素对于 max_value 均无影响；仅当该值出队后，由此值后面的次大元素接任。\n所以这个额外队列的队列头记录当前队列的最大值，后续按值非严格递减的顺序记录其他值。\n当入队时，需要从尾部开始将小于当前值的元素全部删除，然后该值入队； 当出队时，若队首元素是最大值，则两个队列都要出队。 type MaxQueue struct { queue *list.List maxQueue *list.List } func Constructor() MaxQueue { return MaxQueue{ queue: list.New(), maxQueue: list.New(), } } func (this *MaxQueue) Max_value() int { if this.maxQueue.Len() == 0 { return -1 } return this.maxQueue.Front().Value.(int) } func (this *MaxQueue) Push_back(value int) { this.queue.PushBack(value) for this.maxQueue.Len() \u0026gt; 0 \u0026amp;\u0026amp; this.maxQueue.Back().Value.(int) \u0026lt; value { this.maxQueue.Remove(this.maxQueue.Back()) } this.maxQueue.PushBack(value) } func (this *MaxQueue) Pop_front() int { if this.queue.Len() == 0 { return -1 } front := this.queue.Front().Value.(int) this.queue.Remove(this.queue.Front()) if this.maxQueue.Front().Value.(int) == front { this.maxQueue.Remove(this.maxQueue.Front()) } return front } 复杂度 时间复杂度： max_value：$ O(1) $ push_back：$ O(1) $ pop_front：$ O(1) $ 空间复杂度：$ O(N) $ ","date":"2021-10-01T13:26:38+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-59-ii.-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","title":"剑指 Offer 59 - II. 队列的最大值"},{"content":"链接： https://leetcode-cn.com/problems/destination-city/\n难度： 中等\n题目描述 给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。\n题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。\n示例 1： 输入： paths = [[\u0026ldquo;London\u0026rdquo;,\u0026ldquo;New York\u0026rdquo;],[\u0026ldquo;New York\u0026rdquo;,\u0026ldquo;Lima\u0026rdquo;],[\u0026ldquo;Lima\u0026rdquo;,\u0026ldquo;Sao Paulo\u0026rdquo;]]\n输出： \u0026ldquo;Sao Paulo\u0026rdquo;\n解释： 从 \u0026ldquo;London\u0026rdquo; 出发，最后抵达终点站 \u0026ldquo;Sao Paulo\u0026rdquo; 。本次旅行的路线是 \u0026ldquo;London\u0026rdquo; -\u0026gt; \u0026ldquo;New York\u0026rdquo; -\u0026gt; \u0026ldquo;Lima\u0026rdquo; -\u0026gt; \u0026ldquo;Sao Paulo\u0026rdquo; 。\n示例 2: 输入： paths = [[\u0026ldquo;B\u0026rdquo;,\u0026ldquo;C\u0026rdquo;],[\u0026ldquo;D\u0026rdquo;,\u0026ldquo;B\u0026rdquo;],[\u0026ldquo;C\u0026rdquo;,\u0026ldquo;A\u0026rdquo;]]\n输出： \u0026ldquo;A\u0026rdquo;\n解释： 所有可能的线路是：\n\u0026ldquo;D\u0026rdquo; -\u0026gt; \u0026ldquo;B\u0026rdquo; -\u0026gt; \u0026ldquo;C\u0026rdquo; -\u0026gt; \u0026ldquo;A\u0026rdquo;.\n\u0026ldquo;B\u0026rdquo; -\u0026gt; \u0026ldquo;C\u0026rdquo; -\u0026gt; \u0026ldquo;A\u0026rdquo;.\n\u0026ldquo;C\u0026rdquo; -\u0026gt; \u0026ldquo;A\u0026rdquo;.\n\u0026ldquo;A\u0026rdquo;.\n显然，旅行终点站是 \u0026ldquo;A\u0026rdquo; 。\n示例 3: 输入： paths = [[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;Z\u0026rdquo;]]\n输出： \u0026ldquo;Z\u0026rdquo;\n提示： 1 \u0026lt;= paths.length \u0026lt;= 100 paths[i].length == 2 1 \u0026lt;= cityAi.length, cityBi.length \u0026lt;= 10 cityAi != cityBi 所有字符串均由大小写英文字母和空格字符组成。 解题思路 哈希 使用一个哈希表记录可以当前城市可以去往的其他城市的数量，也即图中该结点的出度。\n之后遍历哈希表，返回出度为 0 的结点。\nfunc destCity(paths [][]string) string { outDegrees := make(map[string]int) for _, path := range paths { outDegrees[path[0]]++ outDegrees[path[1]] += 0 } for city, outDegree := range outDegrees { if outDegree == 0 { return city } } return \u0026#34;\u0026#34; } 复杂度 时间复杂度：$ O(N), N=len(paths) $ 空间复杂度：$ O(N) $ ","date":"2021-10-01T13:11:21+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1436.-%E6%97%85%E8%A1%8C%E7%BB%88%E7%82%B9%E7%AB%99/","title":"Leetcode 1436. 旅行终点站"},{"content":"链接： https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/\n难度： 简单\n题目描述 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\u0026quot;abcdefg\u0026quot;和数字2，该函数将返回左旋转两位得到的结果\u0026quot;cdefgab\u0026quot;。\n示例 1： 输入: s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2\n输出: \u0026ldquo;cdefgab\u0026rdquo;\n示例 2： 输入: s = \u0026ldquo;lrloseumgh\u0026rdquo;, k = 6\n输出: \u0026ldquo;umghlrlose\u0026rdquo;\n限制： 1 \u0026lt;= k \u0026lt; s.length \u0026lt;= 10000 解题思路 暴力求解 每次循环移动一个字符，重复 n 次。\nfunc reverseLeftWords(s string, n int) string { chars := []byte(s) for i := 0; i \u0026lt; n; i++ { char := s[0] for j := 0; j \u0026lt; len(s); j++ { chars[j] = chars[j+1] } chars[len(s)-1] = char } return string(chars) } 复杂度 时间复杂度：$ O(Ln), L = len(s) $ 空间复杂度：$ O(1) $ 切片 移动后的结果为：前 n 个字符移动到字符串的尾部，使用切片即可。\nfunc reverseLeftWords(s string, n int) string { return s[n:len(s)] + s[0:n] } 复杂度 时间复杂度：$ O(L), L = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-09-30T20:41:59+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-58-ii.-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"剑指 Offer 58 - II. 左旋转字符串"},{"content":"链接： https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/\n难度： 简单\n题目描述 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串\u0026quot;I am a student. \u0026quot;，则输出\u0026quot;student. a am I\u0026quot;。\n示例 1： 输入: \u0026ldquo;the sky is blue\u0026rdquo;\n输出: \u0026ldquo;blue is sky the\u0026rdquo;\n示例 2： 输入: \u0026quot; hello world! \u0026quot;\n输出: \u0026ldquo;world! hello\u0026rdquo;\n解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n示例 3： 输入: \u0026ldquo;a good example\u0026rdquo;\n输出: \u0026ldquo;example good a\u0026rdquo;\n解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。\n说明： 无空格字符构成一个单词。 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 解题思路 模拟 将整个句子识别拆分为单词数组，将整个单词数组反转，然后使用 ' ' 作为连接符将整个单词数组连接起来。\nfunc reverseWords(s string) string { ss := make([]string, 0, 10) start := 0 for i := range s { if s[i] == \u0026#39; \u0026#39; { if start == i { start++ continue } ss = append(ss, s[start:i]) start = i+1 } } for i := 0; i \u0026lt; len(ss)/2; i++ { ss[i], ss[len(ss)-1-i] = ss[len(ss)-1-i], ss[i] } return strings.Join(ss, \u0026#34; \u0026#34;) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(N) $ ","date":"2021-09-30T20:21:30+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-58-i.-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/","title":"剑指 Offer 58 - I. 翻转单词顺序"},{"content":"链接： https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/\n难度： 简单\n题目描述 输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。\n示例 1： 输入： target = 9\n输出： [[2,3,4],[4,5]]\n示例 2： 输入： target = 15\n输出： [[1,2,3,4,5],[4,5,6],[7,8]]\n限制： 1 \u0026lt;= target \u0026lt;= 105 解题思路 双指针 使用两个指针 i 和 j 代表连续正整数区间的两个端点，另使用变量 sum 记录该段区间的和。\n当 sum 小于 target 时，j 移动； 当 sum 大于 target 时，i 移动； 当 sum 等于 target 时，将区间加入到结果队列中，i 移动。 遍历到 j 大于 target 时结束，返回\nfunc findContinuousSequence(target int) [][]int { ans := make([][]int, 0, 1) sum := 1 for i, j := 1, 1; j \u0026lt; target; { if sum \u0026lt; target { j++ sum += j } else if sum \u0026gt; target { sum -= i i++ } else { t := make([]int, 0, j-i+1) for k := i; k \u0026lt;= j; k++ { t = append(t, k) } ans = append(ans, t) sum -= i i++ } } return ans } 复杂度 时间复杂度：$ O(target) $ 空间复杂度：$ O(1) $ ","date":"2021-09-30T20:04:58+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-57-ii.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/","title":"剑指 Offer 57 - II. 和为s的连续正数序列"},{"content":"链接： https://leetcode-cn.com/problems/diameter-of-binary-tree/\n难度： 简单\n题目描述 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。\n示例： 给定二叉树\n1 / \\ 2 3 / \\ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。\n注意： 两结点之间的路径长度是以它们之间边的数目表示。 解题思路 后序遍历 某个子树的最大直径或者为左右子树的最大直径，或者为跨越当前根结点的左右子树的高度和。\n递归的遍历每棵子树，返回找到的最大直径。\nfunc diameterOfBinaryTree(root *TreeNode) int { var dfs func(node *TreeNode) (int, int) dfs = func(node *TreeNode) (int, int) { if node == nil { return 0, 0 } lDepth, lMax := dfs(node.Left) rDepth, rMax := dfs(node.Right) depth := lDepth if depth \u0026lt; rDepth { depth = rDepth } max := lDepth + rDepth if max \u0026lt; lMax { max = lMax } if max \u0026lt; rMax { max = rMax } return depth+1, max } _, max := dfs(root) return max } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-09-30T12:00:42+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-543.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","title":"Leetcode 543. 二叉树的直径"},{"content":"链接： https://leetcode-cn.com/problems/binary-tree-right-side-view/\n难度： 中等\n题目描述 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n示例 1： 输入: [1,2,3,null,5,null,4]\n输出: [1,3,4]\n示例 2： 输入: [1,null,3]\n输出: [1,3]\n示例 3： 输入: []\n输出: []\n提示： 二叉树的节点个数的范围是 [0,100] -100 \u0026lt;= Node.val \u0026lt;= 100 解题思路 先序遍历 先序遍历二叉树，同时传递深度信息，对于每个遍历到的结点，修改对应深度的结点为当前结点。\nfunc rightSideView(root *TreeNode) []int { ans := make([]int, 0, 10) var dfs func(node *TreeNode, depth int) dfs = func(node *TreeNode, depth int) { if node == nil { return } if depth == len(ans) { ans = append(ans, node.Val) } else { ans[depth] = node.Val } dfs(node.Left, depth+1) dfs(node.Right, depth+1) } dfs(root, 0) return ans } 复杂度 时间复杂度：$ O(N) , N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ 层序遍历 使用一个队列，逐层遍历，将每层最右结点的值置即为该层的右视图的值。\nfunc rightSideView(root *TreeNode) []int { if root == nil { return make([]int, 0) } ans := make([]int, 0, 10) q := list.New() q.PushBack(root) for depth := 0; q.Len() \u0026gt; 0; depth++ { ans = append(ans, 0) for i := q.Len(); i \u0026gt; 0; i-- { node := q.Front().Value.(*TreeNode) q.Remove(q.Front()) ans[depth] = node.Val if node.Left != nil { q.PushBack(node.Left) } if node.Right != nil { q.PushBack(node.Right) } } } return ans } 复杂度 时间复杂度：$ O(N) , N = size(Tree) $ 空间复杂度：$ O(N) $ ","date":"2021-09-30T11:24:18+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-199.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/","title":"Leetcode 199. 二叉树的右视图"},{"content":"链接： https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\n难度： 中等\n题目描述 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n进阶： 你能尝试使用一趟扫描实现吗？\n示例 1： 输入： head = [1,2,3,4,5], n = 2\n输出： [1,2,3,5]\n示例 2： 输入： head = [1], n = 1\n输出： []\n示例 3： 输入： head = [1,2], n = 1\n输出： [1]\n提示： 链表中结点的数目为 sz 1 \u0026lt;= sz \u0026lt;= 30 0 \u0026lt;= Node.val \u0026lt;= 100 1 \u0026lt;= n \u0026lt;= sz 解题思路 计算链表长度 遍历一遍列表，得到链表长度，从而求得距离链表头的偏移量，再次遍历将其删除即可。\n当删除的是第一个结点是需要特判，返回 head.Next。\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode { length := 0 for node := head; node != nil; node = node.Next { length++ } if n == length { return head.Next } node := head for i := length - n; i \u0026gt; 1; i-- { node = node.Next } node.Next = node.Next.Next return head } 复杂度 时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(1) $ 双指针 使用两个指针，首先将其中一个快指针移动 n 次，然后两个指针同时移动，当快指针指向最后一个结点时，慢指针指向当前需要删除的结点的上一个节点，修改其 Next 指针。\n当删除的是第一个结点是需要特判，返回 head.Next。\nfunc removeNthFromEnd(head *ListNode, n int) *ListNode { fast := head for i := 0; i \u0026lt; n; i++ { fast = fast.Next } if fast == nil { return head.Next } slow := head for fast.Next != nil { slow = slow.Next fast = fast.Next } slow.Next = slow.Next.Next return head } 复杂度 时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(1) $ ","date":"2021-09-30T10:58:01+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-19.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/","title":"Leetcode 19. 删除链表的倒数第 N 个结点"},{"content":"链接： https://leetcode-cn.com/problems/permutations/\n难度： 中等\n题目描述 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n示例 1： 输入： nums = [1,2,3]\n输出： [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n示例 2： 输入： nums = [0,1]\n输出： [[0,1],[1,0]]\n示例 3： 输入： nums = [1]\n输出： [[1]]\n提示： 1 \u0026lt;= nums.length \u0026lt;= 6 -10 \u0026lt;= nums[i] \u0026lt;= 10 nums 中的所有整数 互不相同 解题思路 回溯 每次从可选数字中选出一个数，加入到栈中，直到栈中元素数量与原数组相同，则其为其中一个的全排列，加入到结果中，回溯，重复上述步骤，直到搜索到所有情况。\nfunc permute(nums []int) [][]int { cnt := 1 for i := 2; i \u0026lt;= len(nums); i++ { cnt *= i } ans := make([][]int, 0, cnt) choice := make(map[int]struct{}) var backtracking func(stack []int) backtracking = func(stack []int) { if len(stack) == len(nums) { t := make([]int, len(stack)) copy(t, stack) ans = append(ans, t) return } for _, num := range nums { if _, ok := choice[num]; ok { continue } choice[num] = struct{}{} stack = append(stack, num) backtracking(stack) stack = stack[:len(stack)-1] delete(choice, num) } } backtracking(make([]int, 0, len(nums))) return ans } 复杂度 时间复杂度：$ O(N*N!), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2021-09-30T10:40:00+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-46.-%E5%85%A8%E6%8E%92%E5%88%97/","title":"Leetcode 46. 全排列"},{"content":"链接： https://leetcode-cn.com/problems/rectangle-area/\n难度： 中等\n题目描述 给你 二维 平面上两个 由直线构成的 矩形，请你计算并返回两个矩形覆盖的总面积。\n每个矩形由其 左下 顶点和 右上 顶点坐标表示：\n第一个矩形由其左下顶点 (ax1, ay1) 和右上顶点 (ax2, ay2) 定义。 第二个矩形由其左下顶点 (bx1, by1) 和右上顶点 (bx2, by2) 定义。 示例 1： 输入： ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\n输出： 45\n示例 2： 输入： ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2\n输出： 16\n提示： -104 \u0026lt;= ax1, ay1, ax2, ay2, bx1, by1, bx2, by2 \u0026lt;= 104 解题思路 模拟 将两个矩阵面积相加，再将重复计算的部分减掉即可。 重复覆盖部分的坐标表示为 (max(ax1, bx1), max(ay1, by1)) 和 (min(ax2, bx2), min(ay2, by2))。\nfunc computeArea(ax1 int, ay1 int, ax2 int, ay2 int, bx1 int, by1 int, bx2 int, by2 int) int { area := (ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1) x1 := ax1 if x1 \u0026lt; bx1 { x1 = bx1 } y1 := ay1 if y1 \u0026lt; by1 { y1 = by1 } x2 := ax2 if x2 \u0026gt; bx2 { x2 = bx2 } y2 := ay2 if y2 \u0026gt; by2 { y2 = by2 } if x1 \u0026lt;= x2 \u0026amp;\u0026amp; y1 \u0026lt;= y2 { area -= (x2 - x1) * (y2 - y1) } return area } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-09-30T10:21:34+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-223.-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/","title":"Leetcode 223. 矩形面积"},{"content":"链接： https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/\n难度： 中等\n题目描述 在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。\n示例 1： 输入： nums = [3,4,3,3]\n输出： 4\n示例 2： 输入： nums = [9,1,7,9,7,9,7]\n输出： 1\n限制： 1 \u0026lt;= nums.length \u0026lt;= 10000 1 \u0026lt;= nums[i] \u0026lt; 231 解题思路 哈希 使用哈希表记录每个数字出现的次数，找到出现次数为 1 的返回即可。\nfunc singleNumber(nums []int) int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ } for num, v := range cnt { if v == 1 { return num } } return 0 } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ 排序 将整个数组排序，没三个一组进行首尾比较，相同继续，不同返回。\nfunc singleNumber(nums []int) int { sort.Ints(nums) res := nums[0] for i := 2; i \u0026lt; len(nums); i += 3 { if res == nums[i] { res = nums[i+1] continue } else { break } } return res } 复杂度 时间复杂度：$ O(NlogN), N = len(nums) $ 空间复杂度：$ O(\\log{N}) $ 位运算 统计每一位的数字总和，其必然是 0 或者 3n+1，在统计过程中就可以逢3清零，依次求解下去即可。 考虑用两个位 a, b 记录求和数据，表如下所示:\ncur num next 00 0 00 00 1 01 01 0 01 01 1 10 10 0 10 10 1 00 根据上表可推导出 a 和 b 的变换表：\na b x new_a 0 0 0 0 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 1 1 0 1 0 得到a的转移方程： new_a = a'bx + ab'x'\nb a x new_b 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 0 1 0 0 1 1 0 1 0 得到b的转移方程： new_b = a'b'x + a'bx' = a'(b'x+bx') = a'(b⊕x)\nfunc singleNumber(nums []int) int { a, b := 0, 0 for _, x := range nums { t := ^a\u0026amp;b\u0026amp;x | a\u0026amp;^b\u0026amp;^x b = ^a \u0026amp; (b ^ x) a = t } return b } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-09-29T20:54:30+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-56-ii.-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-ii/","title":"剑指 Offer 56 - II. 数组中数字出现的次数 II"},{"content":"链接： https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/\n难度： 中等\n题目描述 一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是$O(n)$，空间复杂度是$O(1)$。\n示例 1： 输入： nums = [4,1,4,6]\n输出： [1,6] 或 [6,1]\n示例 2： 输入： nums = [1,2,10,4,1,4,3,3]\n输出： [2,10] 或 [10,2]\n限制： 2 \u0026lt;= nums.length \u0026lt;= 10000 解题思路 异或 + 拆分 将整个数组进行异或操作，得到最后的两个数字的异或值。从其中找出为 1 的位，按照此位将数组中的数字分为两组，则同一对数字必然在同一组，不同的两个数在不同组，对两组分别求异或即可得出结果。\nfunc singleNumbers(nums []int) []int { xor := 0 for _, num := range nums { xor ^= num } bit := 1 for ; xor\u0026amp;bit == 0; bit \u0026lt;\u0026lt;= 1 { } ans0 := 0 ans1 := 0 for _, num := range nums { if num\u0026amp;bit == 0 { ans0 ^= num } else { ans1 ^= num } } return []int{ans0, ans1} } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-09-29T19:35:15+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-56-i.-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","title":"剑指 Offer 56 - I. 数组中数字出现的次数"},{"content":"链接： https://leetcode-cn.com/problems/path-sum-iii/\n难度： 中等\n题目描述 给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。\n路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。\n示例 1： 输入： root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8\n输出： 3\n解释： 和等于 8 的路径有 3 条，如图所示。\n示例 2： 输入： root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n输出： 3\n提示： 二叉树的节点个数的范围是 [0,1000] -109 \u0026lt;= Node.val \u0026lt;= 109 -1000 \u0026lt;= targetSum \u0026lt;= 1000 解题思路 深度优先搜索 + 前缀和 采用深度优先搜索，并将从根到当前结点的路径和保存到哈希表中，记录该和出现的数量。\n每当到达一个新结点时，查找到该结点的前缀和减去 target 是否存在于路径中，存在将其次数累加进结果中，然后递归的处理子结点，也将查询结果累加进结果中。\n为保证从根结点开始的路径满足条件，初始哈希表中设置前缀和为 0 的次数为 1。\nfunc pathSum(root *TreeNode, targetSum int) int { cnt := make(map[int]int) cnt[0] = 1 var dfs func(node *TreeNode, sum int) int dfs = func(node *TreeNode, sum int) int { if node == nil { return 0 } sum += node.Val ans := cnt[sum-targetSum] cnt[sum]++ ans += dfs(node.Left, sum) ans += dfs(node.Right, sum) cnt[sum]-- return ans } return dfs(root, 0) } 复杂度 时间复杂度：$ O(N), N = size(List) $ 空间复杂度：$ O(N) $ ","date":"2021-09-28T14:08:48+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-437.-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-iii/","title":"Leetcode 437. 路径总和 III"},{"content":"链接： https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/\n难度： 简单\n题目描述 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。\n示例 1： 给定二叉树 [3,9,20,null,null,15,7]\n3 / \\ 9 20 / \\ 15 7 返回 true 。\n示例 2： 给定二叉树 [1,2,2,3,3,null,null,4,4]\n1 / \\ 2 2 / \\ 3 3 / \\ 4 4 返回 false 。\n限制： 0 \u0026lt;= 树的结点个数 \u0026lt;= 10000 解题思路 深度优先搜索 递归的遍历每个结点的左右子树，当左右子树均为平衡树且左右子树的最大深度差值 ≤ 1 时，返回 true。\nfunc isBalanced(root *TreeNode) bool { var dfs func(root *TreeNode) (int, bool) dfs = func(root *TreeNode) (int, bool) { if root == nil { return 0, true } leftDepth, leftBalance := dfs(root.Left) rightDepth, rightBalance := dfs(root.Right) if leftDepth \u0026gt; rightDepth { return leftDepth+1, leftDepth-rightDepth \u0026lt;= 1 \u0026amp;\u0026amp; leftBalance \u0026amp;\u0026amp; rightBalance } else { return rightDepth+1, rightDepth-leftDepth \u0026lt;= 1 \u0026amp;\u0026amp; leftBalance \u0026amp;\u0026amp; rightBalance } } _, ans := dfs(root) return ans } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-09-28T13:21:08+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-55-ii.-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"剑指 Offer 55 - II. 平衡二叉树"},{"content":"链接： https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/\n难度： 简单\n题目描述 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。\n例如：\n给定二叉树 [3,9,20,null,null,15,7]，\n3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。\n提示： 节点总数 \u0026lt;= 10000 解题思路 深度优先搜索 递归的遍历每个结点的左右子树，获得子树最大深度，+1 后返回，当结点不存在时，树高为空\nfunc maxDepth(root *TreeNode) int { if root == nil { return 0 } depth := maxDepth(root.Left) rDepth := maxDepth(root.Right) if depth \u0026lt; rDepth { depth = rDepth } return depth + 1 } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-09-28T12:16:07+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-55-i.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/","title":"剑指 Offer 55 - I. 二叉树的深度"},{"content":"链接： https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/\n难度： 简单\n题目描述 一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。\n示例 1： 输入: [0,1,3]\n输出: 2\n示例 2： 输入: [0,1,2,3,4,5,6,7,9]\n输出: 8\n提示： 1 \u0026lt;= 数组长度 \u0026lt;= 10000 解题思路 哈希 使用哈希表标识出现过数字，遍历数据，将位于数组中的数字添加到哈希表中，然后在哈希表中寻找没有出现过的数。\nfunc missingNumber(nums []int) int { exist := make(map[int]struct{}) for _, num := range nums { exist[num] = struct{}{} } for i := 0; i \u0026lt; len(nums); i++ { if _, ok := exist[i]; !ok { return i } } return len(nums) } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ 顺序查找 由于数组递增，只需要找到与下标不相同的数，返回其下标即可。\nfunc missingNumber(nums []int) int { for i, num := range nums { if i != num { return i } } return len(nums) } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ 二分查找 由于数组递增，下标一定是与当前数字一致的，每次找出中间数字，\n当与下标一致时，说明前半区间的数字都符合条件，从后半区间查找； 否则，去前半区间查找。 最终查找到区间为空时候为止。\nfunc missingNumber(nums []int) int { l, r := 0, len(nums)-1 for l \u0026lt;= r { mid := (l+r)/2 if mid == nums[mid] { l = mid+1 } else { r = mid-1 } } return l } 复杂度 时间复杂度：$ O(\\log{N}), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-09-28T11:25:44+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-53-ii.-0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","title":"剑指 Offer 53 - II. 0～n-1中缺失的数字"},{"content":"链接： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/\n难度： 简单\n题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。\n例如:\n给定二叉树: [3,9,20,null,null,15,7],\n3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果：\n[ [3], [20,9], [15,7] ] 提示： 节点总数 \u0026lt;= 1000 解题思路 层序遍历 使用一个双端队列记录遍历到的结点，初始时根结点入队。\n奇偶分离，偶数层从头至尾遍历完当前整层的所有元素，子结点先左后右从队尾入队；奇数层从尾至头遍历整层所有元素，子结点先右后左从队头入队。\n每次遍历到的结点值加入到结果队列中，直至队列为空为止。\nfunc levelOrder(root *TreeNode) [][]int { ans := make([][]int, 0) if root == nil { return ans } q := list.New() q.PushBack(root) for q.Len() \u0026gt; 0 { // 先偶数层 tmp := make([]int, 0, 1) for i := q.Len(); i \u0026gt; 0 ; i-- { node := q.Front().Value.(*TreeNode) q.Remove(q.Front()) tmp = append(tmp, node.Val) if node.Left != nil { q.PushBack(node.Left) } if node.Right != nil { q.PushBack(node.Right) } } ans = append(ans, tmp) // 空跳过 if q.Len() == 0 { break } // 后奇数层 tmp = make([]int, 0, 1) for i := q.Len(); i \u0026gt; 0 ; i-- { node := q.Back().Value.(*TreeNode) q.Remove(q.Back()) tmp = append(tmp, node.Val) if node.Right != nil { q.PushFront(node.Right) } if node.Left != nil { q.PushFront(node.Left) } } ans = append(ans, tmp) } return ans } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(N) $ ","date":"2021-09-27T19:19:06+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-iii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/","title":"剑指 Offer 32 - III. 从上到下打印二叉树 III"},{"content":"链接： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/\n难度： 简单\n题目描述 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。\n例如:\n给定二叉树: [3,9,20,null,null,15,7],\n3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果：\n[ [3], [9,20], [15,7] ] 提示： 节点总数 \u0026lt;= 1000 解题思路 层序遍历 使用一个队列记录遍历到的结点，初始时根结点入队，每次从头至尾遍历完当前整层的所有元素，并加入到结果队列，按顺序依次将左右非空子结点入队，直到队列为空。\nfunc levelOrder(root *TreeNode) [][]int { ans := make([][]int, 0) if root == nil { return ans } q := list.New() q.PushBack(root) for q.Len() \u0026gt; 0 { ans = append(ans, make([]int, 0, 1)) for i := q.Len(); i \u0026gt; 0 ; i-- { node := q.Front().Value.(*TreeNode) q.Remove(q.Front()) ans[len(ans)-1] = append(ans[len(ans)-1], node.Val) if node.Left != nil { q.PushBack(node.Left) } if node.Right != nil { q.PushBack(node.Right) } } } return ans } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(N) $ ","date":"2021-09-27T19:05:28+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-ii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/","title":"剑指 Offer 32 - II. 从上到下打印二叉树 II"},{"content":"链接： https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/\n难度： 中等\n题目描述 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。\n例如:\n给定二叉树: [3,9,20,null,null,15,7],\n3 / \\ 9 20 / \\ 15 7 返回：\n[3,9,20,15,7]\n提示： 节点总数 \u0026lt;= 1000 解题思路 层序遍历 使用一个队列记录遍历到的结点，初始时根结点入队，每次从队头取出一个结点，将其值加入到结果队列，并按顺序将左右非空子结点入队，直到队列为空。\nfunc levelOrder(root *TreeNode) []int { ans := make([]int, 0) if root == nil { return ans } q := list.New() q.PushBack(root) for q.Len() \u0026gt; 0 { node := q.Front().Value.(*TreeNode) q.Remove(q.Front()) ans = append(ans, node.Val) if node.Left != nil { q.PushBack(node.Left) } if node.Right != nil { q.PushBack(node.Right) } } return ans } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(N) $ ","date":"2021-09-27T18:48:47+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-32-i.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"剑指 Offer 32 - I. 从上到下打印二叉树"},{"content":"链接： https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/\n难度： 中等\n题目描述 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n\u0026gt;1并且m\u0026gt;1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n示例 1： 输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1\n示例 2： 输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36\n提示： 2 \u0026lt;= n \u0026lt;= 1000 解题思路 数学 + 贪心 + 快速幂 根据几何均值不等式: $$ a_1a_2\u0026hellip;a_m \\leq (\\frac{a_1+a_2+\u0026hellip;+a_m}{m})，当且仅当 a_1=a_2=\u0026hellip;=a_m 时，等式成立 $$ 可以得知，当将绳子等分时，可以获得最大值。\n不妨设每段的长度为 $x$，则共可以分为 $\\frac{n}{x}$ 段，得到乘积的最大值为 $x^\\frac{n}{x} = (x^\\frac{1}{x})^n$。现在需要求此最大值，也即求 $ y=x^\\frac{1}{x} $的最大值。 对 $ y=x^\\frac{1}{x} $ 求导： $$ \\begin{aligned} \\ln{y} \u0026amp;= \\frac{1}{x}\\ln{x}\\\\ \\frac{1}{y}\\frac{\\mathrm{d}y}{\\mathrm{d}x} \u0026amp;= -\\frac{1}{x^2}\\ln{x} + \\frac{1}{x^2}\\\\ \\frac{\\mathrm{d}y}{\\mathrm{d}x} \u0026amp;= \\frac{1-\\ln{x}}{x^2}y\\\\ \u0026amp;= \\frac{1-\\ln{x}}{x^2}x^{\\frac{1}{x}} \\end{aligned} $$ 令 $\\frac{\\mathrm{d}y}{\\mathrm{d}x} = 0$，求得 $x=e$，则在此点处取得最大值。 将最接近的点 $2$ 和 $3$ 代入，得到 $3^\\frac{1}{3} \u0026gt; 2^\\frac{1}{2}$，说明将绳子优先分为长度为 $3$ 的段可以得到乘积的最大值。\n当绳子不能等分为长度为 $3$ 的段时，若最后剩余长度为 $2$，则最后一段为 $2$，若为 $1$，则尝试与上一段长度为 $3$ 的 部分构成 2 个 $2$。\n对于长度为 $3$ 的段，使用快速幂求解；剩余部分如上述策略处理。对于无法分为两段的绳子长度需要特判。\nfunc cuttingRope(n int) int { if n \u0026lt;= 3 { return n - 1 } const MOD = int(1e9 + 7) fastPower := func(x, n int) int { power := 1 for ; n \u0026gt; 0; n \u0026gt;\u0026gt;= 1 { if n\u0026amp;1 == 1 { power = (power * x) % MOD } x = (x * x) % MOD } return power } switch threes, remain := n/3, n%3; remain { case 0: return fastPower(3, threes) case 1: return (fastPower(3, threes-1) * 4) % MOD case 2: return (fastPower(3, threes) * 2) % MOD } return 0 } 复杂度 时间复杂度：$ O(\\log{n}) $ 空间复杂度：$ O(1) $ ","date":"2021-09-27T17:54:22+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-14-ii.-%E5%89%AA%E7%BB%B3%E5%AD%90-ii/","title":"剑指 Offer 14- II. 剪绳子 II"},{"content":"链接： https://leetcode-cn.com/problems/jian-sheng-zi-lcof/\n难度： 中等\n题目描述 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n\u0026gt;1并且m\u0026gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n示例 1： 输入: 2\n输出: 1\n解释: 2 = 1 + 1, 1 × 1 = 1\n示例 2： 输入: 10\n输出: 36\n解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36\n提示： 2 \u0026lt;= n \u0026lt;= 58 解题思路 动态规划 使用 dp[i] 表示绳子长度为 i 时的最大乘积。则：\n初始，dp[1] = 0 dp[i] = max(dp[j], j) * (dp[i-j], i-j), 1 ≤ j \u0026lt; i func cuttingRope(n int) int { dp := make([]int, n+1) dp[1] = 1 for i := 2; i \u0026lt;= n; i++ { for j := 1; j \u0026lt; i; j++ { factor1 := dp[j] if factor1 \u0026lt; j { factor1 = j } factor2 := dp[i-j] if factor2 \u0026lt; i-j { factor2 = i - j } if dp[i] \u0026lt; factor1*factor2 { dp[i] = factor1 * factor2 } } } return dp[n] } 复杂度 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(n) $ ","date":"2021-09-27T17:22:32+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-14-i.-%E5%89%AA%E7%BB%B3%E5%AD%90/","title":"剑指 Offer 14- I. 剪绳子"},{"content":"链接： https://leetcode-cn.com/problems/sum-of-two-integers/\n难度： 中等\n题目描述 给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。 示例 1： 输入： a = 1, b = 2\n输出： 3\n示例 2： 输入： a = 2, b = 3\n输出： 5\n提示： -1000 \u0026lt;= a, b \u0026lt;= 1000 解题思路 位运算 以二进制位为单位进行运算，从最低位开始，使用位操作符诸位运算。\n由于负数在计算机中存储的是补码，直接诸位求和即可，用 c 表示进位，利用 数字电路设计 得到计算方法如下：\n当前位计算结果为：$a\\oplus b\\oplus c$ 进位的计算结果为：$(a\\oplus b)c + ab$ func getSum(a int, b int) int { c := 0 ans := 0 for bit := 1; bit != 0; bit \u0026lt;\u0026lt;= 1 { ans |= (a ^ b ^ c) \u0026amp; bit c = (((a ^ b) \u0026amp; c) | (a \u0026amp; b)) \u0026amp; bit \u0026lt;\u0026lt; 1 } return ans } 复杂度 时间复杂度：$ O(\\log{MaxInt}) $ 空间复杂度：$ O(1) $ ","date":"2021-09-26T09:38:03+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-371.-%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/","title":"Leetcode 371. 两整数之和"},{"content":"链接： https://leetcode-cn.com/problems/delete-operation-for-two-strings/\n难度： 中等\n题目描述 给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。\n示例： 输入: \u0026ldquo;sea\u0026rdquo;, \u0026ldquo;eat\u0026rdquo;\n输出: 2\n解释: 第一步将\u0026quot;sea\u0026quot;变为\u0026quot;ea\u0026quot;，第二步将\u0026quot;eat\u0026quot;变为\u0026quot;ea\u0026quot;\n提示： 给定单词的长度不超过500。 给定单词中的字符只含有小写字母。 进阶： 你可以设计一个时间复杂度为 $O(n)$ 的解决方案吗？\n解题思路 动态规划 最长公共子序列(LCS)的变种，求得最长公共子序列的长度，返回剩余字符的数量。\n使用 dp[i][j] 表示分别以 i 和 j 为 word1 和 word2 前缀长度的最长公共子序列，其状态转移方程如下：\n初始时，dp[0][j] = dp[i][0] = 0 当 word1[i] = word2[j] 时，dp[i][j] = dp[i-1][j-1] + 1；否则，dp[i][j] = max(dp[i-1][j], dp[i][j-1]) func minDistance(word1 string, word2 string) int { dp := make([][]int, len(word1)+1) dp[0] = make([]int, len(word2)+1) for i := range word1 { dp[i+1] = make([]int, len(word2)+1) for j := range word2 { if word1[i] == word2[j] { dp[i+1][j+1] = dp[i][j] + 1 continue } dp[i+1][j+1] = dp[i+1][j] if dp[i+1][j+1] \u0026lt; dp[i][j+1] { dp[i+1][j+1] = dp[i][j+1] } } } return len(word1) + len(word2) - (dp[len(word1)][len(word2)] \u0026lt;\u0026lt; 1) } 复杂度 时间复杂度：$ O(NM), N = len(word1), M = len(word2) $ 空间复杂度：$ O(NM) $ 动态规划 使用 dp[i][j] 表示分别以 i 和 j 为 word1 和 word2 前缀结尾的最少删除操作次数，其状态转移方程如下：\n初始时，dp[0][j] = j, dp[i][0] = i 当 word1[i] = word2[j] 时，dp[i][j] = dp[i-1][j-1]；否则，dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1。 func minDistance(word1 string, word2 string) int { dp := make([][]int, len(word1)+1) dp[0] = make([]int, len(word2)+1) for j := range word2 { dp[0][j+1] = j+1 } for i := range word1 { dp[i+1] = make([]int, len(word2)+1) dp[i+1][0] = i+1 for j := range word2 { if word1[i] == word2[j] { dp[i+1][j+1] = dp[i][j] continue } dp[i+1][j+1] = dp[i+1][j] if dp[i+1][j+1] \u0026gt; dp[i][j+1] { dp[i+1][j+1] = dp[i][j+1] } dp[i+1][j+1]++ } } return dp[len(word1)][len(word2)] } 复杂度 时间复杂度：$ O(NM), N = len(word1), M = len(word2) $ 空间复杂度：$ O(NM) $ ","date":"2021-09-25T10:46:36+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-583.-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C/","title":"Leetcode 583. 两个字符串的删除操作"},{"content":"链接： https://leetcode-cn.com/problems/flatten-a-multilevel-doubly-linked-list/\n难度： 中等\n题目描述 多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。\n给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。\n示例 1： 输入： head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]\n输出： [1,2,3,7,8,11,12,9,10,4,5,6]\n解释：\n输入的多级列表如下图所示：\n扁平化后的链表如下图：\n示例 2： 输入： head = [1,2,null,3]\n输出： [1,3,2]\n解释：\n输入的多级列表如下图所示：\n1---2---NULL | 3---NULL 示例 3： 输入： head = []\n输出： []\n如何表示测试用例中的多级链表？ 以 示例 1 为例：\n1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULL 序列化其中的每一级之后：\n[1,2,3,4,5,6,null] [7,8,9,10,null] [11,12,null] 为了将每一级都序列化到一起，我们需要每一级中添加值为 null 的元素，以表示没有节点连接到上一级的上级节点。\n[1,2,3,4,5,6,null] [null,null,7,8,9,10,null] [null,11,12,null] 合并所有序列化结果，并去除末尾的 null 。\n[1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] 提示： 节点数目不超过 1000 1 \u0026lt;= Node.val \u0026lt;= 105 解题思路 深度优先搜索 采用深度优先搜索，遍历当前链表，当遇到 Child 非空时，优先遍历 Child 链表，每次遍历结束返回链表尾部的指针。\n遍历完成 Child 后，将 Next 结点连接到返回的尾部，并将 Child 的头结点时候连接到当前节点。\nfunc flatten(root *Node) *Node { var dfs func(head *Node) *Node dfs = func(head *Node) *Node { tail := head for node := head; node != nil; node = node.Next { if node.Child != nil { tail := dfs(node.Child) if node.Next != nil { tail.Next = node.Next node.Next.Prev = tail } node.Next = node.Child node.Child.Prev = node node.Child = nil } tail = node } return tail } dfs(root) return root } 复杂度 时间复杂度：$ O(N), N = size(List) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-09-24T10:35:19+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-430.-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","title":"Leetcode 430. 扁平化多级双向链表"},{"content":"链接： https://leetcode-cn.com/problems/power-of-three/\n难度： 简单\n题目描述 给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。\n整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3x\n示例 1： 输入： n = 27\n输出： true\n示例 2： 输入： n = 0\n输出： false\n示例 3： 输入： n = 9\n输出： true\n示例 4： 输入： n = 45\n输出： false\n提示： -231 \u0026lt;= n \u0026lt;= 231 - 1 解题思路 试除法 当当前数字可以被 3 的整除，则除以 3，知道不能被 3 整除为止。\n若最后值为 1，返回 true；否则，返回 false。\n对 ≤ 0 的值一开始进行特判，返回 false。\nfunc isPowerOfThree(n int) bool { if n \u0026lt;= 0 { return false } for n%3 == 0 { n /= 3 } return n == 1 } 复杂度 时间复杂度：$ O(\\log{n}) $ 空间复杂度：$ O(1) $ ","date":"2021-09-23T14:50:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-326.-3%E7%9A%84%E5%B9%82/","title":"Leetcode 326. 3的幂"},{"content":"链接： https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/\n难度： 中等\n题目描述 把 n 个骰子扔在地上，所有骰子朝上一面的点数之和为 s。输入 n，打印出 s 的所有可能的值出现的概率。\n你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。\n示例 1： 输入: 1\n输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]\n示例 2： 输入: 2\n输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]\n限制： 1 \u0026lt;= n \u0026lt;= 11 解题思路 动态规划 由于每个骰子的掷出的点数是独立的，使用 dp[i][j] 表示掷出 i 个骰子，点数之和为 j 的概率：\n初始，dp[0][0] = 1 后续，dp[i][j] = \u0008d[i-1][j-1] / 6 + dp[i-1][j-2] / 6 + ... + dp[i-1][j-6] / 6 使用滚动数组的方式降低空间复杂度。\nfunc dicesProbability(n int) []float64 { dp := []float64{1} for i := 1; i \u0026lt;= n; i++ { dpNew := make([]float64, len(dp)+5) for j := range dp { for k := j; k \u0026lt; j+6; k++ { dpNew[k] += dp[j] / 6 } } dp = dpNew } return dp } 复杂度 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(n) $ ","date":"2021-09-22T20:29:42+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-60.-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/","title":"剑指 Offer 60. n个骰子的点数"},{"content":"链接： https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/\n难度： 简单\n题目描述 输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。\n示例 1： 输入： nums = [2,7,11,15], target = 9\n输出： [2,7] 或者 [7,2]\n示例 2： 输入： nums = [10,26,30,31,47,60], target = 40\n输出： [10,30] 或者 [30,10]\n限制： 1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 106 解题思路 哈希 使用哈希表记录每个数字是否出现过，遍历数组，计算对应的另一个数，若已出现过则返回这两个数。\nfunc twoSum(nums []int, target int) []int { hash := make(map[int]struct{}) for _, num := range nums { if _, ok := hash[target-num]; ok { return []int{num, target - num} } hash[num] = struct{}{} } return make([]int, 0) } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ 双指针 使用两个指针 i, j 从头尾分别向中间遍历：\n当 nums[i] + nums[j] = target 时，返回； 当 nums[i] + nums[j] \u0026lt; target 时，i + 1； 当 nums[i] + nums[j] \u0026gt; target 时，j + 1。 当两个指针相交的时候，结束遍历。\nfunc twoSum(nums []int, target int) []int { for i, j := 0, len(nums)-1; i \u0026lt; j; { if nums[i]+nums[j] == target { return []int{nums[i], nums[j]} } else if nums[i]+nums[j] \u0026lt; target { i++ } else { j-- } } return make([]int, 0) } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-09-22T19:39:43+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-57.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/","title":"剑指 Offer 57. 和为s的两个数字"},{"content":"链接： https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/\n难度： 简单\n题目描述 给定一棵二叉搜索树，请找出其中第k大的节点。\n示例 1： 输入: root = [3,1,4,null,2], k = 1\n3 / \\ 1 4 \\ 2 输出: 4\n示例 2： 输入: root = [5,3,6,2,4,null,null,1], k = 3\n5 / \\ 3 6 / \\ 2 4 / 1 输出: 4\n限制： 1 ≤ k ≤ 二叉搜索树元素个数 解题思路 中序遍历 二叉搜索树的中序遍历结果是有序的，可以先遍历右子树，这样遍历的结果是倒序的。\n使用 cnt 记录当前遍历到的节点数量，每次遍历到结点时，其值加一。当 cnt 等于 k 时，记录此值，并通知上方已找到，提前返回。\nfunc kthLargest(root *TreeNode, k int) int { cnt := 0 ans := 0 var dfs func(node *TreeNode) bool dfs = func(node *TreeNode) bool { if node == nil { return false } if dfs(node.Right) { return true } cnt++ if cnt == k { ans = node.Val return true } return dfs(node.Left) } dfs(root) return ans } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-09-22T18:54:53+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-54.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/","title":"剑指 Offer 54. 二叉搜索树的第k大节点"},{"content":"链接： https://leetcode-cn.com/problems/split-linked-list-in-parts/\n难度： 中等\n题目描述 给你一个头结点为 head 的单链表和一个整数 k ，请你设计一个算法将链表分隔为 k 个连续的部分。\n每部分的长度应该尽可能的相等：任意两部分的长度差距不能超过 1 。这可能会导致有些部分为 null 。\n这 k 个部分应该按照在链表中出现的顺序排列，并且排在前面的部分的长度应该大于或等于排在后面的长度。\n返回一个由上述 k 部分组成的数组。\n示例 1： 输入： head = [1,2,3], k = 5\n输出： [[1],[2],[3],[],[]]\n解释：\n第一个元素 output[0] 为 output[0].val = 1 ，output[0].next = null 。\n最后一个元素 output[4] 为 null ，但它作为 ListNode 的字符串表示是 [] 。\n示例 2： 输入： head = [1,2,3,4,5,6,7,8,9,10], k = 3\n输出： [[1,2,3,4],[5,6,7],[8,9,10]]\n解释：\n输入被分成了几个连续的部分，并且每部分的长度相差不超过 1 。前面部分的长度大于等于后面部分的长度。\n提示： 链表中节点的数目在范围 [0, 1000] 0 \u0026lt;= Node.val \u0026lt;= 1000 1 \u0026lt;= k \u0026lt;= 50 解题思路 二分查找 遍历一遍链表，获得链表长度。\n使用当前长度 length 除以当前需要划分的段数 k 得到当前段长度 split，注意，当 length % k 不为 0 时，split 需要 +1，然后将指针向后移动 split 即指向下一个段开始位置。\n重复以上步骤知道 k 为 0。\nfunc splitListToParts(head *ListNode, k int) []*ListNode { length := 0 for node := head; node != nil; node = node.Next { length++ } ans := make([]*ListNode, 0, k) for ;k != 0; k-- { split := length/k if length%k != 0 { split++ } length -= split ans = append(ans, head) for i := 0; i \u0026lt; split \u0026amp;\u0026amp; head != nil ; i++ { t := head head = head.Next if i+1 == split { t.Next = nil } } } return ans } 复杂度 时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(1) $ ","date":"2021-09-22T14:11:15+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-725.-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/","title":"Leetcode 725. 分隔链表"},{"content":"链接： https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/\n难度： 简单\n题目描述 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。\n示例 1： 输入： s = \u0026ldquo;abaccdeff\u0026rdquo;\n输出： \u0026lsquo;b\u0026rsquo;\n示例 2： 输入： s = \u0026quot;\u0026quot;\n输出： \u0026rsquo; '\n限制： 0 \u0026lt;= s 的长度 \u0026lt;= 50000 解题思路 哈希 + 两次遍历 第一次遍历，使用哈希表记录每个字符是否重复出现；第二次遍历，返回找到的第一个不重复的字符，找不到返回 ' '。\nfunc firstUniqChar(s string) byte { repeat := make(map[byte]bool) for i := range s { _, ok := repeat[s[i]] if !ok { repeat[s[i]] = false } else { repeat[s[i]] = true } } for i := range s { if !repeat[s[i]] { return s[i] } } return \u0026#39; \u0026#39; } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ 哈希 + 队列 使用哈希表记录每个字符是否重复出现，使用队列记录字符出现的顺序。\n当每个字符第一次出现时，加入队列，当队列头部元素重复时，弹出直至队列头部元素不重复。\n最后队列中有元素返回头部元素，否则返回 ' '\nfunc firstUniqChar(s string) byte { l := list.New() repeat := make(map[byte]bool) for i := range s { r, ok := repeat[s[i]] if !ok { repeat[s[i]] = false l.PushBack(s[i]) continue } if !r { repeat[s[i]] = true } for l.Len() \u0026gt; 0 \u0026amp;\u0026amp; repeat[l.Front().Value.(byte)] { l.Remove(l.Front()) } } if l.Len() \u0026gt; 0 { return l.Front().Value.(byte) } return \u0026#39; \u0026#39; } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-09-21T23:36:33+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/","title":"剑指 Offer 50. 第一个只出现一次的字符"},{"content":"链接： https://leetcode-cn.com/problems/length-of-last-word/\n难度： 简单\n题目描述 给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。\n单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。\n示例 1： 输入： s = \u0026ldquo;Hello World\u0026rdquo;\n输出： 5\n示例 2： 输入： s = \u0026quot; fly me to the moon \u0026quot;\n输出： 4\n示例 3： 输入： s = \u0026ldquo;luffy is still joyboy\u0026rdquo;\n输出： 6\n提示： 1 \u0026lt;= s.length \u0026lt;= 104 s 仅有英文字母和空格 ' ' 组成 s 中至少存在一个单词 解题思路 倒序遍历 从尾到头倒序遍历，当字符为 ' ' 时，若长度为 0 ，说明是尾部空格，继续遍历；否则说明尾部单词遍历完毕，返回长度。\nfunc lengthOfLastWord(s string) int { ans := 0 for i := len(s)-1; i \u0026gt;= 0; i-- { if s[i] == \u0026#39; \u0026#39; { if ans == 0 { continue } break } ans++ } return ans } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-09-21T22:30:53+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-58.-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/","title":"Leetcode 58. 最后一个单词的长度"},{"content":"链接： https://leetcode-cn.com/problems/chou-shu-lcof/\n难度： 中等\n题目描述 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。\n示例： 输入: n = 10\n输出: 12\n解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。\n说明： 1 是丑数。 n 不超过 1690。 解题思路 堆 + 哈希 维护一个小顶堆和哈希表，初始堆中元素为 1，每次弹出堆顶最小元素，然后将其分别乘以 2、3、5加入堆中，此处需要使用哈希表去重。\n弹出的第 n 个数即为第 n 个丑数。\ntype MinHeap struct { sort.IntSlice } func (this *MinHeap) Push(x interface{}) { this.IntSlice = append(this.IntSlice, x.(int)) } func (this *MinHeap) Pop() interface{} { x := this.IntSlice[this.Len()-1] this.IntSlice = this.IntSlice[:this.Len()-1] return x } func nthUglyNumber(n int) int { exist := make(map[int]struct{}) factors := []int{2,3,5} h := \u0026amp;MinHeap{ IntSlice: make([]int, 0, n*3), } heap.Push(h, 1) ans := 0 for i := 0; i \u0026lt; n; i++ { ans = heap.Pop(h).(int) for _, factor := range factors { if _, ok := exist[ans*factor]; !ok { heap.Push(h, ans*factor) exist[ans*factor] = struct{}{} } } } return ans } 复杂度 时间复杂度：$ O(n\\log{n}) $ 空间复杂度：$ O(n) $ 动态规划 使用 dp[i] 记录第 i 个丑数，由于无法界定 dp[i] 通过哪个丑数转移而来，另外还需要使用三个指针 p2、p3、p5 表示下一个丑数是当前指针指向的丑数乘以对应的质因数 2、3、5，从中找到最小的丑数 dp[i]，并将可以求得 dp[i] 的所有指针的对应下标记增加 1。\n初始时，dp[0] = 1, p2 = p3 = p5 = 1 dp[i] = min(dp[p2]*2, dp[p3]*3, dp[p5]*5) func nthUglyNumber(n int) int { dp := make([]int, n) dp[0] = 1 for i := 0; i \u0026lt; n; i++ { t2, t3, t5 = dp[p2]*2, dp[p3]*3, dp[p5]*5 dp[i] = t2 if dp[i] \u0026gt; t3 { dp[i] = t3 } if dp[i] \u0026gt; t5 { dp[i] = t5 } if dp[i] == t2 { p2++ } if dp[i] == t3 { p3++ } if dp[i] == t5 { p5++ } } return dp[n-1] } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(n) $ ","date":"2021-09-21T17:50:14+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-49.-%E4%B8%91%E6%95%B0/","title":"剑指 Offer 49. 丑数"},{"content":"链接： https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/\n难度： 中等\n题目描述 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。\n示例 1： 输入: \u0026ldquo;abcabcbb\u0026rdquo;\n输出: 3\n解释: 因为无重复字符的最长子串是 \u0026ldquo;abc\u0026rdquo;，所以其长度为 3。\n示例 2： 输入: \u0026ldquo;bbbbb\u0026rdquo;\n输出: 1\n解释: 因为无重复字符的最长子串是 \u0026ldquo;b\u0026rdquo;，所以其长度为 1。\n示例 3： 输入: \u0026ldquo;pwwkew\u0026rdquo;\n输出: 3\n解释: 因为无重复字符的最长子串是 \u0026ldquo;wke\u0026rdquo;，所以其长度为 3。\n请注意，你的答案必须是 子串 的长度，\u0026ldquo;pwke\u0026rdquo; 是一个子序列，不是子串。\n提示： s.length \u0026lt;= 40000 解题思路 哈希 + 双指针 使用哈希表记录每个字符出现过下标，并记录有效数组开始的下标 start：当出现重复字符时，将 start 修正为重复字符出现的下一个下标。\nfunc lengthOfLongestSubstring(s string) int { ans := 0 pos := make(map[byte]int) start := 0 for i := 0; i \u0026lt; len(s); i++ { p, ok := pos[s[i]] if ok \u0026amp;\u0026amp; start \u0026lt;= p { start = p + 1 } pos[s[i]] = i if ans \u0026lt; i-start+1 { ans = i - start + 1 } } return ans } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-09-21T16:18:26+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"剑指 Offer 48. 最长不含重复字符的子字符串"},{"content":"链接： https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/\n难度： 中等\n题目描述 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\n示例： 输入:\n[ [1,3,1], [1,5,1], [4,2,1] ] 输出: 12\n解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物\n提示： 0 \u0026lt; grid.length \u0026lt;= 200 0 \u0026lt; grid[0].length \u0026lt;= 200 解题思路 动态规划 使用 dp[i][j] 记录到达位置 (i,j) 的最大值，则其只能从上边或者左边移动到当前位置，故状态转移方程为：\ndp[0][0] = grid[0][0] dp[i][j] = max(dp[i-1][j], dp[i, j-1]) + grid[i][j] func maxValue(grid [][]int) int { dp := make([][]int, len(grid)) for i := 0; i \u0026lt; len(grid); i++ { dp[i] = make([]int, len(grid[0])) for j := 0; j \u0026lt; len(grid[0]); j++ { if i-1 \u0026gt;= 0 { dp[i][j] = dp[i-1][j] } if j-1 \u0026gt;= 0 \u0026amp;\u0026amp; dp[i][j] \u0026lt; dp[i][j-1] { dp[i][j] = dp[i][j-1] } dp[i][j] += grid[i][j] } } return dp[len(dp)-1][len(dp[0])-1] } 复杂度 时间复杂度：$ O(mn) $ 空间复杂度：$ O(mn) $ ","date":"2021-09-21T15:11:53+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-47.-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/","title":"剑指 Offer 47. 礼物的最大价值"},{"content":"链接： https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/\n难度： 中等\n题目描述 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。\n示例： 输入: 12258\n输出: 5\n解释: 12258有5种不同的翻译，分别是\u0026quot;bccfi\u0026quot;, \u0026ldquo;bwfi\u0026rdquo;, \u0026ldquo;bczi\u0026rdquo;, \u0026ldquo;mcfi\u0026quot;和\u0026quot;mzi\u0026rdquo;\n提示： 0 \u0026lt;= num \u0026lt; 231 解题思路 动态规划 使用 dp[i] 记录前缀数组可以表示方案的最大值。状态转移方程为：\n初始，dp[0] = 1； 如果，nums[i]nums[i+1] 可以翻译，则 dp[i+1] = dp[i] + dp[i-1]； 否则，dp[i+1] = dp[i]。 func translateNum(num int) int { s := strconv.FormatInt(int64(num), 10) dp := make([]int, len(s)) dp[0] = 1 for i := 0; i \u0026lt; len(s)-1; i++ { dp[i+1] = dp[i] if s[i] != \u0026#39;0\u0026#39; \u0026amp;\u0026amp; (s[i]-\u0026#39;0\u0026#39;)*10+(s[i+1]-\u0026#39;0\u0026#39;) \u0026lt; 26 { if i-1 \u0026gt;= 0 { dp[i+1] += dp[i-1] } else { dp[i+1]++ } } } return dp[len(s)-1] } 复杂度 时间复杂度：$ O(N), N = digits(num) $ 空间复杂度：$ O(N) $ ","date":"2021-09-20T20:51:55+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"剑指 Offer 46. 把数字翻译成字符串"},{"content":"链接： https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/\n难度： 中等\n题目描述 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。\n示例 1： 输入: [10,2]\n输出: \u0026ldquo;102\u0026rdquo;\n示例 2： 输入: [3,30,34,5,9]\n输出: \u0026ldquo;3033459\u0026rdquo;\n提示： 0 \u0026lt; nums.length \u0026lt;= 100 说明： 输出结果可能非常大，所以你需要返回一个字符串而不是整数 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0 解题思路 排序 对于两个数 x、y，若 xy \u0026lt; yx，则 x 必然在 y 的前面，证明如下：\n当这两个数相邻，则成立 两数不相邻，不妨设 xzy，则有 xz \u0026lt; zx，zy \u0026lt; yz，需要证明 xzy \u0026lt; yzx xz \u0026lt; zx =\u0026gt; x * 10^len(x) + z \u0026lt; z * 10^len(z) + x zy \u0026lt; yz =\u0026gt; z * 10^len(z) + y \u0026lt; y * 10^len(y) + z 相加得到 x * 10^len(x) + y \u0026lt; y * 10^len(y) + z，即 xy \u0026lt; yx，所以 xzy \u0026lt; yzx成立。 按照上述方案自定义排序规则排序，之后按顺序拼接起来返回。\nfunc minNumber(nums []int) string { sort.Slice(nums, func(i, j int) bool { return fmt.Sprintf(\u0026#34;%d%d\u0026#34;, nums[i], nums[j]) \u0026lt; fmt.Sprintf(\u0026#34;%d%d\u0026#34;, nums[j], nums[i]) }) ans := make([]byte, 0, len(nums)*5) for _, num := range nums { ans = append(ans, strconv.FormatInt(int64(num), 10)...) } return string(ans) } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(nums) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-09-20T19:50:47+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-45.-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/","title":"剑指 Offer 45. 把数组排成最小的数"},{"content":"链接： https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/\n难度： 中等\n题目描述 数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。\n请写一个函数，求任意第n位对应的数字。\n示例 1： 输入： n = 3\n输出： 3\n示例 2： 输入： n = 11\n输出： 0\n限制： 0 \u0026lt;= n \u0026lt; 231 解题思路 模拟 字符串按照数字顺序排列，其按照数字长度为 1、2、3、... 进行排列，可以利用这个规则求得 n 所在的那个数，进而求的该位对应的数字。\n排除 0，则相同长度的数字所占的字符串长度为 9*基数*数字长度，（即9=9*1*1、90=9*10*2、900=9*100*3、...），通过覆盖范围的查找确定到 n 对应的数字长度和基数。\n之后获取到 n 所在数字的偏移量，并求得该数，之后返回 n 对应位的数字即可。对输入 0 需要验证。\nfunc findNthDigit(n int) int { base := 1 // 基数 10^N digit := 1 // 位数 10进制 // 确定位数 for ; n \u0026gt; base*9*digit; base, digit = 10*base, digit+1 { n -= base * 9 * digit } offset := (n - 1) / digit // 偏移量 // 获取指定位数字 ans := base + offset for i := digit - (n-1)%digit; i \u0026gt; 1; i-- { ans /= 10 } return ans % 10 } 复杂度 时间复杂度：$ O(\\log{n}) $ 空间复杂度：$ O(1) $ ","date":"2021-09-20T18:23:10+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-44.-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/","title":"剑指 Offer 44. 数字序列中某一位的数字"},{"content":"链接： https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/\n难度： 中等\n题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。\n为了让您更好地理解问题，以下面的二叉搜索树为例：\n我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。\n下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。\n特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。\n解题思路 深度优先搜索 二叉搜索树中序遍历后的结果即为有序的，采用中序遍历的方式搜索二叉树。\n维护两个指针 head 和 tail ，分别指向当前遍历到的链表的头和尾。对于当前遍历到的结点，将其 left 指向 tail，同时 tail 的 right 指向当前结点，后 tail 变更为指向当前结点。\n完成遍历后，修改头尾指针，使其构成环。\nclass Solution { public: Node *treeToDoublyList(Node *root) { if (root == nullptr) { return nullptr; } dfs(root); head-\u0026gt;left = tail; tail-\u0026gt;right = head; return head; } private: Node *head, *tail; void dfs(Node *node) { if(node == nullptr) { return; } dfs(node-\u0026gt;left); if (head == nullptr) { head = node; } if (tail == nullptr) { tail = node; } else { tail-\u0026gt;right = node; node-\u0026gt;left = tail; tail = node; } dfs(node-\u0026gt;right); } }; 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-09-20T17:20:45+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-36.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","title":"剑指 Offer 36. 二叉搜索树与双向链表"},{"content":"链接： https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/\n难度： 简单\n题目描述 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。\n示例 1： 输入： arr = [3,2,1], k = 2\n输出： [1,2] 或者 [2,1]\n示例 2： 输入： arr = [0,1,2,1], k = 1\n输出： [0]\n限制： 0 \u0026lt;= k \u0026lt;= arr.length \u0026lt;= 10000 0 \u0026lt;= arr[i] \u0026lt;= 10000 解题思路 排序 对数组进行排序，返回前 k 个数。\nfunc getLeastNumbers(arr []int, k int) []int { sort.Ints(arr) return arr[:k] } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(arr) $ 空间复杂度：$ O(\\log{N}) $ 堆 使用大顶堆维护最小的 k 个数。遍历数组，当堆不满 k 时，入堆；否则，当前元素小于堆顶元素时，弹出最大元素，当前元素入堆。\n如此，始终保持堆中的即为当前最小的 k 个数，遍历结束返回堆中所有元素即可。\ntype MaxHeap struct { sort.IntSlice } func (this *MaxHeap) Less(i, j int) bool { return this.IntSlice.Less(j, i) } func (this *MaxHeap) Push(x interface{}) { this.IntSlice = append(this.IntSlice, x.(int)) } func (this *MaxHeap) Pop() interface{} { x := this.IntSlice[0] this.IntSlice = this.IntSlice[:this.Len()-1] return x } func (this *MaxHeap) Top() int { return this.IntSlice[0] } func getLeastNumbers(arr []int, k int) []int { h := \u0026amp;MaxHeap{IntSlice: make([]int, 0, k)} for _, num := range arr { if h.Len() \u0026lt; k { heap.Push(h, num) } else if h.Len() \u0026gt; 0 \u0026amp;\u0026amp; h.Top() \u0026gt; num { heap.Pop(h) heap.Push(h, num) } } return h.IntSlice } 复杂度 时间复杂度：$ O(N\\log{k}), N = len(arr) $ 空间复杂度：$ O(k) $ 快速选择 利用快排思想，找出第 k 大的数，则返回从该数开始到头的部分即可。\nfunc getLeastNumbers(arr []int, k int) []int { pos := 0 for i := range arr { if arr[i] \u0026lt;= arr[len(arr)-1] { arr[i], arr[pos] = arr[pos], arr[i] pos++ } } if pos == k { return arr[:k] } else if pos \u0026lt; k { return append(arr[:pos], getLeastNumbers(arr[pos:], k-pos)...) } return getLeastNumbers(arr[:pos-1], k) } 复杂度 时间复杂度：$ O(N), N = len(arr) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-09-20T16:17:39+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/","title":"剑指 Offer 40. 最小的k个数"},{"content":"链接： https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/\n难度： 简单\n题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n示例： 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]\n输出: 2\n提示： 1 \u0026lt;= 数组长度 \u0026lt;= 50000 解题思路 哈希 遍历数组，用哈希表记录每个元素的出现次数，当超过半数时返回。\nfunc majorityElement(nums []int) int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ if cnt[num] \u0026gt; len(nums)/2 { return num } } return 0 } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ 排序 对数组排序，位于中间位置对必为多数元素。\nfunc majorityElement(nums []int) int { sort.Ints(nums) return nums[len(nums)/2] } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(nums) $ 空间复杂度：$ O(\\log{N}) $ 摩尔投票算法 每次将不同的两个数消除，最终剩下的数即为主要元素。\nfunc majorityElement(nums []int) int { major := 0 cnt := 0 for _, num := range nums { if cnt == 0 { major = num cnt++ } else if major != num { cnt-- } else { cnt++ } } return major } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2021-09-20T16:00:42+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-39.-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/","title":"剑指 Offer 39. 数组中出现次数超过一半的数字"},{"content":"链接： https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/\n难度： 中等\n题目描述 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。\n示例 1： 输入： head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出： [[7,null],[13,0],[11,4],[10,2],[1,0]]\n示例 2： 输入： head = [[1,1],[2,1]]\n输出： [[1,1],[2,1]]\n示例 3： 输入： head = [[3,null],[3,0],[3,null]]\n输出： [[3,null],[3,0],[3,null]]\n示例 4: 输入： head = []\n输出： []\n解释： 给定的链表为空（空指针），因此返回 null\n提示： -10000 \u0026lt;= Node.val \u0026lt;= 10000 Node.random 为空（null）或指向链表中的节点。 节点数目不超过 1000 。 解题思路 哈希 使用哈希表维护一个旧结点到新结点的映射，依次从前向后遍历链表，并逐一的构造新链表。\n首先先从哈希表中获取新结点，若不存在，需要构造新结点，并将其加入到哈希表中。\nfunc copyRandomList(head *Node) *Node { m := make(map[*Node]*Node) newHead := new(Node) for node := newHead; head != nil; head, node = head.Next, node.Next { // 获取 Next 指针指向结点 t, ok := m[head] if !ok { t = \u0026amp;Node{ Val: head.Val, } m[head] = t } // 获取 Random 指针指向结点 if head.Random != nil { random, ok := m[head.Random] if !ok { random = \u0026amp;Node{ Val: head.Random.Val, } m[head.Random] = random } t.Random = random } node.Next = t } return newHead.Next } 复杂度 时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(N) $ 分裂 在原来链表的基础上，将每个结点裂变出一个新结点，形成如 A-\u0026gt;A'-\u0026gt;B-\u0026gt;B'-\u0026gt;…… 的结构，修正每个新结点的 random 指针为原结点的下一个结点，然后将原链表拆分，即得到结果。\nfunc copyRandomList(head *Node) *Node { if head == nil { return nil } // 分裂 for node := head; node != nil; node = node.Next.Next { node.Next = \u0026amp;Node{ Val: node.Val, Next: node.Next, Random: node.Random, } } // random 修正 for node := head; node != nil; node = node.Next.Next { if node.Random != nil { node.Next.Random = node.Random.Next } } // 分离 newHead := head.Next for oldNode, newNode := head, newHead; oldNode != nil; oldNode, newNode = oldNode.Next, newNode.Next { oldNode.Next = newNode.Next if newNode.Next != nil { newNode.Next = newNode.Next.Next } } return newHead } 复杂度 时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(1) $ ","date":"2021-09-20T15:16:13+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-35.-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/","title":"剑指 Offer 35. 复杂链表的复制"},{"content":"链接： https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/\n难度： 中等\n题目描述 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。\n示例： 给定如下二叉树，以及目标和 target = 22，\n5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回:\n[ [5,4,11,2], [5,8,4,5] ] 提示： 节点总数 \u0026lt;= 10000 解题思路 深度优先搜索 从根节点开始进行深度优先搜索，当整条路径上的结点值之和为 target 时，将其拷贝到结果队列中。\nfunc pathSum(root *TreeNode, target int) [][]int { ans := make([][]int, 0) var dfs func(node *TreeNode, path []int, sum int) dfs = func(node *TreeNode, path []int, sum int) { if node == nil { return } path = append(path, node.Val) sum += node.Val if node.Left == nil \u0026amp;\u0026amp; node.Right == nil { if sum == target { ans = append(ans, make([]int, len(path))) copy(ans[len(ans)-1], path) } return } dfs(node.Left, path, sum) dfs(node.Right, path, sum) } dfs(root, []int{}, 0) return ans } 复杂度 时间复杂度：$ O(N\\log{N}), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-09-20T14:55:24+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-34.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/","title":"剑指 Offer 34. 二叉树中和为某一值的路径"},{"content":"链接： https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/\n难度： 中等\n题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都 互不相同。\n参考以下这颗二叉搜索树：\n5 / \\ 2 6 / \\ 1 3 示例 1： 输入： [1,6,3,2,5]\n输出： false\n示例 2： 输入： [1,3,2,6,5]\n输出： true\n提示： 数组长度 \u0026lt;= 1000 解题思路 递归 对于一棵树的后续遍历序列，最后一个元素必然是根，然后向前遍历。根据二叉搜索树的性质，其右边元素一定大于根，而左边元素一定小于根，由此找到首个小于根的元素即为左右子树分界点。\n若在左子树序列里存在一个大于根的结点，则返回 false，否则递归处理左右子树。\nfunc verifyPostorder(postorder []int) bool { if len(postorder) \u0026lt;= 2 { return true } root := postorder[len(postorder)-1] split := len(postorder) - 2 for ; split \u0026gt;= 0 \u0026amp;\u0026amp; postorder[split] \u0026gt; root; split-- { } for i := 0; i \u0026lt; split; i++ { if postorder[i] \u0026gt; root { return false } } return verifyPostorder(postorder[:split+1]) \u0026amp;\u0026amp; verifyPostorder(postorder[split+1:len(postorder)-1]) } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(postorder) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-09-20T13:56:50+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-33.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/","title":"剑指 Offer 33. 二叉搜索树的后序遍历序列"},{"content":"链接： https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/\n难度： 中等\n题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字 均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。\n示例 1： 输入： pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\n输出： true\n解释： 我们可以按以下顺序执行：\npush(1), push(2), push(3), push(4), pop() -\u0026gt; 4,\npush(5), pop() -\u0026gt; 5, pop() -\u0026gt; 3, pop() -\u0026gt; 2, pop() -\u0026gt; 1\n示例 2： 输入： pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\n输出： false\n解释： 1 不能在 2 之前弹出。\n提示： 0 \u0026lt;= pushed.length == popped.length \u0026lt;= 1000 0 \u0026lt;= pushed[i], popped[i] \u0026lt; 1000 pushed 是 popped 的排列。 解题思路 模拟 使用一个栈模拟操作。遍历 pushed，将当前元素压栈，由于元素各不相同，随后将栈与 popped 对照，逐一地相同元素弹出。\n最终栈为空则返回 true，否则返回 false。\nfunc validateStackSequences(pushed []int, popped []int) bool { stack := make([]int, 0, len(pushed)) for i, j := 0, 0; i \u0026lt; len(pushed); i++ { stack = append(stack, pushed[i]) for len(stack) \u0026gt; 0 \u0026amp;\u0026amp; stack[len(stack)-1] == popped[j] { stack = stack[:len(stack)-1] j++ } } return len(stack) == 0 } 复杂度 时间复杂度：$ O(N), N = len(pushed) $ 空间复杂度：$ O(N) $ ","date":"2021-09-20T13:01:33+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-31.-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/","title":"剑指 Offer 31. 栈的压入、弹出序列"},{"content":"链接： https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/\n难度： 简单\n题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 $O(1)$。\n示例： MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.min(); \u0026ndash;\u0026gt; 返回 -3.\nminStack.pop();\nminStack.top(); \u0026ndash;\u0026gt; 返回 0.\nminStack.min(); \u0026ndash;\u0026gt; 返回 -2.\n提示： 各函数的调用总次数不超过 20000 次 解题思路 双栈 当最小元素入栈后，后续压入的所有大于最小元素的元素，均不会影响 min 的值，除非压入更小的元素。同理，需要弹出最小元素，min 的值才会改变。故使用另一个栈 B 记录可能使得 min 改变的所有元素值。\n当一个元素入栈时，压入栈 A ，若此元素不大于栈 B 栈顶元素或栈 B 为空，同时需要压入栈 B； 当出栈时，弹出栈 A 栈顶元素，若该元素与栈 B 栈顶元素相同，栈 B 栈顶元素也弹出。 type MinStack struct { stack *list.List minStack *list.List } func Constructor() MinStack { return MinStack{ stack: list.New(), minStack: list.New(), } } func (this *MinStack) Push(x int) { this.stack.PushBack(x) if this.minStack.Len() == 0 || this.minStack.Back().Value.(int) \u0026gt;= x { this.minStack.PushBack(x) } } func (this *MinStack) Pop() { e := this.stack.Back() this.stack.Remove(e) if this.minStack.Back().Value == e.Value { this.minStack.Remove(this.minStack.Back()) } } func (this *MinStack) Top() int { return this.stack.Back().Value.(int) } func (this *MinStack) Min() int { return this.minStack.Back().Value.(int) } 复杂度 时间复杂度： Push：$ O(1) $ Pop：$ O(1) $ Min：$ O(1) $ Top：$ O(1) $ 空间复杂度：$ O(N) $ ","date":"2021-09-20T12:29:44+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-30.-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","title":"剑指 Offer 30. 包含min函数的栈"},{"content":"链接： https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/\n难度： 简单\n题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。\n示例 1： 输入： matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出： [1,2,3,6,9,8,7,4,5]\n示例 2： 输入： matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n输出： [1,2,3,4,8,12,11,10,9,5,6,7]\n限制： 0 \u0026lt;= matrix.length \u0026lt;= 100 0 \u0026lt;= matrix[i].length \u0026lt;= 100 解题思路 模拟 从 (0,0) 开始，按照 右 \u0026gt; 下 \u0026gt; 左 \u0026gt; 上 \u0026gt; 右 的顺序遍历，当下一步要超出范围时或已访问过时，变换遍历方向。\nfunc spiralOrder(matrix [][]int) []int { if len(matrix) == 0 { return make([]int, 0) } visit := make([][]bool, len(matrix)) for i := range matrix { visit[i] = make([]bool, len(matrix[i])) } ans := make([]int, 0, len(matrix)*len(matrix[0])) directions := [4][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}} for i, j, direction := 0, 0, 0; len(ans) \u0026lt; cap(ans); i, j = i+directions[direction][0], j+directions[direction][1] { ans = append(ans, matrix[i][j]) visit[i][j] = true // 遍历方向修正 nextI, nextJ := i+directions[direction][0], j+directions[direction][1] if nextI \u0026lt; 0 || nextI \u0026gt;= len(matrix) || nextJ \u0026lt; 0 || nextJ \u0026gt;= len(matrix[0]) || visit[nextI][nextJ] { direction = (direction + 1) % len(directions) } } return ans } 复杂度 时间复杂度：$ O(NM), N = len(matrix), M = len(N = len(matrix[i])) $ 空间复杂度：$ O(NM) $ 层序遍历 将矩阵分解为一个个的环，每次只顺时针遍历环即可。\nfunc spiralOrder(matrix [][]int) []int { if len(matrix) == 0 { return make([]int, 0) } ans := make([]int, 0, len(matrix)*len(matrix[0])) for up, down, left, right := 0, len(matrix)-1, 0, len(matrix[0])-1; up \u0026lt;= down \u0026amp;\u0026amp; left \u0026lt;= right; up, down, left, right = up+1, down-1, left+1, right-1 { for i := left; i \u0026lt;= right; i++ { ans = append(ans, matrix[up][i]) } for i := up + 1; i \u0026lt;= down; i++ { ans = append(ans, matrix[i][right]) } if up != down \u0026amp;\u0026amp; left != right { for i := right - 1; i \u0026gt;= left; i-- { ans = append(ans, matrix[down][i]) } for i := down - 1; i \u0026gt; up; i-- { ans = append(ans, matrix[i][left]) } } } return ans } 复杂度 时间复杂度：$ O(NM), N = len(matrix), M = len(N = len(matrix[i])) $ 空间复杂度：$ O(1) $ ","date":"2021-09-20T11:07:24+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-29.-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/","title":"剑指 Offer 29. 顺时针打印矩阵"},{"content":"链接： https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/\n难度： 简单\n题目描述 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。\n例如，二叉树 [1,2,2,3,4,4,3] 是对称的。\n1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:\n1 / \\ 2 2 \\ \\ 3 3 示例 1： 输入： root = [1,2,2,3,4,4,3]\n输出： true\n示例 2： 输入： root = [1,2,2,null,3,null,3]\n输出： false\n限制： 0 \u0026lt;= 节点个数 \u0026lt;= 1000 解题思路 递归 递归遍历比较互为镜像的两个结点，不同则返回 false，相同则继续遍历比较子结点。\n因为是镜像比较，所以左子树的左结点和右子树的右结点比较，而左子树的右结点和右子树的左结点比较。\nfunc isSymmetric(root *TreeNode) bool { if root == nil { return true } var same func(node1, node2 *TreeNode) bool same = func(node1, node2 *TreeNode) bool { if node1 == nil \u0026amp;\u0026amp; node2 == nil { return true } if node1 == nil || node2 == nil || node1.Val != node2.Val { return false } return same(node1.Left, node2.Right) \u0026amp;\u0026amp; same(node1.Right, node2.Left) } return same(root.Left, root.Right) } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-09-19T20:37:47+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-28.-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"剑指 Offer 28. 对称的二叉树"},{"content":"链接： https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/\n难度： 简单\n题目描述 请完成一个函数，输入一个二叉树，该函数输出它的镜像。\n例如输入：\n4 / \\ 2 7 / \\ / \\ 1 3 6 9 镜像输出：\n4 / \\ 7 2 / \\ / \\ 9 6 3 1 示例： 输入： root = [4,2,7,1,3,6,9]\n输出： [4,7,2,9,6,3,1]\n限制： 0 \u0026lt;= 节点个数 \u0026lt;= 1000 解题思路 递归 递归遍历所有的结点，交换左右子树。\nfunc mirrorTree(root *TreeNode) *TreeNode { if root == nil { return nil } root.Left, root.Right = mirrorTree(root.Right), mirrorTree(root.Left) return root } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-09-19T20:27:58+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-27.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/","title":"剑指 Offer 27. 二叉树的镜像"},{"content":"链接： https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/\n难度： 中等\n题目描述 输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)\nB是A的子结构， 即 A中有出现和B相同的结构和节点值。\n例如: 给定的树 A:\n3 / \\ 4 5 / \\ 1 2 给定的树 B：\n4 / 1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。\n示例 1： 输入： A = [1,2,3], B = [3,1]\n输出： false\n示例 2： 输入： A = [3,4,5,1,2], B = [4,1]\n输出： true\n限制： 0 \u0026lt;= 节点个数 \u0026lt;= 10000 解题思路 深度优先搜索 在树 A 上进行 深度优先搜索（先序遍历），当子树根结点与 B 相同时，仍采用 深度优先搜索 的方式比较结构是否相同。\nfunc isSubStructure(A *TreeNode, B *TreeNode) bool { if B == nil { return false } var same func(node1, node2 *TreeNode) bool same = func(node1, node2 *TreeNode) bool { if node2 == nil { return true } if node1 == nil { return false } if node1.Val != node2.Val { return false } return same(node1.Left, node2.Left) \u0026amp;\u0026amp; same(node1.Right, node2.Right) } var dfs func(node *TreeNode) bool dfs = func(node *TreeNode) bool { if node == nil { return false } if node.Val == B.Val \u0026amp;\u0026amp; same(node, B) { return true } return dfs(node.Left) || dfs(node.Right) } return dfs(A) } 复杂度 时间复杂度：$ O(NM), N = size(TreeA), M = size(TreeB) $ 空间复杂度：$ O(\\log{N}) $ ","date":"2021-09-19T19:37:13+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-26.-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/","title":"剑指 Offer 26. 树的子结构"},{"content":"链接： https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/\n难度： 简单\n题目描述 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的\n示例： 输入： 1-\u0026gt;2-\u0026gt;4, 1-\u0026gt;3-\u0026gt;4\n输出： 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4\n限制： 0 \u0026lt;= 链表长度 \u0026lt;= 1000 解题思路 迭代 由于两个链表都是排好序的，所以每次只需要比较两个链表头，选择小的加入到结果队列即可。\nfunc mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { ans := new(ListNode) for node := ans; l1 != nil || l2 != nil; node = node.Next { if l1 == nil { node.Next = l2 break } if l2 == nil { node.Next = l1 break } if l1.Val \u0026lt; l2.Val { node.Next = l1 l1 = l1.Next } else { node.Next = l2 l2 = l2.Next } } return ans.Next } 复杂度 时间复杂度：$ O(N+M), N = len(List1), M = len(List2) $ 空间复杂度：$ O(1) $ 递归 同迭代思路，使用递归实现。\nfunc mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.Val \u0026lt; l2.Val { l1.Next = mergeTwoLists(l1.Next, l2) return l1 } l2.Next = mergeTwoLists(l1, l2.Next) return l2 } 复杂度 时间复杂度：$ O(N+M), N = len(List1), M = len(List2) $ 空间复杂度：$ O(N+M) $ ","date":"2021-09-19T19:23:38+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-25.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/","title":"剑指 Offer 25. 合并两个排序的链表"},{"content":"链接： https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/\n难度： 简单\n题目描述 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。\n示例： 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL\n输出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL\n说明： 0 \u0026lt;= nums.length \u0026lt;= 50000 1 \u0026lt;= nums[i] \u0026lt;= 10000 解题思路 递归 利用调用栈记录上一个结点的信息，每次现将后续链表反转，得到反转链表的头部，然后通过当前结点的 Next 指针将当前节点添加到反转链表的尾部，注意还需要将当前节点的 Next 指针置空。\nfunc reverseList(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } newHead := reverseList(head.Next) head.Next.Next = head head.Next = nil return newHead } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ 双指针 链表是单向的，无法访问到上一个节点，所以使用两个指针 last 和 cur 记录当前结点和上一个结点。\n遍历链表，逐一的将当前节点的 Next 指针指向 last，last 和 cur 前进一步。最终当 cur 为 nil 时，返回 last\nfunc reverseList(head *ListNode) *ListNode { last := (*ListNode)(nil) for cur := head; cur != nil; cur.Next, last, cur = last, cur, cur.Next { } return last } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-09-19T18:31:45+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-24.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","title":"剑指 Offer 24. 反转链表"},{"content":"链接： https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/\n难度： 简单\n题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。\n示例： 输入： nums = [1,2,3,4]\n输出： [1,3,2,4]\n注： [3,1,2,4] 也是正确的答案之一。\n说明： 0 \u0026lt;= nums.length \u0026lt;= 50000 1 \u0026lt;= nums[i] \u0026lt;= 10000 解题思路 双指针 使用两个指针 i 和 j 分别指向下一个奇数待插入的位置和当前遍历到的位置，一次遍历，遇到奇数时，i 、 j 指向的两个元素互换。\nfunc exchange(nums []int) []int { for i, j := 0, 0; j \u0026lt; len(nums); j++ { if nums[j]\u0026amp;1 == 1 { nums[i], nums[j] = nums[j], nums[i] i++ } } return nums } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-09-19T18:13:45+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-21.-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/","title":"剑指 Offer 21. 调整数组顺序使奇数位于偶数前面"},{"content":"链接： https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/\n难度： 中等\n题目描述 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。\n数值（按顺序）可以分成以下几个部分：\n若干空格 一个 小数 或者 整数 （可选）一个 'e' 或 'E' ，后面跟着一个 整数 若干空格 小数（按顺序）可以分成以下几个部分：\n（可选）一个符号字符（'+' 或 '-'） 下述格式之一： 至少一位数字，后面跟着一个点 '.' 至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字 一个点 '.' ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分：\n（可选）一个符号字符（'+' 或 '-'） 至少一位数字 部分数值列举如下：\n[\u0026quot;+100\u0026quot;, \u0026quot;5e2\u0026quot;, \u0026quot;-123\u0026quot;, \u0026quot;3.1416\u0026quot;, \u0026quot;-1E-16\u0026quot;, \u0026quot;0123\u0026quot;] 部分非数值列举如下：\n[\u0026quot;12e\u0026quot;, \u0026quot;1a3.14\u0026quot;, \u0026quot;1.2.3\u0026quot;, \u0026quot;+-5\u0026quot;, \u0026quot;12e+5.4\u0026quot;] 示例 1： 输入： s = \u0026ldquo;0\u0026rdquo;\n输出： true\n示例 2： 输入： s = \u0026ldquo;e\u0026rdquo;\n输出： false\n示例 3： 输入： s = \u0026ldquo;.\u0026rdquo;\n输出： false\n示例 4： 输入： s = \u0026quot; .1 \u0026quot;\n输出： true\n说明： 1 \u0026lt;= s.length \u0026lt;= 20 s 仅含英文字母（大写和小写），数字（0-9），加号 '+' ，减号 '-' ，空格 ' ' 或者点 '.' 。 解题思路 确定有限状态自动机 从头开始遍历字符串，需要依次判断每个字符加入后，能否满足条件；不包含此字符的前缀必然是有效的前缀，一但该字符加入后，若失效，则终止，返回 false；有效继续执行，知道最终停止，返回结果。可以用 确定有限状态自动机 求解。\n如字符串 \u0026quot; ±123.456E±789 \u0026quot;，可以分为一下几个部分：开始空格、正负号、整数部分、小数点、小数部分、E、指数符号、指数部分、结束空格。\n针对以上的几个部分进行挖掘得到状态定义和转移规则：\n状态定义：\n状态枚举 描述 Unknown 未知 Start 开始 Sign 正负号 IntNum 整数部分 DotWithoutNum 无整数部分的小数点 DotNum 小数部分 E e或E IndexSign 指数部分正负号 IndexNum 指数部分 End 结束 状态转移表：\nStart Sign IntNum DotWithoutNum DotNum E IndexSign IndexNum End Start ✔️ ✔️ ✔️ ✔️ Sign ✔️ ✔️ IntNum ✔️ ✔️ ✔️ ✔️ DotWithoutNum ✔️ DotNum ✔️ ✔️ ✔️ E ✔️ ✔️ IndexSign ✔️ IndexNum ✔️ ✔️ End ✔️ func isNumber(s string) bool { const ( Unknown = iota Start Sign IntNum DotWithoutNum DotNum E IndexSign IndexNum End ) trans := map[int]map[int]bool{ Start: {Start: true, Sign: true, IntNum: true, DotWithoutNum: true}, Sign: {IntNum: true, DotWithoutNum: true}, IntNum: {IntNum: true, DotNum: true, E: true, End: true}, DotWithoutNum: {DotNum: true}, DotNum: {DotNum: true, E: true, End: true}, E: {IndexSign: true, IndexNum: true}, IndexSign: {IndexNum: true}, IndexNum: {IndexNum: true, End: true}, End: {End: true}, } status := Start for i := 0; i \u0026lt; len(s); i++ { nextStatus := Unknown switch s[i] { case \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;: switch status { case Start, Sign, IntNum: nextStatus = IntNum case E, IndexSign, IndexNum: nextStatus = IndexNum case DotWithoutNum, DotNum: nextStatus = DotNum } case \u0026#39;.\u0026#39;: switch status { case IntNum: nextStatus = DotNum case Start, Sign: nextStatus = DotWithoutNum } case \u0026#39;e\u0026#39;, \u0026#39;E\u0026#39;: nextStatus = E case \u0026#39;+\u0026#39;, \u0026#39;-\u0026#39;: switch status { case E: nextStatus = IndexSign case Start: nextStatus = Sign } case \u0026#39; \u0026#39;: switch status { case IntNum, DotNum, IndexNum: nextStatus = End case Start: nextStatus = Start case End: nextStatus = End } } if !trans[status][nextStatus] { return false } status = nextStatus } return trans[status][End] } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-09-19T16:21:04+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-20.-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"剑指 Offer 20. 表示数值的字符串"},{"content":"链接： https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/\n难度： 简单\n题目描述 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。\n返回删除后的链表的头节点。\n注意： 此题对比原题有改动\n示例 1： 输入: head = [4,5,1,9], val = 5\n输出: [4,1,9]\n解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -\u0026gt; 1 -\u0026gt; 9.\n示例 2： 输入: head = [4,5,1,9], val = 1\n输出: [4,5,9]\n解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -\u0026gt; 5 -\u0026gt; 9.\n说明： 题目保证链表中节点的值互不相同 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 解题思路 顺序遍历 + 二级指针 顺序遍历该链表，当遇到目标结点时，将指向该节点的指针指向下一个结点。\nfunc deleteNode(head *ListNode, val int) *ListNode { for node := \u0026amp;head; (*node) != nil; node = \u0026amp;(*node).Next { if (*node).Val == val { (*node) = (*node).Next break } } return head } 复杂度 时间复杂度：$ O(N), N = len(List) $ 空间复杂度：$ O(1) $ ","date":"2021-09-19T15:56:41+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-18.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/","title":"剑指 Offer 18. 删除链表的节点"},{"content":"链接： https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/\n难度： 简单\n题目描述 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。\n示例： 输入: n = 1\n输出: [1,2,3,4,5,6,7,8,9]\n说明： 用返回一个整数列表来代替打印 n 为正整数 解题思路 求得上限 max，其值为 10n，然后将 [1,max) 之间的所有数依次按顺序添加到返回队列即可。\nfunc printNumbers(n int) []int { max := 1 for ; n \u0026gt; 0; n-- { max *= 10 } ans := make([]int, 0, max) for i := 1; i \u0026lt; max; i++ { ans = append(ans, i) } return ans } 复杂度 时间复杂度：$ O(10^n) $ 空间复杂度：$ O(1) $ ","date":"2021-09-19T15:44:19+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-17.-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/","title":"剑指 Offer 17. 打印从1到最大的n位数"},{"content":"链接： https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/\n难度： 中等\n题目描述 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。\n示例 1： 输入： x = 2.00000, n = 10\n输出： 1024.00000\n示例 2： 输入： x = 2.10000, n = 3\n输出： 9.26100\n示例 3： 输入： x = 2.00000, n = -2\n输出： 0.25000\n解释： 2-2 = 1/22 = 1/4 = 0.25\n提示： -100.0 \u0026lt; x \u0026lt; 100.0 -231 \u0026lt;= n \u0026lt;= 231-1 -104 \u0026lt;= xn \u0026lt;= 104 解题思路 快速幂 $$ x^n = a_1x^1 * a_2x^2 * a_3x^4 * a_4x^8 * \u0026hellip; , 其中a_i\\in(0,1) $$ 可以看出，$ a_i $ 就是 n 的二进制表示形式，而对应项的幂计算可由上一项乘自身求得，故可以依次枚举二进制的每一位，类乘求的结果。\n注意初始 n 为负数的情况,需要进行转化。\nfunc myPow(x float64, n int) float64 { ans := float64(1) pow := float64(x) if n \u0026lt; 0 { pow = 1 / pow n = -n } for ; n != 0; n \u0026gt;\u0026gt;= 1 { if n\u0026amp;1 == 1 { ans *= pow } pow *= pow } return ans } 复杂度 时间复杂度：$ O(\\log{n}) $ 空间复杂度：$ O(1) $ ","date":"2021-09-19T15:13:54+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/","title":"剑指 Offer 16. 数值的整数次方"},{"content":"链接： https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/\n难度： 中等\n题目描述 地上有一个 m 行 n 列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0,0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n示例 1： 输入： m = 2, n = 3, k = 1\n输出： 3\n示例 2： 输入： m = 3, n = 1, k = 0\n输出： 1\n提示： 1 \u0026lt;= n,m \u0026lt;= 100 0 \u0026lt;= k \u0026lt;= 20 解题思路 深度优先搜索 从 [0,0] 开始进行深度优先搜索，当针对 k 进行剪枝时，整个矩阵是关于 (i,i) 对称的，所以可以限制搜索方向为右和下。\nfunc movingCount(m int, n int, k int) int { visit := make(map[[2]int]struct{}) var dfs func(i, j int) int dfs = func(i, j int) int { // 越界 if i \u0026gt;= m || j \u0026gt;= n { return 0 } // 剪枝 if _, ok := visit[[2]int{i, j}]; ok { return 0 } sum := 0 for t1, t2 := i, j; t1 \u0026gt; 0 || t2 \u0026gt; 0; t1, t2 = t1/10, t2/10 { sum += t1%10 + t2%10 } if sum \u0026gt; k { return 0 } // 继续遍历 visit[[2]int{i, j}] = struct{}{} return 1 + dfs(i+1, j) + dfs(i, j+1) } return dfs(0, 0) } 复杂度 时间复杂度：$ O(mn) $ 空间复杂度：$ O(mn) $ ","date":"2021-09-19T14:29:35+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/","title":"剑指 Offer 13. 机器人的运动范围"},{"content":"链接： https://leetcode-cn.com/problems/2-keys-keyboard/\n难度： 中等\n题目描述 最初记事本上只有一个字符 'A' 。你每次可以对这个记事本进行两种操作：\nCopy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。 Paste（粘贴）：粘贴 上一次 复制的字符。 给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A' 。返回能够打印出 n 个 'A' 的最少操作次数。\n示例 1： 输入： 3\n输出： 3\n解释：\n最初, 只有一个字符 \u0026lsquo;A\u0026rsquo;。\n第 1 步, 使用 Copy All 操作。\n第 2 步, 使用 Paste 操作来获得 \u0026lsquo;AA\u0026rsquo;。\n第 3 步, 使用 Paste 操作来获得 \u0026lsquo;AAA\u0026rsquo;。\n示例 2： 输入： n = 1\n输出： 0\n提示： 1 \u0026lt;= n \u0026lt;= 1000 解题思路 动态规划 为使得每次复制粘贴后的操作总次数最小，则对于复制的子字符串，也要求其操作次数最小，故可以用动态规划求解。\n使用 dp[i] 表示打印出 i 的字符时，所需的最小操作次数，则：\n初始时，dp[1] = 0； 对于 i 的每个因数 j，dp[i] = min(dp[j]+i/j)。 最终得到 n 个字符的最小操作次数 dp[n]\nfunc minSteps(n int) int { dp := make([]int, n+1) for i := 2; i \u0026lt;= n; i++ { for j := int(math.Sqrt(float64(i))); j \u0026gt;= 1; j-- { if i%j == 0 { min := dp[j] + i/j if j \u0026gt; 1 \u0026amp;\u0026amp; min \u0026gt; dp[i/j]+j { min = dp[i/j] + j } if dp[i] == 0 || dp[i] \u0026gt; min { dp[i] = min } } } } return dp[n] } 复杂度 时间复杂度：$ O(n\\sqrt{n}) $ 空间复杂度：$ O(n) $ ","date":"2021-09-19T12:56:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-650.-%E5%8F%AA%E6%9C%89%E4%B8%A4%E4%B8%AA%E9%94%AE%E7%9A%84%E9%94%AE%E7%9B%98/","title":"Leetcode 650. 只有两个键的键盘"},{"content":"链接： https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/\n难度： 中等\n题目描述 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n例如，在下面的 3×4 的矩阵中包含单词 \u0026ldquo;ABCCED\u0026rdquo;（单词中的字母已标出）。\n示例 1： 输入： board = [[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;B\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;E\u0026rdquo;],[\u0026ldquo;S\u0026rdquo;,\u0026ldquo;F\u0026rdquo;,\u0026ldquo;C\u0026rdquo;,\u0026ldquo;S\u0026rdquo;],[\u0026ldquo;A\u0026rdquo;,\u0026ldquo;D\u0026rdquo;,\u0026ldquo;E\u0026rdquo;,\u0026ldquo;E\u0026rdquo;]], word = \u0026ldquo;ABCCED\u0026rdquo;\n输出： true\n示例 2： 输入： board = [[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;],[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;d\u0026rdquo;]], word = \u0026ldquo;abcd\u0026rdquo;\n输出： false\n提示： 1 \u0026lt;= board.length \u0026lt;= 200 1 \u0026lt;= board[i].length \u0026lt;= 200 board 和 word 仅由大小写英文字母组成 解题思路 深度优先搜索 遍历整个矩阵，从每个字符开始进行深度优先搜索，当无法找到下一个字符时，及时剪枝。\nfunc exist(board [][]byte, word string) bool { direction := [][]int{ {-1, 0}, {1, 0}, {0, -1}, {0, 1}, } var dfs func(i, j, length int) bool dfs = func(i, j, length int) bool { // 查找到字符串尾 if length == len(word) { return true } // 越界检查 if i \u0026lt; 0 || i \u0026gt;= len(board) || j \u0026lt; 0 || j \u0026gt;= len(board[0]) { return false } // 剪枝 if board[i][j] == \u0026#39;.\u0026#39; || board[i][j] != word[length] { return false } for _, d := range direction { t := board[i][j] board[i][j] = \u0026#39;.\u0026#39; // 遍历标记，防止重复遍历 if dfs(i+d[0], j+d[1], length+1) { return true } board[i][j] = t // 恢复遍历前状态 } return false } for i := range board { for j := range board[i] { if dfs(i, j, 0) { return true } } } return false } 复杂度 时间复杂度：$ O(mnS), S = len(word) $ 空间复杂度：$ O(S) $ ","date":"2021-09-18T17:25:16+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/","title":"剑指 Offer 12. 矩阵中的路径"},{"content":"链接： https://leetcode-cn.com/problems/nim-game/\n难度： 简单\n题目描述 你和你的朋友，两个人一起玩 Nim 游戏：\n桌子上有一堆石头。 你们轮流进行自己的回合，你作为先手。 每一回合，轮到的人拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。\n示例 1： 输入： n = 4\n输出： false\n解释： 如果堆中有 4 块石头，那么你永远不会赢得比赛；\n因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。\n示例 2： 输入： n = 1\n输出： true\n示例 3： 输入： n = 2\n输出： true\n注意： 1 \u0026lt;= n \u0026lt;= 231 - 1 解题思路 推导 赢家必须要拿到最后1块石头，所以最后一次可以拿1～3块，则拿到第4块的石头的必输。\n赢家可以拿到第5块石头，逼对家拿第4块石头，则可知拿到第8块石头的必输。9、13\u0026hellip;同理，拿到4的倍数的玩家必输。\n若初始石头数量是4的倍数，则先手必败；否则，必胜。\nfunc canWinNim(n int) bool { if n % 4 == 0 { return false } return true } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-09-18T16:47:38+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-292.-nim-%E6%B8%B8%E6%88%8F/","title":"Leetcode 292. Nim 游戏"},{"content":"链接： https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/\n难度： 简单\n题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 示例 1： 输入： [3,4,5,1,2]\n输出： 1\n示例 2： 输入： [2,2,2,0,1]\n输出： 0\n提示： 1 \u0026lt;= values \u0026lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 解题思路 遍历 顺序便利，找出最小值。\nfunc minArray(numbers []int) int { min := math.MaxInt32 for _, num := range numbers { if min \u0026gt; num { min = num } } return min } 复杂度 时间复杂度：$ O(N), N = len(numbers) $ 空间复杂度：$ O(1) $ 二分查找 对于数组，每次选出中间元素，和区间右端点比较：\n若大于右端点，则最小值不在左半区间，从右半区间查找 若小于右端点，则最小值不在右半区间，从左半区间查找 若等于右端点，则无法界定最小值在那半边区间，故使得右端点缩进1 直到区间仅剩一个数，返回。\nfunc minArray(numbers []int) int { if len(numbers) == 0 { return 0 } l, r := 0, len(numbers)-1 for l \u0026lt; r { mid := (l + r) / 2 if numbers[mid] \u0026lt; numbers[r] { r = mid } else if numbers[mid] \u0026gt; numbers[r] { l = mid + 1 } else { r-- } } return numbers[l] } 复杂度 时间复杂度：$ O(\\log N), N = len(numbers) $ 空间复杂度：$ O(1) $ ","date":"2021-09-17T17:37:57+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/","title":"剑指 Offer 11. 旋转数组的最小数字"},{"content":"链接： https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/\n难度： 简单\n题目描述 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n示例 1： 输入：\n[\u0026ldquo;CQueue\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;]\n[[],[3],[],[]]\n输出： [null,null,3,-1]\n示例 2： 输入：\n[\u0026ldquo;CQueue\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;appendTail\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;,\u0026ldquo;deleteHead\u0026rdquo;]\n[[],[],[5],[2],[],[]]\n输出： [null,-1,null,null,5,2]\n提示： 1 \u0026lt;= values \u0026lt;= 10000 最多会对 appendTail、deleteHead 进行 10000 次调用 解题思路 出入分离 栈的特点是后进先出。想要取得头部元素，需要将整个栈中元素依次加入另一个栈中，此时，另一个栈中元素的出栈顺序即变成了先进先出。\n故使用两个栈，将入栈和出栈的操作分离，分别对应到尾部栈和头部栈：\n当一个元素要入栈时，压入尾部栈； 当要出栈时，从头部栈弹出，若头部栈为空，则将尾部栈所有元素加入到头部栈。 type CQueue struct { frontStack *list.List backStack *list.List } func Constructor() CQueue { return CQueue{ frontStack: list.New(), backStack: list.New(), } } func (this *CQueue) AppendTail(value int) { this.backStack.PushBack(value) } func (this *CQueue) DeleteHead() int { if this.frontStack.Len() == 0 { if this.backStack.Len() == 0 { return -1 } for this.backStack.Len() \u0026gt; 0 { v := this.backStack.Back() this.backStack.Remove(v) this.frontStack.PushBack(v.Value) } } front := this.frontStack.Back() this.frontStack.Remove(front) return front.Value.(int) } 复杂度 时间复杂度： AppendTail：$ O(1) $ DeleteHead：$ O(1) $ 空间复杂度：$ O(N) $ ","date":"2021-09-17T16:40:45+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","title":"剑指 Offer 09. 用两个栈实现队列"},{"content":"链接： https://leetcode-cn.com/problems/valid-sudoku/\n难度： 中等\n题目描述 请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。\n数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 '.' 表示。\n注意： 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。\n示例 1： 输入： board =\n[[\u0026#34;5\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;], ,[\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;], ,[\u0026#34;.\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;], ,[\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;], ,[\u0026#34;4\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;], ,[\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;], ,[\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;], ,[\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;5\u0026#34;], ,[\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;9\u0026#34;]] 输出： true\n示例 2： 输入： board =\n[[\u0026#34;8\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;5\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;] ,[\u0026#34;4\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;1\u0026#34;] ,[\u0026#34;7\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;6\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;5\u0026#34;] ,[\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;8\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;.\u0026#34;,\u0026#34;7\u0026#34;,\u0026#34;9\u0026#34;]] 输出： false\n解释： 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。\n提示： board.length == 9 board[i].length == 9 board[i][j] 是一位数字或者 '.' 解题思路 哈希 遍历 board，将坐标映射到行、列、九宫格，使用哈希表记录，验证是否有效。\nfunc isValidSudoku(board [][]byte) bool { for i := 0; i \u0026lt; 9; i++ { var ( rowExist [9]bool colExist [9]bool SquareExist [9]bool ) for j := 0; j \u0026lt; 9; j++ { if board[i][j] != \u0026#39;.\u0026#39; { if rowExist[board[i][j]-\u0026#39;1\u0026#39;] { return false } rowExist[board[i][j]-\u0026#39;1\u0026#39;] = true } if board[j][i] != \u0026#39;.\u0026#39; { if colExist[board[j][i]-\u0026#39;1\u0026#39;] { return false } colExist[board[j][i]-\u0026#39;1\u0026#39;] = true } if board[i/3*3+j/3][i%3*3+j%3] != \u0026#39;.\u0026#39; { if SquareExist[board[i/3*3+j/3][i%3*3+j%3]-\u0026#39;1\u0026#39;] { return false } SquareExist[board[i/3*3+j/3][i%3*3+j%3]-\u0026#39;1\u0026#39;] = true } } } return true } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-09-17T11:22:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-36.-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/","title":"Leetcode 36. 有效的数独"},{"content":"链接： https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/\n难度： 中等\n题目描述 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。\n假设输入的前序遍历和中序遍历的结果中都不含重复的数字。\n示例 1： 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\n输出: [3,9,20,null,null,15,7]\n示例 2： 输入: preorder = [-1], inorder = [-1]\n输出: [-1]\n提示： 0 \u0026lt;= 链表长度 \u0026lt;= 10000 解题思路 递归 二叉树的先序遍历的顺序是 根\u0026gt;左\u0026gt;右，而中序遍历顺序为 左\u0026gt;根\u0026gt;右。\n故先序遍历的第一个结点即为 根结点，然后在中序遍历中找到根节点，其左侧所有元素位于为左子树，右侧所有元素在右子树。\n左右子树均按照上述规则，递归地建立二叉树。\nfunc buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 { return nil } this := \u0026amp;TreeNode{ Val: preorder[0], } for i, val := range inorder { if val == preorder[0] { this.Left = buildTree(preorder[1:i+1], inorder[:i]) this.Right = buildTree(preorder[i+1:], inorder[i+1:]) } } return this } 复杂度 时间复杂度：$ O(N\\log N), N = size(Tree) $ 空间复杂度：$ O(\\log N) $ ","date":"2021-09-17T10:45:40+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"剑指 Offer 07. 重建二叉树"},{"content":"链接： https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/\n难度： 简单\n题目描述 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。\n示例： 输入： head = [1,3,2]\n输出： [2,3,1]\n提示： 0 \u0026lt;= 链表长度 \u0026lt;= 10000 解题思路 递归 递归的添加当前节点的元素到子节点返回的数组后面。递归的终止条件为：当前元素不存在，返回空数组。\nfunc reversePrint(head *ListNode) []int { if head == nil { return make([]int, 0) } return append(reversePrint(head.Next), head.Val) } 复杂度 时间复杂度：$ O(N), N = len(list) $ 空间复杂度：$ O(N) $ 栈 遍历链表，依次压栈，之后反转栈中元素即可。\nfunc reversePrint(head *ListNode) []int { if head == nil { return make([]int, 0) } return append(reversePrint(head.Next), head.Val) } 复杂度 时间复杂度：$ O(N), N = len(list) $ 空间复杂度：$ O(N) $ ","date":"2021-09-16T22:20:54+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/","title":"剑指 Offer 06. 从尾到头打印链表"},{"content":"链接： https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/\n难度： 简单\n题目描述 请实现一个函数，把字符串 s 中的每个空格替换成\u0026quot;%20\u0026quot;。\n示例： 输入： s = \u0026ldquo;We are happy.\u0026rdquo;\n输出： \u0026ldquo;We%20are%20happy.\u0026rdquo;\n提示： 0 \u0026lt;= s 的长度 \u0026lt;= 10000 解题思路 模拟 遍历原字符串，将每个字符加入到结果字符串的末尾，遇到 ' ' 需替换为 \u0026quot;%20\u0026quot;。\nfunc replaceSpace(s string) string { t := make([]byte, 0, len(s)*3) for i := range s { if s[i] == \u0026#39; \u0026#39; { t = append(t, \u0026#34;%20\u0026#34;...) } else { t = append(t, s[i]) } } return string(t) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-09-16T22:15:07+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/","title":"剑指 Offer 05. 替换空格"},{"content":"链接： https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/\n难度： 中等\n题目描述 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n示例： 现有矩阵 matrix 如下：\n[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。\n给定 target = 20，返回 false。\n提示： 0 \u0026lt;= n \u0026lt;= 1000 0 \u0026lt;= m \u0026lt;= 1000 解题思路 暴力求解 遍历整个二维数组，寻找该整数。\nfunc findNumberIn2DArray(matrix [][]int, target int) bool { for _, line := range matrix { for _, cell := range line { if cell == target { return true } else if cell \u0026gt; target { break } } } return false } 复杂度 时间复杂度：$ O(nm) $ 空间复杂度：$ O(1) $ 阶梯遍历 从矩阵右上角开始遍历：\n等于 target，则返回； 大于 target，则向左移动一列； 小于 target，则向下移动一行。 func findNumberIn2DArray(matrix [][]int, target int) bool { if len(matrix) == 0 { return false } i, j := 0, len(matrix[0])-1 for i \u0026lt; len(matrix) \u0026amp;\u0026amp; j \u0026gt;= 0 { if matrix[i][j] == target { return true } else if matrix[i][j] \u0026lt; target { i++ } else { j-- } } return false } 复杂度 时间复杂度：$ O(n+m) $ 空间复杂度：$ O(1) $ ","date":"2021-09-16T19:42:33+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","title":"剑指 Offer 04. 二维数组中的查找"},{"content":"链接： https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/\n难度： 简单\n题目描述 找出数组中重复的数字。\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n示例： 输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出： 2 或 3\n提示： 2 \u0026lt;= n \u0026lt;= 100000 解题思路 哈希 使用哈希表记录数组中的元素是否出现过。遍历数组，如果出现过则返回；否则，在哈希表中标记该元素已出现。\nfunc findRepeatNumber(nums []int) int { appear := make(map[int]struct{}) for _, num := range nums { if _, ok := appear[num]; ok { return num } appear[num] = struct{}{} } return 0 } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2021-09-16T19:19:47+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","title":"剑指 Offer 03. 数组中重复的数字"},{"content":"链接： https://leetcode-cn.com/problems/find-peak-element/\n难度： 中等\n题目描述 峰值元素是指其值严格大于左右相邻值的元素。\n给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。\n你可以假设 nums[-1] = nums[n] = -∞ 。\n你必须实现时间复杂度为 O(log n) 的算法来解决此问题。\n示例 1： 输入： nums = [1,2,3,1]\n输出： 2\n解释： 3 是峰值元素，你的函数应该返回其索引 2。\n示例 2： 输入： nums = [1,2,1,3,5,6,4]\n输出： 1 或 5\n解释： 你的函数可以返回索引 1，其峰值元素为 2；\n或者返回索引 5， 其峰值元素为 6。\n提示： 1 \u0026lt;= nums.length \u0026lt;= 1000 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 对于所有有效的 i 都有 nums[i] != nums[i + 1] 解题思路 暴力求解 遍历数组，每个元素均和左右侧元素比较找出峰值元素，边界元素需要特判。\nfunc findPeakElement(nums []int) int { for i, num := range nums { if (i == 0 || (i \u0026gt; 0 \u0026amp;\u0026amp; num \u0026gt; nums[i-1])) \u0026amp;\u0026amp; (i == len(nums)-1 || (i \u0026lt; len(nums)-1 \u0026amp;\u0026amp; num \u0026gt; nums[i+1])) { return i } } return 0 } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ 二分查找 每次使用区间的中间变量与其左边的值比较：\n当大于左边的值时，说明又半区间有峰值元素 否则，说明左半区间有峰值元素 重复上述步骤，直到区间只剩下一个元素，则返回此峰值元素。\nfunc findPeakElement(nums []int) int { for l, r := 0, len(nums); l \u0026lt; r; { if l+1 == r { return l } mid := (l + r) / 2 if mid == 0 || (mid \u0026gt; 0 \u0026amp;\u0026amp; nums[mid] \u0026gt; nums[mid-1]) { l = mid } else { r = mid } } return 0 } 复杂度 时间复杂度：$ O(\\log N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-09-15T10:11:21+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-162.-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/","title":"Leetcode 162. 寻找峰值"},{"content":"链接： https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/\n难度： 中等\n题目描述 给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。\n如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。\n示例 1： 输入： s = \u0026ldquo;abpcplea\u0026rdquo;, dictionary = [\u0026ldquo;ale\u0026rdquo;,\u0026ldquo;apple\u0026rdquo;,\u0026ldquo;monkey\u0026rdquo;,\u0026ldquo;plea\u0026rdquo;]\n输出： \u0026ldquo;apple\u0026rdquo;\n示例 2： 输入： s = \u0026ldquo;abpcplea\u0026rdquo;, dictionary = [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;c\u0026rdquo;]\n输出： \u0026ldquo;a\u0026rdquo;\n提示： 1 \u0026lt;= s.length \u0026lt;= 1000 1 \u0026lt;= dictionary.length \u0026lt;= 1000 1 \u0026lt;= dictionary[i].length \u0026lt;= 1000 s 和 dictionary[i] 仅由小写英文字母组成 解题思路 暴力求解 遍历字典，对于符合 s 的子序列的每个元素，记录最大长度的最小元素。\nfunc findLongestWord(s string, dictionary []string) string { contains := func(s, sub string) bool { j := 0 for i := 0; i \u0026lt; len(s) \u0026amp;\u0026amp; j \u0026lt; len(sub); i++ { if s[i] == sub[j] { j++ } } if j == len(sub) { return true } return false } maxLen := 0 ans := \u0026#34;\u0026#34; for _, d := range dictionary { if contains(s, d) { if maxLen \u0026lt; len(d) { maxLen = len(d) ans = d } else if maxLen == len(d) \u0026amp;\u0026amp; ans \u0026gt; d { ans = d } } } return ans } 复杂度 时间复杂度：$ O(N*L), N = len(dictionary), L = max(dictionory[i]) $ 空间复杂度：$ O(1) $ ","date":"2021-09-14T17:03:15+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-524.-%E9%80%9A%E8%BF%87%E5%88%A0%E9%99%A4%E5%AD%97%E6%AF%8D%E5%8C%B9%E9%85%8D%E5%88%B0%E5%AD%97%E5%85%B8%E9%87%8C%E6%9C%80%E9%95%BF%E5%8D%95%E8%AF%8D/","title":"Leetcode 524. 通过删除字母匹配到字典里最长单词"},{"content":"链接： https://leetcode-cn.com/problems/number-of-boomerangs/\n难度： 中等\n题目描述 给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的距离相等（需要考虑元组的顺序）。\n返回平面上所有回旋镖的数量。\n示例 1： 输入： points = [[0,0],[1,0],[2,0]]\n输出： 2\n解释： 两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]]\n示例 2： 输入： points = [[1,1],[2,2],[3,3]]\n输出： 2\n示例 3： 输入： points = [[1,1]]\n输出： 0\n提示： n == points.length 1 \u0026lt;= n \u0026lt;= 500 points[i].length == 2 -104 \u0026lt;= xi, yi \u0026lt;= 104 所有点都 互不相同 解题思路 哈希 使用哈希表 cnt[p][d] 记录记录距离点 p 距离为 d 的点的距离，依次求得两个点之间的距离，并记录到哈希表。\n遍历哈希表，对于每个 p 和 d ，将可选点的排列数累加进到结果中。\nfunc numberOfBoomerangs(points [][]int) int { cnt := make(map[int]map[int]int) for i := range points { cnt[i] = make(map[int]int) } for i := 0; i \u0026lt; len(points)-1; i++ { for j := i + 1; j \u0026lt; len(points); j++ { distance := (points[i][0]-points[j][0])*(points[i][0]-points[j][0]) + (points[i][1]-points[j][1])*(points[i][1]-points[j][1]) cnt[i][distance]++ cnt[j][distance]++ } } ans := 0 for _, p := range cnt { for _, v := range p { ans += v * (v - 1) } } return ans } 复杂度 时间复杂度：$ O(N^2), N = len(points) $ 空间复杂度：$ O(N^2) $ ","date":"2021-09-13T10:21:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-447.-%E5%9B%9E%E6%97%8B%E9%95%96%E7%9A%84%E6%95%B0%E9%87%8F/","title":"Leetcode 447. 回旋镖的数量"},{"content":"链接： https://leetcode-cn.com/problems/valid-parenthesis-string/\n难度： 中等\n题目描述 给定一个只包含三种字符的字符串：( ，) 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：\n任何左括号 ( 必须有相应的右括号 )。 任何右括号 ) 必须有相应的左括号 ( 。 左括号 ( 必须在对应的右括号之前 )。 * 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。 一个空字符串也被视为有效字符串。 示例 1： 输入: \u0026ldquo;()\u0026rdquo;\n输出: True\n示例 2： 输入: \u0026ldquo;(*)\u0026rdquo;\n输出: True\n示例 3： 输入: \u0026ldquo;(*))\u0026rdquo;\n输出: True\n注意： 字符串大小将在 [1，100] 范围内。 解题思路 栈 使用栈来进行括号的匹配:\n每当遇到 ( 和 * ，入栈； 当遇到 ) 时，优先从栈中寻找距栈顶最近的 ( ，以完成配对，然后该 ( 从栈中弹出；当不存在 ( 时，使用 * 代替 ( 配对并弹出，都不存在返回 false。 对字符串完成遍历后，栈中仅剩下 ( 和 * ，此时从栈顶开始，配对消除 (，能全部消除，返回 true，否则返回 false。\nfunc checkValidString(s string) bool { stack := make([]byte, 0, len(s)) for i := 0; i \u0026lt; len(s); i++ { switch s[i] { case \u0026#39;*\u0026#39;, \u0026#39;(\u0026#39;: stack = append(stack, s[i]) case \u0026#39;)\u0026#39;: if len(stack) == 0 { return false } // 优先配对 ( j := len(stack) - 1 for ; j \u0026gt;= 0; j-- { if stack[j] == \u0026#39;(\u0026#39; { stack = append(stack[:j], stack[j+1:]...) break } } // 无 ( 使用 * 配对 if j \u0026lt; 0 { stack = stack[:len(stack)-1] } } } stars := 0 // 消除 ( for i := len(stack) - 1; i \u0026gt;= 0; i-- { switch stack[i] { case \u0026#39;*\u0026#39;: stars++ case \u0026#39;(\u0026#39;: if stars \u0026gt; 0 { stars-- } else { return false } } } return true } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(N) $ ","date":"2021-09-12T23:38:03+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-678.-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 678. 有效的括号字符串"},{"content":"链接： https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/\n难度： 中等\n题目描述 一个班级里有 n 个学生，编号为 0 到 n - 1 。每个学生会依次回答问题，编号为 0 的学生先回答，然后是编号为 1 的学生，以此类推，直到编号为 n - 1 的学生，然后老师会重复这个过程，重新从编号为 0 的学生开始回答问题。\n给你一个长度为 n 且下标从 0 开始的整数数组 chalk 和一个整数 k 。一开始粉笔盒里总共有 k 支粉笔。当编号为 i 的学生回答问题时，他会消耗 chalk[i] 支粉笔。如果剩余粉笔数量 严格小于 chalk[i] ，那么学生 i 需要 补充 粉笔。\n请你返回需要 补充 粉笔的学生 编号 。\n示例 1： 输入： chalk = [5,1,5], k = 22\n输出： 0\n解释： 学生消耗粉笔情况如下：\n编号为 0 的学生使用 5 支粉笔，然后 k = 17 。 编号为 1 的学生使用 1 支粉笔，然后 k = 16 。 编号为 2 的学生使用 5 支粉笔，然后 k = 11 。 编号为 0 的学生使用 5 支粉笔，然后 k = 6 。 编号为 1 的学生使用 1 支粉笔，然后 k = 5 。 编号为 2 的学生使用 5 支粉笔，然后 k = 0 。\n编号为 0 的学生没有足够的粉笔，所以他需要补充粉笔。 示例 2： 输入： chalk = [3,4,1,2], k = 25\n输出： 1\n解释： 学生消耗粉笔情况如下：\n编号为 0 的学生使用 3 支粉笔，然后 k = 22 。 编号为 1 的学生使用 4 支粉笔，然后 k = 18 。 编号为 2 的学生使用 1 支粉笔，然后 k = 17 。 编号为 3 的学生使用 2 支粉笔，然后 k = 15 。 编号为 0 的学生使用 3 支粉笔，然后 k = 12 。 编号为 1 的学生使用 4 支粉笔，然后 k = 8 。 编号为 2 的学生使用 1 支粉笔，然后 k = 7 。 编号为 3 的学生使用 2 支粉笔，然后 k = 5 。 编号为 0 的学生使用 3 支粉笔，然后 k = 2 。\n编号为 1 的学生没有足够的粉笔，所以他需要补充粉笔。 提示： chalk.length == n 1 \u0026lt;= n \u0026lt;= 105 1 \u0026lt;= chalk[i] \u0026lt;= 105 1 \u0026lt;= k \u0026lt;= 109 解题思路 遍历优化 遍历 chalk 数组，求得完成一轮需要的粉笔数量 sum，用 k 模 sum ，得到最后一轮所需的粉笔数量，然后再次遍历 chalk，将粉笔用光，返回。\nfunc chalkReplacer(chalk []int, k int) int { sum := 0 for _, c := range chalk { sum += c } k %= sum for i, c := range chalk { k -= c if k \u0026lt; 0 { return i } } return 0 } 复杂度 时间复杂度：$ O(N), N = len(chalk) $ 空间复杂度：$ O(1) $ 前缀和 + 二分查找 求得 chalk 数组的前缀和，同样用 k 模 整个数组的和 得到最后一轮所需的粉笔数量 k'，采用二分查找，找到首个小于 k' 的前缀和位置并返回。\nfunc chalkReplacer(chalk []int, k int) int { for i := 1; i \u0026lt; len(chalk); i++ { chalk[i] = chalk[i-1] + chalk[i] } k %= chalk[len(chalk)-1] return sort.Search(len(chalk), func(i int) bool { return chalk[i] \u0026gt; k }) } 复杂度 时间复杂度：$ O(N), N = len(chalk) $ 空间复杂度：$ O(1) $ ","date":"2021-09-10T12:10:52+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1894.-%E6%89%BE%E5%88%B0%E9%9C%80%E8%A6%81%E8%A1%A5%E5%85%85%E7%B2%89%E7%AC%94%E7%9A%84%E5%AD%A6%E7%94%9F%E7%BC%96%E5%8F%B7/","title":"Leetcode 1894. 找到需要补充粉笔的学生编号"},{"content":"链接： https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/\n难度： 简单\n题目描述 在一个 平衡字符串 中，'L' 和 'R' 字符的数量是相同的。\n给你一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。\n**注意：**分割得到的每个字符串都必须是平衡字符串。\n返回可以通过分割得到的平衡字符串的 最大数量 。\n示例 1： 输入： s = \u0026ldquo;RLRRLLRLRL\u0026rdquo;\n输出： 4\n解释： s 可以分割为 \u0026ldquo;RL\u0026rdquo;、\u0026ldquo;RRLL\u0026rdquo;、\u0026ldquo;RL\u0026rdquo;、\u0026ldquo;RL\u0026rdquo; ，每个子字符串中都包含相同数量的 \u0026lsquo;L\u0026rsquo; 和 \u0026lsquo;R\u0026rsquo; 。\n示例 2： 输入： s = \u0026ldquo;RLLLLRRRLR\u0026rdquo;\n输出： 3\n解释： s 可以分割为 \u0026ldquo;RL\u0026rdquo;、\u0026ldquo;LLLRRR\u0026rdquo;、\u0026ldquo;LR\u0026rdquo; ，每个子字符串中都包含相同数量的 \u0026lsquo;L\u0026rsquo; 和 \u0026lsquo;R\u0026rsquo; 。\n示例 3： 输入： s = \u0026ldquo;LLLLRRRR\u0026rdquo;\n输出： 1\n解释： s 只能保持原样 \u0026ldquo;LLLLRRRR\u0026rdquo;.\n示例 4： 输入： s = \u0026ldquo;RLRRRLLRLL\u0026rdquo;\n输出： 2\n解释： s 可以分割为 \u0026ldquo;RL\u0026rdquo;、\u0026ldquo;RRRLLRLL\u0026rdquo; ，每个子字符串中都包含相同数量的 \u0026lsquo;L\u0026rsquo; 和 \u0026lsquo;R\u0026rsquo; 。\n提示： 1 \u0026lt;= s.length \u0026lt;= 1000 s[i] = \u0026lsquo;L\u0026rsquo; 或 \u0026lsquo;R\u0026rsquo; s 是一个 平衡 字符串 解题思路 贪心 为使得分割后的平衡字符串数量最大，应按最小粒度进行分割。可以采用贪心策略，从前向后遍历原字符串，每当构成平衡字符串时，进行一次分割。\nfunc balancedStringSplit(s string) int { split := 0 balance := 0 for i := 0; i \u0026lt; len(s); i++ { switch s[i] { case \u0026#39;L\u0026#39;: balance-- case \u0026#39;R\u0026#39;: balance++ } if balance == 0 { split++ } } return split } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-09-07T09:47:34+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1221.-%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 1221. 分割平衡字符串"},{"content":"链接： https://leetcode-cn.com/problems/binary-search/\n难度： 简单\n题目描述 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例 1： 输入: nums = [-1,0,3,5,9,12], target = 9\n输出: 4\n解释: 9 出现在 nums 中并且下标为 4\n示例 2： 输入: nums = [-1,0,3,5,9,12], target = 2\n输出: -1\n解释: 2 不存在 nums 中因此返回 -1\n提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000] 之间。 nums 的每个元素都将在 [-9999, 9999] 之间。 解题思路 二分查找 func search(nums []int, target int) int { for l, r := 0, len(nums); l \u0026lt; r; { mid := (l + r) / 2 if target == nums[mid] { return mid } else if target \u0026lt; nums[mid] { r = mid } else { l = mid + 1 } } return -1 } 复杂度 时间复杂度：$ O(\\log N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-09-06T09:41:51+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-704.-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","title":"Leetcode 704. 二分查找"},{"content":"链接： https://leetcode-cn.com/problems/implement-rand10-using-rand7/\n难度： 中等\n题目描述 已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。\n不要使用系统的 Math.random() 方法。\n示例 1： 输入: 1\n输出: [7]\n示例 2： 输入: 2\n输出: [8,4]\n示例 3： 输入: 3\n输出: [8,1,10]\n提示： rand7 已定义。 传入参数: n 表示 rand10 的调用次数。 进阶： rand7() 调用次数的 期望值 是多少 ? 你能否尽量少调用 rand7() ? 解题思路 rand7 函数等概率的生成 1~7 的随机数，为生成 1~10的随机数，需要等概率的生成 10 的倍数个随机数。\n将两次调用 rand7 生成的随机数相乘，将等概率的生成 49 个随机数，将最后 9 个数排除，则前 40 个数字的生成是等概率的，通过简单的模运算即可得到 1~10 的随机数。\n每次生成最后的九个随机数时，重新进行上述步骤，直到生成前 40 个随机数为止。\n期望：\n容易求得前 i 次未生成的概率为$(\\frac{9}{49})^i$，\n则第 i 次生成的概率为$\\frac{40}{49}(\\frac{9}{49})^{i-1}$，调用 rand7 的次数为$2i\\frac{40}{49}(\\frac{9}{49})^{i-1}$\n所以调用期望为:\n$$ E = \\sum_{i=1}^{+\\infty}2i(\\frac{9}{49})^{i-1}\\frac{40}{49} = 2*\\frac{40}{49}\\sum_{i=1}^{+\\infty}i(\\frac{9}{49})^{i-1} $$\n令 $S_n = \\sum\\limits_{i=1}^{n}i(\\frac{9}{49})^{i-1}$，$\\frac{9}{49}S_{n-1} = \\sum\\limits_{i=1}^{n}i(\\frac{9}{49})^{i}$\n$$ S_n - \\frac{9}{49}S_{n-1} = \\frac{40}{49}S_{n-1} = \\sum\\limits_{i=1}^{n}(\\frac{9}{49})^{i-1} - n(\\frac{9}{49}^n) = \\frac{1-(\\frac{9}{49})^n}{1-\\frac{9}{49}} - n(\\frac{9}{49})^n $$\n故 $S_n = \\frac{\\frac{1-(\\frac{9}{49})^n}{1-\\frac{9}{49}} - n(\\frac{9}{49})^n}{\\frac{40}{49}}$\n$$ E = 2*\\frac{40}{49}\\lim_{n\\to+\\infty}S_n = 2\\lim_{n\\to+\\infty}\\frac{1-(\\frac{9}{49})^n}{1-\\frac{9}{49}} - n(\\frac{9}{49})^n = 2.45 $$\n可以生成的期望为：2\nfunc rand10() int { for { pos := 7*(rand7()-1) + rand7() if pos \u0026lt;= 40 { return pos%10 + 1 } } } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-09-05T16:27:29+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-470.-%E7%94%A8-rand7-%E5%AE%9E%E7%8E%B0-rand10/","title":"Leetcode 470. 用 Rand7() 实现 Rand10()"},{"content":"链接： https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/\n难度： 简单\n题目描述 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：\nF(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N \u0026gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。\n答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。\n示例 1： 输入： n = 2\n输出： 1\n示例 2： 输入： n = 5\n输出： 5\n提示： 0 \u0026lt;= n \u0026lt;= 100 解题思路 动态规划 动态规划的状态转移方程已在题目中给出，使用三个变量降低空间复杂度。\nfunc fib(n int) int { const MOD = 1e9 + 7 dp := []int{0, 1, 0} if n \u0026lt; 2 { return dp[n] } for i := 2; i \u0026lt;= n; i++ { dp[2] = (dp[0] + dp[1]) % MOD dp[0], dp[1] = dp[1], dp[2] } return dp[2] } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2021-09-04T08:01:33+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","title":"剑指 Offer 10- I. 斐波那契数列"},{"content":"冒泡排序 func BubbleSort(arr []int) { for i := 0; i \u0026lt; len(arr); i++ { for j := 0; j \u0026lt; len(arr)-1-i; j++ { if arr[j] \u0026gt; arr[j+1] { arr[j], arr[j+1] = arr[j+1], arr[j] } } } } 复杂度 时间复杂度：$ O(N^2) $ 空间复杂度：$ O(1) $ 选择排序 func ChoiceSort(arr []int) { for i := 0; i \u0026lt; len(arr); i++ { minPos := i for j := i + 1; j \u0026lt; len(arr); j++ { if arr[minPos] \u0026gt; arr[j] { minPos = j } } arr[i], arr[minPos] = arr[minPos], arr[i] } } 复杂度 时间复杂度：$ O(N^2) $ 空间复杂度：$ O(1) $ 插入排序 func InsertSort(arr []int) { for i := 1; i \u0026lt; len(arr); i++ { num := arr[i] j := i - 1 for ; j \u0026gt;= 0; j-- { if num \u0026lt; arr[j] { arr[j+1] = arr[j] } else { break } } arr[j+1] = num } } 复杂度 时间复杂度：$ O(N^2) $ 空间复杂度：$ O(1) $ 归并排序 func MergeSort(arr []int) { var mergeSort func(l, r int) mergeSort = func(l, r int) { if r-l \u0026lt;= 1 { return } mid := (l + r) / 2 mergeSort(l, mid) mergeSort(mid, r) mergeSlice := make([]int, 0, r-l) j := mid for i := l; i \u0026lt; mid; { if j \u0026lt; r \u0026amp;\u0026amp; arr[j] \u0026lt; arr[i] { mergeSlice = append(mergeSlice, arr[j]) j++ } else { mergeSlice = append(mergeSlice, arr[i]) i++ } } for ; j \u0026lt; r; j++ { mergeSlice = append(mergeSlice, arr[j]) } copy(arr[l:], mergeSlice) } mergeSort(0, len(arr)) } 复杂度 时间复杂度：$ O(N\\log N) $ 空间复杂度：$ O(N) $ 堆排序 func HeapSort(arr []int) { // 建堆 for i := len(arr)/2 - 1; i \u0026gt;= 0; i-- { for father := i; ; { greater := father\u0026lt;\u0026lt;1 + 1 if greater \u0026gt;= len(arr) { break } if greater+1 \u0026lt; len(arr) \u0026amp;\u0026amp; arr[greater+1] \u0026gt; arr[greater] { greater += 1 } if arr[father] \u0026lt; arr[greater] { arr[father], arr[greater] = arr[greater], arr[father] } father = greater } } // 排序 for i := len(arr) - 1; i \u0026gt; 0; i-- { arr[0], arr[i] = arr[i], arr[0] for father := 0; ; { greater := father\u0026lt;\u0026lt;1 + 1 if greater \u0026gt;= i { break } if greater+1 \u0026lt; i \u0026amp;\u0026amp; arr[greater+1] \u0026gt; arr[greater] { greater += 1 } if arr[father] \u0026lt; arr[greater] { arr[father], arr[greater] = arr[greater], arr[father] } father = greater } } } 复杂度 时间复杂度：$ O(N\\log N) $ 空间复杂度：$ O(1) $ 快速排序 func QuickSort(arr []int) { var quickSort func(l, r int) quickSort = func(l, r int) { if l \u0026gt;= r { return } i := l for j := l; j \u0026lt; r; j++ { if arr[j] \u0026lt;= arr[r-1] { arr[i], arr[j] = arr[j], arr[i] i++ } } quickSort(l, i-1) quickSort(i, r) } quickSort(0, len(arr)) } 复杂度 时间复杂度：$ O(N\\log N) $ 空间复杂度：$ O(\\log N) $ ","date":"2021-09-03T16:15:57+08:00","permalink":"https://xianlianghe0123.github.io/p/%E6%8E%92%E5%BA%8F/","title":"排序"},{"content":"链接： https://leetcode-cn.com/problems/smallest-k-lcci/\n难度： 中等\n题目描述 设计一个算法，找出数组中最小的k个数。以任意顺序返回这k个数均可。\n示例： 输入： arr = [1,3,5,7,2,4,6,8], k = 4\n输出： [1,2,3,4]\n提示： 0 \u0026lt;= len(arr) \u0026lt;= 100000 0 \u0026lt;= k \u0026lt;= min(100000, len(arr)) 解题思路 排序 对原数组排序，返回前 k 个元素。\nfunc smallestK(arr []int, k int) []int { sort.Ints(arr) return arr[:k] } 复杂度 时间复杂度：$ O(N\\log N), N = len(arr) $ 空间复杂度：$ O(\\log N) $ 堆 构建一个大顶堆，保存前 k 个最小的数。遍历 arr 数组\n当堆中元素数量不足 k 时，入堆； 当堆中元素书数量为 k 时，与堆顶元素比较 当堆顶元素为较大时，弹出队顶元素，当前元素入堆 否则，忽略当前元素 遍历结束，返回堆中所有元素。\ntype MaxHeap struct { sort.IntSlice } func (this *MaxHeap) Less(i, j int) bool { return !this.IntSlice.Less(i, j) } func (this *MaxHeap) Push(elem interface{}) { this.IntSlice = append(this.IntSlice, elem.(int)) } func (this *MaxHeap) Pop() interface{} { t := this.IntSlice[len(this.IntSlice)-1] this.IntSlice = this.IntSlice[:len(this.IntSlice)-1] return t } func smallestK(arr []int, k int) []int { if k == 0 { return []int{} } h := \u0026amp;MaxHeap{ IntSlice: make([]int, 0, k), } for _, num := range arr { if h.Len() \u0026lt; k { heap.Push(h, num) } else if h.IntSlice[0] \u0026gt; num { heap.Pop(h) heap.Push(h, num) } } return h.IntSlice } 复杂度 时间复杂度：$ O(N\\log k), N = len(arr) $ 空间复杂度：$ O(k) $ 快速选择 使用快速排序的思路，找到第 k 大的数，则包括其在内的所有左边的书即构成了结果集合。\nfunc smallestK(arr []int, k int) []int { var f func(l, r int) f = func(l, r int) { if l \u0026gt;= r { return } target := arr[r-1] lt := l for i := l; i \u0026lt; r; i++ { if arr[i] \u0026lt;= target { arr[lt], arr[i] = arr[i], arr[lt] lt++ } } if lt \u0026lt; k { f(lt, r) } else if lt \u0026gt; k { f(0, lt-1) } } f(0, len(arr)) return arr[:k] } 复杂度 时间复杂度：$ O(N), N = len(arr) $ 空间复杂度：$ O(\\log N) $ ","date":"2021-09-03T11:30:22+08:00","permalink":"https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.14.-%E6%9C%80%E5%B0%8Fk%E4%B8%AA%E6%95%B0/","title":"面试题 17.14. 最小K个数"},{"content":"链接： https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/\n难度： 简单\n题目描述 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。\n例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。\n示例： 给定一个链表: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, 和 k = 2.\n返回链表 4-\u0026gt;5.\n解题思路 顺序遍历 遍历一边链表，得到其长度 length，则 length - k 即为需要跳过的结点，重新遍历，跳过前 length - k 个结点。\nfunc getKthFromEnd(head *ListNode, k int) *ListNode { length := 0 for node := head; node != nil; node = node.Next { length++ } node := head for i := length - k; i \u0026gt; 0; i-- { node = node.Next } return node } 复杂度 时间复杂度：$ O(N), N = len(head) $ 空间复杂度：$ O(1) $ ","date":"2021-09-02T09:29:06+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-22.-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","title":"剑指 Offer 22. 链表中倒数第k个节点"},{"content":"链接： https://leetcode-cn.com/problems/corporate-flight-bookings/\n难度： 中等\n题目描述 这里有 n 个航班，它们分别从 1 到 n 进行编号。\n有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。\n请你返回一个长度为 n 的数组 answer，其中 answer[i] 是航班 i 上预订的座位总数。\n示例 1： 输入： bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\n输出： [10,55,45,25,25]\n解释：\n航班编号 1 2 3 4 5\n预订记录 1 ：10 10\n预订记录 2 ： 20 20\n预订记录 3 ： 25 25 25 25\n总座位数： 10 55 45 25 25\n因此，answer = [10,55,45,25,25]\n示例 2： 输入： bookings = [[1,2,10],[2,2,15]], n = 2\n输出： [10,25]\n解释：\n航班编号 1 2\n预订记录 1 ：10 10\n预订记录 2 ： 15\n总座位数： 10 25\n因此，answer = [10,25]\n提示： 1 \u0026lt;= n \u0026lt;= 2 * 104 1 \u0026lt;= bookings.length \u0026lt;= 2 * 104 bookings[i].length == 3 1 \u0026lt;= firsti \u0026lt;= lasti \u0026lt;= n 1 \u0026lt;= seatsi \u0026lt;= 104 解题思路 暴力求解 遍历 bookings 列表，将 first 到 last 的 seats 累加到对应的航班中。\nfunc corpFlightBookings(bookings [][]int, n int) []int { ans := make([]int, n) for _, booking := range bookings { for i := booking[0] - 1; i \u0026lt; booking[1]; i++ { ans[i] += booking[2] } } return ans } 复杂度 时间复杂度：$ O(Mn), M = len(bookings) $ 空间复杂度：$ O(1) $ 差分数组 使用差分数组，ans[i] 保存与 ans[i-1] 的差值，每次即可进行区间操作：\n对 firsti 加上 seatsi，然后对 lasti+1 减去 seatsi，表示对区间 [firsti, lasti] 加上seatsi\nfunc corpFlightBookings(bookings [][]int, n int) []int { ans := make([]int, n) for _, booking := range bookings { ans[booking[0]-1] += booking[2] if booking[1] \u0026lt; n { ans[booking[1]] -= booking[2] } } for i := 1; i \u0026lt; n; i++ { ans[i] += ans[i-1] } return ans } 复杂度 时间复杂度：$ O(M+n), M = len(bookings) $ 空间复杂度：$ O(1) $ ","date":"2021-08-31T10:37:40+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1109.-%E8%88%AA%E7%8F%AD%E9%A2%84%E8%AE%A2%E7%BB%9F%E8%AE%A1/","title":"Leetcode 1109. 航班预订统计"},{"content":"链接： https://leetcode-cn.com/problems/random-pick-with-weight/\n难度： 中等\n题目描述 给定一个正整数数组 w ，其中 w[i] 代表下标 i 的权重（下标从 0 开始），请写一个函数 pickIndex ，它可以随机地获取下标 i，选取下标 i 的概率与 w[i] 成正比。\n例如，对于 w = [1, 3]，挑选下标 0 的概率为 1 / (1 + 3) = 0.25 （即，25%），而选取下标 1 的概率为 3 / (1 + 3) = 0.75（即，75%）。\n也就是说，选取下标 i 的概率为 w[i] / sum(w) 。\n示例 1： 输入：\n[\u0026ldquo;Solution\u0026rdquo;,\u0026ldquo;pickIndex\u0026rdquo;]\n[[[1]],[]]\n输出：\n[null,0]\n解释：\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // 返回 0，因为数组中只有一个元素，所以唯一的选择是返回下标 0。\n示例 2： 输入：\n[\u0026ldquo;Solution\u0026rdquo;,\u0026ldquo;pickIndex\u0026rdquo;,\u0026ldquo;pickIndex\u0026rdquo;,\u0026ldquo;pickIndex\u0026rdquo;,\u0026ldquo;pickIndex\u0026rdquo;,\u0026ldquo;pickIndex\u0026rdquo;]\n[[[1,3]],[],[],[],[],[]]\n输出：\n[null,1,1,1,1,0]\n解释：\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // 返回 1，返回下标 1，返回该下标概率为 3/4 。\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 1\nsolution.pickIndex(); // 返回 0，返回下标 0，返回该下标概率为 1/4 。\n由于这是一个随机问题，允许多个答案，因此下列输出都可以被认为是正确的:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0] \u0026hellip;\u0026hellip;\n诸若此类。\n提示： 1 \u0026lt;= w.length \u0026lt;= 10000 1 \u0026lt;= w[i] \u0026lt;= 105 pickIndex 将被调用不超过 10000 次 解题思路 前缀和 Constructor ，求的数组 w 的总和 sum，并构造一个生成器。 PickIndex，使用生成器得到一个位于区间 [0,sum) 的随机数 r ，依次遍历 w 数组，计算前缀和，直到前缀和大于 r 时，返回该下标。\ntype Solution struct { r *rand.Rand w []int sum int } func Constructor(w []int) Solution { sum := 0 for _, t := range w { sum += t } return Solution{ r: rand.New(rand.NewSource(time.Now().UnixNano())), w: w, sum: sum, } } func (this *Solution) PickIndex() int { r := rand.Intn(this.sum) preSum := 0 for i, t := range this.w { preSum += t if r \u0026lt; preSum { return i } } return 0 } 复杂度 时间复杂度： Constructor ：$ O(N), N = len(w) $ PickIndex ：$ O(N) $ 空间复杂度：$ O(N) $ 优化(二分查找) 初始化时，构造出前缀和数组，每次生成时即可采用二分查找。\ntype Solution struct { r *rand.Rand sum []int } func Constructor(w []int) Solution { prefixSum := make([]int, len(w)) prefixSum[0] = w[0] for i := 1; i \u0026lt; len(w); i++ { prefixSum[i] += prefixSum[i-1] + w[i] } return Solution{ r: rand.New(rand.NewSource(time.Now().UnixNano())), sum: prefixSum, } } func (this *Solution) PickIndex() int { r := rand.Intn(this.sum[len(this.sum)-1]) return sort.Search(len(this.sum)-1, func(i int) bool { return r \u0026lt; this.sum[i] }) } 复杂度 时间复杂度： Constructor ：$ O(N), N = len(w) $ PickIndex ：$ O(\\log\\ N) $ 空间复杂度：$ O(N) $ ","date":"2021-08-30T10:33:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-528.-%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9/","title":"Leetcode 528. 按权重随机选择"},{"content":"链接： https://leetcode-cn.com/problems/sum-of-all-odd-length-subarrays/\n难度： 简单\n题目描述 给你一个正整数数组 arr ，请你计算所有可能的奇数长度子数组的和。\n子数组 定义为原数组中的一个连续子序列。\n请你返回 arr 中 所有奇数长度子数组的和 。\n示例 1： 输入： arr = [1,4,2,5,3]\n输出： 58\n解释： 所有奇数长度子数组和它们的和为：\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\n我们将所有值求和得到 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58\n示例 2： 输入： arr = [1,2]\n输出： 3\n解释： 总共只有 2 个长度为奇数的子数组，[1] 和 [2]。它们的和为 3 。\n示例 3： 输入： arr = [10,11,12]\n输出： 66\n提示： 1 \u0026lt;= arr.length \u0026lt;= 100 1 \u0026lt;= arr[i] \u0026lt;= 1000 解题思路 暴力求解 枚举出所有奇数子数组的 [i, j]，求得子数组的和，累加进结果中。\nfunc sumOddLengthSubarrays(arr []int) int { sum := 0 for i := 0; i \u0026lt; len(arr); i++ { for j := i; j \u0026lt; len(arr); j += 2 { t := 0 for k := i; k \u0026lt;= j; k++ { t += arr[k] } sum += t } } return sum } 复杂度 时间复杂度：$ O(N^3), N = len(arr) $ 空间复杂度：$ O(1) $ 前缀和 依次枚举出所有子数组的开始下标 i，对于每个 i ，遍历其后元素，求得子数组的和，每当子数组长度为奇数时，将该数组的和累加进结果中。\nfunc sumOddLengthSubarrays(arr []int) int { sum := 0 for i := 0; i \u0026lt; len(arr); i++ { t := 0 for j := i; j \u0026lt; len(arr); j++ { t += arr[j] if (j-i)\u0026amp;1 == 0 { sum += t } } } return sum } 复杂度 时间复杂度：$ O(N^2), N = len(arr) $ 空间复杂度：$ O(1) $ ","date":"2021-08-29T21:32:29+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1588.-%E6%89%80%E6%9C%89%E5%A5%87%E6%95%B0%E9%95%BF%E5%BA%A6%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E5%92%8C/","title":"Leetcode 1588. 所有奇数长度子数组的和"},{"content":"链接： https://leetcode-cn.com/problems/running-sum-of-1d-array/\n难度： 简单\n题目描述 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。\n请返回 nums 的动态和。\n示例 1： 输入： nums = [1,2,3,4]\n输出： [1,3,6,10]\n解释： 动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。\n示例 2： 输入： nums = [1,1,1,1,1]\n输出： [1,2,3,4,5]\n解释： 动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。\n示例 3： 输入： nums = [3,1,2,10,1]\n输出： [3,4,6,16,17]\n提示： 1 \u0026lt;= nums.length \u0026lt;= 1000 -106 \u0026lt;= nums[i] \u0026lt;= 106 解题思路 模拟 按照题目描述，依次求解动态和的每一项\nfunc runningSum(nums []int) []int { sum := make([]int, len(nums)) for i := 0; i \u0026lt; len(nums); i++ { for j := 0; j \u0026lt;= i; j++ { sum[i] += nums[j] } } return sum } 复杂度 时间复杂度：$ O(N^2), N = len(nums) $ 空间复杂度：$ O(1) $ 动态规划 使用 sum[i] 记录第 i 项动态和，则可以得出：sum[i] = sum[i-1] + nums[i]，依次向后求解。\nfunc runningSum(nums []int) []int { sum := make([]int, len(nums)) sum[0] = nums[0] for i := 1; i \u0026lt; len(nums); i++ { sum[i] = sum[i-1] + nums[i] } return sum } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ​ ","date":"2021-08-28T11:05:35+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1480.-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E5%92%8C/","title":"Leetcode 1480. 一维数组的动态和"},{"content":"链接： https://leetcode-cn.com/problems/boats-to-save-people/\n难度： 中等\n题目描述 第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。\n每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。\n返回载到每一个人所需的最小船数。(保证每个人都能被船载)。\n示例 1： 输入： people = [1,2], limit = 3\n输出： 1\n解释： 1 艘船载 (1, 2)\n示例 2： 输入： people = [3,2,2,1], limit = 3\n输出： 3\n解释： 3 艘船分别载 (1, 2), (2) 和 (3)\n示例 3： 输入： people = [3,5,3,4], limit = 5\n输出： 4\n解释： 4 艘船分别载 (3), (3), (4), (5)\n提示： 1 \u0026lt;= people.length \u0026lt;= 50000 1 \u0026lt;= people[i] \u0026lt;= limit \u0026lt;= 30000 解题思路 排序 + 贪心 由于每艘船最多仅能搭乘两人，可以按照体重排序，每次选出最重的和最轻的两个人，尝试能否同乘一条船：\n当可以同乘一条船时，所需船数量加一，从剩余人中继续挑选； 当无法同乘一条船时，最重的那个人需要独自乘坐一条船，所需船数量加一，轻的人回到队列中 最终使得所有人都乘到船为止，返回所需船的数量。\nfunc numRescueBoats(people []int, limit int) int { boats := 0 sort.Ints(people) for i, j := 0, len(people)-1; i \u0026lt;= j; boats++ { if people[i]+people[j] \u0026lt;= limit { i++ j-- } else { j-- } } return boats } 复杂度 时间复杂度：$ O(N\\log\\ N), N = len(people) $ 空间复杂度：$ O(\\log\\ N) $ ","date":"2021-08-26T18:56:34+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-881.-%E6%95%91%E7%94%9F%E8%89%87/","title":"Leetcode 881. 救生艇"},{"content":"链接： https://leetcode-cn.com/problems/all-paths-from-source-to-target/\n难度： 中等\n题目描述 给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）\n二维数组的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些节点，空就是没有下一个结点了。\n译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。\n示例 1： 输入： graph = [[1,2],[3],[3],[]]\n输出： [[0,1,3],[0,2,3]]\n解释： 有两条路径 0 -\u0026gt; 1 -\u0026gt; 3 和 0 -\u0026gt; 2 -\u0026gt; 3\n示例 2： 输入： graph = [[4,3,1],[3,2,4],[3],[4],[]]\n输出： [[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]\n示例 3： 输入： graph = [[1],[]]\n输出： [[0,1]]\n示例 4： 输入： graph = [[1,2,3],[2],[3],[]]\n输出： [[0,1,2,3],[0,2,3],[0,3]]\n示例 5： 输入： graph = [[1,3],[2],[3],[]]\n输出： [[0,1,2,3],[0,3]]\n提示： n == graph.length 2 \u0026lt;= n \u0026lt;= 15 0 \u0026lt;= graph[i][j] \u0026lt; n graph[i][j] != i（即，不存在自环） graph[i] 中的所有元素 互不相同 保证输入为 有向无环图（DAG） 解题思路 深度优先搜索 采用深度优先搜索，每次将遍历到的结点入栈，直到到达终点，将栈内的路径加入到结果集中。\nfunc allPathsSourceTarget(graph [][]int) [][]int { res := make([][]int, 0, len(graph)) path := make([]int, len(graph)) var dfs func(i int, depth int) dfs = func(i int, depth int) { if depth == len(graph) { return } path[depth] = i // 到达终点，加入结果 if i == len(graph)-1 { t := make([]int, depth+1) copy(t, path[:depth+1]) res = append(res, t) return } // 遍历下一个结点 for _, next := range graph[i] { dfs(next, depth+1) } } dfs(0, 0) return res } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(n) $ ","date":"2021-08-25T22:05:55+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-797.-%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84%E8%B7%AF%E5%BE%84/","title":"Leetcode 797. 所有可能的路径"},{"content":"链接： https://leetcode-cn.com/problems/throne-inheritance/\n难度： 简单\n题目描述 给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ：\nnums[0] = 0 nums[1] = 1 当 2 \u0026lt;= 2 * i \u0026lt;= n 时，nums[2 * i] = nums[i] 当 2 \u0026lt;= 2 * i + 1 \u0026lt;= n 时，nums[2 * i + 1] = nums[i] + nums[i + 1] 返回生成数组 nums 中的 最大 值。\n示例 1： 输入： n = 7\n输出： 3\n解释： 根据规则：\nnums[0] = 0\nnums[1] = 1\nnums[(1 * 2) = 2] = nums[1] = 1\nnums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2\nnums[(2 * 2) = 4] = nums[2] = 1\nnums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3\nnums[(3 * 2) = 6] = nums[3] = 2\nnums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3\n因此，nums = [0,1,1,2,1,3,2,3]，最大值 3\n示例 2： 输入： n = 2\n输出： 1\n解释： 根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1\n示例 3： 输入： n = 3\n输出： 2\n解释： 根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2\n提示： 0 \u0026lt;= n \u0026lt;= 100 解题思路 模拟 按照题设公式，依次求得每个元素的值，返回最大值。\nfunc getMaximumGenerated(n int) int { if n \u0026lt;= 1 { return n } max := 0 nums := make([]int, n+1) nums[0] = 0 nums[1] = 1 for i := 2; i \u0026lt;= n; i++ { if i\u0026amp;1 == 0 { nums[i] = nums[i/2] } else { nums[i] = nums[i/2] + nums[i/2+1] } if max \u0026lt; nums[i] { max = nums[i] } } return max } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(n) $ ","date":"2021-08-23T10:49:08+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1646.-%E8%8E%B7%E5%8F%96%E7%94%9F%E6%88%90%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","title":"Leetcode 1646. 获取生成数组中的最大值"},{"content":"链接： https://leetcode-cn.com/problems/string-compression/\n难度： 中等\n题目描述 给你一个字符数组 chars ，请使用下述算法压缩：\n从一个空字符串 s 开始。对于 chars 中的每组 连续重复字符 ：\n如果这一组长度为 1 ，则将字符追加到 s 中。 否则，需要向 s 追加字符，后跟这一组的长度。 压缩后得到的字符串 s 不应该直接返回 ，需要转储到字符数组 chars 中。需要注意的是，如果组长度为 10 或 10 以上，则在 chars 数组中会被拆分为多个字符。\n请在 修改完输入数组后 ，返回该数组的新长度。\n你必须设计并实现一个只使用常量额外空间的算法来解决此问题。\n示例 1： 输入： chars = [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;c\u0026rdquo;,\u0026ldquo;c\u0026rdquo;,\u0026ldquo;c\u0026rdquo;]\n输出： 返回 6 ，输入数组的前 6 个字符应该是：[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;c\u0026rdquo;,\u0026ldquo;3\u0026rdquo;]\n解释：\n\u0026ldquo;aa\u0026rdquo; 被 \u0026ldquo;a2\u0026rdquo; 替代。\u0026ldquo;bb\u0026rdquo; 被 \u0026ldquo;b2\u0026rdquo; 替代。\u0026ldquo;ccc\u0026rdquo; 被 \u0026ldquo;c3\u0026rdquo; 替代。\n示例 2： 输入： chars = [\u0026ldquo;a\u0026rdquo;]\n输出： 返回 1 ，输入数组的前 1 个字符应该是：[\u0026ldquo;a\u0026rdquo;]\n解释：\n没有任何字符串被替代。\n示例 3： 输入： chars = [\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;b\u0026rdquo;]\n输出： 返回 4 ，输入数组的前 4 个字符应该是：[\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;2\u0026rdquo;]。\n解释：\n由于字符 \u0026ldquo;a\u0026rdquo; 不重复，所以不会被压缩。\u0026ldquo;bbbbbbbbbbbb\u0026rdquo; 被 “b12” 替代。\n注意每个数字在数组中都有它自己的位置。\n提示： 1 \u0026lt;= chars.length \u0026lt;= 2000 chars[i] 可以是小写英文字母、大写英文字母、数字或符号 解题思路 双指针 使用两个指针，分别指向当前遍历到的位置和当前压缩数组的尾部，向后遍历数组，统计每组相同字符出现的次数，计算得到该组压缩后的长度，添加到压缩数组的尾部。\nfunc compress(chars []byte) int { res := 0 cnt := 1 // 当前组数量 for i, c := range chars { // 当前组结束 if i == len(chars)-1 || c != chars[i+1] { chars[res] = c res++ // 写入出现次数 if cnt \u0026gt; 1 { digits := make([]byte, 0, 4) for ; cnt \u0026gt; 0; cnt /= 10 { digits = append(digits, byte(\u0026#39;0\u0026#39;+cnt%10)) } for j := len(digits) - 1; j \u0026gt;= 0; j-- { chars[res] = digits[j] res++ } } cnt = 1 } else { cnt++ } } return res } 复杂度 时间复杂度：$ O(N), N = len(chars) $ 空间复杂度：$ O(1) $ ","date":"2021-08-21T14:52:12+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-443.-%E5%8E%8B%E7%BC%A9%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"Leetcode 443. 压缩字符串"},{"content":"链接： https://leetcode-cn.com/problems/reverse-string-ii/\n难度： 简单\n题目描述 给定一个字符串 s 和一个整数 k，从字符串开头算起，每 2k 个字符反转前 k 个字符。\n如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n示例 1： 输入： s = \u0026ldquo;abcdefg\u0026rdquo;, k = 2\n输出： \u0026ldquo;bacdfeg\u0026rdquo;\n示例 2： 输入： s = \u0026ldquo;abcd\u0026rdquo;, k = 2\n输出： \u0026ldquo;bacd\u0026rdquo;\n提示： 1 \u0026lt;= s.length \u0026lt;= 104 s 仅由小写英文组成 1 \u0026lt;= k \u0026lt;= 104 解题思路 模拟 以长度为 2k 为单位将字符串分割，对于每个区间，反转前 k 个字符。\n对于尾部需进行特判，反转区间不足 k 时，反转到尾部为止。\nfunc reverseStr(s string, k int) string { t := []byte(s) for i := 0; i \u0026lt;= len(t); i += (k \u0026lt;\u0026lt; 1) { // 尾部判定 tail := i + k if len(t) \u0026lt; i+k { tail = len(t) } for l, r := i, tail-1; l \u0026lt; r; l, r = l+1, r-1 { t[l], t[r] = t[r], t[l] } } return string(t) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-08-20T13:31:40+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-541.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-ii/","title":"Leetcode 541. 反转字符串 II"},{"content":"链接： https://leetcode-cn.com/problems/reverse-vowels-of-a-string/\n难度： 简单\n题目描述 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。\n示例 1： 输入： \u0026ldquo;hello\u0026rdquo;\n输出： \u0026ldquo;holle\u0026rdquo;\n示例 2： 输入： \u0026ldquo;leetcode\u0026rdquo;\n输出： \u0026ldquo;leotcede\u0026rdquo;\n提示： 元音字母不包含字母 \u0026ldquo;y\u0026rdquo; 。 解题思路 双指针 使用两个指针 i, j 分别从字符串首尾向中间遍历：\n遇到非元音字母向中间靠拢； i, j 两个指针都指向元音字母时，交换两个指针指向的字母并向中靠拢 最终两个指针相遇时停止，元音字母反转完毕。\nfunc reverseVowels(s string) string { t := []byte(s) isVowel := map[byte]bool{ \u0026#39;a\u0026#39;: true, \u0026#39;A\u0026#39;: true, \u0026#39;e\u0026#39;: true, \u0026#39;E\u0026#39;: true, \u0026#39;i\u0026#39;: true, \u0026#39;I\u0026#39;: true, \u0026#39;o\u0026#39;: true, \u0026#39;O\u0026#39;: true, \u0026#39;u\u0026#39;: true, \u0026#39;U\u0026#39;: true, } for i, j := 0, len(s)-1; i \u0026lt; j; { if !isVowel[t[i]] { i++ continue } if !isVowel[t[j]] { j-- continue } t[i], t[j] = t[j], t[i] i++ j-- } return string(t) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-08-19T10:40:59+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-345.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D/","title":"Leetcode 345. 反转字符串中的元音字母"},{"content":"链接： https://leetcode-cn.com/problems/student-attendance-record-i/\n难度： 简单\n题目描述 给你一个字符串 s 表示一个学生的出勤记录，其中的每个字符用来标记当天的出勤情况（缺勤、迟到、到场）。记录中只含下面三种字符：\n'A'：Absent，缺勤\n'L'：Late，迟到\n'P'：Present，到场\n如果学生能够 同时 满足下面两个条件，则可以获得出勤奖励：\n按 总出勤 计，学生缺勤（'A'）严格 少于两天。 学生 不会 存在 连续 3 天或 3 天以上的迟到（'L'）记录。 如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。\n示例 1： 输入： s = \u0026ldquo;PPALLP\u0026rdquo; 输出： true 解释： 学生缺勤次数少于 2 次，且不存在 3 天或以上的连续迟到记录。 示例 2： 输入： s = \u0026ldquo;PPALLL\u0026rdquo; 输出： false 解释： 学生最后三天连续迟到，所以不满足出勤奖励的条件。 提示： 1 \u0026lt;= s.length \u0026lt;= 1000 s[i] 为 'A'、'L' 或 'P' 解题思路 计数 遍历字符串，每次针对缺和迟到做如下处理:\n每次遇到 'A' , 缺勤次数+1； 每次遇到 'L' , 迟到次数+1，由于连续迟到才会得不到奖励，故每当遇到 'A' 和 'P' 时，连续迟到次数会被打断，故将连续迟到次数清 0。 每次循环后判断缺勤次数和连续迟到次数，以确定能否得到奖励\nfunc checkRecord(s string) bool { absent := 0 late := 0 for i := range s { switch s[i] { case \u0026#39;A\u0026#39;: absent++ late = 0 case \u0026#39;L\u0026#39;: late++ case \u0026#39;P\u0026#39;: late = 0 } if absent \u0026gt;= 2 || late \u0026gt;= 3 { return false } } return true } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(1) $ ","date":"2021-08-17T10:51:13+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-551.-%E5%AD%A6%E7%94%9F%E5%87%BA%E5%8B%A4%E8%AE%B0%E5%BD%95-i/","title":"Leetcode 551. 学生出勤记录 I"},{"content":"链接： https://leetcode-cn.com/problems/beautiful-arrangement/\n难度： 中等\n题目描述 假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 \u0026lt;= i \u0026lt;= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：\n第 i 位的数字能被 i 整除 i 能被第 i 位上的数字整除 现在给定一个整数 N，请问可以构造多少个优美的排列？\n示例： 输入: 2\n输出: 2\n解释:\n第 1 个优美的排列是 [1, 2]:\n第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除\n第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除\n第 2 个优美的排列是 [2, 1]:\n第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除\n第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除\n说明： N 是一个正整数，并且不会超过 15。 解题思路 回溯 使用一个数组 arr 记录该排列，另使用一个数组 choice 记录每个数字是否已经被填写到 arr 中。\n从下标 1 开始，依次选择数字填入到 arr，直到填满数组或者无法找到符合要求的数字，回溯。每次填满数字时，排列数+1。\nfunc countArrangement(n int) int { arr := make([]int, n+1) choice := make([]bool, n+1) res := 0 for idx := 1; idx \u0026gt; 0; { find := false // 是否找到满足田间的数 choice[arr[idx]] = false // 当前数未选择 // 寻找下一个数 for num := arr[idx] + 1; num \u0026lt;= n; num++ { if !choice[num] \u0026amp;\u0026amp; (num%idx == 0 || idx%num == 0) { choice[num] = true // 已选择 arr[idx] = num // 填入 idx++ find = true /// 已找到 break } } if !find { // 未找到满足条件的数 arr[idx] = 0 choice[arr[idx]] = false // 当前数未选择 idx-- // 回溯 } else if idx \u0026gt; n { // 已填满，回溯 idx-- // 回溯 choice[arr[idx]] = false // 当前数未选择 res++ // 排列数 +1 } } return res } 复杂度 时间复杂度：$ O(n!) $ 空间复杂度：$ O(n) $ ","date":"2021-08-16T22:54:27+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-526.-%E4%BC%98%E7%BE%8E%E7%9A%84%E6%8E%92%E5%88%97/","title":"Leetcode 526. 优美的排列"},{"content":"链接： https://leetcode-cn.com/problems/out-of-boundary-paths/\n难度： 中等\n题目描述 给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你 最多 可以移动 maxMove 次球。\n给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 109 + 7 取余 后的结果。\n示例 1： \u0026lt;img src=\u0026quot;/img/576.out_of_boundary_paths_1.png\u0026quot;, width=\u0026ldquo;500px\u0026rdquo;\u0026gt;\n输入： m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0\n输出： 6\n示例 2： \u0026lt;img src=\u0026quot;/img/576.out_of_boundary_paths_2.png\u0026quot;, width=\u0026ldquo;500px\u0026rdquo;\u0026gt;\n输入： m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1\n输出： 12\n提示： 1 \u0026lt;= m, n \u0026lt;= 50 0 \u0026lt;= maxMove \u0026lt;= 50 0 \u0026lt;= startRow \u0026lt; m 0 \u0026lt;= startColumn \u0026lt; n 解题思路 动态规划 使用 dp[move][row][col] 记录移动 move 次后，球位于第 row 行 col 列的方案数量。由于球只能来自周围的单元格，易得状态转移方程：\ndp[startRow][startColumn] = 1 dp[move+1][row][col] = dp[move][row-1][col] + dp[move][row+1][col] + dp[move][row][col-1] + dp[move][row][col1] 由于每次依赖上一次移动，使用滚动数组以降低空间复杂度。 此外，每次移动时，需要进行边界判断，每当可以移出边界时，累加进结果中。\nfunc findPaths(m int, n int, maxMove int, startRow int, startColumn int) int { const MOD = 1e9 + 7 dpCur := make([][]int, m) dpNext := make([][]int, m) for i := 0; i \u0026lt; m; i++ { dpCur[i] = make([]int, n) dpNext[i] = make([]int, n) } dpCur[startRow][startColumn] = 1 res := 0 for move := 0; move \u0026lt; maxMove; move++ { for row := 0; row \u0026lt; m; row++ { for col := 0; col \u0026lt; n; col++ { dpNext[row][col] = 0 for _, offset := range [][]int{{-1, 0}, {1, 0}, {0, -1}, {0, 1}} { // 在边界内 if row+offset[0] \u0026gt;= 0 \u0026amp;\u0026amp; row+offset[0] \u0026lt; m \u0026amp;\u0026amp; col+offset[1] \u0026gt;= 0 \u0026amp;\u0026amp; col+offset[1] \u0026lt; n { dpNext[row][col] = (dpNext[row][col] + dpCur[row+offset[0]][col+offset[1]]) % MOD } else { res = (res + dpCur[row][col]) % MOD } } } } dpCur, dpNext = dpNext, dpCur fmt.Println(dpCur, res) } return res } 复杂度 时间复杂度：$ O(maxMovemn) $ 空间复杂度：$ O(m*n) $ ","date":"2021-08-15T11:04:33+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-576.-%E5%87%BA%E7%95%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E6%95%B0/","title":"Leetcode 576. 出界的路径数"},{"content":"链接： https://leetcode-cn.com/problems/count-unhappy-friends/\n难度： 中等\n题目描述 给你一份 n 位朋友的亲近程度列表，其中 n 总是 偶数 。\n对每位朋友 i，preferences[i] 包含一份 按亲近程度从高到低排列 的朋友列表。换句话说，排在列表前面的朋友与 i 的亲近程度比排在列表后面的朋友更高。每个列表中的朋友均以 0 到 n-1 之间的整数表示。\n所有的朋友被分成几对，配对情况以列表 pairs 给出，其中 pairs[i] = [xi, yi] 表示 xi 与 yi 配对，且 yi 与 xi 配对。\n但是，这样的配对情况可能会是其中部分朋友感到不开心。在 x 与 y 配对且 u 与 v 配对的情况下，如果同时满足下述两个条件，x 就会不开心：\nx 与 u 的亲近程度胜过 x 与 y，且 u 与 x 的亲近程度胜过 u 与 v 返回 不开心的朋友的数目 。\n示例 1： 输入： n = 4, preferences = [[1, 2, 3], [3, 2, 0], [3, 1, 0], [1, 2, 0]], pairs = [[0, 1], [2, 3]]\n输出： 2\n解释：\n朋友 1 不开心，因为：\n1 与 0 配对，但 1 与 3 的亲近程度比 1 与 0 高，且 3 与 1 的亲近程度比 3 与 2 高。\n朋友 3 不开心，因为： 3 与 2 配对，但 3 与 1 的亲近程度比 3 与 2 高，且 1 与 3 的亲近程度比 1 与 0 高。\n朋友 0 和 2 都是开心的。 示例 2： 输入： n = 2, preferences = [[1], [0]], pairs = [[1, 0]]\n输出： 0\n解释： 朋友 0 和 1 都开心。\n示例 3： 输入： n = 4, preferences = [[1, 3, 2], [2, 3, 0], [1, 3, 0], [0, 2, 1]], pairs = [[1, 3], [0, 2]]\n输出： 4\n提示： 2 \u0026lt;= n \u0026lt;= 500 n 是偶数 preferences.length == n preferences[i].length == n - 1 0 \u0026lt;= preferences[i][j] \u0026lt;= n - 1 preferences[i] 不包含 i preferences[i] 中的所有值都是独一无二的 pairs.length == n/2 pairs[i].length == 2 xi != yi 0 \u0026lt;= xi, yi \u0026lt;= n - 1 每位朋友都 恰好 被包含在一对中 解题思路 模拟 对于每一个元素 xi，找出所有比其配对元素 yi 更亲近的所有元素，判断这些元素与 xi 的亲近程度是否高于自己的配对元素。\nfunc unhappyFriends(n int, preferences [][]int, pairs [][]int) int { // 记录每个元素的配对元素 pair := make([]int, n) for _, p := range pairs { pair[p[0]] = p[1] pair[p[1]] = p[0] } // 记录连个元素间的亲近程度 closer := make([][]int, n) for i, others := range preferences { closer[i] = make([]int, n) for j, other := range others { closer[i][other] = j } } unhappy := 0 for k, v := range pair { // 寻找更亲近的元素 p for _, p := range preferences[k] { if p == v { break } // p 与当前元素 k 的亲近程度更高, k 不开心 if closer[p][k] \u0026lt; closer[p][pair[p]] { unhappy++ break } } } return unhappy } 复杂度 时间复杂度：$ O(n^2) $ 空间复杂度：$ O(n^2) $ ","date":"2021-08-14T10:51:40+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1583.-%E7%BB%9F%E8%AE%A1%E4%B8%8D%E5%BC%80%E5%BF%83%E7%9A%84%E6%9C%8B%E5%8F%8B/","title":"Leetcode 1583. 统计不开心的朋友"},{"content":"链接： https://leetcode-cn.com/problems/longest-palindromic-subsequence/\n难度： 中等\n题目描述 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。\n子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。\n示例 1： 输入： s = \u0026ldquo;bbbab\u0026rdquo;\n输出： 4\n解释： 一个可能的最长回文子序列为 \u0026ldquo;bbbb\u0026rdquo; 。\n示例 2： 输入： s = \u0026ldquo;cbbd\u0026rdquo;\n输出： 2\n解释： 一个可能的最长回文子序列为 \u0026ldquo;bb\u0026rdquo; 。\n注意： 1 \u0026lt;= s.length \u0026lt;= 1000 s 仅由小写英文字母组成 解题思路 动态规划 该题可以转化为寻找原字符串 s 和倒序字符串 s' 的最长公共子序列问题。使用动态规划求解，dp[i][j] 表示以下标 i, j 结尾的前缀字串最长公共子序列的长度，状态转移方程如下：\n当 s[i] == s'[j]，dp[i][j] = dp[i-1][j-1] + 1 当 s[i] == s'[j]，dp[i][j] = max(dp[i-1][j], dp[i][j-1] 每次状态转移时仅依赖当前行和上一行，故可以使用滚动数组降低空间复杂度。\nfunc longestPalindromeSubseq(s string) int { dp := [][]int{ make([]int, len(s)+1), make([]int, len(s)+1), } last := 1 cur := 0 for i := 0; i \u0026lt; len(s); i++ { cur, last = last, cur for j := 0; j \u0026lt; len(s); j++ { if s[i] == s[len(s)-1-j] { dp[cur][j+1] = dp[last][j] + 1 } else if dp[cur][j] \u0026gt; dp[last][j+1] { dp[cur][j+1] = dp[cur][j] } else { dp[cur][j+1] = dp[last][j+1] } } } return dp[cur][len(s)] } 复杂度 时间复杂度：$ O(N^2), N = len(s) $ 空间复杂度：$ O(N) $ ","date":"2021-08-12T11:16:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-516.-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/","title":"Leetcode 516. 最长回文子序列"},{"content":"链接： https://leetcode-cn.com/problems/arithmetic-slices/\n难度： 中等\n题目描述 如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。\n例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。 给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。\n子数组 是数组中的一个连续序列。\n示例 1： 输入： nums = [1,2,3,4]\n输出： 3\n解释： nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。\n示例 2： 输入： nums = [1]\n输出： 0\n提示： 1 \u0026lt;= nums.length \u0026lt;= 5000 -1000 \u0026lt;= nums[i] \u0026lt;= 1000 解题思路 数学 对于一个等差数列数组，其长度为 n (n ≥ 3)，其等差数列 子数组 的数量由长度为 3, ..., n 的子数组构成，对应的 子数组 数量为 n-2, ..., 1，其构成等差数列，故总数量为$\\sum\\limits_{i=1}^{n-2}i = \\frac{(n-2+1)(n-2)}{2} = \\frac{(n-1)(n-2)}{2}$\n子数组 为等差数列，则其 父数组 也必须为等差数列。遍历整个数组，找到所有的等差数列父数组，对于子数组的数量求和。\nfunc numberOfArithmeticSlices(nums []int) int { res := 0 n := 1 // 初始只有一个元素 d := 0 // 公差 for i := 1; i \u0026lt; len(nums); i++ { if d == nums[i]-nums[i-1] { // 与之前元素构成等差数列 n++ } else { // 与之前元素不构成等差数列 // 累加前一个等差数列 子数组 数量 if n \u0026gt;= 3 { res += (n - 2) * (n - 1) / 2 } // 初始化公差 \u0026amp; 元素数量 d = nums[i] - nums[i-1] n = 2 } } // 遍历结束，判定尾部等差数列 if n \u0026gt;= 3 { res += (n - 2) * (n - 1) / 2 } return res } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-08-10T10:42:43+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-413.-%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E5%88%92%E5%88%86/","title":"Leetcode 413. 等差数列划分"},{"content":"链接： https://leetcode-cn.com/problems/super-ugly-number/\n难度： 中等\n题目描述 超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。\n给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。\n题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。\n示例 1： 输入： n = 12, primes = [2,7,13,19]\n输出： 32\n解释： 给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。\n示例 2： 输入： n = 1, primes = [2,3,5]\n输出： 1\n解释： 1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。\n注意： 1 \u0026lt;= n \u0026lt;= 106 1 \u0026lt;= primes.length \u0026lt;= 100 2 \u0026lt;= primes[i] \u0026lt;= 1000 题目数据 保证 primes[i] 是一个质数 primes 中的所有值都 互不相同 ，且按 递增顺序 排列 解题思路 堆 + 哈希 使用小顶堆维护超级丑数，初始时，仅有一个超级丑数 1，每次取出最小的超级丑数，依次乘以 primes 中的每个元素并入堆。为防止重复元素入堆，使用哈希表进行记录去重。\n重复上述步骤 n 次，即得到了第 n 个最小的超级丑数。\ntype MinHeap struct { sort.IntSlice } func (m *MinHeap) Push(x interface{}) { m.IntSlice = append(m.IntSlice, x.(int)) } func (m *MinHeap) Pop() interface{} { t := m.IntSlice[len(m.IntSlice)-1] m.IntSlice = m.IntSlice[:len(m.IntSlice)-1] return t } func nthSuperUglyNumber(n int, primes []int) int { appear := make(map[int]struct{}) minHeap := \u0026amp;MinHeap{IntSlice: make([]int, 0, len(primes)*n)} heap.Push(minHeap, 1) appear[1] = struct{}{} x := 1 for i := 0; i \u0026lt; n; i++ { x = heap.Pop(minHeap).(int) for _, p := range primes { if _, ok := appear[p*x]; !ok { heap.Push(minHeap, p*x) appear[p*x] = struct{}{} } } } return x } 复杂度 时间复杂度：$ O(nP\\log(nP)), P = len(primes) $ 空间复杂度：$ O(nP) $ ","date":"2021-08-09T11:00:42+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-313.-%E8%B6%85%E7%BA%A7%E4%B8%91%E6%95%B0/","title":"Leetcode 313. 超级丑数"},{"content":"链接： https://leetcode-cn.com/problems/n-th-tribonacci-number/\n难度： 简单\n题目描述 泰波那契序列 Tn 定义如下： T0 = 0, T1 = 1, T2 = 1, 且在 n \u0026gt;= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2\n给你整数 n，请返回第 n 个泰波那契数 Tn 的值。\n示例 1： 输入： n = 4\n输出： 4\n解释：\nT_3 = 0 + 1 + 1 = 2\nT_4 = 1 + 1 + 2 = 4\n示例 2： 输入： n = 25 输出： 1389537\n提示： 0 \u0026lt;= n \u0026lt;= 37 答案保证是一个 32 位整数，即 answer \u0026lt;= 231 - 1。 解题思路 动态规划 初始 t[0] = 0, t[1] = 1, t[2] = 1，依次向后递推计算，直到 t[n]。\n由于每次仅涉及前三个变量，可以复用以降低空间复杂度。\nfunc tribonacci(n int) int { if n == 0 { return 0 } if n == 1 || n == 2 { return 1 } t0 := 0 t1 := 1 t2 := 1 t := 0 for i := 3; i \u0026lt;= n; i++ { t = t0 + t1 + t2 t0 = t1 t1 = t2 t2 = t } return t } 复杂度 时间复杂度：$ O(n) $ 空间复杂度：$ O(1) $ ","date":"2021-08-08T09:18:26+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1137.-%E7%AC%AC-n-%E4%B8%AA%E6%B3%B0%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0/","title":"Leetcode 1137. 第 N 个泰波那契数"},{"content":"链接： https://leetcode-cn.com/problems/circular-array-loop/\n难度： 中等\n题目描述 存在一个不含 0 的 环形 数组 nums ，每个 nums[i] 都表示位于下标 i 的角色应该向前或向后移动的下标个数：\n如果 nums[i] 是正数，向前 移动 nums[i] 步 如果 nums[i] 是负数，向后 移动 nums[i] 步 因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。\n数组中的 循环 由长度为 k 的下标序列 seq ：\n遵循上述移动规则将导致重复下标序列 seq[0] -\u0026gt; seq[1] -\u0026gt; ... -\u0026gt; seq[k - 1] -\u0026gt; seq[0] -\u0026gt; ... 所有 nums[seq[j]] 应当不是 全正 就是 全负 k \u0026gt; 1 如果 nums 中存在循环，返回 true ；否则，返回 false 。\n示例 1： 输入： nums = [2,-1,1,2,2]\n输出： true\n解释： 存在循环，按下标 0 -\u0026gt; 2 -\u0026gt; 3 -\u0026gt; 0 。循环长度为 3 。\n示例 2： 输入： nums = [-1,2]\n输出： false\n解释： 按下标 1 -\u0026gt; 1 -\u0026gt; 1 \u0026hellip; 的运动无法构成循环，因为循环的长度为 1 。根据定义，循环的长度必须大于 1 。\n示例 3： 输入： nums = [-2,1,-1,-2,-2]\n输出： false\n解释： 按下标 1 -\u0026gt; 2 -\u0026gt; 1 -\u0026gt; \u0026hellip; 的运动无法构成循环，因为 nums[1] 是正数，而 nums[2] 是负数。\n所有 nums[seq[j]] 应当不是全正就是全负。\n提示： 1 \u0026lt;= nums.length \u0026lt;= 5000 -1000 \u0026lt;= nums[i] \u0026lt;= 1000 nums[i] != 0 解题思路 快慢指针 使用快慢指针依次遍历，若有环，则快慢指针最后会相遇。遍历时注意移动方向要一致。\nfunc circularArrayLoop(nums []int) bool { visit := make([]bool, len(nums)) for i := 0; i \u0026lt; len(nums); i++ { if visit[i] { continue } slow := i visit[slow] = true fast := ((slow+nums[slow])%len(nums) + len(nums)) % len(nums) if nums[slow]*nums[fast] \u0026lt; 0 || visit[fast] { continue } for slow != fast { // 快指针前进两步 next := ((fast+nums[fast])%len(nums) + len(nums)) % len(nums) if next == fast || nums[fast]*nums[next] \u0026lt; 0 { break } fast = next next = ((fast+nums[fast])%len(nums) + len(nums)) % len(nums) if next == fast || nums[fast]*nums[next] \u0026lt; 0 { break } fast = next // 慢指针前进一步 slow = ((slow+nums[slow])%len(nums) + len(nums)) % len(nums) if visit[slow] { break } visit[slow] = true } if slow == fast { return true } } return false } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2021-08-07T19:33:30+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-457.-%E7%8E%AF%E5%BD%A2%E6%95%B0%E7%BB%84%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E5%BE%AA%E7%8E%AF/","title":"Leetcode 457. 环形数组是否存在循环"},{"content":"链接： https://leetcode-cn.com/problems/find-eventual-safe-states/\n难度： 中等\n题目描述 在有向图中，以某个节点为起始节点，从该点出发，每一步沿着图中的一条有向边行走。如果到达的节点是终点（即它没有连出的有向边），则停止。\n对于一个起始节点，如果从该节点出发，无论每一步选择沿哪条有向边行走，最后必然在有限步内到达终点，则将该起始节点称作是 安全 的。\n返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。\n该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。\n示例 1： 输入： graph = [[1,2],[2,3],[5],[0],[5],[],[]]\n输出： [2,4,5,6]\n解释： 示意图如上。\n示例 2： 输入： graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\n输出： [4]\n提示： n == graph.length 1 \u0026lt;= n \u0026lt;= 104 0 \u0026lt;= graph[i].length \u0026lt;= n graph[i] 按严格递增顺序排列。 图中可能包含自环。 图中边的数目在范围 [1, 4 * 104] 内。 解题思路 深度优先搜索 通过分析题目得知，当图无环时，所有结点均为 安全 结点；当图有环时，无法到达环的结点属于 安全 结点。\n通过一次深度优先搜索找到环上的结点，找出能到达环结点的所有结点，剩余结点即为 安全 结点。\nfunc eventualSafeNodes(graph [][]int) []int { const ( ALREADY_VISIT = -1 NOT_VISIT = 0 VISIT = 1 ARRIVE_RING = 2 ) attrs := make([]int, len(graph)) var dfs func(node int) bool dfs = func(node int) bool { switch attrs[node] { case ALREADY_VISIT: return false case NOT_VISIT: attrs[node] = VISIT case VISIT: attrs[node] = ARRIVE_RING return true case ARRIVE_RING: return true } // 遍历后续结点，是否可以可到达环 arriveRing := false for _, next := range graph[node] { arriveRing = arriveRing || dfs(next) } // 后续有结点可到达环，则当前结点也可以到达环 if arriveRing { attrs[node] = ARRIVE_RING } // 已访问过的结点，防止重复遍历 if attrs[node] == VISIT { attrs[node] = ALREADY_VISIT } return arriveRing } // dfs 遍历图 for i := 0; i \u0026lt; len(graph); i++ { if attrs[i] == NOT_VISIT { dfs(i) } } // 遍历寻找安全结点 res := make([]int, 0, len(graph)) for i, attr := range attrs { if attr != ARRIVE_RING { res = append(res, i) } } return res } 复杂度 时间复杂度：$ O(n+E), E = size(edges) $ 空间复杂度：$ O(n) $ ","date":"2021-08-05T14:10:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-802.-%E6%89%BE%E5%88%B0%E6%9C%80%E7%BB%88%E7%9A%84%E5%AE%89%E5%85%A8%E7%8A%B6%E6%80%81/","title":"Leetcode 802. 找到最终的安全状态"},{"content":"链接： https://leetcode-cn.com/problems/valid-triangle-number/\n难度： 中等\n题目描述 给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。\n示例： 输入: [2,2,3,4]\n输出: 3\n解释:\n有效的组合是:\n2,3,4 (使用第一个 2)\n2,3,4 (使用第二个 2)\n2,2,3\n注意： 数组长度不超过1000。 数组里整数的范围为 [0, 1000]。 解题思路 排序 + 二分查找 构成三角形的前提条件是两边之和小于第三边，也就是说，两个小边之和大于最长的那条边。\n故，首先对数组进行排序，然后依次枚举两条小边 x 和 y ，其下标为 i 和 j (不妨假设 i ≤ i，则 x ≤ y)，即得到最大边的取值范围 x+y-1， 通过二分查找，找到其最大值的位置，与 j 相减即得到可取值的数量，求和。\nfunc triangleNumber(nums []int) int { sort.Ints(nums) res := 0 for i := 0; i \u0026lt; len(nums)-2; i++ { if nums[i] == 0 { continue } for j := i + 1; j \u0026lt; len(nums)-1; j++ { pos := sort.SearchInts(nums, nums[i]+nums[j]) pos-- if pos-j \u0026gt; 0 { res += pos - j } } } return res } 复杂度 时间复杂度：$ O(N^2\\log\\ N), N = len(nums) $ 空间复杂度：$ O(\\log\\ N) $ 排序 + 双指针 接上题排序的思路，仍然枚举两条小边，不同的是，每次记录上次可以取得最大边的下标 k，上次每次 j 增加时，相应的扩展 k，省去二分查找的时间。\nfunc triangleNumber(nums []int) int { sort.Ints(nums) res := 0 for i := 0; i \u0026lt; len(nums)-2; i++ { if nums[i] == 0 { continue } for j, k := i+1, i+1; j \u0026lt; len(nums)-1; j++ { for ; k+1 \u0026lt; len(nums) \u0026amp;\u0026amp; nums[k+1] \u0026lt; nums[i]+nums[j]; k++ { } res += k - j } } return res } 复杂度 时间复杂度：$ O(N^2), N = len(nums) $ 空间复杂度：$ O(\\log\\ N) $ ","date":"2021-08-04T10:42:47+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-611.-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/","title":"Leetcode 611. 有效三角形的个数"},{"content":"链接： https://leetcode-cn.com/problems/network-delay-time/\n难度： 中等\n题目描述 有 n 个网络节点，标记为 1 到 n 。\n给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。\n现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。\n示例 1： 输入： times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2\n输出： 2\n示例 2： 输入： times = [[1,2,1]], n = 2, k = 1\n输出： 1\n示例 3： 输入： times = [[1,2,1]], n = 2, k = 2\n输出： -1\n提示： 1 \u0026lt;= k \u0026lt;= n \u0026lt;= 100 1 \u0026lt;= times.length \u0026lt;= 6000 times[i].length == 3 1 \u0026lt;= ui, vi \u0026lt;= n ui != vi 0 \u0026lt;= wi \u0026lt;= 100 所有 (ui, vi) 对都 互不相同（即，不含重复边） 解题思路 迪杰斯特拉算法 + 堆 典型的单源最短路径问题，求解到所有结点的最短距离中的最大值，采用迪杰斯特拉算法，使用堆维护结点列表，降低算法复杂度。\ntype NextNode struct { To int // 下一个结点 Weight int // 权，距离 } // 小顶堆，距离源结点距离 type MinHeap struct { Edges []*NextNode } func (m *MinHeap) Len() int { return len(m.Edges) } func (m *MinHeap) Swap(i, j int) { m.Edges[i], m.Edges[j] = m.Edges[j], m.Edges[i] } func (m *MinHeap) Less(i, j int) bool { return m.Edges[i].Weight \u0026lt; m.Edges[j].Weight } func (m *MinHeap) Push(x interface{}) { m.Edges = append(m.Edges, x.(*NextNode)) } func (m *MinHeap) Pop() interface{} { t := m.Edges[m.Len()-1] m.Edges = m.Edges[:m.Len()-1] return t } func networkDelayTime(times [][]int, n int, k int) int { // 初始化结点能到达的其他结点 edges := make(map[int][]*NextNode) for _, time := range times { edges[time[0]-1] = append(edges[time[0]-1], \u0026amp;NextNode{ To: time[1] - 1, Weight: time[2], }) } // 堆初始化，源结点入堆 minHeap := \u0026amp;MinHeap{Edges: make([]*NextNode, 0, len(times))} minHeap.Push(\u0026amp;NextNode{ To: k - 1, Weight: 0, }) isVisit := make(map[int]struct{}) // 是否已访问 distance := make([]int, n) // 距离源结点的距离 // 初始化为无穷大 for i := range distance { distance[i] = math.MaxInt32 } distance[k-1] = 0 // 源结点为0 for minHeap.Len() \u0026gt; 0 { // 获取距离最近的结点 node := heap.Pop(minHeap).(*NextNode) // 己达结点，得到了最小值，跳过 if _, ok := isVisit[node.To]; ok { continue } // 访问结点 isVisit[node.To] = struct{}{} // 可达结点入堆 for _, e := range edges[node.To] { // 己达结点 if _, ok := isVisit[e.To]; ok { continue } // 求解下一个结点更小距离并入堆 if distance[e.To] \u0026gt; e.Weight+distance[node.To] { distance[e.To] = e.Weight + distance[node.To] fmt.Println(e.To, distance[e.To]) } heap.Push(minHeap, \u0026amp;NextNode{ To: e.To, Weight: distance[e.To], }) } } // 有结点不可达 if len(isVisit) \u0026lt; n { return -1 } // 遍历找到所有结点最短距离的最大值，返回 min := -1 for _, d := range distance { if min \u0026lt; d { min = d } } return min } 复杂度 时间复杂度：$ O(E(n+\\log\\ E)), E = len(times) $ 空间复杂度：$ O(n+E) $ ","date":"2021-08-03T20:16:01+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-743.-%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4/","title":"Leetcode 743. 网络延迟时间"},{"content":"链接： https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/\n难度： 中等\n题目描述 给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。\n请你找出符合题意的 最短 子数组，并输出它的长度。\n示例 1： 输入： nums = [2,6,4,8,10,9,15]\n输出： 5\n解释： 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。\n示例 2： 输入： nums = [1,2,3,4]\n输出： 0\n示例 3： 输入： nums = [1]\n输出： 0\n提示： 1 \u0026lt;= nums.length \u0026lt;= 104 -105 \u0026lt;= nums[i] \u0026lt;= 105 进阶： 你可以设计一个时间复杂度为 $O(n)$ 的解决方案吗？\n解题思路 排序 对于连续子数组以外的元素，其在排序前后位置不会改变，故可以将整个数组排序后，从头和尾开始，依次找到不变的元素加以排除，剩余元素就是 最短 连续子数组。\nfunc findUnsortedSubarray(nums []int) int { sortedNum := make([]int, len(nums)) copy(sortedNum, nums) sort.Ints(sortedNum) l := len(nums) for i := 0; i \u0026lt; len(nums) \u0026amp;\u0026amp; nums[i] == sortedNum[i]; i++ { l-- } if l == 0 { return 0 } for i := len(nums) - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] == sortedNum[i]; i-- { l-- } return l } 复杂度 时间复杂度：$ O(N\\log\\ N), N = len(nums) $ 空间复杂度：$ O(N) $ 确定边界 设 min 和 max 为目标数组的最大值和最小值，则该数组左边的所有元素均小于 min，而右边的所有元素均大于 max。\n可以从左向右遍历，同时记录遍历到的最大值，每当当前值小于最大值时，需要扩展右边界，最后确定右边界； 同理，从右向左遍历，同时记录遍历到的最小值，每当当前值大于最小值时 需要扩展左边界， 最后确定左边界。 通过比较左右边界，得到数组长度。\nfunc findUnsortedSubarray(nums []int) int { max := nums[0] right := 0 for i := 1; i \u0026lt; len(nums); i++ { if nums[i] \u0026gt;= max { max = nums[i] } else { right = i } } min := nums[len(nums)-1] left := len(nums) - 1 for i := len(nums) - 1; i \u0026gt;= 0; i-- { if nums[i] \u0026lt;= min { min = nums[i] } else { left = i } } if right \u0026lt;= left { return 0 } return right - left + 1 } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-08-03T14:28:41+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-581.-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/","title":"Leetcode 581. 最短无序连续子数组"},{"content":"链接： https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix/\n难度： 简单\n题目描述 给你一个大小为 m * n 的矩阵 mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。\n请你返回矩阵中战斗力最弱的 k 行的索引，按从最弱到最强排序。\n如果第 i 行的军人数量少于第 j 行，或者两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱。\n军人 总是 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。\n示例 1： 输入： mat =\n[[1,1,0,0,0],\n[1,1,1,1,0],\n[1,0,0,0,0],\n[1,1,0,0,0],\n[1,1,1,1,1]],\nk = 3\n输出： [2,0,3]\n解释：\n每行中的军人数目： 行 0 -\u0026gt; 2\n行 1 -\u0026gt; 4\n行 2 -\u0026gt; 1\n行 3 -\u0026gt; 2\n行 4 -\u0026gt; 5\n从最弱到最强对这些行排序后得到 [2,0,3,1,4]\n示例 2： 输入： mat =\n[[1,0,0,0],\n[1,1,1,1],\n[1,0,0,0],\n[1,0,0,0]],\nk = 2\n输出： [0,2]\n解释：\n每行中的军人数目： 行 0 -\u0026gt; 1\n行 1 -\u0026gt; 4\n行 2 -\u0026gt; 1\n行 3 -\u0026gt; 1\n从最弱到最强对这些行排序后得到 [0,2,3,1]\n提示： m == mat.length n == mat[i].length 2 \u0026lt;= n, m \u0026lt;= 100 1 \u0026lt;= k \u0026lt;= m matrix[i][j] 不是 0 就是 1 解题思路 排序 以行为单位，记录每一行军人的数量及行号，按战力从小到大排序，返回前 k 个最弱战力的行号。\nfunc kWeakestRows(mat [][]int, k int) []int { type Node struct { Row int Soldier int } nodes := make([]*Node, 0, len(mat)) for i := range mat { node := \u0026amp;Node{ Row: i, Soldier: 0, } for _, p := range mat[i] { if p == 1 { node.Soldier++ } else { break } } nodes = append(nodes, node) } sort.Slice(nodes, func(i, j int) bool { if nodes[i].Soldier \u0026lt; nodes[j].Soldier { return true } else if nodes[i].Soldier \u0026gt; nodes[j].Soldier { return false } else { return nodes[i].Row \u0026lt; nodes[j].Row } }) res := make([]int, 0, k) for i := 0; i \u0026lt; k; i++ { res = append(res, nodes[i].Row) } return res } 复杂度 时间复杂度：$ O(MN+M\\log\\ M), M = rows, N = cols $ 空间复杂度：$ O(M) $ 排序 + 二分查找 在上述题解的基础上，由于军人始终排在平民前面，可以用二分查找降低时间复杂度。\nfunc kWeakestRows(mat [][]int, k int) []int { type Node struct { Row int Soldier int } nodes := make([]*Node, 0, len(mat)) for i := range mat { nodes = append(nodes, \u0026amp;Node{ Row: i, Soldier: sort.Search(len(mat[i]), func(j int) bool { return mat[i][j] == 0 })}, ) } sort.Slice(nodes, func(i, j int) bool { if nodes[i].Soldier \u0026lt; nodes[j].Soldier { return true } else if nodes[i].Soldier \u0026gt; nodes[j].Soldier { return false } else { return nodes[i].Row \u0026lt; nodes[j].Row } }) res := make([]int, 0, k) for i := 0; i \u0026lt; k; i++ { res = append(res, nodes[i].Row) } return res } 复杂度 时间复杂度：$ O(M\\log\\ N+M\\log\\ M), M = rows, N = cols $ 空间复杂度：$ O(M) $ ","date":"2021-08-01T09:54:54+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1337.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E6%88%98%E6%96%97%E5%8A%9B%E6%9C%80%E5%BC%B1%E7%9A%84-k-%E8%A1%8C/","title":"Leetcode 1337. 矩阵中战斗力最弱的 K 行"},{"content":"链接： https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/\n难度： 困难\n题目描述 给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。\n对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。\n二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。\n返回二叉树的 垂序遍历 序列。\n示例 1： 输入： root = [3,9,20,null,null,15,7]\n输出： [[9],[3,15],[20],[7]]\n解释：\n列 -1 ：只有结点 9 在此列中。\n列 0 ：只有结点 3 和 15 在此列中，按从上到下顺序。\n列 1 ：只有结点 20 在此列中。\n列 2 ：只有结点 7 在此列中。\n示例 2： 输入： root = [1,2,3,4,5,6,7]\n输出： [[4],[2],[1,5,6],[3],[7]]\n解释：\n列 -2 ：只有结点 4 在此列中。\n列 -1 ：只有结点 2 在此列中。\n列 0 ：结点 1 、5 和 6 都在此列中。\n1 在上面，所以它出现在前面。\n5 和 6 位置都是 (2, 0) ，所以按值从小到大排序，5 在 6 的前面。\n列 1 ：只有结点 3 在此列中。\n列 2 ：只有结点 7 在此列中。\n示例 3： 输入： root = [1,2,3,4,6,5,7]\n输出： [[4],[2],[1,5,6],[3],[7]]\n解释：\n这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。\n因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。\n提示： 树中结点数目总数在范围 [1, 1000] 内 0 \u0026lt;= Node.val \u0026lt;= 1000 解题思路 深度优先搜索+哈希 结果是以列为单位返回，使用哈希表记录相同列的结点信息。每一列又需要自上而下返回，还需要记录每个结点的深度。\n采用深度优先搜索遍历此树，初始时深度 depth = 0，列 col = 0，每当遍历子结点时depth + 1；当遍历左子结点时 col - 1，右子结点 col + 1。将深度和结点值一起加入到哈希表。\n遍历完成过后，对于每一列进行排序，深度优先，当深度相同，值小的优先。\n按照列从小到大，依次构造结果队列并返回。\nfunc verticalTraversal(root *TreeNode) [][]int { type Node struct { Val int Depth int } verticalNodes := make(map[int][]*Node) var dfs func(node *TreeNode, depth int, col int) dfs = func(node *TreeNode, depth int, col int) { if node == nil { return } verticalNodes[col] = append(verticalNodes[col], \u0026amp;Node{ Val: node.Val, Depth: depth, }) dfs(node.Left, depth+1, col-1) dfs(node.Right, depth+1, col+1) } dfs(root, 0, 0) cols := make([]int, 0, len(verticalNodes)) for col, nodes := range verticalNodes { cols = append(cols, col) sort.Slice(nodes, func(i, j int) bool { if nodes[i].Depth \u0026lt; nodes[j].Depth { return true } else if nodes[i].Depth \u0026gt; nodes[j].Depth { return false } else { if nodes[i].Val \u0026lt; nodes[j].Val { return true } else { return false } } }) } sort.Ints(cols) res := make([][]int, 0, len(verticalNodes)) for _, col := range cols { t := make([]int, 0, len(verticalNodes[col])) for _, node := range verticalNodes[col] { t = append(t, node.Val) } res = append(res, t) } return res } 复杂度 时间复杂度：$ O(N\\log_\\ N), N = size(Tree) $ 空间复杂度：$ O(N) $ ","date":"2021-07-31T12:57:30+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-987.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9E%82%E5%BA%8F%E9%81%8D%E5%8E%86/","title":"Leetcode 987. 二叉树的垂序遍历"},{"content":"链接： https://leetcode-cn.com/problems/excel-sheet-column-number/\n难度： 简单\n题目描述 给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。\n例如，\nA -\u0026gt; 1\nB -\u0026gt; 2\nC -\u0026gt; 3\n\u0026hellip;\nZ -\u0026gt; 26\nAA -\u0026gt; 27\nAB -\u0026gt; 28\n\u0026hellip;\n示例 1： 输入: columnTitle = \u0026ldquo;A\u0026rdquo;\n输出: 1\n示例 2： 输入: columnTitle = \u0026ldquo;AB\u0026rdquo;\n输出: 28\n示例 3： 输入: columnTitle = \u0026ldquo;ZY\u0026rdquo;\n输出: 701\n示例 4： 输入: columnTitle = \u0026ldquo;FXSHRXW\u0026rdquo;\n输出: 2147483647\n解题思路 数学 进制转换，将一个26进制的数转换为10进制。\nfunc titleToNumber(columnTitle string) int { res := 0 for i := 0; i \u0026lt; len(columnTitle); i++ { res = res*26 + int(columnTitle[i]-\u0026#39;A\u0026#39;+1) } return res } 复杂度 时间复杂度：$ O(N) , N = len(columnTitle) $ 空间复杂度：$ O(1) $ ","date":"2021-07-30T10:58:59+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-171.-excel%E8%A1%A8%E5%88%97%E5%BA%8F%E5%8F%B7/","title":"Leetcode 171. Excel表列序号"},{"content":"链接： https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/\n难度： 中等\n题目描述 在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。\n如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；\n而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。\n给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。\n示例 1： 输入： label = 14\n输出： [1,3,4,14]\n示例 2： 输入： label = 26\n输出： [1,2,6,10,26]\n提示： 1 \u0026lt;= label \u0026lt;= 106 解题思路 推导 对于一个完全二叉树，可以快速找到子结点 x 的父结点是 x/2。该题描述的是完全二叉树的一种变种，仅是偶数行的结点整体进行了反转。\n可以使用完全二叉树的编号，快速找到父结点，然后推导出在原二叉树中的原编号，加入到结果中。\n对于反转后的某一层，其元素为公差为 1 的等差数列，某个数反转后的编号即为当前层首尾元素之和减去当前元素。\nfunc pathInZigZagTree(label int) []int { layer := 0 // 层 cnt := layer // 满二叉树结点数量 for label \u0026gt; cnt { layer++ cnt = 2*(cnt+1) - 1 } idx := layer - 1 res := make([]int, layer) num := label // 完全二叉树编号 if layer\u0026amp;1 == 0 { num = cnt/2 + 1 + cnt - label } for layer \u0026gt; 0 { if layer\u0026amp;1 == 0 { // 偶数层，转换 res[idx] = cnt/2 + 1 + cnt - num } else { res[idx] = num } idx-- num /= 2 layer-- cnt /= 2 } return res } 复杂度 时间复杂度：$ O(logN)), N = label $ 空间复杂度：$ O(1) $ ","date":"2021-07-29T20:22:11+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1104.-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AF%BB%E8%B7%AF/","title":"Leetcode 1104. 二叉树寻路"},{"content":"链接： https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/\n难度： 中等\n题目描述 给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。\n返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。\n示例： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2\n输出：[7,4,1]\n解释：\n所求结点为与目标结点（值为 5）距离为 2 的结点，值分别为 7，4，以及 1\n注意，输入的 \u0026ldquo;root\u0026rdquo; 和 \u0026ldquo;target\u0026rdquo; 实际上是树上的结点。\n上面的输入仅仅是对这些对象进行了序列化描述。\n提示： 给定的树是非空的。 树上的每个结点都具有唯一的值 0 \u0026lt;= node.val \u0026lt;= 500 。 目标结点 target 是树上的结点。 0 \u0026lt;= K \u0026lt;= 1000 解题思路 深度优先搜索 一次遍历，找到结点 target，同时记录每个结点的父结点，使之构成一张无向图。\n然后从 target 结点开始遍历图，找到所有距离为 K 的结点。\n注意，不要重复遍历，并进行剪枝。\nfunc distanceK(root *TreeNode, target *TreeNode, k int) []int { father := make(map[*TreeNode]*TreeNode) var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node.Left != nil { father[node.Left] = node dfs(node.Left) } if node.Right != nil { father[node.Right] = node dfs(node.Right) } } dfs(root) res := make([]int, 0, len(father)) // from 防止重复搜索 var search func(node, from *TreeNode, distance int) search = func(node, from *TreeNode, distance int) { if node == nil { return } if distance \u0026gt;= k { res = append(res, node.Val) return } if father[node] != from { search(father[node], node, distance+1) } if node.Left != from { search(node.Left, node, distance+1) } if node.Right != from { search(node.Right, node, distance+1) } } search(target, nil, 0) return res } 复杂度 时间复杂度：$ O(N), N = size(Tree)$ 空间复杂度：$ O(N) $ ","date":"2021-07-28T11:09:17+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-863.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E8%B7%9D%E7%A6%BB%E4%B8%BA-k-%E7%9A%84%E7%BB%93%E7%82%B9/","title":"Leetcode 863. 二叉树中所有距离为 K 的结点"},{"content":"链接： https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/\n难度： 简单\n题目描述 给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。\n更正式地说，root.val = min(root.left.val, root.right.val) 总成立。\n给出这样的一个二叉树，你需要输出所有节点中的 第二小的值。如果第二小的值不存在的话，输出 -1 。\n示例 1： 输入： root = [2,2,5,null,null,5,7]\n输出： 5\n解释： 最小的值是 2 ，第二小的值是 5 。\n示例 2： 输入： root = [2,2,2]\n输出： -1\n解释： 最小的值是 2, 但是不存在第二小的值。\n提示： 树中节点数目在范围 [1, 25] 内 1 \u0026lt;= Node.val \u0026lt;= 231 - 1 对于树中每个节点 root.val == min(root.left.val, root.right.val) 解题思路 深度优先搜索 据题意，树的根结点是最小值，故可以遍历整棵树，使用 min 记录最 第二小的值。\n对于每个结点，当该结点的数值小于 min，并且不与根结点相同时，更新 min，一次遍历完成得到 第二小的值。\nfunc findSecondMinimumValue(root *TreeNode) int { max := -1 // 遍历 var dfs func(node *TreeNode) dfs = func(node *TreeNode) { if node == nil { return } if (max == -1 || max \u0026gt; node.Val) \u0026amp;\u0026amp; node.Val != root.Val { max = node.Val } dfs(node.Left) dfs(node.Right) } dfs(root) return max } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(logN) $ ","date":"2021-07-27T10:31:04+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-671.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%AC%AC%E4%BA%8C%E5%B0%8F%E7%9A%84%E8%8A%82%E7%82%B9/","title":"Leetcode 671. 二叉树中第二小的节点"},{"content":"链接： https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/\n难度： 中等\n题目描述 存在一个由 n 个不同元素组成的整数数组 nums ，但你已经记不清具体内容。好在你还记得 nums 中的每一对相邻元素。\n给你一个二维整数数组 adjacentPairs ，大小为 n - 1 ，其中每个 adjacentPairs[i] = [ui, vi] 表示元素 ui 和 vi 在 nums 中相邻。\n题目数据保证所有由元素 nums[i] 和 nums[i+1] 组成的相邻元素对都存在于 adjacentPairs 中，存在形式可能是 [nums[i], nums[i+1]] ，也可能是 [nums[i+1], nums[i]] 。这些相邻元素对可以 按任意顺序 出现。\n返回 原始数组 nums 。如果存在多种解答，返回 其中任意一个 即可。\n示例 1： 输入： adjacentPairs = [[2,1],[3,4],[3,2]]\n输出： [1,2,3,4]\n解释： 数组的所有相邻元素对都在 adjacentPairs 中。\n特别要注意的是，adjacentPairs[i] 只表示两个元素相邻，并不保证其 左-右 顺序。\n示例 2： 输入： adjacentPairs = [[4,-2],[1,4],[-3,1]]\n输出： [-2,4,1,-3]\n解释： 数组中可能存在负数。\n另一种解答是 [-3,1,4,-2] ，也会被视作正确答案。\n示例 3： 输入： adjacentPairs = [[100000,-100000]]\n输出： [100000,-100000]\n提示： nums.length == n adjacentPairs.length == n - 1 adjacentPairs[i].length == 2 2 \u0026lt;= n \u0026lt;= 105 -105 \u0026lt;= nums[i], ui, vi \u0026lt;= 105 题目数据保证存在一些以 adjacentPairs 作为元素对的数组 nums 解题思路 哈希 原数组中的元素没有重复的，所以在 adjacentPairs 中，除了收尾两个元素仅出现一次，其余元素均出现两次。\n使用哈希表记录从一个结点能到达的下一个结点，遍历哈希表找到首结点，依次向后从哈希表中查找可达的下一个结点，构建原数组。\nfunc restoreArray(adjacentPairs [][]int) []int { to := make(map[int][]int) for _, pair := range adjacentPairs { to[pair[0]] = append(to[pair[0]], pair[1]) to[pair[1]] = append(to[pair[1]], pair[0]) } res := make([]int, len(adjacentPairs)+1) for k, v := range to { if len(v) == 1 { res[0] = k res[1] = v[0] break } } for i := 2; i \u0026lt; len(res); i++ { next := to[res[i-1]] if next[0] != res[i-2] { res[i] = next[0] } else { res[i] = next[1] } } return res } 复杂度 时间复杂度：$ O(N), N = len(adjacentPairs) $ 空间复杂度：$ O(N) $ ","date":"2021-07-25T21:48:26+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1743.-%E4%BB%8E%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E5%AF%B9%E8%BF%98%E5%8E%9F%E6%95%B0%E7%BB%84/","title":"Leetcode 1743. 从相邻元素对还原数组"},{"content":"链接： https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/\n难度： 简单\n题目描述 给你一个字符串 time ，格式为 hh:mm（小时：分钟），其中某几位数字被隐藏（用 ? 表示）。\n有效的时间为 00:00 到 23:59 之间的所有时间，包括 00:00 和 23:59 。\n替换 time 中隐藏的数字，返回你可以得到的最晚有效时间。\n示例 1： 输入： time = \u0026ldquo;2?:?0\u0026rdquo;\n输出： \u0026ldquo;23:50\u0026rdquo;\n解释： 以数字 \u0026lsquo;2\u0026rsquo; 开头的最晚一小时是 23 ，以 \u0026lsquo;0\u0026rsquo; 结尾的最晚一分钟是 50\n示例 2： 输入： time = \u0026ldquo;0?:3?\u0026rdquo;\n输出： \u0026ldquo;09:39\u0026rdquo;\n示例 3： 输入： time = \u0026ldquo;1?:22\u0026rdquo;\n输出： \u0026ldquo;19:22\u0026rdquo;\n提示： time 的格式为 hh:mm 题目数据保证你可以由输入的字符串生成有效的时间 解题思路 分类讨论 小时和分钟是完全独立的两个单元，分别针对这两个单元进行判断。\n小时的有效范围为 00 ~ 23，十位和个位相互影响：\n当十位为 ? 时，若个位小于 4 或者个位也为 ?，则可以取到 2；否则取 1 当个位为 ? 时，若十位为 2，则只能取到3；否则取 9 分钟的有效范围为 00 ~ 59，十位和个位互不影响：\n当十位为 ? 时，取 5 当个位为 ? 时，取 9 func maximumTime(time string) string { res := []byte(time) // 小时 if res[0] == \u0026#39;?\u0026#39; { if res[1] == \u0026#39;?\u0026#39; || res[1] \u0026lt; \u0026#39;4\u0026#39; { res[0] = \u0026#39;2\u0026#39; } else { res[0] = \u0026#39;1\u0026#39; } } if res[1] == \u0026#39;?\u0026#39; { if res[0] == \u0026#39;2\u0026#39; { res[1] = \u0026#39;3\u0026#39; } else { res[1] = \u0026#39;9\u0026#39; } } //分钟 if res[3] == \u0026#39;?\u0026#39; { res[3] = \u0026#39;5\u0026#39; } if res[4] == \u0026#39;?\u0026#39; { res[4] = \u0026#39;9\u0026#39; } return string(res) } 复杂度 时间复杂度：$ O(1) $ 空间复杂度：$ O(1) $ ","date":"2021-07-24T12:24:31+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1736.-%E6%9B%BF%E6%8D%A2%E9%9A%90%E8%97%8F%E6%95%B0%E5%AD%97%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E6%99%9A%E6%97%B6%E9%97%B4/","title":"Leetcode 1736. 替换隐藏数字得到的最晚时间"},{"content":"链接： https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/\n难度： 简单\n题目描述 给你一个二维整数数组 ranges 和两个整数 left 和 right 。每个 ranges[i] = [starti, endi] 表示一个从 starti 到 endi 的 闭区间 。\n如果闭区间 [left, right] 内每个整数都被 ranges 中 至少一个 区间覆盖，那么请你返回 true ，否则返回 false 。\n已知区间 ranges[i] = [starti, endi] ，如果整数 x 满足 starti \u0026lt;= x \u0026lt;= endi ，那么我们称整数 x 被覆盖了。\n示例 1： 输入： ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5\n输出： true\n解释： 2 到 5 的每个整数都被覆盖了：\n2 被第一个区间覆盖。 3 和 4 被第二个区间覆盖。 5 被第三个区间覆盖 示例 2： 输入： ranges = [[1,10],[10,20]], left = 21, right = 21\n输出： false\n解释： 21 没有被任何一个区间覆盖。\n提示： 1 \u0026lt;= ranges.length \u0026lt;= 50 1 \u0026lt;= starti \u0026lt;= endi \u0026lt;= 50 1 \u0026lt;= left \u0026lt;= right \u0026lt;= 50 解题思路 暴力求解 对于区间内的每个数字，遍历 range，判断其是否被覆盖，不被覆盖返回 false，被覆盖继续执行下一轮循环。\nfunc isCovered(ranges [][]int, left int, right int) bool { Outer: for i := left; i \u0026lt;= right; i++ { for _, r := range ranges { if i \u0026gt;= r[0] \u0026amp;\u0026amp; i \u0026lt;= r[1] { continue Outer } } return false } return true } 复杂度 时间复杂度：$ O(NM), N = len(ranges), M = right-left+1 $ 空间复杂度：$ O(1) $ 哈希 直接记录被覆盖的数，然后遍历 [left, right] ，判断该区间内的数是否全部被覆盖。\nfunc isCovered(ranges [][]int, left int, right int) bool { isCover := [51]bool{} for _, r := range ranges { for i := r[0]; i \u0026lt;= r[1]; i++ { isCover[i] = true } } for i := left; i \u0026lt;= right; i++ { if !isCover[i] { return false } } return true } 复杂度 时间复杂度：$ O(NS+M), N = len(ranges), S = scope, M = right-left+1 $ 空间复杂度：$ O(S) $ ","date":"2021-07-23T10:32:17+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1893.-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E5%8C%BA%E5%9F%9F%E5%86%85%E6%89%80%E6%9C%89%E6%95%B4%E6%95%B0%E9%83%BD%E8%A2%AB%E8%A6%86%E7%9B%96/","title":"Leetcode 1893. 检查是否区域内所有整数都被覆盖"},{"content":"链接： https://leetcode-cn.com/problems/copy-list-with-random-pointer/\n难度： 中等\n题目描述 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。\n构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。\n例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --\u0026gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --\u0026gt; y 。\n返回复制链表的头节点。\n用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：\nval：一个表示 Node.val 的整数。 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点 head 作为传入参数。\n示例 1： 输入： head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出： [[7,null],[13,0],[11,4],[10,2],[1,0]]\n示例 2： 输入： head = [[1,1],[2,1]]\n输出： [[1,1],[2,1]]\n示例 3： 输入： head = [[3,null],[3,0],[3,null]]\n输出： [[3,null],[3,0],[3,null]]\n示例 4: 输入： head = []\n输出： []\n解释： 给定的链表为空（空指针），因此返回 null\n提示： 0 \u0026lt;= n \u0026lt;= 1000 -10000 \u0026lt;= Node.val \u0026lt;= 10000 Node.random 为空（null）或指向链表中的节点。 解题思路 哈希 使用哈希表维护一个旧结点到新结点的映射，依次从前向后遍历链表，并逐一的构造新结点。\n构造每个新结点时，需要额外维护 random 指针，可以在构造后即进行维护。\n每遍历到一个新结点时，可能已经在维护之前的 random 指针时已构造，故需要先从哈希表中查找，查找到即使用新结点，没查找到构造新结点。 维护 random 指针时，结点可能已经在遍历时构造，也需要优先查找。 经过一次遍历，即可完成原链表的深拷贝。\nfunc copyRandomList(head *Node) *Node { mapping := make(map[*Node]*Node) newHead := new(Node) node := newHead for ; head != nil; head = head.Next { // 优先查找，可能已被random构造 newNode, ok := mapping[head] if !ok { newNode = \u0026amp;Node{ Val: head.Val, Next: nil, Random: nil, } mapping[head] = newNode } node.Next = newNode node = node.Next // random 指针更新 if head.Random != nil { randomNode, ok := mapping[head.Random] if !ok { randomNode = \u0026amp;Node{ Val: head.Random.Val, Next: nil, Random: nil, } mapping[head.Random] = randomNode } node.Random = randomNode } } return newHead.Next } 复杂度 时间复杂度：$ O(N), N = len(list) $ 空间复杂度：$ O(N) $ 分裂 在原来链表的基础上，将每个结点裂变出一个新结点，形成如 A-\u0026gt;A'-\u0026gt;B-\u0026gt;B'-\u0026gt;…… 的结构，修正每个新结点的 random 指针为原结点的下一个结点，然后将原链表拆分，即得到结果。\nfunc copyRandomList(head *Node) *Node { if head == nil { return nil } // 裂变 结点 for node := head; node != nil; node = node.Next.Next { node.Next = \u0026amp;Node{ Val: node.Val, Next: node.Next, Random: node.Random, } } // 修正 random for node := head; node != nil; node = node.Next.Next { if node.Random != nil { node.Next.Random = node.Next.Random.Next } } // 拆分链表 newHead := head.Next for node, newNode := head, newHead; node != nil; node, newNode = node.Next, newNode.Next { node.Next = node.Next.Next if node.Next != nil { newNode.Next = newNode.Next.Next } } return newHead } 复杂度 时间复杂度：$ O(N), N = len(list) $ 空间复杂度：$ O(1) $ ","date":"2021-07-22T11:22:49+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-138.-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/","title":"Leetcode 138. 复制带随机指针的链表"},{"content":"链接： https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/\n难度： 简单\n题目描述 输入两个链表，找出它们的第一个公共节点。\n如下面的两个链表：\n在节点 c1 开始相交。\n示例 1： 输入： intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出： Reference of the node with value = 8\n输入解释： 相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n示例 2： 输入： intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出： Reference of the node with value = 2\n输入解释： 相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n示例 3： 输入： intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出： null\n输入解释： 从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n解释： 这两个链表不相交，因此返回 null。\n注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 $O(n)$ 时间复杂度，且仅用 $O(1)$ 内存。 解题思路 哈希 遍历链表 List1，记录其所有的结点，然后遍历链表 List2 ，查找在第一个链表中首次出现的结点并返回，查找不到返回空。\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode { exist := make(map[*ListNode]bool) for ;headA != nil;headA = headA.Next { exist[headA] = true } for ;headB != nil;headB = headB.Next { if exist[headB] { return headB } } return nil } 复杂度 时间复杂度：$ O(N+M), N = len(List1), M = len(List2) $ 空间复杂度：$ O(N)$ 双指针 两个链表从第一个公共结点开始，后续的结点都是相同的，可以将两个链表的尾部对齐，将长的链表截断，然后依次两两结点比较即可。\n为确认截断位置，需要遍历一遍两个链表。不妨假设长的链表为 List1， 短的为 List2。\n使用两个指针 node1、node2 分别同时对 List1 和 List2 进行遍历。 List2 首先被遍历完，此时 List1 剩余未遍历完的结点数量即为 List1 需要截断的数量。此时，直接将 node2 指向 List1 头结点。 当 node1 遍历到尾部时候，node2恰到达截断位置，故将 node1 指向 List2 头结点`，即完成对齐，继续向后遍历查找相同结点。 当 node1 == node2 时，查找结束，或者找到了公共结点，或者没找到node1、node2均为空，返回 node1 即可 当两个链表等长时候，相当于已经完成了对齐，跳过了第一阶段，直接遍历即可。\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode { for node1, node2 := headA, headB;; { if node1 == node2 { return node1 } if node1 == nil { node1 = headB } else { node1 = node1.Next } if node2 == nil { node2 = headA } else { node2 = node2.Next } } } 复杂度 时间复杂度：$ O(N+M), N = len(List1), M = len(List2) $ 空间复杂度：$ O(1) $ ","date":"2021-07-21T10:43:36+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/","title":"剑指 Offer 52. 两个链表的第一个公共节点"},{"content":"链接： https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/\n难度： 中等\n题目描述 一个数对 (a,b) 的 数对和 等于 a + b 。最大数对和 是一个数对数组中最大的 数对和 。\n比方说，如果我们有数对 (1,5) ，(2,3) 和 (4,4)，最大数对和 为 max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8 。 给你一个长度为 偶数 n 的数组 nums ，请你将 nums 中的元素分成 n / 2 个数对，使得：\nnums 中每个元素 恰好 在 一个 数对中，且 最大数对和 的值 最小 。 请你在最优数对划分的方案下，返回最小的 最大数对和 。\n示例 1： 输入： nums = [3,5,2,3]\n输出： 7\n解释： 数组中的元素可以分为数对 (3,3) 和 (5,2) 。\n最大数对和为 max(3+3, 5+2) = max(6, 7) = 7 。\n示例 2： 输入： nums = [3,5,4,2,4,6]\n输出： 8\n解释： 数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2) 。\n最大数对和为 max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8 。\n提示： n == nums.length 2 \u0026lt;= n \u0026lt;= 105 n 是偶数 1 \u0026lt;= nums[i] \u0026lt;= 105 解题思路 排序 为使得 最大数对和 最小，应让最大值和最小值成对，次大值和次小值成对……，以此类推。\n经过一次排序，可以快速地找出每一组数对，并记录最大数对和。\nfunc minPairSum(nums []int) int { sort.Ints(nums) max := 0 for i := 0; i \u0026lt; len(nums)/2; i++ { if max \u0026lt; nums[i]+nums[len(nums)-1-i] { max = nums[i] + nums[len(nums)-1-i] } } return max } 复杂度 时间复杂度：$ O(NlogN), N = len(nums) $ 空间复杂度：$ O(logN) $ ","date":"2021-07-20T09:55:22+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1877.-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AF%B9%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","title":"Leetcode 1877. 数组中最大数对和的最小值"},{"content":"链接： https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/\n难度： 中等\n题目描述 元素的 频数 是该元素在一个数组中出现的次数。\n给你一个整数数组 nums 和一个整数 k 。在一步操作中，你可以选择 nums 的一个下标，并将该下标对应元素的值增加 1 。\n执行最多 k 次操作后，返回数组中最高频元素的 最大可能频数 。\n示例 1： 输入： nums = [1,2,4], k = 5\n输出： 3\n解释： 对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。\n4 是数组中最高频元素，频数是 3 。\n示例 2： 输入： nums = [1,4,8,13], k = 5\n输出： 2\n解释： 存在多种最优解决方案：\n对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。 示例 3： 输入： nums = [3,9,6], k = 2\n输出： 1\n提示： 1 \u0026lt;= nums.length \u0026lt;= 105 1 \u0026lt;= nums[i] \u0026lt;= 105 1 \u0026lt;= k \u0026lt;= 105 解题思路 排序 \u0026amp; 滑动窗口 假设经过变换后 x 的频数最多，则对于原数组来说，每次优先让小于 x 且最接近 x 的数字变换为 x，消耗的 k 最小， 可以使得 x 的频数最大。\n为快速确定数字与 x 的接近程度，可以对数组进行一次排序。\n后续需要的是确定这个 x：对于每个元素 num，将能变换的全变换为 num 后，统计频数。按照上述思路，完成变换后的数字在数组中是连续的，故可以使用滑动窗口降低时间复杂度。\n使用 [l, r) 记录滑动窗口的左右边界，每次判断右边界直到到达数组尾：\n每次变换为 nums[r] 时，需要将滑动数组内的数字全部变换为 nums[r]，需要的变换次数为 need = (nums[r] - nums[r-1]) * (r - l); 当 need 大于等于剩余次数时，右边界 r 向右扩展，剩余次数减去 need; 当 need 小于剩余次数时，左边界 l 向右收缩，剩余次数加上 nums[r-1] - nums[l]。 右边界 r 到达数组结尾时，滑动窗口完成滑动，其中滑动窗口的最大长度 r - l 即为数组中最高频元素的 最大可能频数。\nfunc maxFrequency(nums []int, k int) int { sort.Ints(nums) max := 1 for l, r := 0, 1; r \u0026lt; len(nums); { need := (nums[r] - nums[r-1]) * (r - l) // 扩展 if k \u0026gt;= need { k -= need r++ } else { // 收缩 if r-1 \u0026gt; l { k += nums[r-1] - nums[l] } l++ } if max \u0026lt; r-l { max = r - l } } return max } 复杂度 时间复杂度：$ O(NlogN), N = len(nums) $ 空间复杂度：$ O(logN) $ ","date":"2021-07-19T10:31:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1838.-%E6%9C%80%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E7%9A%84%E9%A2%91%E6%95%B0/","title":"Leetcode 1838. 最高频元素的频数"},{"content":"链接： https://leetcode-cn.com/problems/group-anagrams-lcci/\n难度： 中等\n题目描述 编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。\n**注意：**本题相对原题稍作修改\n示例： 输入: [\u0026ldquo;eat\u0026rdquo;, \u0026ldquo;tea\u0026rdquo;, \u0026ldquo;tan\u0026rdquo;, \u0026ldquo;ate\u0026rdquo;, \u0026ldquo;nat\u0026rdquo;, \u0026ldquo;bat\u0026rdquo;],\n输出:\n[\n[\u0026ldquo;ate\u0026rdquo;,\u0026ldquo;eat\u0026rdquo;,\u0026ldquo;tea\u0026rdquo;],\n[\u0026ldquo;nat\u0026rdquo;,\u0026ldquo;tan\u0026rdquo;],\n[\u0026ldquo;bat\u0026rdquo;]\n]\n解题思路 哈希 \u0026amp; 计数 对于每个字符串，使用数组统计每个字母出现的数字，两个同位词得出的统计数组必然相同，故用该数组作为 key\nfunc groupAnagrams(strs []string) [][]string { cnt := func(s string) (cnt [26]int) { for i := range s { cnt[s[i]-\u0026#39;a\u0026#39;]++ } return } hash := make(map[[26]int][]string) for _, str := range strs { key := cnt(str) hash[key] = append(hash[key], str) } res := make([][]string, 0, len(hash)) for _, v := range hash { res = append(res, v) } return res } 复杂度 时间复杂度：$ O(NL), N = len(strs), L = max(len(str)) $ 空间复杂度：$ O(NL) $ 哈希 \u0026amp; 排序 不同变位词中字母相同，所以将字符串按照字母排序后，其值也一定相同。故可以将其排序后的值作为哈希表的 key，并将其添加进 value 数组中。\nfunc groupAnagrams(strs []string) [][]string { hash := make(map[string][]string) for _, str := range strs { t := []byte(str) sort.Slice(t, func(i, j int) bool { return t[i] \u0026lt; t[j] }) hash[string(t)] = append(hash[string(t)], str) } res := make([][]string, 0, len(hash)) for _, v := range hash { res = append(res, v) } return res } 复杂度 时间复杂度：$ O(NLlogL), N = len(strs), L = max(len(str)) $ 空间复杂度：$ O(NL) $ ","date":"2021-07-18T11:32:11+08:00","permalink":"https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-10.02.-%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84/","title":"面试题 10.02. 变位词组"},{"content":"链接： https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/\n难度： 简单\n题目描述 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。\n要求时间复杂度为$O(n)$。\n示例： 输入: nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出: 6\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。\n提示： 1 \u0026lt;= arr.length \u0026lt;= 105 -100 \u0026lt;= arr[i] \u0026lt;= 100 解题思路 动态规划 用 dp[i] 记录以 i 为结尾的连续子数组和的最大值，容易得到状态转移方程：\ndp[0] = nums[0] dp[i] = max(dp[i-1]+nums[i], nums[i]) 由于每次转移仅涉及到前一个结果，使用变量代替数组降低空间复杂度\nfunc maxSubArray(nums []int) int { if len(nums) == 0 { return 0 } dp := nums[0] max := dp for pre, i := 0, 1; i \u0026lt; len(nums); i++ { pre = dp if pre+nums[i] \u0026gt; nums[i] { dp = pre + nums[i] } else { dp = nums[i] } if max \u0026lt; dp { max = dp } } return max } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-07-17T13:21:52+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-42.-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/","title":"剑指 Offer 42. 连续子数组的最大和"},{"content":"链接： https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/\n难度： 简单\n题目描述 统计一个数字在排序数组中出现的次数。\n示例 1： 输入: nums = [5,7,7,8,8,10], target = 8\n输出: 2\n示例 2： 输入: nums = [5,7,7,8,8,10], target = 6\n输出: 0\n提示： 0 \u0026lt;= 数组长度 \u0026lt;= 50000 解题思路 顺序查找 顺序遍历，统计数量 target。由于数组有序，当当前元素大于 target时，\nfunc search(nums []int, target int) int { cnt := 0 for _, num := range nums { if num == target { cnt++ } else if num \u0026gt; target { break } } return cnt } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ 二分查找 二分查找，找到首个等于 target 的元素位置，依次向后遍历到元素不等于 target 为止，记录出现的次数。\nfunc search(nums []int, target int) int { pos := len(nums) for l, r := 0, len(nums)-1; l \u0026lt;= r; { if l == r { pos = l break } mid := (l + r) / 2 if nums[mid] \u0026lt; target { l = mid + 1 } else { r = mid } } cnt := 0 for i := pos; i \u0026lt; len(nums) \u0026amp;\u0026amp; nums[i] == target; i++ { cnt++ } return cnt } 复杂度 时间复杂度：$ O(\\log{N}), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-07-16T14:55:24+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-53-i.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-i/","title":"剑指 Offer 53 - I. 在排序数组中查找数字 I"},{"content":"链接： https://leetcode-cn.com/problems/maximum-element-after-decreasing-and-rearranging/\n难度： 中等\n题目描述 给你一个正整数数组 arr 。请你对 arr 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：\narr 中 第一个 元素必须为 1 。 任意相邻两个元素的差的绝对值 小于等于 1 ，也就是说，对于任意的 1 \u0026lt;= i \u0026lt; arr.length （数组下标从 0 开始），都满足 abs(arr[i] - arr[i - 1]) \u0026lt;= 1 。abs(x) 为 x 的绝对值。 你可以执行以下 2 种操作任意次：\n减小 arr 中任意元素的值，使其变为一个 更小的正整数 。 重新排列 arr 中的元素，你可以以任意顺序重新排列。 请你返回执行以上操作后，在满足前文所述的条件下，arr 中可能的 最大值 。\n示例 1： 输入： arr = [2,2,1,2,1]\n输出： 2\n解释：\n我们可以重新排列 arr 得到 [1,2,2,2,1] ，该数组满足所有条件。\narr 中最大元素为 2 。\n示例 2： 输入： arr = [100,1,1000]\n输出： 3\n解释：\n一个可行的方案如下：\n重新排列 arr 得到 [1,100,1000] 。 将第二个元素减小为 2 。 将第三个元素减小为 3 。\n现在 arr = [1,2,3] ，满足所有条件。\narr 中最大元素为 3 。 示例 3： 输入： arr = [1,2,3,4,5] 输出： 5 解释： 数组已经满足所有条件，最大元素为 5\n提示： 1 \u0026lt;= arr.length \u0026lt;= 105 1 \u0026lt;= arr[i] \u0026lt;= 109 解题思路 排序 先将数组排序，并令arr[0] = 1，然后逐一地调整后续元素，其值为上个元素值加一。当遇到小于等于前一个值的元素时，从当前元素重新开始调整，直至遍历结束，返回尾部元素。\nfunc maximumElementAfterDecrementingAndRearranging(arr []int) int { sort.Ints(arr) arr[0] = 1 for i := 1; i \u0026lt; len(arr); i++ { if arr[i] \u0026gt; arr[i-1] { arr[i] = arr[i-1] + 1 } } return arr[len(arr)-1] } 复杂度 时间复杂度：$ O(NlogN), N = len(arr) $ 空间复杂度：$ O(logN) $ ","date":"2021-07-15T10:33:47+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1846.-%E5%87%8F%E5%B0%8F%E5%92%8C%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/","title":"Leetcode 1846. 减小和重新排列数组后的最大元素"},{"content":"链接： https://leetcode-cn.com/problems/minimum-absolute-sum-difference/\n难度： 中等\n题目描述 给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。\n数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|（0 \u0026lt;= i \u0026lt; n）的 总和（下标从 0 开始）。\n你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。\n在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 109 + 7 取余 后返回。\n|x| 定义为：\n如果 x \u0026gt;= 0 ，值为 x ，或者 如果 x \u0026lt;= 0 ，值为 -x 示例 1： 输入： nums1 = [1,7,5], nums2 = [2,3,5]\n输出： 3\n解释： 有两种可能的最优方案：\n将第二个元素替换为第一个元素：[1,7,5] =\u0026gt; [1,1,5] ，或者 将第二个元素替换为第三个元素：[1,7,5] =\u0026gt; [1,5,5]\n两种方案的绝对差值和都是 |1-2| + (|1-3| 或者 |5-3|) + |5-5| = 3 示例 2： 输入： nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]\n输出： 0\n解释： nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0\n示例 3： 输入： nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]\n输出： 20\n解释： 将第一个元素替换为第二个元素：[1,10,4,4,2,7] =\u0026gt; [10,10,4,4,2,7]\n绝对差值和为 |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20\n提示： n == nums1.length n == nums2.length 1 \u0026lt;= n \u0026lt;= 105 1 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 105 解题思路 排序 \u0026amp; 二分查找 不妨设用 nums1[j] 替换了 nums1[i]，使得绝对差值和最小化。替换前之差为 |nums1[i] - nums2[i]|，替换之后为 |nums1[j] - nums2[i]|，则其替换后绝对差值和的缩小量即为 |nums1[i] - nums2[i]| - |nums1[j] - nums2[i]|，要求该缩小量最大。\n通过上式观察得出：对于每个 i，前一项 |nums1[i] - nums2[i]| 确定不变，唯一的变量即在 j，需要找出使得 |nums1[j] - nums2[i]| 最小的 j，也就是找出 nums1 中与 nums2[i] 最接近的值。\n对于每个 i，通过二分查找的方法，找出最接近的 j。一次遍历完成后，得到最大的缩小量的最大值 max，用原始绝对差值和减去 max 即得到 最小化 绝对差值和。\n二分查找时，当不存在与 nums2[i] 相等的值时，需要找寻最接近的值，此时查找终止条件为仅剩两个元素，因为最接近的值可能大于 nums2[i]，也可能小于 nums2[i]，需要对两个元素均进行判断。\nfunc minAbsoluteSumDiff(nums1 []int, nums2 []int) int { const MOD = 1e9 + 7 // 求绝对值 diff := func(x, y int) int { d := x - y if d \u0026lt; 0 { d = -d } return d } // nums1排序 sortedNums1 := make([]int, len(nums1)) copy(sortedNums1, nums1) sort.Ints(sortedNums1) sum := 0 // 绝对差只和 max := 0 // 最小化缩小量最大值 for i := range nums2 { absDiff := diff(nums1[i], nums2[i]) sum %= MOD sum += absDiff // 求和 // 二分查找确定最小化缩小量 for l, r := 0, len(sortedNums1)-1; l \u0026lt; r; { // l, r 最接近nums2[i] if l+1 == r { dl := diff(sortedNums1[l], nums2[i]) dr := diff(sortedNums1[r], nums2[i]) if dl \u0026lt; dr { if max \u0026lt; absDiff-dl { max = absDiff - dl } } else { if max \u0026lt; absDiff-dr { max = absDiff - dr } } break } mid := (l + r) / 2 // 与nums2相等，已找到 if sortedNums1[mid] == nums2[i] { if max \u0026lt; absDiff { max = absDiff } break } else if sortedNums1[mid] \u0026gt; nums2[i] { r = mid } else { l = mid } } } return (sum + MOD - max) % MOD } 复杂度 时间复杂度：$ O(N\\log{N}), N = len(nums1) $ 空间复杂度：$ O(N) $ ","date":"2021-07-14T10:34:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1818.-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E5%80%BC%E5%92%8C/","title":"Leetcode 1818. 绝对差值和"},{"content":"链接： https://leetcode-cn.com/problems/h-index-ii/\n难度： 中等\n题目描述 给定一位研究者论文被引用次数的数组（被引用次数是非负整数）,数组已经按照 升序排列。编写一个方法，计算出研究者的 h 指数。\nh 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共 有 h 篇论文分别被引用了至少 h 次。且其余的 $N - h$ 篇论文每篇被引用次数 不超过 h 次。\n例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。\n示例： 输入： citations = [0,1,3,5,6]\n输出： 3\n解释： 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 0, 1, 3, 5, 6 次。\n由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。\n**说明：**如果 h 有多种可能的值，h 指数是其中最大的那个。\n进阶： 这是 H 指数 的延伸题目，本题中的 citations 数组是保证有序的。 你可以优化你的算法到对数时间复杂度吗？ 解题思路 顺序查找 解题思路同 Leetcode 274. H 指数，由于已经排好序，只需要从后往前查找即可。\nfunc hIndex(citations []int) int { for i := len(citations) - 1; i \u0026gt;= 0; i-- { if citations[i] \u0026lt; len(citations)-i { return len(citations) - 1 - i } } return len(citations) } 复杂度 时间复杂度：$ O(N), N=len(citations) $ 空间复杂度：$ O(1) $ 二分查找 用 [l, r] 作为二分查找的区间下标，每次用区间中位数 citations[mid] 与到数组末尾的距离 len(citations)-mid 相比:\n当 citations[mid] \u0026lt; len(citations)-l 时，不满足条件，需要继续到右侧查找，令 l = mid+1； 当 citations[mid] ≥ len(citations)-l 时，len(citations)-mid 是一个满足条件的 h，但不确定是否为最大的 h，需要保留并继续到右侧查找，令 r = mid。 遍历到 l = r 时，仅剩一个元素 citations[mid]，当其 ≥ len(citations)-l，len(citations)-l即为最大 h，返回；否则，说明找不到符合条件的 h,返回 0。\nfunc hIndex(citations []int) int { for l, r := 0, len(citations)-1; ; { if l == r { if citations[l] \u0026gt;= len(citations)-l { return len(citations) - l } else { return 0 } } mid := (l + r) / 2 if citations[mid] \u0026lt; len(citations)-mid { l = mid + 1 } else { r = mid } } } 复杂度 时间复杂度：$ O(logN), N=len(citations) $ 空间复杂度：$ O(1) $ ","date":"2021-07-12T10:50:26+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-275.-h-%E6%8C%87%E6%95%B0-ii/","title":"Leetcode 275. H 指数 II"},{"content":"链接： https://leetcode-cn.com/problems/h-index/\n难度： 中等\n题目描述 给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。\nh 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共 有 h 篇论文分别被引用了至少 h 次。且其余的 $N - h$ 篇论文每篇被引用次数 不超过 h 次。\n例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。\n示例： 输入： citations = [3,0,6,1,5]\n输出： 3\n解释： 给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。\n由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。\n**提示：**如果 h 有多种可能的值，h 指数是其中最大的那个。\n解题思路 排序 按照每篇论文被引用次数从多到少排序，依次遍历直到首次找到第 i 篇论文，其被引用次数 \u0026lt; i，则说明其前面的论文被引用数均 ≥ i-1，且其前一篇恰好时第 i-1 篇，返回 i-1。\n当遍历完整个数组均为找到时，表明最后一篇被引用数仍 ≥ len(citations)，返回 len(citations)。\nfunc hIndex(citations []int) int { sort.Sort(sort.Reverse(sort.IntSlice(citations))) for i, num := range citations { if num \u0026lt; i+1 { return i } } return len(citations) } 复杂度 时间复杂度：$ O(NlogN), N=len(citations) $ 空间复杂度：$ O(logN) $ ","date":"2021-07-11T12:04:41+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-274.-h-%E6%8C%87%E6%95%B0/","title":"Leetcode 274. H 指数"},{"content":"链接： https://leetcode-cn.com/problems/time-based-key-value-store/\n难度： 中等\n题目描述 创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作：\nset(string key, string value, int timestamp) 存储键 key、值 value，以及给定的时间戳 timestamp。\nget(string key, int timestamp) 返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev \u0026lt;= timestamp。 如果有多个这样的值，则返回对应最大的 timestamp_prev 的那个值。 如果没有值，则返回空字符串（\u0026quot;\u0026quot;）。 示例1： 输入： inputs = [\u0026ldquo;TimeMap\u0026rdquo;,\u0026ldquo;set\u0026rdquo;,\u0026ldquo;get\u0026rdquo;,\u0026ldquo;get\u0026rdquo;,\u0026ldquo;set\u0026rdquo;,\u0026ldquo;get\u0026rdquo;,\u0026ldquo;get\u0026rdquo;], inputs = [[],[\u0026ldquo;foo\u0026rdquo;,\u0026ldquo;bar\u0026rdquo;,1],[\u0026ldquo;foo\u0026rdquo;,1],[\u0026ldquo;foo\u0026rdquo;,3],[\u0026ldquo;foo\u0026rdquo;,\u0026ldquo;bar2\u0026rdquo;,4],[\u0026ldquo;foo\u0026rdquo;,4],[\u0026ldquo;foo\u0026rdquo;,5]]\n输出： [null,null,\u0026ldquo;bar\u0026rdquo;,\u0026ldquo;bar\u0026rdquo;,null,\u0026ldquo;bar2\u0026rdquo;,\u0026ldquo;bar2\u0026rdquo;]\n解释：\nTimeMap kv;\nkv.set(\u0026ldquo;foo\u0026rdquo;, \u0026ldquo;bar\u0026rdquo;, 1); // 存储键 \u0026ldquo;foo\u0026rdquo; 和值 \u0026ldquo;bar\u0026rdquo; 以及时间戳 timestamp = 1\nkv.get(\u0026ldquo;foo\u0026rdquo;, 1); // 输出 \u0026ldquo;bar\u0026rdquo;\nkv.get(\u0026ldquo;foo\u0026rdquo;, 3); // 输出 \u0026ldquo;bar\u0026rdquo; 因为在时间戳 3 和时间戳 2 处没有对应 \u0026ldquo;foo\u0026rdquo; 的值，所以唯一的值位于时间戳 1 处（即 \u0026gt; \u0026ldquo;bar\u0026rdquo;）\nkv.set(\u0026ldquo;foo\u0026rdquo;, \u0026ldquo;bar2\u0026rdquo;, 4);\nkv.get(\u0026ldquo;foo\u0026rdquo;, 4); // 输出 \u0026ldquo;bar2\u0026rdquo;\nkv.get(\u0026ldquo;foo\u0026rdquo;, 5); // 输出 \u0026ldquo;bar2\u0026rdquo;\n示例2： 输入： inputs = [\u0026ldquo;TimeMap\u0026rdquo;,\u0026ldquo;set\u0026rdquo;,\u0026ldquo;set\u0026rdquo;,\u0026ldquo;get\u0026rdquo;,\u0026ldquo;get\u0026rdquo;,\u0026ldquo;get\u0026rdquo;,\u0026ldquo;get\u0026rdquo;,\u0026ldquo;get\u0026rdquo;], inputs = [[],[\u0026ldquo;love\u0026rdquo;,\u0026ldquo;high\u0026rdquo;,10],[\u0026ldquo;love\u0026rdquo;,\u0026ldquo;low\u0026rdquo;,20],[\u0026ldquo;love\u0026rdquo;,5],[\u0026ldquo;love\u0026rdquo;,10],[\u0026ldquo;love\u0026rdquo;,15],[\u0026ldquo;love\u0026rdquo;,20],[\u0026ldquo;love\u0026rdquo;,25]]\n输出： [null,null,null,\u0026quot;\u0026quot;,\u0026ldquo;high\u0026rdquo;,\u0026ldquo;high\u0026rdquo;,\u0026ldquo;low\u0026rdquo;,\u0026ldquo;low\u0026rdquo;]\n提示： 所有的键/值字符串都是小写的。 所有的键/值字符串长度都在 [1, 100] 范围内。 所有 TimeMap.set 操作中的时间戳 timestamps 都是严格递增的。 1 \u0026lt;= timestamp \u0026lt;= 107 TimeMap.set 和 TimeMap.get 函数在每个测试用例中将（组合）调用总计 120000 次。 解题思路 哈希+二分查找 利用哈希表作为存储。每个 key 记录按照 timestamp 顺序记录的数组，数组元素记录 value 和 timestamp 。\nSet ，由于 timestamp 严格递增，只需将 value 和 timestamp 添加到对应数组的尾部； Get ，利用数组的有序性，使用二分查找，找到不大于 timestamp 的首个值。 type Value struct { value string timestamp int } type TimeMap struct { hash map[string][]*Value } /** Initialize your data structure here. */ func Constructor() TimeMap { return TimeMap{ hash: make(map[string][]*Value), } } func (this *TimeMap) Set(key string, value string, timestamp int) { this.hash[key] = append(this.hash[key], \u0026amp;Value{ value: value, timestamp: timestamp, }) } func (this *TimeMap) Get(key string, timestamp int) string { t := this.hash[key] l, r := 0, len(t) for l \u0026lt; r { if l+1 == r { if t[l].timestamp \u0026lt;= timestamp { return t[l].value } else { return \u0026#34;\u0026#34; } } mid := (l + r) / 2 if t[mid].timestamp \u0026gt; timestamp { r = mid } else { l = mid } } return \u0026#34;\u0026#34; } 复杂度 时间复杂度： Set：$ O(1) $ Get：$ O(logN), N=len(keys) $ 空间复杂度：$ O(N) $ ","date":"2021-07-10T11:47:18+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-981.-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E9%94%AE%E5%80%BC%E5%AD%98%E5%82%A8/","title":"Leetcode 981. 基于时间的键值存储"},{"content":"链接： https://leetcode-cn.com/problems/find-majority-element-lcci/\n难度： 简单\n题目描述 数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 $O(N)$ 、空间复杂度为 $O(1)$ 的解决方案。\n示例 1： 输入： [1,2,5,9,5,9,5,5,5]\n输出： 5\n示例 2： 输入： [3,2]\n输出： -1\n示例 3： 输入： [2,2,1,1,1,2,2]\n输出： 2\n解题思路 哈希计数 遍历数组，记录每个数出现的次数，直到某个数 num 出现的次数大于数组长度的一半则返回 num，否则返回 -1\nfunc majorityElement(nums []int) int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ if cnt[num] \u0026gt; len(nums)/2 { return num } } return -1 } 复杂度 时间复杂度：$ O(N) $ 空间复杂度：$ O(N) $ 排序 将数组排序，依次统计连续相同数字的数量，直到满足条件为止。\nfunc majorityElement(nums []int) int { if len(nums) == 1 { return nums[0] } sort.Ints(nums) cnt := 1 for i := 1; i \u0026lt; len(nums); i++ { if nums[i] == nums[i-1] { cnt++ if cnt \u0026gt; len(nums)/2 { return nums[i] } } else { cnt = 1 } } return -1 } 复杂度 时间复杂度：$ O(NlogN) $ 空间复杂度：$ O(1) $ 摩尔投票算法 这一算法应用的问题原型是在集合中寻找可能存在的多数元素，这一元素在输入的序列重复出现并占到了序列元素的一半以上。\n假设存在占到序列元素一半以上的众数，每次将两个不相同的两个数消除，直到最后剩下的数字即为该数。\n如果一个序列中没有占到多数的元素，那么第一次的结果就可能是无效的随机元素，所以在第一遍遍历之后应该再进行一个遍历以统计第一次算法遍历的结果出现次数，以确定其是否占到了序列元素的一半以上。\n算法步骤如下：\n用 major 和 cnt 记录主要元素和其数量，初始 cnt 为 0； 当 cnt 数量为 0 时，将 major 设置为当前元素； 当当前元素 num 和 major 不同时，cnt 减一； 当当前元素 num 和 major 相同时，cnt 加一； 一次遍历后，major 即为选出来的元素； 二次遍历统计 major，验证其是否占到了序列元素的一半以上。 func majorityElement(nums []int) int { major := 0 cnt := 0 for _, num := range nums { if cnt == 0 { major = num cnt++ continue } if num == major { cnt++ } else { cnt-- } } cnt = 0 for _, num := range nums { if num == major { cnt++ } } if cnt \u0026gt; len(nums)/2 { return major } return -1 } 复杂度 时间复杂度：$ O(N) $ 空间复杂度：$ O(1) $ ","date":"2021-07-09T10:46:07+08:00","permalink":"https://xianlianghe0123.github.io/p/%E9%9D%A2%E8%AF%95%E9%A2%98-17.10.-%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0/","title":"面试题 17.10. 主要元素"},{"content":"链接： https://leetcode-cn.com/problems/binary-subarrays-with-sum/\n难度： 中等\n题目描述 给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。\n子数组 是数组的一段连续部分。\n示例 1： 输入： nums = [1,0,1,0,1], goal = 2\n输出： 4\n解释：\n有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]\n示例 2： 输入： nums = [0,0,0,0,0], goal = 0\n输出： 15\n提示： 1 \u0026lt;= nums.length \u0026lt;= 3 * 104 nums[i] 不是 0 就是 1 0 \u0026lt;= goal \u0026lt;= nums.length 解题思路 哈希 假设满足条件的子数组下标为 [i, j) ，则以 i 和 j 为结尾的两个前缀数组的前缀和记作 sum[i]、sum[j] ，有 goal = sum[j] - sum[i]。\n将上式变换为：sum[i] = sum[j] - goal ，故可以用哈希表记录前缀和出现的次数，当遍历到 j 时，将 sum[j] 出现的次数加入到结果中。\nfunc numSubarraysWithSum(nums []int, goal int) int { cnt := make(map[int]int) res := 0 sum := 0 for _, num := range nums { cnt[sum]++ sum += num res += cnt[sum-goal] } return res } 复杂度 时间复杂度：$ O(N), N=len(nums) $ 空间复杂度：$ O(N) $ ","date":"2021-07-08T15:11:00+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-930.-%E5%92%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E5%85%83%E5%AD%90%E6%95%B0%E7%BB%84/","title":"Leetcode 930. 和相同的二元子数组"},{"content":"链接： https://leetcode-cn.com/problems/count-good-meals/\n难度： 中等\n题目描述 大餐 是指 恰好包含两道不同餐品 的一餐，其美味程度之和等于 2 的幂。\n你可以搭配 任意 两道餐品做一顿大餐。\n给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i​​​​​​​​​​​​​​ 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 109 + 7 取余。\n注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。\n示例 1： 输入： deliciousness = [1,3,5,7,9]\n输出： 4\n解释： 大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。\n它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。\n示例 2: 输入： deliciousness = [1,1,1,3,3,3,7]\n输出： 15\n解释： 大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。\n提示： 1 \u0026lt;= deliciousness.length \u0026lt;= 105 0 \u0026lt;= deliciousness[i] \u0026lt;= 220 解题思路 哈希计数 通过哈希表 foodCnt 记录每个美味程度的菜品数量。\n对于每个美味程度 d，可以求得与其组成大餐的另一道菜品的所有美味程度 power - d，将 foodCnt[d]*foodCnt[power-d]\u0008 即可得到这两种美味程度组成的大餐数量\n上述方式可能会重复计算，有两个地方需要特殊处理：\n当 d == power -d 时，问题变成了从 foodCnt[d] 道菜品中找出两个不同的菜品，这是个组合问题，其结果为 foodCnt[d]*(foodCnt[d]-1)/2； 第一次选中 d，和第一次选中 power-d 存在重复计算，可以限制 power-d \u0026gt;= d，则仅计算依次。 func countPairs(deliciousness []int) int { const MOD = 1e9 + 7 sum := 0 foodCnt := make(map[int]int) for _, d := range deliciousness { foodCnt[d]++ } for d, cnt := range foodCnt { for power := 1; power \u0026lt; math.MaxInt32 \u0026amp;\u0026amp; power \u0026gt; 0; power \u0026lt;\u0026lt;= 1 { another := power - d if another \u0026lt; d || foodCnt[another] == 0 { continue } if another == d { sum += cnt * (cnt - 1) / 2 % MOD } else { sum += (foodCnt[another] * cnt) % MOD } sum %= MOD } } return sum } 复杂度 时间复杂度：$ O(NlogB), N=len(deliciousness) B=max(deliciousness[i])$ 空间复杂度：$ O(N) $ ","date":"2021-07-07T10:28:11+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1711.-%E5%A4%A7%E9%A4%90%E8%AE%A1%E6%95%B0/","title":"Leetcode 1711. 大餐计数"},{"content":"链接： https://leetcode-cn.com/problems/display-table-of-food-orders-in-a-restaurant/\n难度： 中等\n题目描述 给你一个数组 orders ，表示客户在餐厅中完成的订单，确切地说， orders[i]=[customerNamei,tableNumberi,foodItemi] ，其中 customerNamei 是客户的姓名，tableNumberi 是客户所在餐桌的桌号，而 foodItemi 是客户点的餐品名称。\n请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。\n注意：客户姓名不是点菜展示表的一部分。此外，表中的数据行应该按餐桌桌号升序排列。\n示例 1： 输入： orders = [[\u0026ldquo;David\u0026rdquo;,\u0026ldquo;3\u0026rdquo;,\u0026ldquo;Ceviche\u0026rdquo;],[\u0026ldquo;Corina\u0026rdquo;,\u0026ldquo;10\u0026rdquo;,\u0026ldquo;Beef Burrito\u0026rdquo;],[\u0026ldquo;David\u0026rdquo;,\u0026ldquo;3\u0026rdquo;,\u0026ldquo;Fried Chicken\u0026rdquo;],[\u0026ldquo;Carla\u0026rdquo;,\u0026ldquo;5\u0026rdquo;,\u0026ldquo;Water\u0026rdquo;],[\u0026ldquo;Carla\u0026rdquo;,\u0026ldquo;5\u0026rdquo;,\u0026ldquo;Ceviche\u0026rdquo;],[\u0026ldquo;Rous\u0026rdquo;,\u0026ldquo;3\u0026rdquo;,\u0026ldquo;Ceviche\u0026rdquo;]]\n输出： [[\u0026ldquo;Table\u0026rdquo;,\u0026ldquo;Beef Burrito\u0026rdquo;,\u0026ldquo;Ceviche\u0026rdquo;,\u0026ldquo;Fried Chicken\u0026rdquo;,\u0026ldquo;Water\u0026rdquo;],[\u0026ldquo;3\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;],[\u0026ldquo;5\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;1\u0026rdquo;],[\u0026ldquo;10\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;0\u0026rdquo;]]\n解释：\n点菜展示表如下所示：\nTable,Beef Burrito,Ceviche,Fried Chicken,Water\n3 ,0 ,2 ,1 ,0\n5 ,0 ,1 ,0 ,1\n10 ,1 ,0 ,0 ,0\n对于餐桌 3：David 点了 \u0026ldquo;Ceviche\u0026rdquo; 和 \u0026ldquo;Fried Chicken\u0026rdquo;，而 Rous 点了 \u0026ldquo;Ceviche\u0026rdquo;\n而餐桌 5：Carla 点了 \u0026ldquo;Water\u0026rdquo; 和 \u0026ldquo;Ceviche\u0026rdquo;\n餐桌 10：Corina 点了 \u0026ldquo;Beef Burrito\u0026rdquo;\n示例 2: 输入： orders = [[\u0026ldquo;James\u0026rdquo;,\u0026ldquo;12\u0026rdquo;,\u0026ldquo;Fried Chicken\u0026rdquo;],[\u0026ldquo;Ratesh\u0026rdquo;,\u0026ldquo;12\u0026rdquo;,\u0026ldquo;Fried Chicken\u0026rdquo;],[\u0026ldquo;Amadeus\u0026rdquo;,\u0026ldquo;12\u0026rdquo;,\u0026ldquo;Fried Chicken\u0026rdquo;],[\u0026ldquo;Adam\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;Canadian Waffles\u0026rdquo;],[\u0026ldquo;Brianna\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;Canadian Waffles\u0026rdquo;]]\n输出： [[\u0026ldquo;Table\u0026rdquo;,\u0026ldquo;Canadian Waffles\u0026rdquo;,\u0026ldquo;Fried Chicken\u0026rdquo;],[\u0026ldquo;1\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;0\u0026rdquo;],[\u0026ldquo;12\u0026rdquo;,\u0026ldquo;0\u0026rdquo;,\u0026ldquo;3\u0026rdquo;]]\n解释：\n对于餐桌 1：Adam 和 Brianna 都点了 \u0026ldquo;Canadian Waffles\u0026rdquo;\n而餐桌 12：James, Ratesh 和 Amadeus 都点了 \u0026ldquo;Fried Chicken\u0026rdquo;\n示例 3: 输入： orders = [[\u0026ldquo;Laura\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;Bean Burrito\u0026rdquo;],[\u0026ldquo;Jhon\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;Beef Burrito\u0026rdquo;],[\u0026ldquo;Melissa\u0026rdquo;,\u0026ldquo;2\u0026rdquo;,\u0026ldquo;Soda\u0026rdquo;]]\n输出： [[\u0026ldquo;Table\u0026rdquo;,\u0026ldquo;Bean Burrito\u0026rdquo;,\u0026ldquo;Beef Burrito\u0026rdquo;,\u0026ldquo;Soda\u0026rdquo;],[\u0026ldquo;2\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;1\u0026rdquo;]]\n提示： 1 \u0026lt;= orders.length \u0026lt;= 5 * 104 orders[i].length == 3 1 \u0026lt;= customerNamei.length, foodItemi.length \u0026lt;= 20 customerNamei 和 foodItemi 由大小写英文字母及空格字符 ' ' 组成。 tableNumberi 是 1 到 500 范围内的整数。 解题思路 哈希计数 遍历所有每个订单，记录同一桌号每种菜品的数量，然后根据桌号顺序，和菜品顺序生成结果。\nfunc displayTable(orders [][]string) [][]string { tableFoodsCnt := make(map[int]map[string]int) foods := make([]string, 0, len(orders)) // 菜品名单 isAddToFoods := make(map[string]bool) // 去重 for _, order := range orders { // 加入菜品名单 if !isAddToFoods[order[2]] { foods = append(foods, order[2]) isAddToFoods[order[2]] = true } // 统计数量 table, _ := strconv.Atoi(order[1]) if tableFoodsCnt[table] == nil { tableFoodsCnt[table] = make(map[string]int) } tableFoodsCnt[table][order[2]]++ } // 菜品排序 sort.Strings(foods) // 桌号排序 tables := make([]int, 0, len(tableFoodsCnt)) for table := range tableFoodsCnt { tables = append(tables, table) } sort.Ints(tables) // 生成结果 res := make([][]string, len(tables)+1) res[0] = make([]string, 0, len(foods)+1) // 表头 res[0] = append(res[0], \u0026#34;Table\u0026#34;) for _, food := range foods { res[0] = append(res[0], food) } // 填表 i := 1 for _, table := range tables { res[i] = make([]string, 0, len(foods)+1) res[i] = append(res[i], strconv.FormatInt(int64(table), 10)) // 桌号 // 菜品数 for _, food := range foods { res[i] = append(res[i], strconv.FormatInt(int64(tableFoodsCnt[table][food]), 10)) } i++ } return res } 复杂度 时间复杂度：$ O(N\\log{N}), N=len(orders) $ 空间复杂度：$ O(N) $ ","date":"2021-07-06T09:20:22+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1418.-%E7%82%B9%E8%8F%9C%E5%B1%95%E7%A4%BA%E8%A1%A8/","title":"Leetcode 1418. 点菜展示表"},{"content":"链接： https://leetcode-cn.com/problems/number-of-atoms/\n难度： 困难\n题目描述 给定一个化学式 formula （作为字符串），返回每种原子的数量。\n原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。\n如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。\n两个化学式连在一起是新的化学式。例如 H2O2He3Mg4 也是化学式。\n一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。\n给定一个化学式 formula ，返回所有原子的数量。格式为：第一个（按字典序）原子的名字，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。\n示例 1： 输入： formula = \u0026ldquo;H2O\u0026rdquo;\n输出： \u0026ldquo;H2O\u0026rdquo;\n解释：\n原子的数量是 {\u0026lsquo;H\u0026rsquo;: 2, \u0026lsquo;O\u0026rsquo;: 1}。\n示例 2： 输入： formula = \u0026ldquo;Mg(OH)2\u0026rdquo;\n输出： \u0026ldquo;H2MgO2\u0026rdquo;\n解释：\n原子的数量是 {\u0026lsquo;H\u0026rsquo;: 2, \u0026lsquo;Mg\u0026rsquo;: 1, \u0026lsquo;O\u0026rsquo;: 2}。\n示例 3： 输入： formula = \u0026ldquo;K4(ON(SO3)2)2\u0026rdquo;\n输出： \u0026ldquo;K4N2O14S4\u0026rdquo;\n解释：\n原子的数量是 {\u0026lsquo;K\u0026rsquo;: 4, \u0026lsquo;N\u0026rsquo;: 2, \u0026lsquo;O\u0026rsquo;: 14, \u0026lsquo;S\u0026rsquo;: 4}。\n示例 4： 输入： formula = \u0026ldquo;Be32\u0026rdquo;\n输出： \u0026ldquo;Be32\u0026rdquo;\n提示： 1 \u0026lt;= formula.length \u0026lt;= 1000 formula 由小写英文字母、数字 '(' 和 ')' 组成。 formula 是有效的化学式。 解题思路 栈 依次记录每个元素的数量，当遇到 '(' 时，入栈，直至遇到 ')'：\n读取其后的数字 cnt ，没有则记为 1 从栈中依次弹出元素，直到遇到 '(' 为止 将这些元素的数量 乘以 cnt ，然后重新放回栈中 重复以上步骤直到遍历完化学式，从栈中取出所有元素，排序，生成结果并返回。\n为避免重复记录过多的元素，通过 map 进行计数，作为栈的元素单位。\nfunc countOfAtoms(formula string) string { // 获取下一个数字 getNum := func(idx *int) int { num := 0 for ; *idx \u0026lt; len(formula); *idx++ { if formula[*idx] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; formula[*idx] \u0026lt;= \u0026#39;9\u0026#39; { num = num*10 + int(formula[*idx]-\u0026#39;0\u0026#39;) } else { break } } if num == 0 { num = 1 } return num } // 获取下一个元素 getAtom := func(idx *int) string { atom := make([]byte, 0, 2) atom = append(atom, formula[*idx]) for *idx++; *idx \u0026lt; len(formula); *idx++ { if formula[*idx] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; formula[*idx] \u0026lt;= \u0026#39;z\u0026#39; { atom = append(atom, formula[*idx]) } else { break } } return string(atom) } // 栈 stack := make([]map[string]int, 0, len(formula)) // 入栈 merge := func(tmp *map[string]int) { if len(*tmp) == 0 { return } if len(stack) \u0026gt; 0 \u0026amp;\u0026amp; len(stack[len(stack)-1]) \u0026gt; 0 { for k, v := range *tmp { stack[len(stack)-1][k] += v } } else { stack = append(stack, *tmp) } *tmp = make(map[string]int) } // 计数map tmp := make(map[string]int) for i := 0; i \u0026lt; len(formula); { switch formula[i] { // 左括号所有元素入栈 case \u0026#39;(\u0026#39;: merge(\u0026amp;tmp) stack = append(stack, nil) i++ // 右括号，最近左括号范围的元素数量 乘以 括号后的数 case \u0026#39;)\u0026#39;: i++ merge(\u0026amp;tmp) cnt := getNum(\u0026amp;i) for len(stack) \u0026gt; 0 { pairs := stack[len(stack)-1] stack = stack[:len(stack)-1] if pairs == nil { break } for k, v := range pairs { tmp[k] += v * cnt } } merge(\u0026amp;tmp) default: tmp[getAtom(\u0026amp;i)] += getNum(\u0026amp;i) } } // 合并为一个map merge(\u0026amp;tmp) tmp = make(map[string]int) for _, s := range stack { for atom, cnt := range s { tmp[atom] += cnt } } // 字典序排序 atoms := make([]string, 0, len(tmp)) for atom := range tmp { atoms = append(atoms, atom) } sort.Strings(atoms) // 生成结果字符串 res := make([]byte, 0, len(formula)\u0026lt;\u0026lt;1) for _, atom := range atoms { res = append(res, []byte(atom)...) if tmp[atom] \u0026gt; 1 { res = append(res, []byte(strconv.FormatInt(int64(tmp[atom]), 10))...) } } return string(res) } 复杂度 时间复杂度：$ O(N^2), N = len(formula) $ 空间复杂度：$ O(N) $ ","date":"2021-07-05T20:30:53+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-726.-%E5%8E%9F%E5%AD%90%E7%9A%84%E6%95%B0%E9%87%8F/","title":"Leetcode 726. 原子的数量"},{"content":"链接： https://leetcode-cn.com/problems/set-mismatch/\n难度： 简单\n题目描述 集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。\n给定一个数组 nums 代表了集合 S 发生错误后的结果。\n请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。\n示例 1： 输入： nums = [1,2,2,4]\n输出： [2,3]\n示例 2： 输入： nums = [1,1]\n输出： [1,2]\n提示： 2 \u0026lt;= nums.length \u0026lt;= 104 1 \u0026lt;= nums[i] \u0026lt;= 104 解题思路 哈希 利用哈希表记录每个数字是否出现，可以找到重复出现过的数字；遍历哈希表可以找到丢失的数字。\nfunc findErrorNums(nums []int) []int { res := []int{0, 0} exist := make([]bool, len(nums)) for _, num := range nums { if exist[num-1] { res[0] = num } exist[num-1] = true } for num, ok := range exist { if !ok { res[1] = num + 1 } } return res } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ ","date":"2021-07-04T10:12:40+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-645.-%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88/","title":"Leetcode 645. 错误的集合"},{"content":"链接： https://leetcode-cn.com/problems/sort-characters-by-frequency/\n难度： 中等\n题目描述 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。\n示例1： 输入:\n\u0026ldquo;tree\u0026rdquo;\n输出:\n\u0026ldquo;eert\u0026rdquo;\n解释:\n\u0026rsquo;e\u0026rsquo;出现两次，\u0026lsquo;r\u0026rsquo;和\u0026rsquo;t\u0026rsquo;都只出现一次。\n因此\u0026rsquo;e\u0026rsquo;必须出现在\u0026rsquo;r\u0026rsquo;和\u0026rsquo;t\u0026rsquo;之前。此外，\u0026ldquo;eetr\u0026quot;也是一个有效的答案。\n示例2： 输入:\n\u0026ldquo;cccaaa\u0026rdquo;\n输出:\n\u0026ldquo;cccaaa\u0026rdquo;\n解释:\n\u0026lsquo;c\u0026rsquo;和\u0026rsquo;a\u0026rsquo;都出现三次。此外，\u0026ldquo;aaaccc\u0026quot;也是有效的答案。\n注意\u0026quot;cacaca\u0026quot;是不正确的，因为相同的字母必须放在一起。\n示例3： 输入:\n\u0026ldquo;Aabb\u0026rdquo;\n输出:\n\u0026ldquo;bbAa\u0026rdquo;\n解释:\n此外，\u0026ldquo;bbaA\u0026quot;也是一个有效的答案，但\u0026quot;Aabb\u0026quot;是不正确的。\n注意\u0026rsquo;A\u0026rsquo;和\u0026rsquo;a\u0026rsquo;被认为是两种不同的字符。\n解题思路 计数+排序 统计每个字符出现的次数，按照统计的次数对字符进行排序，然后按照字符顺序和数量展开。\nfunc frequencySort(s string) string { cnt := make(map[byte]int) for i := 0; i \u0026lt; len(s); i++ { cnt[s[i]]++ } chars := make([]byte, 0, len(s)) for char := range cnt { chars = append(chars, char) } sort.Slice(chars, func(i, j int) bool { return cnt[chars[i]] \u0026gt; cnt[chars[j]] }) res := make([]byte, 0, len(s)) for _, char := range chars { res = append(res, bytes.Repeat([]byte{char}, cnt[char])...) } return string(res) } 复杂度 时间复杂度：O(NlogN), N = len(s) 空间复杂度：O(N) ","date":"2021-07-03T09:35:21+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-451.-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F/","title":"Leetcode 451. 根据字符出现频率排序"},{"content":"链接： https://leetcode-cn.com/problems/maximum-ice-cream-bars/\n难度： 中等\n题目描述 夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。\n商店中新到 n 支雪糕，用长度为 n 的数组 costs 表示雪糕的定价，其中 costs[i] 表示第 i 支雪糕的现金价格。Tony 一共有 coins 现金可以用于消费，他想要买尽可能多的雪糕。\n给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。\n**注意：**Tony 可以按任意顺序购买雪糕。\n示例 1： 输入： costs = [1,3,2,4,1], coins = 7\n输出： 4\n解释： Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 = 7\n示例 2： 输入： costs = [10,6,8,7,7,8], coins = 5\n输出： 0\n解释： Tony 没有足够的钱买任何一支雪糕。\n示例 3： 输入： costs = [1,6,3,1,2,5], coins = 20\n输出： 6\n解释： Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 = 18 。\n提示： costs.length == n 1 \u0026lt;= n \u0026lt;= 105 1 \u0026lt;= costs[i] \u0026lt;= 105 1 \u0026lt;= coins \u0026lt;= 108 解题思路 贪心 为了获得 最大数量，优先购买价格最低的雪糕即可，按照雪糕价格进行一次排序，依次选择到买不起为止。\nfunc maxIceCream(costs []int, coins int) int { sort.Ints(costs) for i, cost := range costs { coins -= cost if coins \u0026lt; 0 { return i } } return len(costs) } 复杂度 时间复杂度：O(NlogN) 空间复杂度：O(1) ","date":"2021-07-02T10:28:04+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1833.-%E9%9B%AA%E7%B3%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/","title":"Leetcode 1833. 雪糕的最大数量"},{"content":"链接： https://leetcode-cn.com/problems/chuan-di-xin-xi/\n难度： 简单\n题目描述 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：\n有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人 给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。\n示例1： 输入： n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3\n输出： 3\n解释： 信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-\u0026gt;2-\u0026gt;0-\u0026gt;4， 0-\u0026gt;2-\u0026gt;1-\u0026gt;4， 0-\u0026gt;2-\u0026gt;3-\u0026gt;4。\n示例2： 输入： n = 3, relation = [[0,2],[2,1]], k = 2\n输出： 0\n解释： 信息不能从小 A 处经过 2 轮传递到编号 2\n限制： 2 \u0026lt;= n \u0026lt;= 10 1 \u0026lt;= k \u0026lt;= 5 1 \u0026lt;= relation.length \u0026lt;= 90, 且 relation[i].length == 2 0 \u0026lt;= relation[i][0],relation[i][1] \u0026lt; n 且 relation[i][0] != relation[i][1] 解题思路 深度优先搜索 从 0 开始进行深度优先搜索，结点可以重复到达，深度限制为 k，最后的结点为 n-1 时，计数+1。\n为快速找到某个玩家可达的下一个玩家，用 map 记录。\nfunc numWays(n int, relation [][]int, k int) int { deliver := make(map[int][]int, len(relation)) for _, pair := range relation { deliver[pair[0]] = append(deliver[pair[0]], pair[1]) } var dfs func(player int, depth int) int dfs = func(player int, depth int) int { if depth == k { if player == n-1 { return 1 } return 0 } res := 0 for _, nextPlayer := range deliver[player] { res += dfs(nextPlayer, depth+1) } return res } return dfs(0, 0) } 复杂度 时间复杂度：O(nk) 空间复杂度：O(n+k+len(relation)) 动态规划 dp[i][j] 表示第 i 轮传递后，信息传递到第 j 个玩家的方案数量，很容易得到状态转移方程：\ndp[0][k] = 1 dp[i][k] = dp[i-1][j] + 1, (j, k) ∈ relation 注意到每次遍历下一行仅依赖上一行，可以对空间做进一步优化，将矩阵压缩到两个数组。\nfunc numWays(n int, relation [][]int, k int) int { dp := make([]int, n) dp[0] = 1 for i := 0; i \u0026lt; k; i++ { next := make([]int, n) for _, r := range relation { next[r[1]] += dp[r[0]] } dp = next } return dp[n-1] } 复杂度 时间复杂度：O(n*len(relation)) 空间复杂度：O(n) ","date":"2021-07-01T11:14:31+08:00","permalink":"https://xianlianghe0123.github.io/p/lcp-07.-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF/","title":"LCP 07. 传递信息"},{"content":"链接： https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/\n难度： 困难\n题目描述 请实现两个函数，分别用来序列化和反序列化二叉树。\n你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。\n提示： 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。\n示例1： 输入： root = [1,2,3,null,null,4,5]\n输出： [1,2,3,null,null,4,5]\n解题思路 先序遍历 序列化时，先序遍历整个二叉树，将遍历到的每个结点按顺序加入列表中。需要将遍历到的空结点也加入到列表中，作为分割。\n反序列化时，按照列表顺序构建二叉树，遇到空结点表示该分支已结束，回到另一个分支处，继续构造结点。\nclass Codec: def serialize(self, root): \u0026#34;\u0026#34;\u0026#34;Encodes a tree to a single string. :type root: TreeNode :rtype: str \u0026#34;\u0026#34;\u0026#34; list = [] def dfs(node): if node == None: list.append(\u0026#34;None\u0026#34;) else: list.append(str(node.val)) dfs(node.left) dfs(node.right) dfs(root) return \u0026#34;,\u0026#34;.join(list) def deserialize(self, data): \u0026#34;\u0026#34;\u0026#34;Decodes your encoded data to tree. :type data: str :rtype: TreeNode \u0026#34;\u0026#34;\u0026#34; list = data.split(\u0026#34;,\u0026#34;) i = 0 def dfs(): nonlocal i if list[i] == \u0026#34;None\u0026#34;: i += 1 return None node = TreeNode(int(list[i])) i += 1 node.left = dfs() node.right = dfs() return node return dfs() 复杂度 时间复杂度： serialize：$ O(N_1), N_1 = size(Tree) $ deserialize：$ O(N_2), N_2 = len(data) $ 空间复杂度： serialize：$ O(N_1) $ deserialize：$ O(N_2) $ ","date":"2021-06-30T15:51:24+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-37.-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/","title":"剑指 Offer 37. 序列化二叉树"},{"content":"链接： https://leetcode-cn.com/problems/excel-sheet-column-title/\n难度： 简单\n题目描述 给定一个正整数，返回它在 Excel 表中相对应的列名称。\n例如，\n1 -\u0026gt; A\n2 -\u0026gt; B\n3 -\u0026gt; C\n\u0026hellip;\n26 -\u0026gt; Z\n27 -\u0026gt; AA\n28 -\u0026gt; AB\n\u0026hellip;\n示例1： 输入: 1\n输出: \u0026ldquo;A\u0026rdquo;\n示例2： 输入: 28\n输出: \u0026ldquo;AB\u0026rdquo;\n示例3： 输入: 701\n输出: \u0026ldquo;ZY\u0026rdquo;\n解题思路 数学 通过分析题意可以得知，该题是一个进制转换，将一个10进制的数转换为26进制。\n通过数学方法，逐次模26取余数，即可求得倒序的26进制每一位，反转该序列即可求得转换后的数。\n**注意：**该26进制从1开始计数，每次取模前应减1。\nfunc convertToTitle(columnNumber int) string { res := make([]byte, 0, 10) for ; columnNumber \u0026gt; 0; columnNumber /= 26 { columnNumber = columnNumber - 1 res = append(res, \u0026#39;A\u0026#39;+byte((columnNumber)%26)) } for i := 0; i \u0026lt; len(res)/2; i++ { res[i], res[len(res)-1-i] = res[len(res)-1-i], res[i] } return string(res) } 复杂度 时间复杂度：O(log26columnNumber) 空间复杂度：O(log26columnNumber) ","date":"2021-06-29T10:26:51+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-168.-excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0/","title":"Leetcode 168. Excel表列名称"},{"content":"链接： https://leetcode-cn.com/problems/bus-routes/\n难度： 困难\n题目描述 给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。\n例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -\u0026gt; 5 -\u0026gt; 7 -\u0026gt; 1 -\u0026gt; 5 -\u0026gt; 7 -\u0026gt; 1 -\u0026gt; ... 这样的车站路线行驶。 现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。\n求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。\n示例 1： 输入： routes = [[1,2,7],[3,6,7]], source = 1, target = 6\n输出： 2\n解释： 最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。\n示例 2： 输入： routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\n输出： -1\n提示： 1 \u0026lt;= routes.length \u0026lt;= 500. 1 \u0026lt;= routes[i].length \u0026lt;= 105 routes[i] 中的所有值 互不相同 sum(routes[i].length) \u0026lt;= 105 0 \u0026lt;= routes[i][j] \u0026lt; 106 0 \u0026lt;= source, target \u0026lt; 106 解题思路 广度优先搜索 由于借助公交车进行移动，可以以公交车作为基本单位实行广度优先搜索，在每个站点搜索所有可乘坐公交车，直到某一条可以到达终点，或者乘坐过可乘坐的所有公交车均不能到达终点为止。\n需要对起点和终点相同的情况进行特判。\nfunc numBusesToDestination(routes [][]int, source int, target int) int { if source == target { return 0 } type Pair struct { Bus int Step int } buses := make(map[int][]int) for i, route := range routes { for _, station := range route { buses[station] = append(buses[station], i) } } isVisit := make([]bool, len(routes)) queue := make([]*Pair, 0, len(isVisit)) for _, bus := range buses[source] { queue = append(queue, \u0026amp;Pair{ Bus: bus, Step: 1, }) isVisit[bus] = true } for len(queue) \u0026gt; 0 { bus := queue[0].Bus step := queue[0].Step queue = queue[1:] for _, b := range buses[target] { if b == bus { return step } } for _, station := range routes[bus] { for _, b := range buses[station] { if !isVisit[b] { queue = append(queue, \u0026amp;Pair{ Bus: b, Step: step + 1, }) isVisit[b] = true } } } } return -1 } 复杂度 时间复杂度：$ O(N*M), N = len(routes), M = avg(len(routes[i]))$ 空间复杂度：$ O(N*M) $ ","date":"2021-06-28T10:54:56+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-815.-%E5%85%AC%E4%BA%A4%E8%B7%AF%E7%BA%BF/","title":"Leetcode 815. 公交路线"},{"content":"链接： https://leetcode-cn.com/problems/snakes-and-ladders/\n难度： 中等\n题目描述 N x N 的棋盘 board 上，按从 1 到 N*N 的数字给方格编号，编号 从左下角开始，每一行交替方向。\n例如，一块 6 x 6 大小的棋盘，编号如下：\nr 行 c 列的棋盘，按前述方法编号，棋盘格中可能存在 “蛇” 或 “梯子”；如果 board[r][c] != -1，那个蛇或梯子的目的地将会是 board[r][c]。\n玩家从棋盘上的方格 1 （总是在最后一行、第一列）开始出发。\n每一回合，玩家需要从当前方格 x 开始出发，按下述要求前进：\n选定目标方格：选择从编号 x+1，x+2，x+3，x+4，x+5，或者 x+6 的方格中选出一个目标方格 s ，目标方格的编号 \u0026lt;= N*N。 该选择模拟了掷骰子的情景，无论棋盘大小如何，你的目的地范围也只能处于区间 [x+1, x+6] 之间。 传送玩家：如果目标方格 S 处存在蛇或梯子，那么玩家会传送到蛇或梯子的目的地。否则，玩家传送到目标方格 S。 注意，玩家在每回合的前进过程中最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。 返回达到方格 N*N 所需的最少移动次数，如果不可能，则返回 -1。\n示例： 输入： [\n[-1,-1,-1,-1,-1,-1],\n[-1,-1,-1,-1,-1,-1],\n[-1,-1,-1,-1,-1,-1],\n[-1,35,-1,-1,13,-1],\n[-1,-1,-1,-1,-1,-1],\n[-1,15,-1,-1,-1,-1]]\n输出： 4\n解释：\n首先，从方格 1 [第 5 行，第 0 列] 开始。\n你决定移动到方格 2，并必须爬过梯子移动到到方格 15。\n然后你决定移动到方格 17 [第 3 行，第 5 列]，必须爬过蛇到方格 13。\n然后你决定移动到方格 14，且必须通过梯子移动到方格 35。\n然后你决定移动到方格 36, 游戏结束。\n可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。\n提示： 2 \u0026lt;= board.length = board[0].length \u0026lt;= 20 board[i][j] 介于 1 和 N*N 之间或者等于 -1。 编号为 1 的方格上没有蛇或梯子。 编号为 N*N 的方格上没有蛇或梯子。 解题思路 广度优先搜索 每次搜索下 6 个格子，当碰到蛇或者梯子时，将跳转位置入队，否则将当前位置入队，步数加一，标记已访问，避免重复搜索。直到到达 N*N返回步数；或队列为空，返回 -1。\nfunc snakesAndLadders(board [][]int) int { type Pair struct { Pos int Step int } isVisit := make([]bool, len(board)*len(board[0])) queue := make([]*Pair, 0, len(isVisit)) queue = append(queue, \u0026amp;Pair{ Pos: 0, Step: 0, }) isVisit[0] = true for len(queue) \u0026gt; 0 { pos := queue[0].Pos step := queue[0].Step queue = queue[1:] if pos == len(isVisit)-1 { return step } for i := 1; i \u0026lt;= 6; i++ { if pos+i \u0026gt;= len(isVisit) { break } row := len(board) - 1 - (pos+i)/len(board[0]) col := (pos + i) % len(board[0]) if (len(board)-1-row)\u0026amp;1 == 1 { col = len(board[0]) - 1 - col } cell := board[row][col] - 1 if cell \u0026lt; 0 { if isVisit[pos+i] { continue } queue = append(queue, \u0026amp;Pair{ Pos: pos + i, Step: step + 1, }) isVisit[pos+i] = true } else if !isVisit[cell] { queue = append(queue, \u0026amp;Pair{ Pos: cell, Step: step + 1, }) isVisit[cell] = true } } } return -1 } 复杂度 时间复杂度：O(N2) 空间复杂度：O(N2) ","date":"2021-06-27T19:07:10+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-909.-%E8%9B%87%E6%A2%AF%E6%A3%8B/","title":"Leetcode 909. 蛇梯棋"},{"content":"链接： https://leetcode-cn.com/problems/open-the-lock/\n难度： 中等\n题目描述 你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为 '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。\n锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。\n列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。\n字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。\n示例 1： 输入： deadends = [\u0026ldquo;0201\u0026rdquo;,\u0026ldquo;0101\u0026rdquo;,\u0026ldquo;0102\u0026rdquo;,\u0026ldquo;1212\u0026rdquo;,\u0026ldquo;2002\u0026rdquo;], target = \u0026ldquo;0202\u0026rdquo;\n输出： 6\n解释：\n可能的移动序列为 \u0026ldquo;0000\u0026rdquo; -\u0026gt; \u0026ldquo;1000\u0026rdquo; -\u0026gt; \u0026ldquo;1100\u0026rdquo; -\u0026gt; \u0026ldquo;1200\u0026rdquo; -\u0026gt; \u0026ldquo;1201\u0026rdquo; -\u0026gt; \u0026ldquo;1202\u0026rdquo; -\u0026gt; \u0026ldquo;0202\u0026rdquo;。\n注意 \u0026ldquo;0000\u0026rdquo; -\u0026gt; \u0026ldquo;0001\u0026rdquo; -\u0026gt; \u0026ldquo;0002\u0026rdquo; -\u0026gt; \u0026ldquo;0102\u0026rdquo; -\u0026gt; \u0026ldquo;0202\u0026rdquo; 这样的序列是不能解锁的，\n因为当拨动到 \u0026ldquo;0102\u0026rdquo; 时这个锁就会被锁定。\n示例 2： 输入: deadends = [\u0026ldquo;8888\u0026rdquo;], target = \u0026ldquo;0009\u0026rdquo;\n输出： 1\n解释：\n把最后一位反向旋转一次即可 \u0026ldquo;0000\u0026rdquo; -\u0026gt; \u0026ldquo;0009\u0026rdquo;\n示例 3： 输入: deadends = [\u0026ldquo;8887\u0026rdquo;,\u0026ldquo;8889\u0026rdquo;,\u0026ldquo;8878\u0026rdquo;,\u0026ldquo;8898\u0026rdquo;,\u0026ldquo;8788\u0026rdquo;,\u0026ldquo;8988\u0026rdquo;,\u0026ldquo;7888\u0026rdquo;,\u0026ldquo;9888\u0026rdquo;], target = \u0026ldquo;8888\u0026rdquo;\n输出： -1\n解释：\n无法旋转到目标数字且不被锁定。\n示例 4： 输入: deadends = [\u0026ldquo;0000\u0026rdquo;], target = \u0026ldquo;8888\u0026rdquo;\n输出： -1\n提示： 1 \u0026lt;= deadends.length \u0026lt;= 500 deadends[i].length == 4 target.length == 4 target 不在 deadends 之中 target 和 deadends[i] 仅由若干位数字组成 解题思路 广度优先搜索 每次转动一个拨轮，记录转动后的锁状态，以及到目前为止转动的次数，如果未访问过，加入队列，直到首次与target匹配则返回。\n每次入队后将当前锁状态加入到 deadends 中，防止重复搜索。\n需要对一开始即被锁的情况进行特判。\nfunc openLock(deadends []string, target string) int { type Pair struct { Cur string Cnt int } deadendsMap := make(map[string]bool) for _, s := range deadends { deadendsMap[s] = true } if deadendsMap[\u0026#34;0000\u0026#34;] { return -1 } // 广度优先搜索 min := -1 queue := make([]*Pair, 0, 10000) queue = append(queue, \u0026amp;Pair{ Cur: \u0026#34;0000\u0026#34;, Cnt: 0, }) deadendsMap[\u0026#34;0000\u0026#34;] = true for len(queue) \u0026gt; 0 { cur := queue[0].Cur cnt := queue[0].Cnt queue = queue[1:] if cur == target { if min == -1 { min = cnt break } } for i := 0; i \u0026lt; 4; i++ { // 向后旋转 t := []byte(cur) t[i] = \u0026#39;0\u0026#39; + ((t[i]-\u0026#39;0\u0026#39;)+1)%10 if !deadendsMap[string(t)] { queue = append(queue, \u0026amp;Pair{ Cur: string(t), Cnt: cnt + 1, }) deadendsMap[string(t)] = true } // 向前旋转 t = []byte(cur) t[i] = \u0026#39;0\u0026#39; + ((t[i]-\u0026#39;0\u0026#39;)-1+10)%10 if !deadendsMap[string(t)] { queue = append(queue, \u0026amp;Pair{ Cur: string(t), Cnt: cnt + 1, }) deadendsMap[string(t)] = true } } } return min } 复杂度 时间复杂度：$ O(b^d*d)，其中 b 是数字的进制，d 是转盘数字的位数 $ 空间复杂度：$ O(b^d*d) $ ","date":"2021-06-25T17:34:59+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-752.-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/","title":"Leetcode 752. 打开转盘锁"},{"content":"链接： https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/\n难度： 简单\n题目描述 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。\n示例1： 输入： 00000000000000000000000000001011\n输出： 3\n解释： 输入的二进制串 00000000000000000000000000001011 中，共有三位为 \u0026lsquo;1\u0026rsquo;。\n示例 2： 输入： 00000000000000000000000010000000\n输出： 1\n解释： 输入的二进制串 00000000000000000000000010000000 中，共有一位为 \u0026lsquo;1\u0026rsquo;。\n示例 3： 输入： 11111111111111111111111111111101\n输出： 31\n解释： 输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 \u0026lsquo;1\u0026rsquo;。\n提示： 输入必须是长度为 32 的 二进制串 。 解题思路 计数 每次统计最右边的一位，并向右移动一位。\nfunc hammingWeight(num uint32) int { cnt := 0 for ; num != 0; num \u0026gt;\u0026gt;= 1 { cnt += int(num \u0026amp; 1) } return cnt } 复杂度 时间复杂度：$ O(\\log{N}) $ 空间复杂度：$ O(1) $ 消除 使用lowbit算法，每次消除最右边的 1，直到该数为 0，消除次数即为1的个数 每次统计最右边的一位，并向右移动一位。\nfunc hammingWeight(num uint32) int { cnt := 0 for ; num != 0; cnt++ { num \u0026amp;= num - 1 } return cnt } 复杂度 时间复杂度：$ O(\\log{N}) $ 空间复杂度：$ O(1) $ ","date":"2021-06-23T21:39:35+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/","title":"剑指 Offer 15. 二进制中1的个数"},{"content":"链接： https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/\n难度： 中等\n题目描述 输入一个字符串，打印出该字符串中字符的所有排列。\n你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。\n示例1： 输入： s = \u0026ldquo;abc\u0026rdquo;\n输出： [\u0026ldquo;abc\u0026rdquo;,\u0026ldquo;acb\u0026rdquo;,\u0026ldquo;bac\u0026rdquo;,\u0026ldquo;bca\u0026rdquo;,\u0026ldquo;cab\u0026rdquo;,\u0026ldquo;cba\u0026rdquo;]\n提示： 1 \u0026lt;= s 的长度 \u0026lt;= 8 解题思路 回溯 遍历未入栈字符列表，每次选取一个字符入栈，并标记此字符已经入栈，递归的寻找下一个字符，直到所有字符全部入栈，将结果加入集合中。\nfunc permutation(s string) []string { only := make(map[string]bool) choice := make([]bool, len(s)) prefix := make([]byte, 0, len(s)) var backtrack func() backtrack = func() { if len(prefix) == len(s) { only[string(prefix)] = true return } for i := range choice { if choice[i] { continue } prefix = append(prefix, s[i]) choice[i] = true backtrack() choice[i] = false prefix = prefix[:len(prefix)-1] } } backtrack() res := make([]string, 0, 1\u0026lt;\u0026lt;(len(s)-1)) for k := range only { res = append(res, k) } return res } 复杂度 时间复杂度：O(N*N!) 空间复杂度：O(N*N!) ","date":"2021-06-22T21:43:40+08:00","permalink":"https://xianlianghe0123.github.io/p/%E5%89%91%E6%8C%87-offer-38.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/","title":"剑指 Offer 38. 字符串的排列"},{"content":"链接： https://leetcode-cn.com/problems/binary-watch/\n难度： 简单\n题目描述 二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。\n例如，下面的二进制手表读取 \u0026quot;3:25\u0026quot; 。 给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。\n小时不会以零开头：\n例如，\u0026quot;01:00\u0026quot; 是无效的时间，正确的写法应该是 \u0026quot;1:00\u0026quot; 。 分钟必须由两位数组成，可能会以零开头：\n例如，\u0026quot;10:2\u0026quot; 是无效的时间，正确的写法应该是 \u0026quot;10:02\u0026quot; 。 示例 1： 输入： turnedOn = 1\n输出： [\u0026ldquo;0:01\u0026rdquo;,\u0026ldquo;0:02\u0026rdquo;,\u0026ldquo;0:04\u0026rdquo;,\u0026ldquo;0:08\u0026rdquo;,\u0026ldquo;0:16\u0026rdquo;,\u0026ldquo;0:32\u0026rdquo;,\u0026ldquo;1:00\u0026rdquo;,\u0026ldquo;2:00\u0026rdquo;,\u0026ldquo;4:00\u0026rdquo;,\u0026ldquo;8:00\u0026rdquo;]\n示例 2： 输入： turnedOn = 9\n输出： []\n提示： 0 \u0026lt;= turnedOn \u0026lt;= 10 解题思路 穷举 枚举出所有小时和分钟的合法数，将符合条件的加入到结果列表中\nfunc readBinaryWatch(turnedOn int) []string { res := make([]string, 0, 720) for h := 0; h \u0026lt; 12; h++ { for m := 0; m \u0026lt; 60; m++ { if bits.OnesCount8(uint8(h))+bits.OnesCount8(uint8(m)) == turnedOn { res = append(res, fmt.Sprintf(\u0026#34;%d:%02d\u0026#34;, h, m)) } } } return res } 复杂度 时间复杂度：O(1) 空间复杂度：O(1) ","date":"2021-06-21T21:27:36+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-401.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/","title":"Leetcode 401. 二进制手表"},{"content":"链接： https://leetcode-cn.com/problems/throne-inheritance/\n难度： 中等\n题目描述 一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。\n这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义递归函数 Successor(x, curOrder) ，给定一个人 x 和当前的继承顺序，该函数返回 x 的下一继承人。\nSuccessor(x, curOrder):\n如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：\n如果 x 是国王，那么返回 null\n否则，返回 Successor(x 的父亲, curOrder)\n否则，返回 x 不在 curOrder 中最年长的孩子\n比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。\n一开始， curOrder 为 [\u0026ldquo;king\u0026rdquo;]. 调用 Successor(king, curOrder) ，返回 Alice ，所以我们将 Alice 放入 curOrder 中，得到 [\u0026quot;king\u0026quot;, \u0026quot;Alice\u0026quot;] 。 调用 Successor(Alice, curOrder) ，返回 Jack ，所以我们将 Jack 放入 curOrder 中，得到 [\u0026quot;king\u0026quot;, \u0026quot;Alice\u0026quot;, \u0026quot;Jack\u0026quot;] 。 调用 Successor(Jack, curOrder) ，返回 Bob ，所以我们将 Bob 放入 curOrder 中，得到 [\u0026quot;king\u0026quot;, \u0026quot;Alice\u0026quot;, \u0026quot;Jack\u0026quot;, \u0026quot;Bob\u0026quot;] 。 调用 Successor(Bob, curOrder) ，返回 null 。最终得到继承顺序为 [\u0026quot;king\u0026quot;, \u0026quot;Alice\u0026quot;, \u0026quot;Jack\u0026quot;, \u0026quot;Bob\u0026quot;] 。 通过以上的函数，我们总是能得到一个唯一的继承顺序。\n请你实现 ThroneInheritance 类：\nThroneInheritance(string kingName) 初始化一个 ThroneInheritance 类的对象。国王的名字作为构造函数的参数传入。 void birth(string parentName, string childName) 表示 parentName 新拥有了一个名为 childName 的孩子。 void death(string name) 表示名为 name 的人死亡。一个人的死亡不会影响 Successor 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。 string[] getInheritanceOrder() 返回 除去 死亡人员的当前继承顺序列表。 示例： 输入： [\u0026ldquo;ThroneInheritance\u0026rdquo;, \u0026ldquo;birth\u0026rdquo;, \u0026ldquo;birth\u0026rdquo;, \u0026ldquo;birth\u0026rdquo;, \u0026ldquo;birth\u0026rdquo;, \u0026ldquo;birth\u0026rdquo;, \u0026ldquo;birth\u0026rdquo;, \u0026ldquo;getInheritanceOrder\u0026rdquo;, \u0026ldquo;death\u0026rdquo;, \u0026ldquo;getInheritanceOrder\u0026rdquo;]\n[[\u0026ldquo;king\u0026rdquo;], [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;andy\u0026rdquo;], [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;bob\u0026rdquo;], [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;catherine\u0026rdquo;], [\u0026ldquo;andy\u0026rdquo;, \u0026ldquo;matthew\u0026rdquo;], [\u0026ldquo;bob\u0026rdquo;, \u0026ldquo;alex\u0026rdquo;], [\u0026ldquo;bob\u0026rdquo;, \u0026ldquo;asha\u0026rdquo;], [null], [\u0026ldquo;bob\u0026rdquo;], [null]]\n输出： [null, null, null, null, null, null, null, [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;andy\u0026rdquo;, \u0026ldquo;matthew\u0026rdquo;, \u0026ldquo;bob\u0026rdquo;, \u0026ldquo;alex\u0026rdquo;, \u0026ldquo;asha\u0026rdquo;, \u0026ldquo;catherine\u0026rdquo;], null, [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;andy\u0026rdquo;, \u0026ldquo;matthew\u0026rdquo;, \u0026ldquo;alex\u0026rdquo;, \u0026ldquo;asha\u0026rdquo;, \u0026ldquo;catherine\u0026rdquo;]]\n解释： ThroneInheritance t= new ThroneInheritance(\u0026ldquo;king\u0026rdquo;); // 继承顺序：king\nt.birth(\u0026ldquo;king\u0026rdquo;, \u0026ldquo;andy\u0026rdquo;); // 继承顺序：king \u0026gt; andy\nt.birth(\u0026ldquo;king\u0026rdquo;, \u0026ldquo;bob\u0026rdquo;); // 继承顺序：king \u0026gt; andy \u0026gt; bob\nt.birth(\u0026ldquo;king\u0026rdquo;, \u0026ldquo;catherine\u0026rdquo;); // 继承顺序：king \u0026gt; andy \u0026gt; bob \u0026gt; catherine\nt.birth(\u0026ldquo;andy\u0026rdquo;, \u0026ldquo;matthew\u0026rdquo;); // 继承顺序：king \u0026gt; andy \u0026gt; matthew \u0026gt; bob \u0026gt; catherine\nt.birth(\u0026ldquo;bob\u0026rdquo;, \u0026ldquo;alex\u0026rdquo;); // 继承顺序：king \u0026gt; andy \u0026gt; matthew \u0026gt; bob \u0026gt; alex \u0026gt; catherine\nt.birth(\u0026ldquo;bob\u0026rdquo;, \u0026ldquo;asha\u0026rdquo;); // 继承顺序：king \u0026gt; andy \u0026gt; matthew \u0026gt; bob \u0026gt; alex \u0026gt; asha \u0026gt; catherine\nt.getInheritanceOrder(); // 返回 [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;andy\u0026rdquo;, \u0026ldquo;matthew\u0026rdquo;, \u0026ldquo;bob\u0026rdquo;, \u0026ldquo;alex\u0026rdquo;, \u0026ldquo;asha\u0026rdquo;, \u0026ldquo;catherine\u0026rdquo;]\nt.death(\u0026ldquo;bob\u0026rdquo;); // 继承顺序：king \u0026gt; andy \u0026gt; matthew \u0026gt; bob（已经去世）\u0026gt; alex \u0026gt; asha \u0026gt; catherine\nt.getInheritanceOrder(); // 返回 [\u0026ldquo;king\u0026rdquo;, \u0026ldquo;andy\u0026rdquo;, \u0026ldquo;matthew\u0026rdquo;, \u0026ldquo;alex\u0026rdquo;, \u0026ldquo;asha\u0026rdquo;, \u0026ldquo;catherine\u0026rdquo;]\n提示： 1 \u0026lt;= kingName.length, parentName.length, childName.length, name.length \u0026lt;= 15 kingName，parentName， childName 和 name 仅包含小写英文字母。 所有的参数 childName 和 kingName 互不相同。 所有 death 函数中的死亡名字 name 要么是国王，要么是已经出生了的人员名字。 每次调用 birth(parentName, childName) 时，测试用例都保证 parentName 对应的人员是活着的。 最多调用 105 次birth 和 death 。 最多调用 10 次 getInheritanceOrder 。 解题思路 树 整个家庭成员的关系显然是一个树状结构，用树来保存家庭成员关系信息，而继承的顺序则是数的前序遍历。\n另外，为快速定位到某个成员，使用一个 map 记录代表每个成员的结点。\ntype Person struct { name string isLive bool children []*Person } type ThroneInheritance struct { root *Person pos map[string]*Person } func Constructor(kingName string) ThroneInheritance { king := \u0026amp;Person{ name: kingName, isLive: true, } return ThroneInheritance{ root: king, pos: map[string]*Person{ kingName: king, }, } } func (this *ThroneInheritance) Birth(parentName string, childName string) { this.pos[childName] = \u0026amp;Person{ name: childName, isLive: true, } this.pos[parentName].children = append(this.pos[parentName].children, this.pos[childName]) } func (this *ThroneInheritance) Death(name string) { this.pos[name].isLive = false } func (this *ThroneInheritance) GetInheritanceOrder() []string { res := make([]string, 0, len(this.pos)) var dfs func(p *Person) dfs = func(p *Person) { if p.isLive { res = append(res, p.name) } for _, child := range p.children { dfs(child) } } dfs(this.root) return res } 复杂度 时间复杂度： Constructor: $ O(1) $ Birth: $ O(1) $ Death: $ O(1) $ GetInheritanceOrder: $ O(N) $ 空间复杂度：$ O(N) $ ","date":"2021-06-20T09:58:32+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1600.-%E7%9A%87%E4%BD%8D%E7%BB%A7%E6%89%BF%E9%A1%BA%E5%BA%8F/","title":"Leetcode 1600. 皇位继承顺序"},{"content":"链接： https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/\n难度： 简单\n题目描述 符合下列属性的数组 arr 称为 山脉数组 ：\narr.length \u0026gt;= 3 存在 i（0 \u0026lt; i \u0026lt; arr.length - 1）使得： arr[0] \u0026lt; arr[1] \u0026lt; \u0026hellip; arr[i-1] \u0026lt; arr[i] arr[i] \u0026gt; arr[i+1] \u0026gt; \u0026hellip; \u0026gt; arr[arr.length - 1] 给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] \u0026lt; arr[1] \u0026lt; ... arr[i - 1] \u0026lt; arr[i] \u0026gt; arr[i + 1] \u0026gt; ... \u0026gt; arr[arr.length - 1] 的下标 i 。\n示例 1： 输入： arr = [0,1,0]\n输出： 1\n示例 2： 输入： arr = [0,2,1,0]\n输出： 1\n示例 3： 输入： arr = [0,10,5,2]\n输出： 1\n示例 4： 输入： arr = [3,4,5,1]\n输出： 2\n示例 5： 输入： arr = [24,69,100,99,79,78,67,36,26,19]\n输出： 2 提示： 3 \u0026lt;= arr.length \u0026lt;= 104 0 \u0026lt;= arr[i] \u0026lt;= 106 题目数据保证 arr 是一个山脉数组 解题思路 暴力求解 遍历数组，找出最大值，返回其下标。\nfunc peakIndexInMountainArray(arr []int) int { max := 0 idx := 0 for i, num := range arr { if max \u0026lt; num { max = num idx = i } } return idx } 复杂度 时间复杂度：$ O(N), N = len(arr) $ 空间复杂度：$ O(1) $ 二分查找 每次获取数组中间的数，并与相邻的两个数做比较：\n均大于这两个数，说明该数为山顶，返回 大于前一个数，说明左侧均小于该书数，右侧查找 同理，大于后一个数，左侧查找 func peakIndexInMountainArray(arr []int) int { mid := 0 for l, r := 0, len(arr)-1; ; { mid = (l + r) / 2 if arr[mid] \u0026gt; arr[mid-1] { if arr[mid] \u0026gt; arr[mid+1] { break } l = mid } else { r = mid } } return mid } 复杂度 时间复杂度：$ O(\\log{N}), N = len(arr) $ 空间复杂度：$ O(1) $ ","date":"2021-06-15T20:49:55+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-852.-%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84%E7%9A%84%E5%B3%B0%E9%A1%B6%E7%B4%A2%E5%BC%95/","title":"Leetcode 852. 山脉数组的峰顶索引"},{"content":"链接： https://leetcode-cn.com/problems/guess-number-higher-or-lower/\n难度： 简单\n题目描述 猜数字游戏的规则如下：\n每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。 你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：\n-1：我选出的数字比你猜的数字小 pick \u0026lt; num 1：我选出的数字比你猜的数字大 pick \u0026gt; num 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num 返回我选出的数字。\n示例 1： 输入： n = 10, pick = 6\n输出： 6\n示例 2： 输入： n = 1, pick = 1\n输出： 1\n示例 3： 输入： n = 2, pick = 1\n输出： 1\n示例 4： 输入： n = 2, pick = 2\n输出： 2 提示： 1 \u0026lt;= n \u0026lt;= 231 - 1 1 \u0026lt;= pick \u0026lt;= n 解题思路 二分查找 每次选取中间的数字获取比较结果，等于返回，大于去左半边找，小于去右半边找。\nfunc guessNumber(n int) int { var binSearch func(l, r int) int binSearch = func(l, r int) int { mid := (l + r) / 2 switch guess(mid) { case 0: return mid case -1: return binSearch(l, mid-1) case 1: return binSearch(mid+1, r) } return 0 } return binSearch(1, n) } 复杂度 时间复杂度：O(logN) 空间复杂度：O(1) ","date":"2021-06-14T10:50:24+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-374.-%E7%8C%9C%E6%95%B0%E5%AD%97%E5%A4%A7%E5%B0%8F/","title":"Leetcode 374. 猜数字大小"},{"content":"链接： https://leetcode-cn.com/problems/first-bad-version/\n难度： 简单\n题目描述 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。\n假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。\n你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。\n示例 1： 给定 n = 5，并且 version = 4 是第一个错误的版本。\n调用 isBadVersion(3) -\u0026gt; false\n调用 isBadVersion(5) -\u0026gt; true\n调用 isBadVersion(4) -\u0026gt; true\n所以，4 是第一个错误的版本。 解题思路 二分查找 对于连续的版本号 [i, j] 每次判断版本号 (i+j)/2 是否出错，未出错查找范围缩小到 [(i+j)/2+1, j]，出错缩小到 [i, (i+j)/2]，直到 i = j 即得到首个出错的版本号 i\nfunc firstBadVersion(n int) int { var binSearch func(i, j int) int binSearch = func(i, j int) int { if i == j { return i } mid := (i + j) / 2 if isBadVersion(mid) { return binSearch(i, mid) } else { return binSearch(mid+1, j) } } return binSearch(1, n) } 复杂度 时间复杂度：O(logN) 空间复杂度：O(1) ","date":"2021-06-13T10:25:24+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-278.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/","title":"Leetcode 278. 第一个错误的版本"},{"content":"链接： https://leetcode-cn.com/problems/perfect-squares/\n难度： 中等\n题目描述 给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。\n给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n示例 1： 输入： n = 12\n输出： 3\n解释： 12 = 4 + 4 + 4\n示例 2： 输入： n = 13\n输出： 2\n解释： 13 = 4 + 9\n注意： 你可以假设：\n1 \u0026lt;= n \u0026lt;= 104 解题思路 动态规划 dp[i] 表示组成数字 i 的最少完全平方数，易得到状态转移方程：\ndp[0] = 0 dp[i] = min(dp[i-j]+1), j \u0026lt; i 且 j是完全平方数 func change(amount int, coins []int) int { dp = make([]int, amount+1) dp[0] = 1 for i := range coins { for j := 0; j \u0026lt;= amount; j++ { for k := 0; k*coins[i] \u0026lt;= j; k++ { dp[j] += dp[j-k*coins[i]] } } } return dp[amount] } 复杂度 时间复杂度：O(N*√N) 空间复杂度：O(N) ","date":"2021-06-11T19:33:36+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-279.-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/","title":"Leetcode 279. 完全平方数"},{"content":"链接： https://leetcode-cn.com/problems/coin-change-2/\n难度： 中等\n题目描述 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。\n示例 1： 输入: amount = 5, coins = [1, 2, 5]\n输出: 4\n解释: 有四种方式可以凑成总金额:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1\n示例 2： 输入: amount = 3, coins = [2]\n输出: 0\n解释: 只用面额2的硬币不能凑成总金额3。\n示例 3： 输入: amount = 10, coins = [10]\n输出: 1\n注意： 你可以假设：\n0 \u0026lt;= amount (总金额) \u0026lt;= 5000 1 \u0026lt;= coin (硬币面额) \u0026lt;= 5000 硬币种类不超过 500 种 结果符合 32 位符号整数 解题思路 动态规划 dp[i][j] 表示前 i 种面额的硬币，组成总金额 j 的方案数，则可以得到状态转移方程：\ndp[0][0] = 1 dp[i][j] = ∑dp[i-1][j-k*coins[i]], k∈N 且 k*coins[i] \u0026lt;= j func change(amount int, coins []int) int { dp = make([]int, amount+1) dp[0] = 1 for i := range coins { for j := 0; j \u0026lt;= amount; j++ { for k := 0; k*coins[i] \u0026lt;= j; k++ { dp[j] += dp[j-k*coins[i]] } } } return dp[amount] } 复杂度 时间复杂度：O(N*amount) 空间复杂度：O(N*amount) 优化 用 dp[i] 记录组成总金额 i 的方案数，则对于每个面额 coin 的金币，都可以将其加进去，使得 dp[i+coin] 的方案数增加 dp[i] 。由此得到状态转移方程：\ndp[0] = 1 dp[i] = ∑dp[i-coin], coin∈coins func change(amount int, coins []int) int { dp := make([]int, amount+1) dp[0] = 1 for _, coin := range coins { for i := coin; i \u0026lt;= amount; i++ { dp[i] += dp[i-coin] } fmt.Println(dp) } return dp[amount] } 复杂度 时间复杂度：O(N*amount) 空间复杂度：O(amount) ","date":"2021-06-10T10:35:20+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-518.-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii/","title":"Leetcode 518. 零钱兑换 II"},{"content":"链接： https://leetcode-cn.com/problems/last-stone-weight-ii/\n难度： 中等\n题目描述 有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。\n每一回合，从中选出 任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x \u0026lt;= y。那么粉碎的可能结果如下：\n如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。\n示例 1： 输入： stones = [2,7,4,1,8,1]\n输出： 1\n解释：\n组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，\n组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，\n组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，\n组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。\n示例 2： 输入： stones = [31,26,33,21,40]\n输出： 5\n示例 3： 输入： stones = [1,2]\n输出： 1\n提示： 1 \u0026lt;= stones.length \u0026lt;= 30 1 \u0026lt;= stones[i] \u0026lt;= 100 解题思路 动态规划 每次从石头堆中拿出两块石头 a 和 b，不妨假设 a \u0026lt; b，则放回石头堆的石头为 b - a。所以最后的结果是 ∑ki*stonesi, ki=-1或1。\n为使得结果最小，要求系数为 -1 和 1 的两堆石头的重量和要最接近，所以原问题转化 01背包问题，背包容量为石头重量总和 sum 的一半，要求从石头堆选取石头装到背包的最大值。\nfunc lastStoneWeightII(stones []int) int { sum := 0 for _, stone := range stones { sum += stone } dp := make([]int, sum/2+1) for _, stones := range stones { for j := len(dp) - 1; j \u0026gt;= 0; j-- { if j \u0026gt;= stones \u0026amp;\u0026amp; dp[j] \u0026lt; dp[j-stones]+stones { dp[j] = dp[j-stones] + stones } } } if (dp[len(dp)-1] \u0026lt;\u0026lt; 1) \u0026gt; sum { return (dp[len(dp)-1] \u0026lt;\u0026lt; 1) - sum } else { return sum - (dp[len(dp)-1] \u0026lt;\u0026lt; 1) } } 复杂度 时间复杂度：$ O(N*sum(stones)) $ 空间复杂度：$ O(sum(stones)) $ ","date":"2021-06-08T11:35:42+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1049.-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-ii/","title":"Leetcode 1049. 最后一块石头的重量 II"},{"content":"链接： https://leetcode-cn.com/problems/target-sum/\n难度： 中等\n题目描述 给你一个整数数组 nums 和一个整数 target 。\n向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：\n例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 \u0026quot;+2-1\u0026quot; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。\n示例 1： 输入： nums = [1,1,1,1,1], target = 3\n输出： 5\n解释： 一共有 5 种方法让最终目标和为 3 。\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n示例 2： 输入： nums = [1], target = 1\n输出： 1\n注意： 1 \u0026lt;= nums.length \u0026lt;= 20 0 \u0026lt;= nums[i] \u0026lt;= 1000 0 \u0026lt;= sum(nums[i]) \u0026lt;= 1000 -1000 \u0026lt;= target \u0026lt;= 100 解题思路 暴力求解 对于每个数字，可以有 + 和 - 两种符号，枚举出所有的情况，统计符合题意的数量。\nfunc findTargetSumWays(nums []int, target int) int { if len(nums) == 0 { if target == 0 { return 1 } else { return 0 } } return findTargetSumWays(nums[1:], target-nums[0]) + findTargetSumWays(nums[1:], target+nums[0]) } 复杂度 时间复杂度：O(2N) 空间复杂度：O(N) 动态规划 用 dp[i][j] 记录以 i 为结尾的前缀数组，计算结果为 j 的方案数量，很容易得到状态转移方程：\ndp[i][j] = dp[i-1][j-num[i]] + dp[i-1][j+num[i]] 由于计算结果可以为负值，故对其添加一个偏移量，使之全部为非负数\nfunc findTargetSumWays(nums []int, target int) int { dp := [20][2002]int{} dp[0][1000+nums[0]] += 1 dp[0][1000-nums[0]] += 1 for i := 1; i \u0026lt; len(nums); i++ { for j, cnt := range dp[i-1] { if cnt == 0 { continue } dp[i][j+nums[i]] += dp[i-1][j] dp[i][j-nums[i]] += dp[i-1][j] } } return dp[len(nums)-1][target+1000] } 复杂度 时间复杂度：O(N*scope) 空间复杂度：O(N*scope) ","date":"2021-06-07T20:34:13+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-494.-%E7%9B%AE%E6%A0%87%E5%92%8C/","title":"Leetcode 494. 目标和"},{"content":"链接： https://leetcode-cn.com/problems/ones-and-zeroes/\n难度： 中等\n题目描述 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。\n请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。\n如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。\n示例 1： 输入： strs = [\u0026ldquo;10\u0026rdquo;, \u0026ldquo;0001\u0026rdquo;, \u0026ldquo;111001\u0026rdquo;, \u0026ldquo;1\u0026rdquo;, \u0026ldquo;0\u0026rdquo;], m = 5, n = 3\n输出： 4\n解释： 最多有 5 个 0 和 3 个 1 的最大子集是 {\u0026ldquo;10\u0026rdquo;,\u0026ldquo;0001\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;} ，因此答案是 4 。\n其他满足题意但较小的子集包括 {\u0026ldquo;0001\u0026rdquo;,\u0026ldquo;1\u0026rdquo;} 和 {\u0026ldquo;10\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026ldquo;0\u0026rdquo;} 。{\u0026ldquo;111001\u0026rdquo;} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。\n示例 2： 输入： strs = [\u0026ldquo;10\u0026rdquo;, \u0026ldquo;0\u0026rdquo;, \u0026ldquo;1\u0026rdquo;], m = 1, n = 1\n输出： 2\n解释： 最大的子集是 {\u0026ldquo;0\u0026rdquo;, \u0026ldquo;1\u0026rdquo;} ，所以答案是 2 。\n注意： 1 \u0026lt;= strs.length \u0026lt;= 600 1 \u0026lt;= strs[i].length \u0026lt;= 100 strs[i] 仅由 '0' 和 '1' 组成 1 \u0026lt;= m, n \u0026lt;= 100 解题思路 动态规划 对于数组中的每个元素，都有两种选择，要么其位于最大集合中，要么其不在最大子集中。所以该题为背包问题的一个变种，参考背包问题的求解思路，用动态规划求解。\n用 dp[i][j][k] 表示当选择第 i 个元素时，0 的数量为 j，而 1 的数量为 k，此时最大子集的大小。状态转移方程如下：\n当前元素不可被选择时，即j \u0026lt; zeros 或 k \u0026lt; ones，dp[i][j][k] = dp[i-1][j][k]； 当当前元素可以被选择时，即j \u0026gt;= zeros 且 k \u0026gt;= ones，dp[i][j][k] = max(dp[i-1][j-zeros][k-ones] + 1, dp[i-1][j][k])。 注意到每次转移仅依赖与上一个元素选择的结果，可以缩减一维空间，降低空间复杂度，而依赖前值的问题可以通过倒序计算解决:\nfunc findMaxForm(strs []string, m int, n int) int { dp := [101][101]int{} for _, str := range strs { zeros := 0 ones := 0 for i := 0; i \u0026lt; len(str); i++ { if str[i] == \u0026#39;0\u0026#39; { zeros++ } else { ones++ } } for j := m; j \u0026gt;= 0; j-- { for k := n; k \u0026gt;= 0; k-- { if j \u0026gt;= zeros \u0026amp;\u0026amp; k \u0026gt;= ones \u0026amp;\u0026amp; dp[j-zeros][k-ones] \u0026gt;= dp[j][k] { dp[j][k] = dp[j-zeros][k-ones] + 1 } } } } return dp[m][n] } 复杂度 时间复杂度：O(N*m*n) 空间复杂度：O(m*n) ","date":"2021-06-06T10:08:43+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-474.-%E4%B8%80%E5%92%8C%E9%9B%B6/","title":"Leetcode 474. 一和零"},{"content":"链接： https://leetcode-cn.com/problems/remove-linked-list-elements/\n难度： 简单\n题目描述 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\n示例 1： \u0026lt;img src=\u0026ldquo;https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg\", width=\u0026ldquo;500px\u0026rdquo;\u0026gt;\n输入： head = [1,2,6,3,4,5,6], val = 6\n输出： [1,2,3,4,5]\n示例 2： 输入： head = [], val = 1\n输出： []\n示例 3： 输入： head = [7,7,7,7], val = 7\n输出： []\n提示： 列表中的节点在范围 [0, 10] 内 1 \u0026lt;= Node.val \u0026lt;= 50 0 \u0026lt;= k \u0026lt;= 50 解题思路 模拟 遍历整个链表，遇到值为 val 的结点，将其从链表中删除。\nfunc removeElements(head *ListNode, val int) *ListNode { head = \u0026amp;ListNode{ Val: 0, Next: head, } for node := head; node.Next != nil; { if node.Next.Val == val { node.Next = node.Next.Next } else { node = node.Next } } head = head.Next return head } 复杂度 时间复杂度：O(N) 空间复杂度：O(1) ","date":"2021-06-05T22:26:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-203.-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/","title":"Leetcode 203. 移除链表元素"},{"content":"链接： https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n难度： 简单\n题目描述 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n图示两个链表在节点 c1 开始相交：\n题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构。\n示例1： 输入： intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出： Intersected at \u0026lsquo;8\u0026rsquo;\n解释： 相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n示例2： 输入： intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出： Intersected at \u0026lsquo;2\u0026rsquo;\n解释： 相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n示例3： 输入： intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出： null\n解释： 从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n提示： listA 中节点数目为 m listB 中节点数目为 n 0 \u0026lt;= m, n \u0026lt;= 3 * 104 1 \u0026lt;= Node.val \u0026lt;= 105 0 \u0026lt;= skipA \u0026lt;= m 0 \u0026lt;= skipB \u0026lt;= n 如果 listA 和 listB 没有交点，intersectVal 为 0 如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1] 进阶： 你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？\n解题思路 哈希 使用哈希表记录其中的一个链表结点，遍历另一个结点，在哈希表中查找该结点是否出现。\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode { hash := make(map[*ListNode]bool) for node := headA; node != nil; node = node.Next { hash[node] = true } for node := headB; node != nil; node = node.Next { if hash[node] { return node } } return nil } 复杂度 时间复杂度：$ O(N+M), N = len(List1), M = len(List2) $ 空间复杂度：$ O(N) $ 截断 两个链表相交，即尾部对齐，可以将较长的链表截断，使得两个链表的长度相同，就可以逐结点比较。\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode { // 记长 lenA := 0 for node := headA; node != nil; node = node.Next { lenA++ } lenB := 0 for node := headB; node != nil; node = node.Next { lenB++ } nodeA := headA nodeB := headB // 对齐 if lenA \u0026gt; lenB { for i := 0; i \u0026lt; lenA-lenB; i++ { nodeA = nodeA.Next } } else { for i := 0; i \u0026lt; lenB-lenA; i++ { nodeB = nodeB.Next } } // 比较 for ; nodeA != nil; nodeA, nodeB = nodeA.Next, nodeB.Next { if nodeA == nodeB { return nodeA } } return nil } 复杂度 时间复杂度：$ O(N+M), N = len(List1), M = len(List2) $ 空间复杂度：$ O(1) $ ","date":"2021-06-04T17:53:32+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-160.-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","title":"Leetcode 160. 相交链表"},{"content":"链接： https://leetcode-cn.com/problems/contiguous-array/\n难度： 中等\n题目描述 给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。\n示例1： 输入: nums = [0,1]\n输出: 2\n说明: [0, 1] 是具有相同数量0和1的最长连续子数组。\n示例2： 输入: nums = [0,1,0]\n输出: 2\n说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。\n示例3： 输入： nums = [23,2,6,4,7], k = 13\n输出： false\n提示： 1 \u0026lt;= nums.length \u0026lt;= 105 nums[i] 不是 0 就是 1 解题思路 前缀和+哈希 在一段区间内，对该段区间求和即可得出 1 的数量，用区间长度减去 1 的数量，就可以得到 0 的数量，可以用前缀和降低时间复杂度。\n又结果要求对 0 和 1 的数量相等，所以前缀和可以只记录0 和 1 的数量差，当两个前缀数组的和相同时，表示该段数组中0 和 1 的数量相等。原问题转化为在一个数组中找到两个相同的数，且距离相差最大。\n可以利用哈希表保存每个数最早出现的位置，直到找到相同的数，其距离必然为最大，判断是否满足条件即可。\n注意，对 0 需要特殊判断，可以预先在哈希表中存入其位置为 -1。\nfunc findMaxLength(nums []int) int { pos := map[int]int{ 0: -1, } sum := 0 max := 0 for i, num := range nums { if num == 0 { sum-- } else { sum++ } if p, ok := pos[sum]; ok { if max \u0026lt; (i - p) { max = i - p } } else { pos[sum] = i } } return max } 复杂度 时间复杂度：O(N) 空间复杂度：O(N) ","date":"2021-06-03T22:32:03+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-525.-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84/","title":"Leetcode 525. 连续数组"},{"content":"链接： https://leetcode-cn.com/problems/continuous-subarray-sum/\n难度： 中等\n题目描述 给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：\n子数组大小 至少为 2 ，且 子数组元素总和为 k 的倍数。 如果存在，返回 true ；否则，返回 false 。\n如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。\n示例1： 输入： nums = [23,2,4,6,7], k = 6\n输出： true\n解释： [2,4] 是一个大小为 2 的子数组，并且和为 6 。\n示例2： 输入： nums = [23,2,6,4,7], k = 6\n输出： true\n解释： [23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。\n42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。\n示例3： 输入： nums = [23,2,6,4,7], k = 13\n输出： false\n提示： 1 \u0026lt;= nums.length \u0026lt;= 105 0 \u0026lt;= nums[i] \u0026lt;= 109 0 \u0026lt;= sum(nums[i]) \u0026lt;= 231 - 1 1 \u0026lt;= k \u0026lt;= 231 - 1 解题思路 前缀和+哈希 要求解连续子区间的和，首先考虑利用前缀和来降低区间运算的复杂度，两个前缀数组和的差值是 k 的倍数即可。\n又结果要求对 k 取模为 0，所以前缀和可以只需保留对 k 取模的值，此时两个前缀数组的差值就变为了 0 ，原问题转化为在一个数组中找到两个相同的数，要求其距离大于 1。\n可以利用哈希表保存每个数最早出现的位置，直到找到相同的数，其距离必然为最大，判断是否满足条件即可。\n注意，对 0 需要特殊判断，可以预先在哈希表中存入其位置为 -1。\nfunc checkSubarraySum(nums []int, k int) bool { pos := map[int]int{ 0: -1, } sum := 0 for i := 0; i \u0026lt; len(nums); i++ { sum = (sum + nums[i]) % k if p, ok := pos[sum]; ok { if i-p \u0026gt; 1 { return true } } else { pos[sum] = i } } return false } 复杂度 时间复杂度：O(N) 空间复杂度：O(min(N,k)) ","date":"2021-06-02T22:51:40+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-523.-%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/","title":"Leetcode 523. 连续的子数组和"},{"content":"链接： https://leetcode-cn.com/problems/can-you-eat-your-favorite-candy-on-your-favorite-day/\n难度： 中等\n题目描述 给你一个下标从 0 开始的正整数数组 candiesCount ，其中 candiesCount[i] 表示你拥有的第 i 类糖果的数目。同时给你一个二维数组 queries ，其中 queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。\n你按照如下规则进行一场游戏：\n你从第 0 天开始吃糖果。 你在吃完 所有 第 i - 1 类糖果之前，不能 吃任何一颗第 i 类糖果。 在吃完所有糖果之前，你必须每天 至少 吃 一颗 糖果。 请你构建一个布尔型数组 answer ，满足 answer.length == queries.length 。answer[i] 为 true 的条件是：在每天吃 不超过 dailyCapi 颗糖果的前提下，你可以在第 favoriteDayi 天吃到第 favoriteTypei 类糖果；否则 answer[i] 为 false 。注意，只要满足上面 3 条规则中的第二条规则，你就可以在同一天吃不同类型的糖果。\n请你返回得到的数组 answer 。\n示例 1： 输入： candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]\n输出： [true,false,true]\n提示：\n1- 在第 0 天吃 2 颗糖果(类型 0），第 1 天吃 2 颗糖果（类型 0），第 2 天你可以吃到类型 0 的糖果。\n2- 每天你最多吃 4 颗糖果。即使第 0 天吃 4 颗糖果（类型 0），第 1 天吃 4 颗糖果（类型 0 和类型 1），你也没办法在第 2 天吃到类型 4 的糖果。换言之，你没法在每天吃 4 颗糖果的限制下在第 2 天吃到第 4 类糖果。\n3- 如果你每天吃 1 颗糖果，你可以在第 13 天吃到类型 2 的糖果。\n示例 2： 输入： candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]\n输出： [false,true,true,false,false]\n提示： 1 \u0026lt;= candiesCount.length \u0026lt;= 105 1 \u0026lt;= candiesCount[i] \u0026lt;= 105 1 \u0026lt;= queries.length \u0026lt;= 105 queries[i].length == 3 0 \u0026lt;= favoriteTypei \u0026lt; candiesCount.length 0 \u0026lt;= favoriteDayi \u0026lt;= 109 1 \u0026lt;= dailyCapi \u0026lt;= 109 解题思路 前缀和 据题意可知，每天可以吃的糖果数量在 1 ~ dailyCapi 之间，若想在第 favoriteDayi 天可以吃到第 favoriteTypei 类糖果，则必须将之前的类型全部吃完。\n从每天的可以吃的量可以推断出一个在第 favoriteDayi 天吃到糖果数量的一个范围，当该范围与小于等于第 favoriteTypei 类糖果的总量的范围有交集时，则可以吃到；否则不能。\n因每次获取的是当前种类之前的糖果总量，采用前缀和降低时间复杂度。\nfunc canEat(candiesCount []int, queries [][]int) []bool { sum := make([]int, len(candiesCount)) sum[0] = candiesCount[0] for i := 1; i \u0026lt; len(sum); i++ { sum[i] = sum[i-1] + candiesCount[i] } canEat := make([]bool, 0, len(queries)) for _, query := range queries { EatMin := query[1] + 1 EatMax := (query[1] + 1) * query[2] // 小于大的，大与小的有交集 if sum[query[0]] \u0026gt;= EatMin \u0026amp;\u0026amp; ((query[0] \u0026gt; 0 \u0026amp;\u0026amp; sum[query[0]-1] \u0026lt; EatMax) || query[0] == 0) { canEat = append(canEat, true) } else { canEat = append(canEat, false) } } return canEat } 复杂度 时间复杂度：$ O(N+Q), N = len(candiesCount), Q = len(queries) $ 空间复杂度：$ O(N) $ ","date":"2021-06-01T22:35:59+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1744.-%E4%BD%A0%E8%83%BD%E5%9C%A8%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E9%82%A3%E5%A4%A9%E5%90%83%E5%88%B0%E4%BD%A0%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E7%B3%96%E6%9E%9C%E5%90%97/","title":"Leetcode 1744. 你能在你最喜欢的那天吃到你最喜欢的糖果吗？"},{"content":"链接： https://leetcode-cn.com/problems/power-of-four/\n难度： 简单\n题目描述 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。\n整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x\n示例 1： 输入： n = 16\n输出： true\n示例 2： 输入： n = 5\n输出： false\n示例 3： 输入： n = 1\n输出： true\n提示： -231 \u0026lt;= n \u0026lt;= 231 - 1\u0026gt; 解题思路 二进制 2 的幂其二进制表示为最高位为 1，后跟偶数个 0 的数，每次向右移位两位，最终结果为 1，即说明是 4 的幂。\n另，4 的幂为非负数。\nfunc isPowerOfFour(n int) bool { for ; n \u0026gt; 0; n \u0026gt;\u0026gt;= 2 { if n == 1 { return true } else if n\u0026amp;3 != 0 { return false } } return false } 复杂度 时间复杂度：O(logB) 空间复杂度：O(1) ","date":"2021-05-31T22:42:12+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-342.-4%E7%9A%84%E5%B9%82/","title":"Leetcode 342. 4的幂"},{"content":"链接： https://leetcode-cn.com/problems/power-of-two/\n难度： 简单\n题目描述 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。\n如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。\n示例 1： 输入： n = 1\n输出： true\n解释： 20 = 1\n示例 2： 输入： n = 16\n输出： true\n解释： 24 = 16\n示例 3： 输入： n = 3\n输出： false\n示例 4： 输入： n = 4\n输出： true\n示例 5： 输入： n = 5\n输出： false\n提示： -231 \u0026lt;= n \u0026lt;= 231 - 1\u0026gt; 解题思路 二进制 2 的幂其二进制表示为最高位为 1，其余位为 0 的数，只有二进制位中 1 的数量是 1的数才满足条件。\n另，2 的幂为非负数。\nfunc isPowerOfTwo(n int) bool { cnt := 0 for ; n \u0026gt; 0; n \u0026gt;\u0026gt;= 1 { cnt += n \u0026amp; 1 } if cnt == 1 { return true } return false } 复杂度 时间复杂度：O(logB) 空间复杂度：O(1) 优化 利用lowbit算法，消除最小为的 1 ，所得结果为 0 即满足条件。\nfunc isPowerOfTwo(n int) bool { if n \u0026gt; 0 \u0026amp;\u0026amp; n\u0026amp;(n-1) == 0 { return true } return false } 复杂度 时间复杂度：O(1) 空间复杂度：O(1) ","date":"2021-05-30T11:06:34+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-231.-2-%E7%9A%84%E5%B9%82/","title":"Leetcode 231. 2 的幂"},{"content":"链接： https://leetcode-cn.com/problems/total-hamming-distance/\n难度： 中等\n题目描述 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。\n计算一个数组中，任意两个数之间汉明距离的总和。\n示例： 输入: x = 1, y = 4\n输出: 2\n解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）\n所以答案为：\nHammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.\n注意： 数组中元素的范围为从 0 到 109。 数组的长度不超过 104。 解题思路 按位计数 当一对数字某一位上的两个数字不同时，汉明距离的总和才会加一。故可以统计数组中相同位的 0 和 1 的数量，相乘可统计当前位的汉明距离和。\nfunc totalHammingDistance(nums []int) int { totalDistance := 0 for i := 1 \u0026lt;\u0026lt; 30; i \u0026gt; 0; i \u0026gt;\u0026gt;= 1 { ones := 0 zeros := 0 for _, num := range nums { if num\u0026amp;i == 0 { zeros++ } else { ones++ } } totalDistance += ones * zeros } return totalDistance } 复杂度 时间复杂度：O(N*B) 空间复杂度：O(1) ","date":"2021-05-28T17:37:15+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-477.-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/","title":"Leetcode 477. 汉明距离总和"},{"content":"链接： https://leetcode-cn.com/problems/hamming-distance/\n难度： 简单\n题目描述 两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。\n给出两个整数 x 和 y，计算它们之间的汉明距离。\n注意： 0 ≤ x, y \u0026lt; 231 示例： 输入: x = 1, y = 4\n输出: 2\n解释:\n1 (0 0 0 1)\n4 (0 1 0 0)\n↑ ↑\n上面的箭头指出了对应二进制位不同的位置。\n解题思路 异或 异或操作可以得出标记出两个数二进制位不同的位置，然后统计数量即可。\nfunc hammingDistance(x int, y int) int { distance := 0 for xor := x ^ y; xor != 0; xor \u0026gt;\u0026gt;= 1 { distance += xor \u0026amp; 1 } return distance } 复杂度 时间复杂度：O(logB) 空间复杂度：O(1) ","date":"2021-05-27T23:17:23+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-461.-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/","title":"Leetcode 461. 汉明距离"},{"content":"链接： https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/\n难度： 中等\n题目描述 给出一个字符串 s（仅含有小写英文字母和括号）。\n请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。\n注意，您的结果中 不应 包含任何括号。\n示例 1： 输入： s = \u0026ldquo;(abcd)\u0026rdquo;\n输出： \u0026ldquo;dcba\u0026rdquo;\n示例 2： 输入： s = \u0026ldquo;(u(love)i)\u0026rdquo;\n输出： \u0026ldquo;iloveu\u0026rdquo;\n示例 3： 输入： s = \u0026ldquo;(ed(et(oc))el)\u0026rdquo;\n输出： \u0026ldquo;leetcode\u0026rdquo;\n示例 4： 输入： s = \u0026ldquo;a(bcdefghijkl(mno)p)q\u0026rdquo;\n输出： \u0026ldquo;apmnolkjihgfedcbq\u0026rdquo;\n提示： 0 \u0026lt;= s.length \u0026lt;= 2000 s 中只有小写英文字母和括号 我们确保所有括号都是成对出现的 解题思路 栈 利用栈来进行每一次的反转：\n当遇到非 ) 时，入栈； 当遇到 ) 时，依次从栈中取出元素加入一个队列，直到取出 ( 时为止，再将队列中的元素全部入栈，即先完成了内层括号的反转。 依次执行上述逻辑，直到遍历到字符串结尾，栈中元素即为反转后的结果。\nfunc reverseParentheses(s string) string { stack := make([]byte, 0, len(s)) queue := make([]byte, 0, len(s)) for i := range s { if s[i] != \u0026#39;)\u0026#39; { stack = append(stack, s[i]) continue } queue = queue[:0] for j := len(stack) - 1; stack[j] != \u0026#39;(\u0026#39;; j-- { queue = append(queue, stack[j]) stack = stack[:len(stack)-1] } stack = stack[:len(stack)-1] stack = append(stack, queue...) } return string(stack) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(N^2) $ 跳跃 通过模拟可以发现，每次奇数层的括号内元素需要反转，而偶数内不需要。\n当遇到一个括号时，可以跳转到其对应的另一个括号处，并改变遍历方向，即完成了反转。最终遍历的结果即是答案。\nfunc reverseParentheses(s string) string { stack := make([]int, 0, len(s)) pair := make(map[int]int) for i := range s { switch s[i] { case \u0026#39;(\u0026#39;: stack = append(stack, i) case \u0026#39;)\u0026#39;: pair[i] = stack[len(stack)-1] pair[stack[len(stack)-1]] = i stack = stack[:len(stack)-1] } } res := make([]byte, 0, len(s)) step := 1 for i := 0; i \u0026lt; len(s); i += step { if s[i] == \u0026#39;(\u0026#39; || s[i] == \u0026#39;)\u0026#39; { step = -step i = pair[i] } else { res = append(res, s[i]) } } return string(res) } 复杂度 时间复杂度：$ O(N), N = len(s) $ 空间复杂度：$ O(N) $ ","date":"2021-05-26T23:59:13+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1190.-%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%90%E4%B8%B2/","title":"Leetcode 1190. 反转每对括号间的子串"},{"content":"链接： https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/\n难度： 困难\n题目描述 给你一个由非负整数组成的数组 nums 。另有一个查询数组 queries ，其中 queries[i] = [xi, mi] 。\n第 i 个查询的答案是 xi 和任何 nums 数组中不超过 mi 的元素按位异或（XOR）得到的最大值。换句话说，答案是 max(nums[j] XOR xi) ，其中所有 j 均满足 nums[j] \u0026lt;= mi 。如果 nums 中的所有元素都大于 mi，最终答案就是 -1 。\n返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。\n示例1： 输入： nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]\n输出： [3,3,7]\n解释：\n0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。 1 XOR 2 = 3. 5 XOR 2 = 7. 示例2： 输入： nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]\n输出： [15,-1,5]\n提示： 1 \u0026lt;= nums.length, queries.length \u0026lt;= 105 queries[i].length == 2 0 \u0026lt;= nums[j], xi, mi \u0026lt;= 109 解题思路 Trie树 同421题的思路，采用二进制形的形式，生成一个包含数组中所有数字的Trie树，通过贪心策略求解满足条件的那个最大值。\n因为对元素的取值范围有限制，所以每次需要判断代表 1 的路径能否可达，可以在每个节点记录通过当前路径的最小值，其与 mi 比较即可得到路径是否可达。\nfunc maximizeXor(nums []int, queries [][]int) []int { type Node struct { Left, Right *Node Min int } // 生成Trie数 root := new(Node) for _, num := range nums { node := root for bit := 1 \u0026lt;\u0026lt; 30; bit \u0026gt; 0; bit \u0026gt;\u0026gt;= 1 { if num\u0026amp;bit == 0 { if node.Left == nil { node.Left = \u0026amp;Node{ Left: nil, Right: nil, Min: num, } } node = node.Left if node.Min \u0026gt; num { node.Min = num } } else { if node.Right == nil { node.Right = \u0026amp;Node{ Left: nil, Right: nil, Min: num, } } node = node.Right if node.Min \u0026gt; num { node.Min = num } } } } res := make([]int, 0, len(queries)) // 求最大值 for _, query := range queries { node := root val := 0 for bit := 1 \u0026lt;\u0026lt; 30; bit \u0026gt; 0; bit \u0026gt;\u0026gt;= 1 { if query[0]\u0026amp;bit == 0 { // 优先取1 if node.Right != nil \u0026amp;\u0026amp; node.Right.Min \u0026lt;= query[1] { node = node.Right val += bit } else if node.Left != nil { node = node.Left } else { val = -1 break } } else { // 优先取0 if node.Left != nil { node = node.Left } else if node.Right != nil \u0026amp;\u0026amp; node.Right.Min \u0026lt;= query[1] { node = node.Right val += bit } else { val = -1 break } } } if val == -1 { res = append(res, -1) } else { res = append(res, query[0]^val) } } return res } 复杂度 时间复杂度：O(N*logB) 空间复杂度：O(N*logB) ","date":"2021-05-23T09:17:20+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1707.-%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/","title":"Leetcode 1707. 与数组中元素的最大异或值"},{"content":"链接： https://leetcode-cn.com/problems/uncrossed-lines/\n难度： 中等\n题目描述 在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。\n现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：\nnums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。\n以这种方法绘制线条，并返回可以绘制的最大连线数。\n示例 1： 输入： nums1 = [1,4,2], nums2 = [1,2,4]\n输出： 2\n解释： 可以画出两条不交叉的线，如上图所示。\n但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。\n示例 2： 输入： nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]\n输出： 3\n示例 3: 输入： nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]\n输出： 2\n提示： 1 \u0026lt;= nums1.length \u0026lt;= 500 1 \u0026lt;= nums2.length \u0026lt;= 500 1 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 2000 解题思路 动态规划 最长公共子序列的变种题目，其思路也相同，用动态规划解决。用 dp[i][j] 表示 nums1[0:i] 和 nums2[0:j] 两个子数组的最大连接数，状态转移方程如下：\n当 nums1[i] = nums2[j] 时，dp[i][j] = dp[i-1][j-1] + 1 当 nums1[i] != nums2[j] 时， dp[i][j] = max(dp[i-1][j], dp[i][j-1]) func maxUncrossedLines(nums1 []int, nums2 []int) int { dp := make([][]int, 0, len(nums1)+1) dp = append(dp, make([]int, len(nums2)+1)) for i := range nums1 { dp = append(dp, make([]int, len(nums2)+1)) for j := range nums2 { if nums1[i] == nums2[j] { dp[i+1][j+1] = dp[i][j] + 1 } else { if dp[i][j+1] \u0026gt; dp[i+1][j] { dp[i+1][j+1] = dp[i][j+1] } else { dp[i+1][j+1] = dp[i+1][j] } } } } return dp[len(nums1)][len(nums2)] } 复杂度 时间复杂度：$ O(NM), N = len(nums1), M = len(nums2) $ 空间复杂度：$ O(NM) $ ","date":"2021-05-21T23:42:03+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1035.-%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF/","title":"Leetcode 1035. 不相交的线"},{"content":"链接： https://leetcode-cn.com/problems/top-k-frequent-words/\n难度： 中等\n题目描述 给一非空的单词列表，返回前 k 个出现次数最多的单词。\n返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。\n示例 1： 输入: [\u0026ldquo;i\u0026rdquo;, \u0026ldquo;love\u0026rdquo;, \u0026ldquo;leetcode\u0026rdquo;, \u0026ldquo;i\u0026rdquo;, \u0026ldquo;love\u0026rdquo;, \u0026ldquo;coding\u0026rdquo;], k = 2\n输出: [\u0026ldquo;i\u0026rdquo;, \u0026ldquo;love\u0026rdquo;]\n解析: \u0026ldquo;i\u0026rdquo; 和 \u0026ldquo;love\u0026rdquo; 为出现次数最多的两个单词，均为2次。\n注意，按字母顺序 \u0026ldquo;i\u0026rdquo; 在 \u0026ldquo;love\u0026rdquo; 之前。\n示例 2： 输入: [\u0026ldquo;the\u0026rdquo;, \u0026ldquo;day\u0026rdquo;, \u0026ldquo;is\u0026rdquo;, \u0026ldquo;sunny\u0026rdquo;, \u0026ldquo;the\u0026rdquo;, \u0026ldquo;the\u0026rdquo;, \u0026ldquo;the\u0026rdquo;, \u0026ldquo;sunny\u0026rdquo;, \u0026ldquo;is\u0026rdquo;, \u0026ldquo;is\u0026rdquo;], k = 4\n输出: [\u0026ldquo;the\u0026rdquo;, \u0026ldquo;is\u0026rdquo;, \u0026ldquo;sunny\u0026rdquo;, \u0026ldquo;day\u0026rdquo;]\n解析: \u0026ldquo;the\u0026rdquo;, \u0026ldquo;is\u0026rdquo;, \u0026ldquo;sunny\u0026rdquo; 和 \u0026ldquo;day\u0026rdquo; 是出现次数最多的四个单词，\n出现次数依次为 4, 3, 2 和 1 次。\n注意： 假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。 输入的单词均由小写字母组成。 扩展联系： 尝试以 $O(nlog{k})$ 时间复杂度和 $O(n)$ 空间复杂度解决。 解题思路 哈希 遍历单词列表，记录每个单词的频率，然后经一次排序即可找出结果。\nfunc topKFrequent(words []string, k int) []string { wordsCnt := make(map[string]int) for _, word := range words { wordsCnt[word]++ } uniqWords := make([]string, 0, len(wordsCnt)) for k := range wordsCnt { uniqWords = append(uniqWords, k) } sort.Slice(uniqWords, func(i, j int) bool { if wordsCnt[uniqWords[i]] \u0026gt; wordsCnt[uniqWords[j]] { return true } else if wordsCnt[uniqWords[i]] \u0026lt; wordsCnt[uniqWords[j]] { return false } else { return uniqWords[i] \u0026lt; uniqWords[j] } }) return uniqWords[:k] } 复杂度 时间复杂度：$ O(N\\log{N}) $ 空间复杂度：$ O(N) $ ","date":"2021-05-20T21:45:44+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-692.-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/","title":"Leetcode 692. 前K个高频单词"},{"content":"链接： https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/\n难度： 中等\n题目描述 给你一个整数数组 arr 。\n现需要从数组中取三个下标 i、j 和 k ，其中 (0 \u0026lt;= i \u0026lt; j \u0026lt;= k \u0026lt; arr.length) 。\na 和 b 定义如下：\na = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1] b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k] 注意：^ 表示 按位异或 操作。 请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。\n示例1： 输入： arr = [2,3,1,6,7]\n输出： 4\n解释： 满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)\n示例 2： 输入： arr = [1,1,1,1,1]\n输出： 10\n示例 3： 输入： arr = [2,3]\n输出： 0\n示例 4： 输入： arr = [1,3,5,7,9]\n输出： 3\n示例 5： 输入： arr = [7,11,12,9,5,2,7,17,22]\n输出： 8\n提示： 1 \u0026lt;= arr.length \u0026lt;= 300 1 \u0026lt;= arr[i] \u0026lt;= 108 解题思路 暴力求解 枚举所有可能的 i、j 和 k ，求解所有符合条件的三元组数量。\nfunc countTriplets(arr []int) int { cnt := 0 for i := 0; i \u0026lt; len(arr); i++ { a := 0 for j := i + 1; j \u0026lt; len(arr); j++ { a ^= arr[j-1] b := 0 for k := j; k \u0026lt; len(arr); k++ { b ^= arr[k] if a == b { cnt++ } } } } return cnt } 复杂度 时间复杂度：O(N3) 空间复杂度：O(1) 异或性质 两个数异或为 0 ，则这两个数一定相等，反之亦然。\n可以利用此条性质，寻找一段异或为 0 的子数组，则以其中任意一点分割得到的两个子数组，其异或结果必然相等。\nfunc countTriplets(arr []int) int { cnt := 0 for i := 0; i \u0026lt; len(arr); i++ { a := arr[i] for j := i + 1; j \u0026lt; len(arr); j++ { a ^= arr[j] if a == 0 { cnt += j - i } } } return cnt } 复杂度 时间复杂度：O(N2) 空间复杂度：O(1) ​\n","date":"2021-05-18T22:40:57+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1442.-%E5%BD%A2%E6%88%90%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%88%96%E7%9B%B8%E7%AD%89%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE/","title":"Leetcode 1442. 形成两个异或相等数组的三元组数目"},{"content":"链接： https://leetcode-cn.com/problems/cousins-in-binary-tree/\n难度： 简单\n题目描述 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。\n如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。\n我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。\n只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。\n示例1： \u0026lt;img src=\u0026ldquo;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png\", width=\u0026ldquo;180px\u0026rdquo;\u0026gt;\n输入： root = [1,2,3,4], x = 4, y = 3\n输出： false\n示例2： \u0026lt;img src=\u0026ldquo;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png\", width=\u0026ldquo;201px\u0026rdquo;\u0026gt;\n输入： root = [1,2,3,null,4,null,5], x = 5, y = 4\n输出： true\n示例3： \u0026lt;img src=\u0026ldquo;https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png\", width=\u0026ldquo;156px\u0026rdquo;\u0026gt;\n输入： root = [1,2,3,null,4], x = 2, y = 3\n输出： false\n提示： 二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。 解题思路 搜索 记录两个结点的父节点和高度，然后比较即可。\nfunc isCousins(root *TreeNode, x int, y int) bool { parents := make([]int, 0, 2) heights := make([]int, 0, 2) var dfs func(*TreeNode, int, int) dfs = func(node *TreeNode, parent, height int) { if node == nil { return } if node.Val == x || node.Val == y { heights = append(heights, height) parents = append(parents, parent) } dfs(node.Left, node.Val, height+1) dfs(node.Right, node.Val, height+1) } dfs(root, 0, 1) if parents[0] != parents[1] \u0026amp;\u0026amp; heights[0] == heights[1] { return true } return false } 复杂度 时间复杂度：O(N) 空间复杂度：O(N) ","date":"2021-05-17T09:29:10+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-993.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9/","title":"Leetcode 993. 二叉树的堂兄弟节点"},{"content":"链接： https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/\n难度： 中等\n题目描述 给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j \u0026lt; n 。\n进阶： 你可以在 O(n) 的时间解决这个问题吗？\n示例1： 输入： nums = [3,10,5,25,2,8]\n输出： 28\n解释： 最大运算结果是 5 XOR 25 = 28.\n示例2： 输入： nums = [0]\n输出： 0\n示例3： 输入： nums = [2,4]\n输出： 6\n示例4： 输入： nums = [8,10,2]\n输出： 10\n示例5： 输入： nums = [14,70,53,83,49,91,36,80,92,51,66,70]\n输出： 127\n提示： 1 \u0026lt;= nums.length \u0026lt;= 2 * 104 0 \u0026lt;= nums[i] \u0026lt;= 232 - 1 解题思路 暴力求解 枚举所有的 i 和 j，求解比较得出最大值。\nfunc findMaximumXOR(nums []int) int { max := 0 for i := range nums { for j := i + 1; j \u0026lt; len(nums); j++ { t := nums[i] ^ nums[j] if max \u0026lt; t { max = t } } } return max } 复杂度 时间复杂度：O(N2) 空间复杂度：O(1) Trie树 采用二进制形的形式，生成一个包含数组中所有数字的Trie树，通过贪心策略可以得到与某个数异或最大值。依次枚举每一个数，即可得到全局最大值。\nfunc findMaximumXOR(nums []int) int { type Node struct { Left, Right *Node } // 生成Trie数 root := new(Node) for _, num := range nums { node := root for bit := 1 \u0026lt;\u0026lt; 30; bit \u0026gt; 0; bit \u0026gt;\u0026gt;= 1 { if num\u0026amp;bit == 0 { if node.Left == nil { node.Left = new(Node) } node = node.Left } else { if node.Right == nil { node.Right = new(Node) } node = node.Right } } } // 求最大值 max := 0 for _, num := range nums { node := root localMax := 0 for bit := 1 \u0026lt;\u0026lt; 30; bit \u0026gt; 0; bit \u0026gt;\u0026gt;= 1 { if num\u0026amp;bit == 0 { if node.Right != nil { node = node.Right localMax += bit } else { node = node.Left } } else { if node.Left != nil { node = node.Left localMax += bit } else { node = node.Right } } } if max \u0026lt; localMax { max = localMax } } return max } 复杂度 时间复杂度：O(N*logB) 空间复杂度：O(N*logB) ","date":"2021-05-16T22:31:57+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-421.-%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/","title":"Leetcode 421. 数组中两个数的最大异或值"},{"content":"链接： https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/\n难度： 困难\n题目描述 有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。\n每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。\n给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。\n由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。\n示例 1： 输入： steps = 3, arrLen = 2\n输出： 4\n解释： 3 步后，总共有 4 种不同的方法可以停在索引 0 处。\n向右，向左，不动\n不动，向右，向左\n向右，不动，向左\n不动，不动，不动\n示例 2： 输入： steps = 2, arrLen = 4\n输出： 2\n解释： 2 步后，总共有 2 种不同的方法可以停在索引 0 处。\n向右，向左\n不动，不动\n示例 3： 输入： steps = 4, arrLen = 2\n输出： 8\n提示： 1 \u0026lt;= steps \u0026lt;= 500 1 \u0026lt;= arrLen \u0026lt;= 10^6 解题思路 动态规划 由于方案数量很多，记录中间结果并重复使用将有效的降低时间复杂度，考虑用动态规划求解。\n用 dp[i][j] 表示指针移动 i 次到达下标 j 的方案数量，其来源分为三部分：\n上一步到达下标 j-1 处，此时移动了 i-1 次， 上一步已经到达 j 处，移动了 i-1 次 上一步到达 j+1 处，移动了 i-1 次 根据以上情况得到状态转移方程： dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1]，随即可得出结果。\nfunc numWays(steps int, arrLen int) int { const MOD = 1_000_000_007 far := steps + 1 if far \u0026gt; arrLen { far = arrLen } dp := make([][]int, steps) // 计算到i-1步为止 dp[0] = make([]int, far) // 移动0次 dp[0][0] = 1 // 初始在0 for i := 1; i \u0026lt; cap(dp); i++ { dp[i] = make([]int, 0, far) for j := 0; j \u0026lt; far; j++ { t := dp[i-1][j] if j == 0 { // 左边越界 t = (t + dp[i-1][j+1]) % MOD } else if j == far-1 { // 右边越界 t = (t + dp[i-1][j-1]) % MOD } else { t = ((t+dp[i-1][j-1])%MOD + dp[i-1][j+1]) % MOD } dp[i] = append(dp[i], t) } } res := dp[steps-1][0] if arrLen \u0026gt; 1 { res = (res + dp[steps-1][1]) % MOD } return res } 复杂度 时间复杂度：$ O(steps*min(steps, arrLen)) $ 空间复杂度：$ O(steps*min(steps, arrLen)) $ 优化 由于下一行的状态转移计算仅依赖于上一行，所以可以仅用一个数组，降低空间复杂度\nfunc numWays(steps int, arrLen int) int { const MOD = 1_000_000_007 far := steps + 1 if far \u0026gt; arrLen { far = arrLen } dp := make([]int, far) // 移动0次 dp[0] = 1 // 初始在0 for i := 1; i \u0026lt; steps; i++ { last := dp[0] for j := 0; j \u0026lt; far; j++ { t := dp[j] if j == 0 { // 左边越界 t = (t + dp[j+1]) % MOD } else if j == far-1 { // 右边越界 t = (t + last) % MOD } else { t = ((t+last)%MOD + dp[j+1]) % MOD } last = dp[j] dp[j] = t } } res := dp[0] if arrLen \u0026gt; 1 { res = (res + dp[1]) % MOD } return res } 复杂度 时间复杂度：$ O(steps*min(steps, arrLen)) $ 空间复杂度：$ O(min(steps, arrLen)) $ ","date":"2021-05-13T23:12:12+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1269.-%E5%81%9C%E5%9C%A8%E5%8E%9F%E5%9C%B0%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/","title":"Leetcode 1269. 停在原地的方案数"},{"content":"链接： https://leetcode-cn.com/problems/xor-queries-of-a-subarray/\n难度： 中等\n题目描述 有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]。\n对于每个查询 i，请你计算从 Li 到 Ri 的 XOR 值（即 arr[Li] xor arr[Li+1] xor ... xor arr[Ri]）作为本次查询的结果。\n并返回一个包含给定查询 queries 所有结果的数组。\n示例 1： 输入： arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]\n输出： [2,7,14,8]\n解释：\n数组中元素的二进制表示形式是：\n1 = 0001\n3 = 0011\n4 = 0100\n8 = 1000\n查询的 XOR 值为：\n[0,1] = 1 xor 3 = 2\n[1,2] = 3 xor 4 = 7\n[0,3] = 1 xor 3 xor 4 xor 8 = 14\n[3,3] = 8\n示例 2： 输入： arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]\n输出： [8,0,4,4]\n提示： 1 \u0026lt;= arr.length \u0026lt;= 3 * 104 1 \u0026lt;= arr[i] \u0026lt;= 109 1 \u0026lt;= queries.length \u0026lt;= 3 * 104 queries[i].length == 2 0 \u0026lt;= queries[i][0] \u0026lt;= queries[i][1] \u0026lt; arr.length 解题思路 暴力 依照题意，直接对查询下标范围内的所有数进行异或运算。\nfunc xorQueries(arr []int, queries [][]int) []int { res := make([]int, 0, len(queries)) for _, query := range queries { t := 0 for i := query[0]; i \u0026lt;= query[1]; i++ { t ^= arr[i] } res = append(res, t) } return res } 复杂度 时间复杂度：$ O(N_1*N_2), N_1 = len(arr), N_2 = len $ 空间复杂度：$ O(1) $ 消除 利用异或运算的 自反性，记录前缀数组的异或值，然后通过异或操作对前缀数组的值进行消除，即可以 O(1) 的时间求得结果。\nfunc xorQueries(arr []int, queries [][]int) []int { xor := make([]int, 0, len(arr)+1) xor = append(xor, 0) for i := 0; i \u0026lt; len(arr); i++ { xor = append(xor, xor[i]^arr[i]) } res := make([]int, 0, len(queries)) for _, query := range queries { res = append(res, xor[query[0]]^xor[query[1]+1]) } return res } 复杂度 时间复杂度：$ O(N_1*N_2), N_1 = len(arr), N_2 = len(queries) $ 空间复杂度：$ O(N_1) $ ","date":"2021-05-12T23:14:18+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1310.-%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2/","title":"Leetcode 1310. 子数组异或查询"},{"content":"链接： https://leetcode-cn.com/problems/decode-xored-permutation/\n难度： 中等\n题目描述 给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。\n它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足 encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，那么 encoded = [2,1] 。\n给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。\n示例1： 输入： encoded = [3,1]\n输出： [1,2,3]\n解释： 如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]\n示例2： 输入： encoded = [6,5,4,6]\n输出： [2,4,1,5,3]\n提示： 3 \u0026lt;= n \u0026lt; 105 n 是奇数。 encoded.length == n - 1 解题思路 消除 有题意可知，只要知道原数组 perm 的一个元素，就可以推导得出整个数组，而原数组的所有元素均已知，所以可以求得所有元素的异或值 1⊕2⊕…⊕n。\n由 encoded[i] = perm[i]⊕[i+1] 且 n为奇数，可以进一步得到 perm[1]⊕perm[2]⊕…⊕perm[n-1] = encoded[1]⊕encoded[3]⊕...⊕encoded[n-2]。\n将上述两个结果异或即可消除除 perm[0] 外的所有值，然后就可以推导 perm 了\nfunc decode(encoded []int) []int { perm := make([]int, 0, len(encoded)+1) tmp := 0 for i := 1; i \u0026lt;= cap(perm); i++ { tmp ^= i } for i := 1; i \u0026lt; len(encoded); i += 2 { tmp ^= encoded[i] } perm = append(perm, tmp) for i := range encoded { perm = append(perm, perm[i]^encoded[i]) } return perm } 复杂度 时间复杂度：O(N) 空间复杂度：O(1) ","date":"2021-05-11T19:55:25+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1734.-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97/","title":"Leetcode 1734. 解码异或后的排列"},{"content":"链接： https://leetcode-cn.com/problems/leaf-similar-trees/\n难度： 简单\n题目描述 请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。\n举个例子，如上图所示，给定一棵叶值序列为 (6, 7, 4, 9, 8) 的树。\n如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。\n如果给定的两个根结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。\n示例 1： 输入： root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\n输出： true\n示例 2： 输入： root1 = [1], root2 = [1]\n输出： true\n示例 3： 输入： root1 = [1], root2 = [2]\n输出： false\n示例 4： 输入： root1 = [1,2], root2 = [2,2]\n输出： true\n示例 5： \u0026lt;img src=\u0026ldquo;https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg\", width=\u0026ldquo;450px\u0026rdquo;\u0026gt;\n输入： root1 = [1,2,3], root2 = [1,3,2]\n输出： false\n提示： 给定的两棵树可能会有 1 到 200 个结点。 给定的两棵树上的值介于 0 到 200 之间。 解题思路 直接求解 分别求出两棵树的叶值序列，然后逐一进行比较即可。\nfunc leafSimilar(root1 *TreeNode, root2 *TreeNode) bool { var dfs func(node *TreeNode, leafs *[]int) dfs = func(node *TreeNode, leafs *[]int) { fmt.Println(node.Val) if node.Left == nil \u0026amp;\u0026amp; node.Right == nil { *leafs = append(*leafs, node.Val) } else { if node.Left != nil { dfs(node.Left, leafs) } if node.Right != nil { dfs(node.Right, leafs) } } } leafs1 := make([]int, 0, 100) dfs(root1, \u0026amp;leafs1) leafs2 := make([]int, 0, 100) dfs(root2, \u0026amp;leafs2) if len(leafs1) != len(leafs2) { return false } for i := range leafs1 { if leafs1[i] != leafs2[i] { return false } } return true } 复杂度 时间复杂度：$ O(N_1+N_2), N_1 = size(Tree1), N_2 = size(Tree2) $ 空间复杂度：$ O(N_1+N_2) $ ","date":"2021-05-10T23:30:50+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-872.-%E5%8F%B6%E5%AD%90%E7%9B%B8%E4%BC%BC%E7%9A%84%E6%A0%91/","title":"Leetcode 872. 叶子相似的树"},{"content":"链接： https://leetcode-cn.com/problems/xor-operation-in-an-array/\n难度： 简单\n题目描述 给你两个整数，n 和 start 。\n数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。\n请返回 nums 中所有元素按位异或（XOR）后得到的结果。\n示例1： 输入： n = 5, start = 0\n输出： 8\n解释： 数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。\n\u0026ldquo;^\u0026rdquo; 为按位异或 XOR 运算符。\n示例2： 输入： n = 4, start = 3\n输出： 8\n解释： 数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8.\n示例3： 输入： n = 1, start = 7\n输出： 7\n示例4： 输入： n = 10, start = 5\n输出： 2\n提示： 1 \u0026lt;= n \u0026lt;= 1000 0 \u0026lt;= start \u0026lt;= 1000 n == nums.length 解题思路 模拟 按照数组生成方式生成数组，然后依次异或求解，由于每个元素只用依次，所以可以省略掉数组空间\nfunc xorOperation(n int, start int) int { res := 0 for i := 0; i \u0026lt; n; i++ { res ^= start + i\u0026lt;\u0026lt;1 } return res } 复杂度 时间复杂度：O(N) 空间复杂度：O(1) ","date":"2021-05-07T17:05:42+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1486.-%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%93%8D%E4%BD%9C/","title":"Leetcode 1486. 数组异或操作"},{"content":"链接： https://leetcode-cn.com/problems/decode-xored-array/\n难度： 中等\n题目描述 未知 整数数组 arr 由 n 个非负整数组成。\n经编码后变为长度为 n - 1 的另一个整数数组 encoded ，其中 encoded[i] = arr[i] XOR arr[i + 1] 。例如，arr = [1,0,2,1] 经编码后得到 encoded = [1,2,3] 。\n给你编码后的数组 encoded 和原数组 arr 的第一个元素 first（arr[0]）。\n请解码返回原数组 arr 。可以证明答案存在并且是唯一的。\n示例 1： 输入： encoded = [1,2,3], first = 1\n输出： [1,0,2,1]\n解释： 若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]\n示例 2： 输入： encoded = [6,2,7,3], first = 4\n输出： [4,2,0,7,4]\n提示： 2 \u0026lt;= n \u0026lt;= 104 encoded.length == n - 1 0 \u0026lt;= encoded[i] \u0026lt;= 105 0 \u0026lt;= first \u0026lt;= 105 解题思路 数学 a b a⊕b 0 0 0 0 1 1 1 0 1 1 1 0 通过上表可以推出: a = b ⊕ a⊕b，从而得到推导方程：arr[i+1] = arr[i] ⊕ encoded[i] func decode(encoded []int, first int) []int { res := make([]int, 0, len(encoded)+1) res = append(res, first) for i, e := range encoded { res = append(res, res[i] ^ e) } return res } 复杂度 时间复杂度：$ O(N), N = len(encoded) $ 空间复杂度：$ O(1) $ ","date":"2021-05-06T23:09:07+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1720.-%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%95%B0%E7%BB%84/","title":"Leetcode 1720. 解码异或后的数组"},{"content":"链接： https://leetcode-cn.com/problems/delete-and-earn/\n难度： 中等\n题目描述 给你一个整数数组 nums ，你可以对它进行一些操作。\n每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。\n开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。\n示例1： 输入： nums = [3,4,2]\n输出： 6\n解释： 删除 4 获得 4 个点数，因此 3 也被删除。\n之后，删除 2 获得 2 个点数。总共获得 6 个点数。\n示例2： 输入： nums = [2,2,3,3,3,4]\n输出： 9\n解释： 删除 3 获得 3 个点数，接着要删除两个 2 和 4 。\n之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。\n总共获得 9 个点数。\n提示： 1 \u0026lt;= nums.length \u0026lt;= 2 * 104 1 \u0026lt;= nums[i] \u0026lt;= 104 解题思路 动态规划 典型的求最优解的问题，考虑用动态规划求解。\n当要删除一个数字 i 时，需将删除所有的 i 全部从数组中删除，记其数量为 cnt, 同时可以获得点数 i * cnt，将删除每个数获得的点数用 map 记录下来。\n用 dp[i] 表示在数组中，当前满足所有的数字均小于时的最大点数，则容易得到转移方程：\ndp[0] = 0, dp[1] = map[i] dp[i] = max(dp[i-1], dp[i-2]+map[i]) 执行到整个数组的最大值时为止，得到最大点数。\nfunc deleteAndEarn(nums []int) int { maxNum := 0 cnt := make(map[int]int) for _, num := range nums { cnt[num]++ if maxNum \u0026lt; num { maxNum = num } } dp := make([]int, maxNum+1) dp[1] = cnt[1] for i := 2; i \u0026lt;= maxNum; i++ { dp[i] = dp[i-2] + cnt[i]*i if dp[i] \u0026lt; dp[i-1] { dp[i] = dp[i-1] } } return dp[maxNum] } 复杂度 时间复杂度：O(max(num[i])) 空间复杂度：O(N) ","date":"2021-05-05T23:47:15+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-740.-%E5%88%A0%E9%99%A4%E5%B9%B6%E8%8E%B7%E5%BE%97%E7%82%B9%E6%95%B0/","title":"Leetcode 740. 删除并获得点数"},{"content":"链接： https://leetcode-cn.com/problems/reverse-integer/\n难度： 简单\n题目描述 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。\n如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。\n假设环境不允许存储 64 位整数（有符号或无符号）。\n示例1： 输入： x = 123\n输出： 321\n示例2： 输入： x = -123\n输出： -321\n示例3： 输入： x = 120\n输出： 21\n示例4： 输入： x = 0\n输出： 0\n提示： -231 \u0026lt;= x \u0026lt;= 231 - 14 解题思路 双指针 直接数字逐位反转，当数字为十位数时，32位整数无法存储，需要做一次溢位判断：\n可以将数字分为前9位数与第10位数进行比较，不再临界值的范围内，说明溢出。\nfunc reverse(x int) int { res := 0 for i := 0; x != 0 \u0026amp;\u0026amp; i \u0026lt; 9; i++ { res = res*10 + x%10 x /= 10 } if x != 0 { if (x \u0026gt; 0 \u0026amp;\u0026amp; (res \u0026gt; math.MaxInt32/10 || (res == math.MaxInt32/10 \u0026amp;\u0026amp; x \u0026gt; math.MaxInt32%10))) || (x \u0026lt; 0 \u0026amp;\u0026amp; (res \u0026lt; math.MinInt32/10 || (res == math.MinInt32/10 \u0026amp;\u0026amp; x \u0026lt; math.MinInt32%10))) { res = 0 } else { res = res*10 + x } } return res } 复杂度 时间复杂度：O(logB) 空间复杂度：O(1) ","date":"2021-05-03T11:57:39+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-7.-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","title":"Leetcode 7. 整数反转"},{"content":"链接： https://leetcode-cn.com/problems/brick-wall/\n难度： 中等\n题目描述 你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和应该相等。\n你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。\n给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。\n示例1： \u0026lt;img src=\u0026ldquo;https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg\", width=\u0026ldquo;493px\u0026rdquo;\u0026gt;\n输入： wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]\n输出： 2\n示例2： 输入： wall = [[1],[1],[1]]\n输出： 3\n提示： n == wall.length 1 \u0026lt;= n \u0026lt;= 104 1 \u0026lt;= wall[i].length \u0026lt;= 104 1 \u0026lt;= sum(wall[i].length) \u0026lt;= 2 * 104 对于每一行 i ，sum(wall[i]) 应当是相同的 1 \u0026lt;= wall[i][j] \u0026lt;= 231 - 1 解题思路 计数 以每一行起点为 0 坐标，可以使得同一列的缝隙唯一标识，从而标记出所有缝隙的列坐标。\n统计每一列的缝隙出现次数，找出出现最多的缝隙，即可求得最小穿过砖块数量。\nfunc leastBricks(wall [][]int) int { gapCnt := make(map[int]int) for _, bricks := range wall { gap := 0 l := len(bricks) - 1 for i := 0; i \u0026lt; l; i++ { gap += bricks[i] gapCnt[gap]++ } } maxGaps := 0 for _, v := range gapCnt { if maxGaps \u0026lt; v { maxGaps = v } } return len(wall) - maxGaps } 复杂度 时间复杂度：O(M*N) 空间复杂度：O(M*N) ","date":"2021-05-02T10:03:17+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-554.-%E7%A0%96%E5%A2%99/","title":"Leetcode 554. 砖墙"},{"content":"链接： https://leetcode-cn.com/problems/employee-importance/\n难度： 简单\n题目描述 给定一个保存员工信息的数据结构，它包含了员工 唯一的 id ，重要度 和 直系下属的 id 。\n比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 并不是直系 下属，因此没有体现在员工 1 的数据结构中。\n现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。\n示例： 输入： [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1\n输出： 11\n解释： 员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。\n提示： 一个员工最多有一个 直系 领导，但是可以有多个 直系 下属 员工数量不超过 2000 解题思路 深度优先搜素 很容易可以看出整个的员工体系是一个树状结构，故可以采用深度优先搜索的策略，对某一员工及其下属逐一求和。\n为能快速定位到某一个员工，另使用一个 map 维护员工id到员工信息的映射。\nfunc getImportance(employees []*Employee, id int) int { m := make(map[int]*Employee) for _, e := range employees { m[e.Id] = e } var dfs func(id int) int dfs = func(id int) int { e, ok := m[id] if !ok { return 0 } sum := e.Importance for _, s := range e.Subordinates { sum += dfs(s) } return sum } return dfs(id) } 复杂度 时间复杂度：O(N) 空间复杂度：O(N) ","date":"2021-05-01T21:20:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-690.-%E5%91%98%E5%B7%A5%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7/","title":"Leetcode 690. 员工的重要性"},{"content":"链接： https://leetcode-cn.com/problems/single-number-ii/\n难度： 中等\n题目描述 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。\n示例1： 输入： nums = [2,2,3,2] 输出： 3\n示例2： 输入： nums = [0,1,0,1,0,1,99] 输出： 99\n提示： 1 \u0026lt;= nums.length \u0026lt;= 3 * 104 -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 进阶： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？\n解题思路 哈希 统计每个数出现的次数，然后找出其中只出现一次的数\nfunc singleNumber(nums []int) int { cnt := make(map[int]int) for _, num := range nums { cnt[num]++ } for k, v := range cnt { if v == 1 { return k } } return 0 } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(N) $ 排序 将整个数组排序，没三个一组进行首尾比较，相同继续，不同返回。\nfunc singleNumber(nums []int) int { sort.Ints(nums) res := nums[0] for i := 2; i \u0026lt; len(nums); i += 3 { if res == nums[i] { res = nums[i+1] continue } else { break } } return res } 复杂度 时间复杂度：$ O(NlogN), N = len(nums) $ 空间复杂度：$ O(\\log{N}) $ 位运算 统计每一位的数字总和，其必然是 0 或者 3n+1，在统计过程中就可以逢3清零，依次求解下去即可。 考虑用两个位 a, b 记录求和数据，表如下所示:\ncur num next 00 0 00 00 1 01 01 0 01 01 1 10 10 0 10 10 1 00 根据上表可推导出 a 和 b 的变换表：\na b x new_a 0 0 0 0 0 0 1 0 0 1 0 0 0 1 1 1 1 0 0 1 1 0 1 0 得到a的转移方程： new_a = a'bx + ab'x'\nb a x new_b 0 0 0 0 0 0 1 1 0 1 0 0 0 1 1 0 1 0 0 1 1 0 1 0 得到b的转移方程： new_b = a'b'x + a'bx' = a'(b'x+bx') = a'(b⊕x)\nfunc singleNumber(nums []int) int { a, b := 0, 0 for _, x := range nums { t := ^a\u0026amp;b\u0026amp;x | a\u0026amp;^b\u0026amp;^x b = ^a \u0026amp; (b ^ x) a = t } return b } 复杂度 时间复杂度：$ O(N), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-04-30T18:18:49+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-137.-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-ii/","title":"Leetcode 137. 只出现一次的数字 II"},{"content":"链接： https://leetcode-cn.com/problems/frog-jump/\n难度： 困难\n题目描述 一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。\n给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。\n开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。\n如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。\n示例1： 输入： stones = [0,1,3,5,6,8,12,17]\n输出： true\n解释： 青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。\n示例2： 输入： stones = [0,1,2,3,4,8,9,11]\n输出： false\n解释： 这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。\n提示： 2 \u0026lt;= stones.length \u0026lt;= 2000 0 \u0026lt;= stones[i] \u0026lt;= 231-1 stones[0] == 0 解题思路 动态规划 从题意可以看出，青蛙每次从某块石头开始起跳，可以降落到一个范围 [k-1 k+1], k 表示上一次的跳跃步长。由于每次跳跃都依赖于前一次跳跃的步长，考虑用动态规划实现。 dp[i] 记录所有可以跳跃到第 i 个石头上面的步长集合，之后就可以根据该集合，向后推导下一跳：\n针对 dp[i] 的每一个步长 step，当 step-1 \u0026lt;= stones[j]-stones[i] \u0026lt;= step+1, (j \u0026gt; i, k∈dp[i]) 时，将步长 stones[j]-stones[i] 添加进 dp[j]\ndp[len-1] 不是空集合，说明能找到，返回 true；否则找不到返回 false\nfunc canCross(stones []int) bool { dp := make([]map[int]bool, len(stones)) dp[0] = map[int]bool{0: true} for i := 0; i \u0026lt; len(stones); i++ { for step := range dp[i] { for j := i + 1; j \u0026lt; len(stones) \u0026amp;\u0026amp; stones[j]-stones[i] \u0026lt;= step+1; j++ { if stones[j]-stones[i] \u0026gt;= step-1 { if dp[j] == nil { dp[j] = make(map[int]bool) } dp[j][stones[j]-stones[i]] = true } } } } if len(dp[len(stones)-1]) != 0 { return true } return false } 复杂度 时间复杂度：O(N2) 空间复杂度：O(N2) ","date":"2021-04-29T14:21:06+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-403.-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3/","title":"Leetcode 403. 青蛙过河"},{"content":"链接： https://leetcode-cn.com/problems/sum-of-square-numbers/\n难度： 中等\n题目描述 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。\n示例 1： 输入： c = 5\n输出： true\n解释： 1 * 1 + 2 * 2 = 5\n示例 2： 输入： c = 3\n输出： false\n示例 3： 输入： c = 4\n输出： true\n示例 4： 输入： c = 2\n输出： true\n示例 5： 输入： c = 1 输出： true\n提示： 0 \u0026lt;= c \u0026lt;= 231 - 1 解题思路 打表 维护一个保存所有平方数的 map，然后从0开始枚举所有可能是 a 的情况，寻找 b = c-a2 是否存在于 map 中\nvar exist = make(map[int]bool) func init() { for i := 0; i*i \u0026lt; math.MaxInt32; i++ { exist[i*i] = true } } func judgeSquareSum(c int) bool { for i := 0; i*i \u0026lt;= c; i++ { if exist[c-i*i] { return true } } return false } 复杂度 时间复杂度：$ O(\\sqrt{c}) $ 空间复杂度：$ O(\\sqrt{N}) $ 开方 枚举所有可能是 a 的情况，然后对 b = c-a2 开放，判断开方后的结果是否为整数即可\nfunc judgeSquareSum(c int) bool { for i := 0; i*i \u0026lt;= c; i++ { t := math.Sqrt(float64(c - i*i)) if i*i+int(t)*int(t) == c { return true } } return false } 复杂度 时间复杂度：$ O(\\sqrt{c}) $ 空间复杂度：$ O(1) $ 双指针 用 i, j(i \u0026lt; j) 表示两个指针，向中间遍历，初始 i = 0, j = √c\n当 i*i + j*j == c 时，返回 true; 当 i*i + j*j \u0026lt; c 时， i++; 当 i*i + j*j \u0026gt; c 时， j--; 直到 i \u0026gt; j 时，依然未能找到 a, b，返回 false\nfunc judgeSquareSum(c int) bool { for i := 0, j := int(); i*i \u0026lt;= c; i++ { t := math.Sqrt(float64(c - i*i)) if i*i+int(t)*int(t) == c { return true } } return false } 复杂度 时间复杂度：$ O(\\sqrt{c}) $ 空间复杂度：$ O(1) $ ","date":"2021-04-28T22:46:56+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-633.-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C/","title":"Leetcode 633. 平方数之和"},{"content":"链接： https://leetcode-cn.com/problems/range-sum-of-bst/\n难度： 简单\n题目描述 给定二叉搜索树的根结点 root，返回值位于范围 [low, high] 之间的所有结点的值的和。\n示例 1： 输入： root = [10,5,15,3,7,null,18], low = 7, high = 15\n输出： 32\n示例 2： 输入： root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\n输出： 23\n提示： 树中节点数目在范围 [1, 2 * 104] 内 1 \u0026lt;= Node.val \u0026lt;= 105 1 \u0026lt;= low \u0026lt;= high \u0026lt;= 105 所有 Node.val 互不相同 解题思路 深度优先搜索 不同于一般搜索树的搜索，该搜索需要遍历整颗树，以累计求和，必要部分需要剪枝加快遍历速度。\n搜索时需要区分三种情况：\n当前结点值 val \u0026lt; low 时，左子树均不满足条件，继续搜索右子树； 当前结点值 val \u0026gt; high 时，右子树均不满足条件，继续搜索左子树； 其余情况，累加当前结点值，无法剪枝，左右子树都需要继续搜索。 func rangeSumBST(root *TreeNode, low int, high int) int { sum := 0 var search func(node *TreeNode) search = func(node *TreeNode) { if node == nil { return } if node.Val \u0026lt; low { search(node.Right) } else if node.Val \u0026gt; high { search(node.Left) } else { sum += node.Val search(node.Left) search(node.Right) } } search(root) return sum } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(1) $ ","date":"2021-04-27T10:31:11+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-938.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C/","title":"Leetcode 938. 二叉搜索树的范围和"},{"content":"链接： https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/\n难度： 中等\n题目描述 传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。\n传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。\n返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。\n示例 1： 输入： weights = [1,2,3,4,5,6,7,8,9,10], D = 5\n输出： 15\n解释：\n船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：\n第 1 天：1, 2, 3, 4, 5\n第 2 天：6, 7\n第 3 天：8\n第 4 天：9\n第 5 天：10\n请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。\n示例 2： 输入： weights = [3,2,2,4,1,4], D = 3\n输出： 6\n解释：\n船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：\n第 1 天：3, 2\n第 2 天：2, 4\n第 3 天：1, 4\n示例 3： 输入： weights = [1,2,3,1,1], D = 4\n输出： 3\n解释：\n第 1 天：1\n第 2 天：2\n第 3 天：3\n第 4 天：1, 1\n提示： 1 \u0026lt;= D \u0026lt;= weights.length \u0026lt;= 50000 1 \u0026lt;= weights[i] \u0026lt;= 500 解题思路 暴力求解 将货物总重量的 平均数 和 最重货物 较大的一个重量作为初始的载重量，逐一向上累加，求得首次符合条件的结果。\nfunc shipWithinDays(weights []int, D int) int { sum := 0 max := 0 for _, weight := range weights { sum += weight if max \u0026lt; weight { max = weight } } minCap := sum / len(weights) if sum%len(weights) != 0 { minCap++ } if minCap \u0026lt; max { minCap = max } for { curCap := minCap // 当前容量 cnt := 1 // 第几天 i := 0 // 装到第几箱货物 for i \u0026lt; len(weights) \u0026amp;\u0026amp; cnt \u0026lt;= D { // 能装入，继续 if curCap \u0026gt;= weights[i] { curCap -= weights[i] i++ continue } // 不能装入，等第二天 cnt++ curCap = minCap } // 装完 if i == len(weights) { return minCap } minCap++ } } 复杂度 时间复杂度：O(N*∑weight) 空间复杂度：O(1) 二分查找 将 最重货物重量 l 和 货物的总重量 r 作为二分查找的两端起始点，进行二分查找，每次求得完成送达的天数 d。\n当 d \u0026lt;= D 时，载重量偏大，需要从左半部分 [l,mid] 查找 当 d \u0026gt; D 时，载重量偏小，需要从右半部分 (mid, r] 查找 func shipWithinDays(weights []int, D int) int { r := 0 l := 0 for _, weight := range weights { r += weight if l \u0026lt; weight { l = weight } } var binarySearch func(l, r int) int binarySearch = func(l, r int) int { if l == r { return l } mid := (l + r) / 2 cnt := 1 curCap := mid for i := 0; i \u0026lt; len(weights); { // 能装入，继续 if curCap \u0026gt;= weights[i] { curCap -= weights[i] i++ continue } // 不能装入，等第二天 cnt++ curCap = mid } if cnt \u0026lt;= D { return binarySearch(l, mid) } else { return binarySearch(mid+1, r) } } return binarySearch(l, r) } 复杂度 时间复杂度：$ O(N*\\log{\\sum_{i=0}^{N}{weight_i}}), N = len(weights) $ 空间复杂度：$ O(1) $ ","date":"2021-04-26T11:10:26+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-1011.-%E5%9C%A8-d-%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B/","title":"Leetcode 1011. 在 D 天内送达包裹的能力"},{"content":"链接： https://leetcode-cn.com/problems/increasing-order-search-tree/\n难度： 简单\n题目描述 给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。\n示例 1： 输入： root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\n输出： [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]\n示例 2： 输入： root = [5,1,7]\n输出： [1,null,5,null,7]\n提示： 树中节点数的取值范围是 [1, 100] 0 \u0026lt;= Node.val \u0026lt;= 1000 解题思路 新建树 重新构造一棵树，中序遍历原树的每个结点，将其加入到新树的右结点中。\nfunc increasingBST(root *TreeNode) *TreeNode { newRoot := new(TreeNode) newNode := newRoot var InorderTraversal func(node *TreeNode) InorderTraversal = func(node *TreeNode) { if node == nil { return } InorderTraversal(node.Left) newNode.Right = \u0026amp;TreeNode{ Val: node.Val, Left: nil, Right: nil, } newNode = newNode.Right InorderTraversal(node.Right) } InorderTraversal(root) newRoot = newRoot.Right return newRoot } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(N) $ 就地改指针 维护一个叶结点指针，中序遍历整棵树，每当遇到一个新结点时，该结点 left 置为空，叶结点 right 修改为该结点，叶结点修正为该结点。\nfunc increasingBST(root *TreeNode) *TreeNode { newRoot := new(TreeNode) newLeaf := newRoot var LDR func(node *TreeNode) LDR = func(node *TreeNode) { if node == nil { return } LDR(node.Left) newLeaf.Right = node newLeaf = newLeaf.Right node.Left = nil LDR(node.Right) } LDR(root) newRoot = newRoot.Right return newRoot } 复杂度 时间复杂度：$ O(N), N = size(Tree) $ 空间复杂度：$ O(1) $ ","date":"2021-04-25T11:41:33+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-897.-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E6%A0%91/","title":"Leetcode 897. 递增顺序搜索树"},{"content":"链接： https://leetcode-cn.com/problems/combination-sum-iv/\n难度： 中等\n题目描述 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。\n题目数据保证答案符合 32 位整数范围。\n示例 1： 输入： nums = [1,2,3], target = 4\n输出： 7\n解释：\n所有可能的组合为：\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\n请注意，顺序不同的序列被视作不同的组合。\n示例 2： 输入： nums = [9], target = 3\n输出： 0\n提示： 1 \u0026lt;= nums.length \u0026lt;= 200 1 \u0026lt;= nums[i] \u0026lt;= 1000 nums 中的所有元素 互不相同 1 \u0026lt;= target \u0026lt;= 1000 解题思路 动态规划 用 dp[i] 表示当 i 作为 target 时，排列方案的数量。当 dp[i] 不为 0 时，不妨假设排列的做后一位数字为 num，则 i-num 的排列数为 dp[i-num] ，容易得知状态转移方程：\n当 i = 0 时，dp[i] = 1，表示没有元素被选中； 当 0 \u0026lt; i \u0026lt;= target 时，dp[i] = ∑dp[i-num],(num \u0026lt;= i)。 func combinationSum4(nums []int, target int) int { dp := make([]int, target+1) dp[0] = 1 for i := 1; i \u0026lt;= target; i++ { for _, num := range nums { if num \u0026lt;= i { dp[i] += dp[i-num] } } } return dp[target] } 复杂度 时间复杂度：$ O(N*target), N = len(nums) $ 空间复杂度：$ O(1) $ ","date":"2021-04-24T21:50:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-377.-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/","title":"Leetcode 377. 组合总和 Ⅳ"},{"content":"链接： https://leetcode-cn.com/problems/decode-ways/\n难度： 中等\n题目描述 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：\n\u0026#39;A\u0026#39; -\u0026gt; 1 \u0026#39;B\u0026#39; -\u0026gt; 2 ... \u0026#39;Z\u0026#39; -\u0026gt; 26 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，\u0026quot;11106\u0026quot; 可以映射为：\n\u0026quot;AAJF\u0026quot; ，将消息分组为 (1 1 10 6) \u0026quot;KJF\u0026quot; ，将消息分组为 (11 10 6) 注意，消息不能分组为 (1 11 06) ，因为 \u0026quot;06\u0026quot; 不能映射为 \u0026quot;F\u0026quot; ，这是由于 \u0026quot;6\u0026quot; 和 \u0026quot;06\u0026quot; 在映射中并不等价。\n给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。\n题目数据保证答案肯定是一个 32 位 的整数。\n示例1： 输入： s = \u0026ldquo;12\u0026rdquo;\n输出： 2\n解释： 它可以解码为 \u0026ldquo;AB\u0026rdquo;（1 2）或者 \u0026ldquo;L\u0026rdquo;（12）。\n示例2： 输入： s = \u0026ldquo;226\u0026rdquo;\n输出： 3\n解释： 它可以解码为 \u0026ldquo;BZ\u0026rdquo; (2 26), \u0026ldquo;VF\u0026rdquo; (22 6), 或者 \u0026ldquo;BBF\u0026rdquo; (2 2 6) 。\n示例3： 输入： s = \u0026ldquo;0\u0026rdquo;\n输出： 0\n解释： 没有字符映射到以 0 开头的数字。\n含有 0 的有效映射是 \u0026lsquo;J\u0026rsquo; -\u0026gt; \u0026ldquo;10\u0026rdquo; 和 \u0026lsquo;T\u0026rsquo;-\u0026gt; \u0026ldquo;20\u0026rdquo; 。\n由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。\n示例4: 输入： s = \u0026ldquo;06\u0026rdquo;\n输出： 0\n解释： \u0026ldquo;06\u0026rdquo; 不能映射到 \u0026ldquo;F\u0026rdquo; ，因为字符串含有前导 0（\u0026ldquo;6\u0026rdquo; 和 \u0026ldquo;06\u0026rdquo; 在映射中并不等价）。\n提示： 1 \u0026lt;= s.length \u0026lt;= 100 s 只包含数字，并且可能包含前导零。 解题思路 动态规划 使用数组 dp 保存解码的总数， dp[i] 表示截止到长度为 i 的字串可以解码的总数，转移时有两种情况需要考虑：\n第一种情况，对 s[i] 进行解码，要求 s[i] != 0 第二种情况，对 s[i-1]s[i] 解码, 要求 \u0026quot;00\u0026quot; \u0026lt; s[i-1]s[i] \u0026lt;= \u0026quot;26 然后就可以推导出状态转移方程：\n初始时，dp[0] = 1, 表示空字符串有一种解法 - 空串 仅满足情况一， dp[i+1] = dp[i] 经满足情况二， dp[i+1] = dp[i-1] 同时满足情况一和二， dp[i+1] = dp[i] + dp[i-1] 情况一和二均不满足，说明该字符串不能解码 求解到 s 尾，即可求解得所有解码总数 dp[len(s)]。\nfunc numDecodings(s string) int { dp := make([]int, len(s)+1) dp[0] = 1 for i := 0; i \u0026lt; len(s); i++ { exist := false // 标记是否可以解码 // 情况一 if s[i] \u0026gt; \u0026#39;0\u0026#39; { dp[i+1] += dp[i] exist = true } // 情况二 if i \u0026gt; 0 \u0026amp;\u0026amp; s[i-1] != \u0026#39;0\u0026#39; { num := 10*int(s[i-1]-\u0026#39;0\u0026#39;) + int(s[i]-\u0026#39;0\u0026#39;) if num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt;= 26 { dp[i+1] += dp[i-1] exist = true } } if !exist { break } } return dp[len(s)] } 优化 每次迭代只涉及到三个变量，故可以用三个变量代替数组，进一步降低空间复杂度\nfunc numDecodings(s string) int { dp := []int{0, 1, 0} for i := 0; i \u0026lt; len(s); i++ { exist := false // 标记是否可以解码 dp[2] = 0 // 情况一 if s[i] \u0026gt; \u0026#39;0\u0026#39; { dp[2] += dp[1] exist = true } // 情况二 if i \u0026gt; 0 \u0026amp;\u0026amp; s[i-1] != \u0026#39;0\u0026#39; { num := 10*int(s[i-1]-\u0026#39;0\u0026#39;) + int(s[i]-\u0026#39;0\u0026#39;) if num \u0026gt; 0 \u0026amp;\u0026amp; num \u0026lt;= 26 { dp[2] += dp[0] exist = true } } if !exist { break } dp[0], dp[1] = dp[1], dp[2] } return dp[2] } 复杂度 时间复杂度：O(N) 空间复杂度：优化前：O(N)，优化后O(1) ","date":"2021-04-21T10:35:45+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-91.-%E8%A7%A3%E7%A0%81%E6%96%B9%E5%BC%8F/","title":"Leetcode 91. 解码方式"},{"content":"链接： https://leetcode-cn.com/problems/compare-version-numbers/\n难度： 中等\n题目描述 给你两个版本号 version1 和 version2 ，请你比较它们。\n版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。\n比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 \u0026lt; 1 。\n返回规则如下：\n如果 version1 \u0026gt; version2 返回 1， 如果 version1 \u0026lt; version2 返回 -1， 除此之外返回 0。 示例1： 输入： version1 = \u0026ldquo;1.01\u0026rdquo;, version2 = \u0026ldquo;1.001\u0026rdquo;\n输出： 0\n解释： 忽略前导零，\u0026ldquo;01\u0026rdquo; 和 \u0026ldquo;001\u0026rdquo; 都表示相同的整数 \u0026ldquo;1\u0026rdquo;\n示例2： 输入： version1 = \u0026ldquo;1.0\u0026rdquo;, version2 = \u0026ldquo;1.0.0\u0026rdquo;\n输出： 0\n解释： version1 没有指定下标为 2 的修订号，即视为 \u0026ldquo;0\u0026rdquo;\n示例3： 输入： version1 = \u0026ldquo;0.1\u0026rdquo;, version2 = \u0026ldquo;1.1\u0026rdquo;\n输出： -1\n解释： version1 中下标为 0 的修订号是 \u0026ldquo;0\u0026rdquo;，version2 中下标为 0 的修订号是 \u0026ldquo;1\u0026rdquo; 。0 \u0026lt; 1，所以 version1 \u0026lt; version2\n示例4： 输入： version1 = \u0026ldquo;1.0.1\u0026rdquo;, version2 = \u0026ldquo;1\u0026rdquo;\n输出： 1\n示例5： 输入： version1 = \u0026ldquo;7.5.2.4\u0026rdquo;, version2 = \u0026ldquo;7.5.3\u0026rdquo;\n输出： -1\n提示： 1 \u0026lt;= version1.length, version2.length \u0026lt;= 500 version1 和 version2 仅包含数字和 '.' version1 和 version2 都是 有效版本号 version1 和 version2 的所有修订号都可以存储在 32 位整数 中 解题思路 分割 将两个版本号以 '.' 为分割符进行分割，之后注意比较各个部分，较短的版本号，后续缺失的部分用 0 进行代替。\nfunc compareVersion(version1 string, version2 string) int { num1 := strings.Split(version1, \u0026#34;.\u0026#34;) num2 := strings.Split(version2, \u0026#34;.\u0026#34;) for i := 0; i \u0026lt; len(num1) || i \u0026lt; len(num2); i++ { var p, q int64 if i \u0026lt; len(num1) { p, _ = strconv.ParseInt(num1[i], 10, 64) } if i \u0026lt; len(num2) { q, _ = strconv.ParseInt(num2[i], 10, 64) } if p \u0026gt; q { return 1 } else if p \u0026lt; q { return -1 } } return 0 } 复杂度 时间复杂度：$ O(N+M), N = len(version1), M = len(version2) $ 空间复杂度：$ O(N+M) $ 双指针 指针 i , j 分别指向 version1 和 version2 , 每次分别从两个版本号中获取一个有效数字进行比较：\ni 指向的数字大，返回 1； j 指向的数字大，返回 -1； 两个数字相同，继续向后遍历。 遍历结束，仍未比较得出大小，说明两个版本号相同，返回 0\nfunc compareVersion(version1 string, version2 string) int { num1, num2 := 0, 0 for i, j := 0, 0; i \u0026lt; len(version1) || j \u0026lt; len(version2); { for ; i \u0026lt; len(version1) \u0026amp;\u0026amp; version1[i] != \u0026#39;.\u0026#39;; i++ { num1 = num1*10 + int(version1[i]-\u0026#39;0\u0026#39;) } for ; j \u0026lt; len(version2) \u0026amp;\u0026amp; version2[j] != \u0026#39;.\u0026#39;; j++ { num2 = num2*10 + int(version2[j]-\u0026#39;0\u0026#39;) } if num1 \u0026gt; num2 { return 1 } else if num1 \u0026lt; num2 { return -1 } else { i++ j++ num1, num2 = 0, 0 } } return 0 } 复杂度 时间复杂度：$ O(N+M), N = len(version1), M = len(version2) $ 空间复杂度：$ O(1) $ ","date":"2021-04-20T20:33:19+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-165.-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/","title":"Leetcode 165. 比较版本号"},{"content":"链接： https://leetcode-cn.com/problems/implement-strstr/\n难度： 简单\n题目描述 实现 strStr() 函数。\n给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。\n说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。\n对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。\n示例1： 输入： haystack = \u0026ldquo;hello\u0026rdquo;, needle = \u0026ldquo;ll\u0026rdquo;\n输出： 2\n示例2： 输入： haystack = \u0026ldquo;aaaaa\u0026rdquo;, needle = \u0026ldquo;bba\u0026rdquo;\n输出： -1\n示例3： 输入： haystack = \u0026ldquo;\u0026rdquo;, needle = \u0026quot;\u0026quot;\n输出： 0\n提示： 0 \u0026lt;= haystack.length, needle.length \u0026lt;= 5 * 104 haystack 和 needle 仅由小写英文字符组成 解题思路 暴力匹配 从 haystack 的每个字符开始，依次向后和 needle 中的字符逐个匹配：\n匹配成功，继续向后匹配； 匹配失败，从 haystack 的下个字符重新进行匹配； 匹配到 needle 结束，说明完成了查找，返回 haystack 初始匹配的下标。 遍历结束，都未完成匹配，表示无法找到，返回 -1\nfunc strStr(haystack string, needle string) int { maxIdx := len(haystack) - len(needle) + 1 for i := 0; i \u0026lt; maxIdx; i++ { j := 0 for ; j \u0026lt; len(needle); j++ { if haystack[i+j] != needle[j] { break } } if j == len(needle) { return i } } return -1 } 复杂度 时间复杂度：O(N*M) 空间复杂度：O(1) KMP算法 func strStr(haystack string, needle string) int { if len(needle) == 0 { return 0 } // 求解next数组 next := make([]int, len(needle)) next[0] = -1 i, j := -1, 0 for j+1 \u0026lt; len(needle) { if i == -1 || needle[i] == needle[j] { i++ j++ if needle[i] == needle[j] { next[j] = next[i] } else { next[j] = i } } else { i = next[i] } } // 匹配 i, j = 0, 0 for i \u0026lt; len(haystack) \u0026amp;\u0026amp; j \u0026lt; len(needle) { if j == -1 || haystack[i] == needle[j] { i++ j++ } else { j = next[j] } } if j == len(needle) { return i - j } return -1 } 复杂度 时间复杂度：O(N+M) 空间复杂度：O(1) ","date":"2021-04-20T17:21:05+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-28.-%E5%AE%9E%E7%8E%B0-strstr/","title":"Leetcode 28. 实现 strStr()"},{"content":"链接： https://leetcode-cn.com/problems/remove-element/\n难度： 简单\n题目描述 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n说明： 为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 示例1： 输入： nums = [3,2,2,3], val = 3\n输出： 2, nums = [2,2]\n解释： 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n示例2： 输入： nums = [0,1,2,2,3,0,4,2], val = 2\n输出： 5, nums = [0,1,4,0,3]\n解释： 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n提示： 0 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 100 解题思路 双指针 用两个指针分别指向 待返回的结果数组 和 待遍历的原数组 第一个指针 i 表示当前已删除 val 的结果数组的下一个可赋值的位置，也即结果数组的长度；第二个指针 j 表示当前遍历到的元素下标。\n当 nums[i] == val 时，继续向后遍历； 当 nums[j] != val 时，表示该数毋需删除，将其加入到结果数组，遍历下一个元素。 遍历结束，返回数组长度 i\nfunc removeElement(nums []int, val int) int { i := 0 for j := 0; j \u0026lt; len(nums); j++ { if nums[j] != val { nums[i] = nums[j] i++ } } return i } 复杂度 时间复杂度：O(N) 空间复杂度：O(1) ","date":"2021-04-19T10:34:28+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-27.-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/","title":"Leetcode 27. 移除元素"},{"content":"链接： https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\n难度： 简单\n题目描述 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n说明： 为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 示例1： 输入： nums = [1,1,2]\n输出： 2, nums = [1,2]\n解释： 函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n示例2： 输入： nums = [0,0,1,1,1,2,2,3,3,4]\n输出： 5, nums = [0,1,2,3,4]\n解释： 函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n提示： 0 \u0026lt;= nums.length \u0026lt;= 3 * 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 已按升序排列 解题思路 双指针 由于整个数组已经过排序，排在某个数之前的数不会在其后重复出现，所以可以简单的用双指针实现。\n第一个指针 i 表示当前不重复的数组最后一个数的下标，第二个指针 j 表示当前遍历到的元素下标。\n当 nums[i] == nums[j] 时，表示该数已加入结果中，继续向后遍历； 当 nums[i] != nums[j] 时，表示该数是一个新的不重复数，将其填入 nums[i+1] 中，i指针向后移动一位。 遍历结束，返回数组长度 i+1\nfunc removeDuplicates(nums []int) int { i := 0 for j := 1; j \u0026lt; len(nums); j++ { if nums[i] != nums[j] { i++ nums[i] = nums[j] } } return i + 1 } 复杂度 时间复杂度：O(N) 空间复杂度：O(1) ","date":"2021-04-18T10:52:18+08:00","permalink":"https://xianlianghe0123.github.io/p/leetcode-26.-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","title":"Leetcode 26. 删除有序数组中的重复项"}]